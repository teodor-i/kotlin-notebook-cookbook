<body data-new-gr-c-s-check-loaded="14.1268.0" data-gr-ext-installed=""><script>!function(){try{var d=document.documentElement,c=d.classList;c.remove('light','dark');var e=localStorage.getItem('theme');if('system'===e||(!e&&true)){var t='(prefers-color-scheme: dark)',m=window.matchMedia(t);if(m.media!==t||m.matches){d.style.colorScheme = 'dark';c.add('dark')}else{d.style.colorScheme = 'light';c.add('light')}}else if(e){c.add(e|| '')}if(e==='light'||e==='dark')d.style.colorScheme=e}catch(e){}}()</script><nav class="flex items-center justify-between py-3 px-4 sm:px-8 sticky top-0 bg-[var(--background-nav)] h-16 z-50 backdrop-blur"><a href="/" class="flex items-center space-x-1.5"><svg width="187" height="24" viewBox="0 0 187 24" fill="none" xmlns="http://www.w3.org/2000/svg" class="fill-black dark:fill-white hover:text-primary"><mask id="mask0_1137_16681" maskUnits="userSpaceOnUse" x="0" y="0" width="187" height="24"><path d="M186.105 0H0.0571289V24H186.105V0Z" fill="white"></path></mask><g mask="url(#mask0_1137_16681)"><path d="M8.2482 4.45178C4.09666 4.45178 0.699951 7.84849 0.699951 12.0001C0.699951 16.1516 4.09666 19.5483 8.2482 19.5483C12.3998 19.5483 15.7964 16.1725 15.7964 12.0001C15.7964 7.82753 12.4207 4.45178 8.2482 4.45178ZM8.2482 16.8435C5.66922 16.8435 3.59345 14.7258 3.59345 12.0001C3.59345 9.27427 5.66922 7.15657 8.2482 7.15657C10.8272 7.15657 12.903 9.27427 12.903 12.0001C12.903 14.7258 10.8272 16.8435 8.2482 16.8435Z" fill="currentColor"></path><path d="M23.4285 8.64526C22.0656 8.64526 20.7446 9.19041 20.0527 10.1129V8.85494H17.3269V23.5321H20.0527V18.2273C20.7446 19.087 22.0236 19.5483 23.4285 19.5483C26.3639 19.5483 28.6703 17.2419 28.6703 14.0967C28.6703 10.9517 26.3639 8.64526 23.4285 8.64526ZM22.9672 17.179C21.4155 17.179 20.0317 15.9629 20.0317 14.0967C20.0317 12.2307 21.4155 11.0146 22.9672 11.0146C24.5187 11.0146 25.9026 12.2307 25.9026 14.0967C25.9026 15.9629 24.5187 17.179 22.9672 17.179Z" fill="currentColor"></path><path d="M35.0867 8.64526C32.1093 8.64526 29.761 10.9726 29.761 14.0967C29.761 17.2209 31.8158 19.5483 35.1706 19.5483C37.9172 19.5483 39.6786 17.8919 40.2236 16.0258H37.5608C37.2254 16.8015 36.2818 17.3467 35.1496 17.3467C33.7448 17.3467 32.6754 16.3613 32.4238 14.9564H40.3495V13.8871C40.3495 11.0355 38.3576 8.64526 35.0867 8.64526ZM32.4448 13.0274C32.7383 11.7065 33.8286 10.8469 35.1496 10.8469C36.5544 10.8469 37.6238 11.7694 37.7495 13.0274H32.4448Z" fill="currentColor"></path><path d="M47.6039 8.64526C46.3878 8.64526 45.1088 9.19041 44.5216 10.092V8.85494H41.7959V19.3386H44.5216V13.6983C44.5216 12.063 45.4023 10.9936 46.828 10.9936C48.149 10.9936 48.8619 12 48.8619 13.4049V19.3386H51.5877V12.9645C51.5877 10.3646 49.9941 8.64526 47.6039 8.64526Z" fill="currentColor"></path><path d="M58.5688 4.66187L52.635 19.3391H55.5495L56.8076 16.131H63.559L64.817 19.3391H67.7734L61.8816 4.66187H58.5688ZM57.751 13.6988L60.1833 7.55536L62.5945 13.6988H57.751Z" fill="currentColor"></path><path d="M71.6524 4.66187H68.8848V19.3391H71.6524V4.66187Z" fill="currentColor"></path><path d="M94.2134 16.8432C91.5295 16.8432 89.6635 14.8094 89.6635 11.9998C89.6635 9.19017 91.5295 7.15633 94.1715 7.15633C96.1008 7.15633 97.5888 8.28857 98.0294 9.67239H101.027C100.503 6.65312 97.6732 4.45154 94.1295 4.45154C89.8732 4.45154 86.749 7.82728 86.749 11.9998C86.749 16.1723 89.7892 19.548 94.1504 19.548C97.7568 19.548 100.524 17.3884 101.091 14.3271H98.1129C97.6099 15.732 96.142 16.8432 94.2134 16.8432Z" fill="currentColor"></path><path d="M107.696 8.64502C104.572 8.64502 102.16 11.1192 102.16 14.0965C102.16 17.0739 104.572 19.548 107.696 19.548C110.819 19.548 113.231 17.0739 113.231 14.0965C113.231 11.1192 110.819 8.64502 107.696 8.64502ZM107.696 17.1158C106.249 17.1158 104.864 15.9416 104.864 14.0965C104.864 12.2514 106.249 11.0772 107.696 11.0772C109.142 11.0772 110.526 12.2514 110.526 14.0965C110.526 15.9416 109.142 17.1158 107.696 17.1158Z" fill="currentColor"></path><path d="M119.857 8.64502C116.732 8.64502 114.322 11.1192 114.322 14.0965C114.322 17.0739 116.732 19.548 119.857 19.548C122.981 19.548 125.392 17.0739 125.392 14.0965C125.392 11.1192 122.981 8.64502 119.857 8.64502ZM119.857 17.1158C118.41 17.1158 117.026 15.9416 117.026 14.0965C117.026 12.2514 118.41 11.0772 119.857 11.0772C121.304 11.0772 122.687 12.2514 122.687 14.0965C122.687 15.9416 121.304 17.1158 119.857 17.1158Z" fill="currentColor"></path><path d="M136.903 8.85497H133.548L129.564 12.8178V4.6615H126.839V19.3387H129.564V16.0678L130.843 14.7468L133.883 19.3387H137.113L132.856 13.0065L136.903 8.85497Z" fill="currentColor"></path><path d="M144.178 8.6453C142.774 8.6453 141.494 9.19045 140.803 10.0921V4.6615H138.077V19.3387H140.803V18.2274C141.494 19.108 142.815 19.5484 144.178 19.5484C147.114 19.5484 149.42 17.242 149.42 14.0968C149.42 10.9517 147.114 8.6453 144.178 8.6453ZM143.718 17.179C142.165 17.179 140.782 15.9629 140.782 14.0968C140.782 12.2308 142.165 11.0146 143.718 11.0146C145.269 11.0146 146.652 12.2308 146.652 14.0968C146.652 15.9629 145.269 17.179 143.718 17.179Z" fill="currentColor"></path><path d="M156.045 8.64502C152.921 8.64502 150.51 11.1192 150.51 14.0965C150.51 17.0739 152.921 19.548 156.045 19.548C159.17 19.548 161.58 17.0739 161.58 14.0965C161.58 11.1192 159.17 8.64502 156.045 8.64502ZM156.045 17.1158C154.598 17.1158 153.215 15.9416 153.215 14.0965C153.215 12.2514 154.598 11.0772 156.045 11.0772C157.492 11.0772 158.876 12.2514 158.876 14.0965C158.876 15.9416 157.492 17.1158 156.045 17.1158Z" fill="currentColor"></path><path d="M168.206 8.64502C165.082 8.64502 162.671 11.1192 162.671 14.0965C162.671 17.0739 165.082 19.548 168.206 19.548C171.331 19.548 173.742 17.0739 173.742 14.0965C173.742 11.1192 171.331 8.64502 168.206 8.64502ZM168.206 17.1158C166.76 17.1158 165.376 15.9416 165.376 14.0965C165.376 12.2514 166.76 11.0772 168.206 11.0772C169.653 11.0772 171.037 12.2514 171.037 14.0965C171.037 15.9416 169.653 17.1158 168.206 17.1158Z" fill="currentColor"></path><path d="M181.207 13.0065L185.253 8.85497H181.899L177.915 12.8178V4.6615H175.188V19.3387H177.915V16.0678L179.194 14.7468L182.234 19.3387H185.462L181.207 13.0065Z" fill="currentColor"></path></g></svg></a><div class="flex"><div class="deskNav"><div class="flex items-center space-x-1 sm:space-x-2 mx-3 sm:mx-4"><button type="button" class="text-sm flex flex-row items-center category-button text-primary py-1 px-2 hover:bg-card-border rounded" aria-haspopup="dialog" aria-expanded="false" aria-controls="radix-:Rb6cq:" data-state="closed"><span class="flex items-center justify-between">Topics<svg width="15" height="15" viewBox="0 0 15 15" fill="none" xmlns="http://www.w3.org/2000/svg" class="w-4 h-4 ml-1"><path d="M3.13523 6.15803C3.3241 5.95657 3.64052 5.94637 3.84197 6.13523L7.5 9.56464L11.158 6.13523C11.3595 5.94637 11.6759 5.95657 11.8648 6.15803C12.0536 6.35949 12.0434 6.67591 11.842 6.86477L7.84197 10.6148C7.64964 10.7951 7.35036 10.7951 7.15803 10.6148L3.15803 6.86477C2.95657 6.67591 2.94637 6.35949 3.13523 6.15803Z" fill="currentColor" fill-rule="evenodd" clip-rule="evenodd"></path></svg></span></button><a href="/about" class="text-sm flex flex-row items-center py-1 px-2 hover:text-primary hover:bg-card-border rounded"><span class="hidden sm:inline  text-primary">About</span><svg width="15" height="15" viewBox="0 0 15 15" fill="none" xmlns="http://www.w3.org/2000/svg" class="inline sm:hidden w-3.5 h-3.5"><path d="M0.877075 7.49972C0.877075 3.84204 3.84222 0.876892 7.49991 0.876892C11.1576 0.876892 14.1227 3.84204 14.1227 7.49972C14.1227 11.1574 11.1576 14.1226 7.49991 14.1226C3.84222 14.1226 0.877075 11.1574 0.877075 7.49972ZM7.49991 1.82689C4.36689 1.82689 1.82708 4.36671 1.82708 7.49972C1.82708 10.6327 4.36689 13.1726 7.49991 13.1726C10.6329 13.1726 13.1727 10.6327 13.1727 7.49972C13.1727 4.36671 10.6329 1.82689 7.49991 1.82689ZM8.24993 10.5C8.24993 10.9142 7.91414 11.25 7.49993 11.25C7.08571 11.25 6.74993 10.9142 6.74993 10.5C6.74993 10.0858 7.08571 9.75 7.49993 9.75C7.91414 9.75 8.24993 10.0858 8.24993 10.5ZM6.05003 6.25C6.05003 5.57211 6.63511 4.925 7.50003 4.925C8.36496 4.925 8.95003 5.57211 8.95003 6.25C8.95003 6.74118 8.68002 6.99212 8.21447 7.27494C8.16251 7.30651 8.10258 7.34131 8.03847 7.37854L8.03841 7.37858C7.85521 7.48497 7.63788 7.61119 7.47449 7.73849C7.23214 7.92732 6.95003 8.23198 6.95003 8.7C6.95004 9.00376 7.19628 9.25 7.50004 9.25C7.8024 9.25 8.04778 9.00601 8.05002 8.70417L8.05056 8.7033C8.05924 8.6896 8.08493 8.65735 8.15058 8.6062C8.25207 8.52712 8.36508 8.46163 8.51567 8.37436L8.51571 8.37433C8.59422 8.32883 8.68296 8.27741 8.78559 8.21506C9.32004 7.89038 10.05 7.35382 10.05 6.25C10.05 4.92789 8.93511 3.825 7.50003 3.825C6.06496 3.825 4.95003 4.92789 4.95003 6.25C4.95003 6.55376 5.19628 6.8 5.50003 6.8C5.80379 6.8 6.05003 6.55376 6.05003 6.25Z" fill="currentColor" fill-rule="evenodd" clip-rule="evenodd"></path></svg></a><a href="https://platform.openai.com/docs/introduction" target="_blank" class="text-sm flex flex-row items-center py-1 px-2 hover:text-primary hover:bg-card-border rounded whitespace-nowrap flex items-center"><span class="hidden sm:inline  text-primary">API docs</span><svg width="15" height="15" viewBox="0 0 15 15" fill="none" xmlns="http://www.w3.org/2000/svg" class="inline sm:hidden w-3.5 h-3.5"><path d="M3 2.5C3 2.22386 3.22386 2 3.5 2H9.08579C9.21839 2 9.34557 2.05268 9.43934 2.14645L11.8536 4.56066C11.9473 4.65443 12 4.78161 12 4.91421V12.5C12 12.7761 11.7761 13 11.5 13H3.5C3.22386 13 3 12.7761 3 12.5V2.5ZM3.5 1C2.67157 1 2 1.67157 2 2.5V12.5C2 13.3284 2.67157 14 3.5 14H11.5C12.3284 14 13 13.3284 13 12.5V4.91421C13 4.51639 12.842 4.13486 12.5607 3.85355L10.1464 1.43934C9.86514 1.15804 9.48361 1 9.08579 1H3.5ZM4.5 4C4.22386 4 4 4.22386 4 4.5C4 4.77614 4.22386 5 4.5 5H7.5C7.77614 5 8 4.77614 8 4.5C8 4.22386 7.77614 4 7.5 4H4.5ZM4.5 7C4.22386 7 4 7.22386 4 7.5C4 7.77614 4.22386 8 4.5 8H10.5C10.7761 8 11 7.77614 11 7.5C11 7.22386 10.7761 7 10.5 7H4.5ZM4.5 10C4.22386 10 4 10.2239 4 10.5C4 10.7761 4.22386 11 4.5 11H10.5C10.7761 11 11 10.7761 11 10.5C11 10.2239 10.7761 10 10.5 10H4.5Z" fill="currentColor" fill-rule="evenodd" clip-rule="evenodd"></path></svg><svg width="15" height="15" viewBox="0 0 15 15" fill="none" xmlns="http://www.w3.org/2000/svg" class="hidden sm:inline w-3.5 h-3.5 ml-0.5 mt-0.5 -mr-0.5 text-primary"><path d="M3.64645 11.3536C3.45118 11.1583 3.45118 10.8417 3.64645 10.6465L10.2929 4L6 4C5.72386 4 5.5 3.77614 5.5 3.5C5.5 3.22386 5.72386 3 6 3L11.5 3C11.6326 3 11.7598 3.05268 11.8536 3.14645C11.9473 3.24022 12 3.36739 12 3.5L12 9.00001C12 9.27615 11.7761 9.50001 11.5 9.50001C11.2239 9.50001 11 9.27615 11 9.00001V4.70711L4.35355 11.3536C4.15829 11.5488 3.84171 11.5488 3.64645 11.3536Z" fill="currentColor" fill-rule="evenodd" clip-rule="evenodd"></path></svg></a><a href="https://github.com/openai/openai-cookbook" target="_blank" class="text-sm flex flex-row items-center py-1 px-2 hover:text-primary hover:bg-card-border rounded"><span class="hidden sm:inline text-primary">Source</span><svg width="15" height="15" viewBox="0 0 15 15" fill="none" xmlns="http://www.w3.org/2000/svg" class="w-3.5 h-3.5 sm:ml-1.5 text-primary"><path d="M7.49933 0.25C3.49635 0.25 0.25 3.49593 0.25 7.50024C0.25 10.703 2.32715 13.4206 5.2081 14.3797C5.57084 14.446 5.70302 14.2222 5.70302 14.0299C5.70302 13.8576 5.69679 13.4019 5.69323 12.797C3.67661 13.235 3.25112 11.825 3.25112 11.825C2.92132 10.9874 2.44599 10.7644 2.44599 10.7644C1.78773 10.3149 2.49584 10.3238 2.49584 10.3238C3.22353 10.375 3.60629 11.0711 3.60629 11.0711C4.25298 12.1788 5.30335 11.8588 5.71638 11.6732C5.78225 11.205 5.96962 10.8854 6.17658 10.7043C4.56675 10.5209 2.87415 9.89918 2.87415 7.12104C2.87415 6.32925 3.15677 5.68257 3.62053 5.17563C3.54576 4.99226 3.29697 4.25521 3.69174 3.25691C3.69174 3.25691 4.30015 3.06196 5.68522 3.99973C6.26337 3.83906 6.8838 3.75895 7.50022 3.75583C8.1162 3.75895 8.73619 3.83906 9.31523 3.99973C10.6994 3.06196 11.3069 3.25691 11.3069 3.25691C11.7026 4.25521 11.4538 4.99226 11.3795 5.17563C11.8441 5.68257 12.1245 6.32925 12.1245 7.12104C12.1245 9.9063 10.4292 10.5192 8.81452 10.6985C9.07444 10.9224 9.30633 11.3648 9.30633 12.0413C9.30633 13.0102 9.29742 13.7922 9.29742 14.0299C9.29742 14.2239 9.42828 14.4496 9.79591 14.3788C12.6746 13.4179 14.75 10.7025 14.75 7.50024C14.75 3.49593 11.5036 0.25 7.49933 0.25Z" fill="currentColor" fill-rule="evenodd" clip-rule="evenodd"></path></svg></a><button class="inline-flex items-center justify-center rounded-md text-sm font-medium transition-colors focus-visible:outline-none disabled:pointer-events-none disabled:opacity-50 hover:text-accent-foreground h-10 hover:bg-transparent text-primary w-8 group" type="button" id="radix-:R1b6cq:" aria-haspopup="menu" aria-expanded="false" data-state="closed"><div class="relative flex items-center justify-center"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class=" h-4 w-4  rotate-0 scale-100  dark:-rotate-90 dark:scale-0  stroke-current          /* base stroke color pulled from current text color */ stroke-[2px]           /* base stroke width (arbitrary value in Tailwind 3.2+) */ group-hover:stroke-[3px]  /* hover stroke width */ transition-all         /* so it transitions smoothly if desired */ "><circle cx="12" cy="12" r="4"></circle><path d="M12 2v2"></path><path d="M12 20v2"></path><path d="m4.93 4.93 1.41 1.41"></path><path d="m17.66 17.66 1.41 1.41"></path><path d="M2 12h2"></path><path d="M20 12h2"></path><path d="m6.34 17.66-1.41 1.41"></path><path d="m19.07 4.93-1.41 1.41"></path></svg><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class=" absolute  h-4 w-4  rotate-90 scale-0  dark:rotate-0 dark:scale-100  stroke-current stroke-[2px] group-hover:stroke-[3px] transition-all "><path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"></path></svg></div><span class="sr-only">Toggle theme</span></button></div></div><div class="mobileNav"><button class="IconButton p-2" aria-label="Customise options" type="button" aria-haspopup="dialog" aria-expanded="false" aria-controls="radix-:Rd6cq:" data-state="closed"><svg width="15" height="15" viewBox="0 0 15 15" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M1.5 3C1.22386 3 1 3.22386 1 3.5C1 3.77614 1.22386 4 1.5 4H13.5C13.7761 4 14 3.77614 14 3.5C14 3.22386 13.7761 3 13.5 3H1.5ZM1 7.5C1 7.22386 1.22386 7 1.5 7H13.5C13.7761 7 14 7.22386 14 7.5C14 7.77614 13.7761 8 13.5 8H1.5C1.22386 8 1 7.77614 1 7.5ZM1 11.5C1 11.2239 1.22386 11 1.5 11H13.5C13.7761 11 14 11.2239 14 11.5C14 11.7761 13.7761 12 13.5 12H1.5C1.22386 12 1 11.7761 1 11.5Z" fill="currentColor" fill-rule="evenodd" clip-rule="evenodd"></path></svg></button><button class="inline-flex items-center justify-center rounded-md text-sm font-medium transition-colors focus-visible:outline-none disabled:pointer-events-none disabled:opacity-50 hover:text-accent-foreground h-10 hover:bg-transparent text-primary w-8 group" type="button" id="radix-:Rl6cq:" aria-haspopup="menu" aria-expanded="false" data-state="closed"><div class="relative flex items-center justify-center"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class=" h-4 w-4  rotate-0 scale-100  dark:-rotate-90 dark:scale-0  stroke-current          /* base stroke color pulled from current text color */ stroke-[2px]           /* base stroke width (arbitrary value in Tailwind 3.2+) */ group-hover:stroke-[3px]  /* hover stroke width */ transition-all         /* so it transitions smoothly if desired */ "><circle cx="12" cy="12" r="4"></circle><path d="M12 2v2"></path><path d="M12 20v2"></path><path d="m4.93 4.93 1.41 1.41"></path><path d="m17.66 17.66 1.41 1.41"></path><path d="M2 12h2"></path><path d="M20 12h2"></path><path d="m6.34 17.66-1.41 1.41"></path><path d="m19.07 4.93-1.41 1.41"></path></svg><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class=" absolute  h-4 w-4  rotate-90 scale-0  dark:rotate-0 dark:scale-100  stroke-current stroke-[2px] group-hover:stroke-[3px] transition-all "><path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"></path></svg></div><span class="sr-only">Toggle theme</span></button></div><button class="group"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="h-4 mr-2 stroke-primary group-hover:[stroke-width:3] transition-all"><circle cx="11" cy="11" r="8"></circle><path d="m21 21-4.3-4.3"></path></svg></button></div></nav><div class="flex flex-col items-center pt-8 pb-32 px-4 sm:px-8"><div class="w-full"><div class="w-full"><div class="mx-auto max-w-3xl px-4 sm:px-8"><div class="mb-12 mt-4"><h3 class="text-sm text-gray-500 mb-2 sm:mb-8 text-center">Mar 11, 2025</h3><h1 class="text-xl sm:text-4xl font-bold mb-12 sm:mb-16 text-center">Web Search and States with Responses API</h1><div class="flex justify-between items-end"><div class="flex space-x-2 items-center"><div class="flex"><button class="transform transition-all cursor-pointer ml-0" style="z-index:1" rel="noopener noreferrer" aria-label="View profile of billchen-openai"><div class="relative rounded-full h-8 w-8 bg-white"><img alt="Bill Chen" draggable="false" loading="lazy" width="32" height="32" decoding="async" data-nimg="1" class="rounded-full h-8 w-8 border border-gray-30" style="color:transparent" srcset="/_next/image?url=https%3A%2F%2Favatars.githubusercontent.com%2Fu%2F198814448%3Fv%3D4&amp;w=32&amp;q=75 1x, /_next/image?url=https%3A%2F%2Favatars.githubusercontent.com%2Fu%2F198814448%3Fv%3D4&amp;w=64&amp;q=75 2x" src="https://cookbook.openai.com/_next/image?url=https%3A%2F%2Favatars.githubusercontent.com%2Fu%2F198814448%3Fv%3D4&amp;w=64&amp;q=75"><div class="absolute bottom-[-2px] right-[-2px] rounded-full bg-white h-4 w-4 flex items-center justify-center"><img alt="Verified" loading="lazy" width="512" height="512" decoding="async" data-nimg="1" style="color:transparent" src="/_next/static/media/openai-logomark-2.63a8dac2.svg"></div></div></button></div><div class="flex flex-col justify-center"><div><span class="text-sm text-primary"><button aria-label="View profile of billchen-openai" rel="noopener noreferrer">Bill Chen<span class="ml-1 text-xs text-muted-foreground">(OpenAI)</span></button></span></div></div></div><div class="flex flex-row gap-x-0"><a href="https://github.com/openai/openai-cookbook/blob/main/examples/responses_api/responses_example.ipynb" target="_blank" rel="noopener noreferrer" class="text-sm rounded py-2 px-2 sm:px-3 hover:bg-muted transition-colors flex gap-2 items-center"><svg width="15" height="15" viewBox="0 0 15 15" fill="none" xmlns="http://www.w3.org/2000/svg" class="w-4 h-4"><path d="M7.49933 0.25C3.49635 0.25 0.25 3.49593 0.25 7.50024C0.25 10.703 2.32715 13.4206 5.2081 14.3797C5.57084 14.446 5.70302 14.2222 5.70302 14.0299C5.70302 13.8576 5.69679 13.4019 5.69323 12.797C3.67661 13.235 3.25112 11.825 3.25112 11.825C2.92132 10.9874 2.44599 10.7644 2.44599 10.7644C1.78773 10.3149 2.49584 10.3238 2.49584 10.3238C3.22353 10.375 3.60629 11.0711 3.60629 11.0711C4.25298 12.1788 5.30335 11.8588 5.71638 11.6732C5.78225 11.205 5.96962 10.8854 6.17658 10.7043C4.56675 10.5209 2.87415 9.89918 2.87415 7.12104C2.87415 6.32925 3.15677 5.68257 3.62053 5.17563C3.54576 4.99226 3.29697 4.25521 3.69174 3.25691C3.69174 3.25691 4.30015 3.06196 5.68522 3.99973C6.26337 3.83906 6.8838 3.75895 7.50022 3.75583C8.1162 3.75895 8.73619 3.83906 9.31523 3.99973C10.6994 3.06196 11.3069 3.25691 11.3069 3.25691C11.7026 4.25521 11.4538 4.99226 11.3795 5.17563C11.8441 5.68257 12.1245 6.32925 12.1245 7.12104C12.1245 9.9063 10.4292 10.5192 8.81452 10.6985C9.07444 10.9224 9.30633 11.3648 9.30633 12.0413C9.30633 13.0102 9.29742 13.7922 9.29742 14.0299C9.29742 14.2239 9.42828 14.4496 9.79591 14.3788C12.6746 13.4179 14.75 10.7025 14.75 7.50024C14.75 3.49593 11.5036 0.25 7.49933 0.25Z" fill="currentColor" fill-rule="evenodd" clip-rule="evenodd"></path></svg><span class="max-sm:hidden">Open in GitHub</span></a><a href="https://nbviewer.org/format/script/github/openai/openai-cookbook/blob/main/examples/responses_api/responses_example.ipynb" class="text-sm rounded py-2 px-2 sm:px-3 hover:bg-muted transition-colors flex gap-2 items-center" target="_blank" rel="noopener noreferrer"><svg width="15" height="15" viewBox="0 0 15 15" fill="none" xmlns="http://www.w3.org/2000/svg" class="w-4 h-4"><path d="M3 2.5C3 2.22386 3.22386 2 3.5 2H9.08579C9.21839 2 9.34557 2.05268 9.43934 2.14645L11.8536 4.56066C11.9473 4.65443 12 4.78161 12 4.91421V12.5C12 12.7761 11.7761 13 11.5 13H3.5C3.22386 13 3 12.7761 3 12.5V2.5ZM3.5 1C2.67157 1 2 1.67157 2 2.5V12.5C2 13.3284 2.67157 14 3.5 14H11.5C12.3284 14 13 13.3284 13 12.5V4.91421C13 4.51639 12.842 4.13486 12.5607 3.85355L10.1464 1.43934C9.86514 1.15804 9.48361 1 9.08579 1H3.5ZM4.5 4C4.22386 4 4 4.22386 4 4.5C4 4.77614 4.22386 5 4.5 5H7.5C7.77614 5 8 4.77614 8 4.5C8 4.22386 7.77614 4 7.5 4H4.5ZM4.5 7C4.22386 7 4 7.22386 4 7.5C4 7.77614 4.22386 8 4.5 8H10.5C10.7761 8 11 7.77614 11 7.5C11 7.22386 10.7761 7 10.5 7H4.5ZM4.5 10C4.22386 10 4 10.2239 4 10.5C4 10.7761 4.22386 11 4.5 11H10.5C10.7761 11 11 10.7761 11 10.5C11 10.2239 10.7761 10 10.5 10H4.5Z" fill="currentColor" fill-rule="evenodd" clip-rule="evenodd"></path></svg><span class="max-sm:hidden">View as Markdown</span></a></div></div></div></div><div id="content" class="w-full"><div class="w-full px-6 lg:px-8"><div class="grid grid-cols-1 lg:grid-cols-[clamp(12rem,20vw,18rem)_minmax(0,1fr)] gap-14"><aside class="hidden lg:block"><nav aria-label="On this page" class="sticky top-20 h-[calc(100vh-5rem)] overflow-y-auto pr-4 text-sm"><ul class="space-y-1"><li><a href="#basics" class="block w-full text-left text-sm font-medium py-1 px-2 rounded hover:bg-muted/40"><span class="">Basics</span></a></li><li><a href="#hosted-tools" class="block w-full text-left text-sm font-medium py-1 px-2 rounded hover:bg-muted/40"><span class="">Hosted Tools</span></a></li><li><a href="#multimodal-tool-augmented-conversation" class="block w-full text-left text-sm font-medium py-1 px-2 rounded hover:bg-muted/40"><span class="">Multimodal, Tool-augmented conversation</span></a></li></ul></nav></aside><div class="mx-auto w-full max-w-[clamp(60ch,72vw,90ch)] px-4 sm:px-8"><div class="flex flex-col space-y-6"><article class="prose prose-sm sm:prose-base max-w-none dark:prose-invert"><p>The Responses API is a new way to interact with OpenAI models, designed to be simpler and more flexible than previous APIs. It makes it easy to build advanced AI applications that use multiple tools, handle multi-turn conversations, and work with different types of data (not just text).</p>
    <p>Unlike older APIs—such as Chat Completions, which were built mainly for text, or the Assistants API, which can require a lot of setup—the Responses API is built from the ground up for:</p>
    <ul>
        <li>Seamless multi-turn interactions (carry on a conversation across several steps in a single API call)</li>
        <li>Easy access to powerful hosted tools (like file search, web search, and code interpreter)</li>
        <li>Fine-grained control over the context you send to the model</li>
    </ul>
    <p>As AI models become more capable of complex, long-running reasoning, developers need an API that is both asynchronous and stateful. The Responses API is designed to meet these needs.</p>
    <p>In this guide, you'll see some of the new features the Responses API offers, along with practical examples to help you get started.</p></article><article class="prose prose-sm sm:prose-base max-w-none dark:prose-invert"><h2 class="
        group
        relative
        cursor-pointer
        scroll-mt-24
      " id="basics"><a class="heading-link" href="#basics">Basics</a><button class=" absolute  top-1/2  -translate-y-1/2 opacity-0 group-hover:opacity-100 transition-opacity duration-300 ease-in-out text-[var(--oai-green)] hover:text-[var(--oai-green-hover)] p-1 pl-3 pointer-events-none group-hover:pointer-events-auto " aria-label="Copy link to clipboard"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-4 h-4"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></button><div id="_rht_toaster" style="position:fixed;z-index:9999;top:16px;left:16px;right:16px;bottom:16px;pointer-events:none"></div></h2>
    <p>By design, on the surface, the Responses API is very similar to the Completions API.</p></article><div><div class="relative"><div class="[&amp;&gt;*]:rounded-md [&amp;&gt;*]:p-4 [&amp;&gt;*]:text-xs [&amp;&gt;*]:overflow-x-auto"><pre class="shiki github-dark" style="background-color: #24292e" tabindex="0"><code><span class="line"><span style="color: #F97583">from</span><span style="color: #E1E4E8"> openai </span><span style="color: #F97583">import</span><span style="color: #E1E4E8"> OpenAI</span></span>
<span class="line"><span style="color: #F97583">import</span><span style="color: #E1E4E8"> os</span></span>
<span class="line"><span style="color: #E1E4E8">client </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> OpenAI(</span><span style="color: #FFAB70">api_key</span><span style="color: #F97583">=</span><span style="color: #E1E4E8">os.getenv(</span><span style="color: #9ECBFF">"OPENAI_API_KEY"</span><span style="color: #E1E4E8">))</span></span></code></pre></div><button class="rounded p-1.5 hover:bg-muted/10 transition-all absolute top-2 right-2"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="h-5 w-5 stroke-1 stroke-gray-200"><rect width="14" height="14" x="8" y="8" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></div></div><div><div class="relative"><div class="[&amp;&gt;*]:rounded-md [&amp;&gt;*]:p-4 [&amp;&gt;*]:text-xs [&amp;&gt;*]:overflow-x-auto"><pre class="shiki github-dark" style="background-color: #24292e" tabindex="0"><code><span class="line"><span style="color: #E1E4E8">response </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> client.responses.create(</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #FFAB70">model</span><span style="color: #F97583">=</span><span style="color: #9ECBFF">"gpt-4o-mini"</span><span style="color: #E1E4E8">,</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #FFAB70">input</span><span style="color: #F97583">=</span><span style="color: #9ECBFF">"tell me a joke"</span><span style="color: #E1E4E8">,</span></span>
<span class="line"><span style="color: #E1E4E8">)</span></span>
<span class="line"></span></code></pre></div><button class="rounded p-1.5 hover:bg-muted/10 transition-all absolute top-2 right-2"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="h-5 w-5 stroke-1 stroke-gray-200"><rect width="14" height="14" x="8" y="8" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></div></div><div><div class="relative"><div class="[&amp;&gt;*]:rounded-md [&amp;&gt;*]:p-4 [&amp;&gt;*]:text-xs [&amp;&gt;*]:overflow-x-auto [&amp;&gt;*]:rounded-b-none"><pre class="shiki github-dark" style="background-color: #24292e" tabindex="0"><code><span class="line"><span style="color: #79B8FF">print</span><span style="color: #E1E4E8">(response.output[</span><span style="color: #79B8FF">0</span><span style="color: #E1E4E8">].content[</span><span style="color: #79B8FF">0</span><span style="color: #E1E4E8">].text)</span></span></code></pre></div><button class="rounded p-1.5 hover:bg-muted/10 transition-all absolute top-2 right-2"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="h-5 w-5 stroke-1 stroke-gray-200"><rect width="14" height="14" x="8" y="8" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></div><div class="border border-t-0 border-border rounded-b-md text-xs max-h-[50vh] overflow-scroll"><pre class="p-4 font-mono overflow-scroll">Why did the scarecrow win an award?
    <!-- -->
    <!-- -->Because he was outstanding in his field!
</pre></div></div><article class="prose prose-sm sm:prose-base max-w-none dark:prose-invert"><p>One key feature of the Response API is that it is stateful. This means that you do not have to manage the state of the conversation by yourself, the API will handle it for you. For example, you can retrieve the response at any time and it will include the full conversation history.</p></article><div><div class="relative"><div class="[&amp;&gt;*]:rounded-md [&amp;&gt;*]:p-4 [&amp;&gt;*]:text-xs [&amp;&gt;*]:overflow-x-auto [&amp;&gt;*]:rounded-b-none"><pre class="shiki github-dark" style="background-color: #24292e" tabindex="0"><code><span class="line"><span style="color: #E1E4E8">fetched_response </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> client.responses.retrieve(</span></span>
<span class="line"><span style="color: #FFAB70">response_id</span><span style="color: #F97583">=</span><span style="color: #E1E4E8">response.id)</span></span>
<span class="line"></span>
<span class="line"><span style="color: #79B8FF">print</span><span style="color: #E1E4E8">(fetched_response.output[</span><span style="color: #79B8FF">0</span><span style="color: #E1E4E8">].content[</span><span style="color: #79B8FF">0</span><span style="color: #E1E4E8">].text)</span></span>
<span class="line"></span></code></pre></div><button class="rounded p-1.5 hover:bg-muted/10 transition-all absolute top-2 right-2"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="h-5 w-5 stroke-1 stroke-gray-200"><rect width="14" height="14" x="8" y="8" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></div><div class="border border-t-0 border-border rounded-b-md text-xs max-h-[50vh] overflow-scroll"><pre class="p-4 font-mono overflow-scroll">Why did the scarecrow win an award?
    <!-- -->
    <!-- -->Because he was outstanding in his field!
</pre></div></div><article class="prose prose-sm sm:prose-base max-w-none dark:prose-invert"><p>You can continue the conversation by referring to the previous response.</p></article><div><div class="relative"><div class="[&amp;&gt;*]:rounded-md [&amp;&gt;*]:p-4 [&amp;&gt;*]:text-xs [&amp;&gt;*]:overflow-x-auto"><pre class="shiki github-dark" style="background-color: #24292e" tabindex="0"><code><span class="line"><span style="color: #E1E4E8">response_two </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> client.responses.create(</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #FFAB70">model</span><span style="color: #F97583">=</span><span style="color: #9ECBFF">"gpt-4o-mini"</span><span style="color: #E1E4E8">,</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #FFAB70">input</span><span style="color: #F97583">=</span><span style="color: #9ECBFF">"tell me another"</span><span style="color: #E1E4E8">,</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #FFAB70">previous_response_id</span><span style="color: #F97583">=</span><span style="color: #E1E4E8">response.id</span></span>
<span class="line"><span style="color: #E1E4E8">)</span></span>
<span class="line"></span></code></pre></div><button class="rounded p-1.5 hover:bg-muted/10 transition-all absolute top-2 right-2"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="h-5 w-5 stroke-1 stroke-gray-200"><rect width="14" height="14" x="8" y="8" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></div></div><div><div class="relative"><div class="[&amp;&gt;*]:rounded-md [&amp;&gt;*]:p-4 [&amp;&gt;*]:text-xs [&amp;&gt;*]:overflow-x-auto [&amp;&gt;*]:rounded-b-none"><pre class="shiki github-dark" style="background-color: #24292e" tabindex="0"><code><span class="line"><span style="color: #79B8FF">print</span><span style="color: #E1E4E8">(response_two.output[</span><span style="color: #79B8FF">0</span><span style="color: #E1E4E8">].content[</span><span style="color: #79B8FF">0</span><span style="color: #E1E4E8">].text)</span></span></code></pre></div><button class="rounded p-1.5 hover:bg-muted/10 transition-all absolute top-2 right-2"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="h-5 w-5 stroke-1 stroke-gray-200"><rect width="14" height="14" x="8" y="8" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></div><div class="border border-t-0 border-border rounded-b-md text-xs max-h-[50vh] overflow-scroll"><pre class="p-4 font-mono overflow-scroll">Why don't skeletons fight each other?
    <!-- -->
    <!-- -->They don't have the guts!
</pre></div></div><article class="prose prose-sm sm:prose-base max-w-none dark:prose-invert"><p>You can of course manage the context yourself. But one benefit of OpenAI maintaining the context for you is that you can fork the response at any point and continue the conversation from that point.</p></article><div><div class="relative"><div class="[&amp;&gt;*]:rounded-md [&amp;&gt;*]:p-4 [&amp;&gt;*]:text-xs [&amp;&gt;*]:overflow-x-auto [&amp;&gt;*]:rounded-b-none"><pre class="shiki github-dark" style="background-color: #24292e" tabindex="0"><code><span class="line"><span style="color: #E1E4E8">response_two_forked </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> client.responses.create(</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #FFAB70">model</span><span style="color: #F97583">=</span><span style="color: #9ECBFF">"gpt-4o-mini"</span><span style="color: #E1E4E8">,</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #FFAB70">input</span><span style="color: #F97583">=</span><span style="color: #9ECBFF">"I didn't like that joke, tell me another and tell me the difference between the two jokes"</span><span style="color: #E1E4E8">,</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #FFAB70">previous_response_id</span><span style="color: #F97583">=</span><span style="color: #E1E4E8">response.id </span><span style="color: #6A737D"># Forking and continuing from the first response</span></span>
<span class="line"><span style="color: #E1E4E8">)</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">output_text </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> response_two_forked.output[</span><span style="color: #79B8FF">0</span><span style="color: #E1E4E8">].content[</span><span style="color: #79B8FF">0</span><span style="color: #E1E4E8">].text</span></span>
<span class="line"><span style="color: #79B8FF">print</span><span style="color: #E1E4E8">(output_text)</span></span></code></pre></div><button class="rounded p-1.5 hover:bg-muted/10 transition-all absolute top-2 right-2"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="h-5 w-5 stroke-1 stroke-gray-200"><rect width="14" height="14" x="8" y="8" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></div><div class="border border-t-0 border-border rounded-b-md text-xs max-h-[50vh] overflow-scroll"><pre class="p-4 font-mono overflow-scroll">Sure! Here’s another joke:
    <!-- -->
    <!-- -->Why don’t scientists trust atoms?
    <!-- -->
    <!-- -->Because they make up everything!
    <!-- -->
    <!-- -->**Difference:** The first joke plays on a pun involving "outstanding" in a literal sense versus being exceptional, while the second joke relies on a play on words about atoms "making up" matter versus fabricating stories. Each joke uses wordplay, but they target different concepts (farming vs. science).
</pre></div></div><article class="prose prose-sm sm:prose-base max-w-none dark:prose-invert"><h2 class="
        group
        relative
        cursor-pointer
        scroll-mt-24
      " id="hosted-tools"><a class="heading-link" href="#hosted-tools">Hosted Tools</a><button class=" absolute  top-1/2  -translate-y-1/2 opacity-0 group-hover:opacity-100 transition-opacity duration-300 ease-in-out text-[var(--oai-green)] hover:text-[var(--oai-green-hover)] p-1 pl-3 pointer-events-none group-hover:pointer-events-auto " aria-label="Copy link to clipboard"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-4 h-4"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></button><div id="_rht_toaster" style="position:fixed;z-index:9999;top:16px;left:16px;right:16px;bottom:16px;pointer-events:none"></div></h2>
    <p>Another benefit of the Responses API is that it adds support for hosted tools like <code>file_search</code> and <code>web_search</code>. Instead of manually calling the tools, simply pass in the tools and the API will decide which tool to use and use it.</p>
    <p>Here is an example of using the <code>web_search</code> tool to incorporate web search results into the response.</p></article><div><div class="relative"><div class="[&amp;&gt;*]:rounded-md [&amp;&gt;*]:p-4 [&amp;&gt;*]:text-xs [&amp;&gt;*]:overflow-x-auto"><pre class="shiki github-dark" style="background-color: #24292e" tabindex="0"><code><span class="line"><span style="color: #E1E4E8">response </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> client.responses.create(</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #FFAB70">model</span><span style="color: #F97583">=</span><span style="color: #9ECBFF">"gpt-4o"</span><span style="color: #E1E4E8">,  </span><span style="color: #6A737D"># or another supported model</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #FFAB70">input</span><span style="color: #F97583">=</span><span style="color: #9ECBFF">"What's the latest news about AI?"</span><span style="color: #E1E4E8">,</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #FFAB70">tools</span><span style="color: #F97583">=</span><span style="color: #E1E4E8">[</span></span>
<span class="line"><span style="color: #E1E4E8">        {</span></span>
<span class="line"><span style="color: #E1E4E8">            </span><span style="color: #9ECBFF">"type"</span><span style="color: #E1E4E8">: </span><span style="color: #9ECBFF">"web_search"</span></span>
<span class="line"><span style="color: #E1E4E8">        }</span></span>
<span class="line"><span style="color: #E1E4E8">    ]</span></span>
<span class="line"><span style="color: #E1E4E8">)</span></span></code></pre></div><button class="rounded p-1.5 hover:bg-muted/10 transition-all absolute top-2 right-2"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="h-5 w-5 stroke-1 stroke-gray-200"><rect width="14" height="14" x="8" y="8" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></div></div><div><div class="relative"><div class="[&amp;&gt;*]:rounded-md [&amp;&gt;*]:p-4 [&amp;&gt;*]:text-xs [&amp;&gt;*]:overflow-x-auto [&amp;&gt;*]:rounded-b-none"><pre class="shiki github-dark" style="background-color: #24292e" tabindex="0"><code><span class="line"><span style="color: #F97583">import</span><span style="color: #E1E4E8"> json</span></span>
<span class="line"><span style="color: #79B8FF">print</span><span style="color: #E1E4E8">(json.dumps(response.output, </span><span style="color: #FFAB70">default</span><span style="color: #F97583">=lambda</span><span style="color: #E1E4E8"> o: o.</span><span style="color: #79B8FF">__dict__</span><span style="color: #E1E4E8">, </span><span style="color: #FFAB70">indent</span><span style="color: #F97583">=</span><span style="color: #79B8FF">2</span><span style="color: #E1E4E8">))</span></span></code></pre></div><button class="rounded p-1.5 hover:bg-muted/10 transition-all absolute top-2 right-2"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="h-5 w-5 stroke-1 stroke-gray-200"><rect width="14" height="14" x="8" y="8" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></div><div class="border border-t-0 border-border rounded-b-md text-xs max-h-[50vh] overflow-scroll"><pre class="p-4 font-mono overflow-scroll">[
    <!-- -->  {
    <!-- -->    "id": "ws_67bd64fe91f081919bec069ad65797f1",
    <!-- -->    "status": "completed",
    <!-- -->    "type": "web_search_call"
    <!-- -->  },
    <!-- -->  {
    <!-- -->    "id": "msg_67bd6502568c8191a2cbb154fa3fbf4c",
    <!-- -->    "content": [
    <!-- -->      {
    <!-- -->        "annotations": [
    <!-- -->          {
    <!-- -->            "index": null,
    <!-- -->            "title": "Huawei improves AI chip production in boost for China's tech goals",
    <!-- -->            "type": "url_citation",
    <!-- -->            "url": "https://www.ft.com/content/f46b7f6d-62ed-4b64-8ad7-2417e5ab34f6?utm_source=chatgpt.com"
    <!-- -->          },
    <!-- -->          {
    <!-- -->            "index": null,
    <!-- -->            "title": "Apple cheers Trump with $500bn US investment plan; more losses on Wall Street - as it happened",
    <!-- -->            "type": "url_citation",
    <!-- -->            "url": "https://www.theguardian.com/business/live/2025/feb/24/euro-hits-one-month-high-german-election-result-stock-markets-dax-bank-of-england-business-live-news?utm_source=chatgpt.com"
    <!-- -->          },
    <!-- -->          {
    <!-- -->            "index": null,
    <!-- -->            "title": "Microsoft axes data center leases as DeepSeek casts doubt on massive AI spend: report",
    <!-- -->            "type": "url_citation",
    <!-- -->            "url": "https://nypost.com/2025/02/24/business/microsoft-axes-some-ai-data-center-leases-td-cowen-says/?utm_source=chatgpt.com"
    <!-- -->          },
    <!-- -->          {
    <!-- -->            "index": null,
    <!-- -->            "title": "Alibaba Plans to Invest $52B in AI, Cloud Over Next Three Years",
    <!-- -->            "type": "url_citation",
    <!-- -->            "url": "https://www.investopedia.com/alibaba-plans-to-invest-usd52b-in-ai-cloud-over-next-three-years-11684981?utm_source=chatgpt.com"
    <!-- -->          },
    <!-- -->          {
    <!-- -->            "index": null,
    <!-- -->            "title": "JPMorgan Unit Backs Albert Invent at a $270 Million Valuation",
    <!-- -->            "type": "url_citation",
    <!-- -->            "url": "https://www.wsj.com/articles/jpmorgan-unit-backs-albert-invent-at-a-270-million-valuation-1ab03c96?utm_source=chatgpt.com"
    <!-- -->          }
    <!-- -->        ],
    <!-- -->        "text": "As of February 25, 2025, several significant developments have emerged in the field of artificial intelligence (AI):\n\n**Huawei's Advancements in AI Chip Production**\n\nHuawei has notably enhanced its AI chip production capabilities, increasing the yield rate of its Ascend 910C processors from 20% to nearly 40%. This improvement has rendered the production line profitable for the first time and is pivotal for China's ambition to achieve self-sufficiency in advanced semiconductors. Despite these strides, Nvidia continues to dominate the AI chip market in China, attributed to its user-friendly software and widespread adoption. Huawei aims to further elevate its yield rate to 60% and plans to produce 100,000 Ascend 910C processors and 300,000 910B chips in 2025. ([ft.com](https://www.ft.com/content/f46b7f6d-62ed-4b64-8ad7-2417e5ab34f6?utm_source=chatgpt.com))\n\n**Apple's $500 Billion U.S. Investment Plan**\n\nApple has unveiled a substantial $500 billion investment strategy in the United States over the next four years. This plan encompasses the creation of 20,000 new jobs and the establishment of a major facility in Texas dedicated to manufacturing artificial intelligence servers. President Donald Trump has lauded this initiative, viewing it as a testament to the confidence in his administration. Concurrently, Wall Street has experienced further losses due to concerns over a potential economic slowdown, exacerbated by tariffs. ([theguardian.com](https://www.theguardian.com/business/live/2025/feb/24/euro-hits-one-month-high-german-election-result-stock-markets-dax-bank-of-england-business-live-news?utm_source=chatgpt.com))\n\n**Microsoft Adjusts AI Data Center Investments**\n\nMicrosoft has canceled leases on U.S. data centers totaling several hundred megawatts, potentially affecting two large centers. This decision is reportedly linked to concerns about oversupply, following claims by Chinese competitor DeepSeek of developing a generative chatbot more efficiently than U.S. companies. Analysts suggest that Microsoft might be reallocating funds or responding to OpenAI's shift to Oracle for a $500 billion project. Despite being a leading AI investor with planned expenditures of $80 billion this year, Microsoft appears to be scaling back on massive spending initiatives, allowing significant data center agreements to lapse and citing facility and power delays. ([nypost.com](https://nypost.com/2025/02/24/business/microsoft-axes-some-ai-data-center-leases-td-cowen-says/?utm_source=chatgpt.com))\n\n**Alibaba's $52 Billion Investment in AI and Cloud Infrastructure**\n\nAlibaba Group has announced plans to invest over $52 billion in artificial intelligence and cloud infrastructure over the next three years, surpassing its total investment in these areas over the past decade. This strategic move underscores Alibaba's commitment to AI-driven growth and reinforces its position as a leading global cloud provider. Following this announcement, Alibaba's U.S.-listed shares experienced a 3% drop in premarket trading. Analysts view this investment as aligning with market expectations and indicative of Alibaba Cloud's significant capital expenditure compared to peers. ([investopedia.com](https://www.investopedia.com/alibaba-plans-to-invest-usd52b-in-ai-cloud-over-next-three-years-11684981?utm_source=chatgpt.com))\n\n**JPMorgan's Investment in AI-Driven Chemical Development**\n\nJPMorgan Chase's private investment arm has led a $20 million growth investment in Albert Invent, an AI-driven chemical development platform, valuing the company at $270 million. This funding will enable Albert Invent to expand globally and increase its workforce from 120 to over 200 employees by the end of the year. The company assists chemists in developing new formulations and materials, significantly accelerating chemical experiments. For instance, Albert's platform can simulate 100,000 experiments in 10 minutes for clients like Nouryon Chemicals. ([wsj.com](https://www.wsj.com/articles/jpmorgan-unit-backs-albert-invent-at-a-270-million-valuation-1ab03c96?utm_source=chatgpt.com))\n\nThese developments reflect the dynamic and rapidly evolving landscape of AI, with major corporations and financial institutions making significant investments to advance technology and infrastructure in this sector.\n\n\n# Key AI Developments as of February 25, 2025:\n- [Huawei improves AI chip production in boost for China's tech goals](https://www.ft.com/content/f46b7f6d-62ed-4b64-8ad7-2417e5ab34f6?utm_source=chatgpt.com)\n- [Apple cheers Trump with $500bn US investment plan; more losses on Wall Street - as it happened](https://www.theguardian.com/business/live/2025/feb/24/euro-hits-one-month-high-german-election-result-stock-markets-dax-bank-of-england-business-live-news?utm_source=chatgpt.com)\n- [Microsoft axes data center leases as DeepSeek casts doubt on massive AI spend: report](https://nypost.com/2025/02/24/business/microsoft-axes-some-ai-data-center-leases-td-cowen-says/?utm_source=chatgpt.com)\n ",
    <!-- -->        "type": "output_text",
    <!-- -->        "logprobs": null
    <!-- -->      }
    <!-- -->    ],
    <!-- -->    "role": "assistant",
    <!-- -->    "type": "message"
    <!-- -->  }
    <!-- -->]
</pre></div></div><article class="prose prose-sm sm:prose-base max-w-none dark:prose-invert"><h2 class="
        group
        relative
        cursor-pointer
        scroll-mt-24
      " id="multimodal-tool-augmented-conversation"><a class="heading-link" href="#multimodal-tool-augmented-conversation">Multimodal, Tool-augmented conversation</a><button class=" absolute  top-1/2  -translate-y-1/2 opacity-0 group-hover:opacity-100 transition-opacity duration-300 ease-in-out text-[var(--oai-green)] hover:text-[var(--oai-green-hover)] p-1 pl-3 pointer-events-none group-hover:pointer-events-auto " aria-label="Copy link to clipboard"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-4 h-4"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></button><div id="_rht_toaster" style="position:fixed;z-index:9999;top:16px;left:16px;right:16px;bottom:16px;pointer-events:none"></div></h2>
    <p>The Responses API natively supports text, images, and audio modalities.
        Tying everything together, we can build a fully multimodal, tool-augmented interaction with one API call through the responses API.</p></article><div><div class="relative"><div class="[&amp;&gt;*]:rounded-md [&amp;&gt;*]:p-4 [&amp;&gt;*]:text-xs [&amp;&gt;*]:overflow-x-auto [&amp;&gt;*]:rounded-b-none"><pre class="shiki github-dark" style="background-color: #24292e" tabindex="0"><code><span class="line"><span style="color: #F97583">import</span><span style="color: #E1E4E8"> base64</span></span>
<span class="line"></span>
<span class="line"><span style="color: #F97583">from</span><span style="color: #E1E4E8"> IPython.display </span><span style="color: #F97583">import</span><span style="color: #E1E4E8"> Image, display</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A737D"># Display the image from the provided URL</span></span>
<span class="line"><span style="color: #E1E4E8">url </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">"https://upload.wikimedia.org/wikipedia/commons/thumb/1/15/Cat_August_2010-4.jpg/2880px-Cat_August_2010-4.jpg"</span></span>
<span class="line"><span style="color: #E1E4E8">display(Image(</span><span style="color: #FFAB70">url</span><span style="color: #F97583">=</span><span style="color: #E1E4E8">url, </span><span style="color: #FFAB70">width</span><span style="color: #F97583">=</span><span style="color: #79B8FF">400</span><span style="color: #E1E4E8">))</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">response_multimodal </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> client.responses.create(</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #FFAB70">model</span><span style="color: #F97583">=</span><span style="color: #9ECBFF">"gpt-4o"</span><span style="color: #E1E4E8">,</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #FFAB70">input</span><span style="color: #F97583">=</span><span style="color: #E1E4E8">[</span></span>
<span class="line"><span style="color: #E1E4E8">        {</span></span>
<span class="line"><span style="color: #E1E4E8">            </span><span style="color: #9ECBFF">"role"</span><span style="color: #E1E4E8">: </span><span style="color: #9ECBFF">"user"</span><span style="color: #E1E4E8">,</span></span>
<span class="line"><span style="color: #E1E4E8">            </span><span style="color: #9ECBFF">"content"</span><span style="color: #E1E4E8">: [</span></span>
<span class="line"><span style="color: #E1E4E8">                {</span><span style="color: #9ECBFF">"type"</span><span style="color: #E1E4E8">: </span><span style="color: #9ECBFF">"input_text"</span><span style="color: #E1E4E8">, </span><span style="color: #9ECBFF">"text"</span><span style="color: #E1E4E8">: </span></span>
<span class="line"><span style="color: #E1E4E8">                 </span><span style="color: #9ECBFF">"Come up with keywords related to the image, and search on the web using the search tool for any news related to the keywords"</span></span>
<span class="line"><span style="color: #E1E4E8">                 </span><span style="color: #9ECBFF">", summarize the findings and cite the sources."</span><span style="color: #E1E4E8">},</span></span>
<span class="line"><span style="color: #E1E4E8">                {</span><span style="color: #9ECBFF">"type"</span><span style="color: #E1E4E8">: </span><span style="color: #9ECBFF">"input_image"</span><span style="color: #E1E4E8">, </span><span style="color: #9ECBFF">"image_url"</span><span style="color: #E1E4E8">: </span><span style="color: #9ECBFF">"https://upload.wikimedia.org/wikipedia/commons/thumb/1/15/Cat_August_2010-4.jpg/2880px-Cat_August_2010-4.jpg"</span><span style="color: #E1E4E8">}</span></span>
<span class="line"><span style="color: #E1E4E8">            ]</span></span>
<span class="line"><span style="color: #E1E4E8">        }</span></span>
<span class="line"><span style="color: #E1E4E8">    ],</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #FFAB70">tools</span><span style="color: #F97583">=</span><span style="color: #E1E4E8">[</span></span>
<span class="line"><span style="color: #E1E4E8">        {</span><span style="color: #9ECBFF">"type"</span><span style="color: #E1E4E8">: </span><span style="color: #9ECBFF">"web_search"</span><span style="color: #E1E4E8">}</span></span>
<span class="line"><span style="color: #E1E4E8">    ]</span></span>
<span class="line"><span style="color: #E1E4E8">)</span></span>
<span class="line"></span></code></pre></div><button class="rounded p-1.5 hover:bg-muted/10 transition-all absolute top-2 right-2"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="h-5 w-5 stroke-1 stroke-gray-200"><rect width="14" height="14" x="8" y="8" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></div><div class="border border-t-0 border-border rounded-b-md text-xs max-h-[50vh] overflow-scroll"><div class="p-4 font-mono overflow-scroll prose dark:prose-invert max-w-none text-xs"><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/1/15/Cat_August_2010-4.jpg/2880px-Cat_August_2010-4.jpg" width="400"></div></div></div><div><div class="relative"><div class="[&amp;&gt;*]:rounded-md [&amp;&gt;*]:p-4 [&amp;&gt;*]:text-xs [&amp;&gt;*]:overflow-x-auto [&amp;&gt;*]:rounded-b-none"><pre class="shiki github-dark" style="background-color: #24292e" tabindex="0"><code><span class="line"><span style="color: #F97583">import</span><span style="color: #E1E4E8"> json</span></span>
<span class="line"><span style="color: #79B8FF">print</span><span style="color: #E1E4E8">(json.dumps(response_multimodal.</span><span style="color: #79B8FF">__dict__</span><span style="color: #E1E4E8">, </span><span style="color: #FFAB70">default</span><span style="color: #F97583">=lambda</span><span style="color: #E1E4E8"> o: o.</span><span style="color: #79B8FF">__dict__</span><span style="color: #E1E4E8">, </span><span style="color: #FFAB70">indent</span><span style="color: #F97583">=</span><span style="color: #79B8FF">4</span><span style="color: #E1E4E8">))</span></span></code></pre></div><button class="rounded p-1.5 hover:bg-muted/10 transition-all absolute top-2 right-2"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="h-5 w-5 stroke-1 stroke-gray-200"><rect width="14" height="14" x="8" y="8" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></div><div class="border border-t-0 border-border rounded-b-md text-xs max-h-[50vh] overflow-scroll"><pre class="p-4 font-mono overflow-scroll">{
    <!-- -->    "id": "resp_67bd65392a088191a3b802a61f4fba14",
    <!-- -->    "created_at": 1740465465.0,
    <!-- -->    "error": null,
    <!-- -->    "metadata": {},
    <!-- -->    "model": "gpt-4o-2024-08-06",
    <!-- -->    "object": "response",
    <!-- -->    "output": [
    <!-- -->        {
    <!-- -->            "id": "msg_67bd653ab9cc81918db973f0c1af9fbb",
    <!-- -->            "content": [
    <!-- -->                {
    <!-- -->                    "annotations": [],
    <!-- -->                    "text": "Based on the image of a cat, some relevant keywords could be:\n\n- Cat\n- Feline\n- Pet\n- Animal care\n- Cat behavior\n\nI'll search for recent news related to these keywords.",
    <!-- -->                    "type": "output_text",
    <!-- -->                    "logprobs": null
    <!-- -->                }
    <!-- -->            ],
    <!-- -->            "role": "assistant",
    <!-- -->            "type": "message"
    <!-- -->        },
    <!-- -->        {
    <!-- -->            "id": "ws_67bd653c7a548191af86757fbbca96e1",
    <!-- -->            "status": "completed",
    <!-- -->            "type": "web_search_call"
    <!-- -->        },
    <!-- -->        {
    <!-- -->            "id": "msg_67bd653f34fc8191989241b2659fd1b5",
    <!-- -->            "content": [
    <!-- -->                {
    <!-- -->                    "annotations": [
    <!-- -->                        {
    <!-- -->                            "index": null,
    <!-- -->                            "title": "Cat miraculously survives 3 weeks trapped in sofa during family's cross-country move",
    <!-- -->                            "type": "url_citation",
    <!-- -->                            "url": "https://nypost.com/2025/02/24/us-news/cat-miraculously-survives-3-weeks-trapped-in-sofa-during-familys-cross-country-move/?utm_source=chatgpt.com"
    <!-- -->                        },
    <!-- -->                        {
    <!-- -->                            "index": null,
    <!-- -->                            "title": "Ex-College Soccer Player Accused of Killing Fellow Athlete Brother, Cat Using Knife, Golf Club: Prosecutors",
    <!-- -->                            "type": "url_citation",
    <!-- -->                            "url": "https://people.com/princeton-murder-soccer-player-accused-murdering-athlete-brother-11685671?utm_source=chatgpt.com"
    <!-- -->                        },
    <!-- -->                        {
    <!-- -->                            "index": null,
    <!-- -->                            "title": "Cuddly 8-Year-Old Cat Surrendered to Shelter for Being 'Too Affectionate' Inspires Dozens of Adoption Applications",
    <!-- -->                            "type": "url_citation",
    <!-- -->                            "url": "https://people.com/cat-surrendered-connecticut-shelter-too-affectionate-11684130?utm_source=chatgpt.com"
    <!-- -->                        },
    <!-- -->                        {
    <!-- -->                            "index": null,
    <!-- -->                            "title": "Emaciated cat found in Meriden abandoned in snow dies after rescue attempt, officials say",
    <!-- -->                            "type": "url_citation",
    <!-- -->                            "url": "https://www.ctinsider.com/recordjournal/article/meriden-animal-control-cat-neglected-abandoned-20172924.php?utm_source=chatgpt.com"
    <!-- -->                        },
    <!-- -->                        {
    <!-- -->                            "index": null,
    <!-- -->                            "title": "Cat proves mom correct by using human toilet",
    <!-- -->                            "type": "url_citation",
    <!-- -->                            "url": "https://nypost.com/video/cat-proves-mom-correct-by-using-human-toilet/?utm_source=chatgpt.com"
    <!-- -->                        },
    <!-- -->                        {
    <!-- -->                            "index": null,
    <!-- -->                            "title": "Litter-Robot 3 Connect Review",
    <!-- -->                            "type": "url_citation",
    <!-- -->                            "url": "https://www.thesprucepets.com/litter-robot-3-connect-review-8780105?utm_source=chatgpt.com"
    <!-- -->                        },
    <!-- -->                        {
    <!-- -->                            "index": null,
    <!-- -->                            "title": "Taylor Swift's favourite cat faces breeding ban",
    <!-- -->                            "type": "url_citation",
    <!-- -->                            "url": "https://www.thetimes.co.uk/article/taylor-swifts-favourite-cat-faces-breeding-ban-k32nvf6kv?utm_source=chatgpt.com"
    <!-- -->                        }
    <!-- -->                    ],
    <!-- -->                    "text": "Here are some recent news stories related to cats:\n\n**1. Cat Survives Three Weeks Trapped in Sofa During Move**\n\nA cat named Sunny-Loo survived three weeks trapped inside a sofa during the Hansons' move from Washington state to Colorado. After disappearing during the move, she was discovered emaciated but alive when the family unpacked their furniture. Sunny-Loo received intensive care and has since been reunited with her family. ([nypost.com](https://nypost.com/2025/02/24/us-news/cat-miraculously-survives-3-weeks-trapped-in-sofa-during-familys-cross-country-move/?utm_source=chatgpt.com))\n\n**2. Man Charged with Killing Brother and Family Cat**\n\nMatthew Hertgen, a former college soccer player, has been charged with the murder of his younger brother, Joseph Hertgen, and animal cruelty for allegedly killing the family cat. The incident occurred in Princeton, New Jersey, where authorities found Joseph's body with signs of trauma. Matthew faces multiple charges, including first-degree murder. ([people.com](https://people.com/princeton-murder-soccer-player-accused-murdering-athlete-brother-11685671?utm_source=chatgpt.com))\n\n**3. \"Too Affectionate\" Cat Sparks Adoption Interest**\n\nAn 8-year-old cat named Ravi was surrendered to a Connecticut shelter for being \"too affectionate.\" A TikTok video highlighting his story went viral, amassing over 12.6 million views and leading to more than 160 adoption applications. Ravi now has an adoption appointment, and the shelter has gained increased attention for its other adoptable pets. ([people.com](https://people.com/cat-surrendered-connecticut-shelter-too-affectionate-11684130?utm_source=chatgpt.com))\n\n**4. Emaciated Cat Found in Snow Dies After Rescue Attempt**\n\nA severely neglected cat named Lizzy was found abandoned in a snowbank in Meriden, Connecticut. Despite rescue efforts, Lizzy did not survive. Authorities are seeking information to identify the person responsible for her abandonment, with a reward offered for leads. ([ctinsider.com](https://www.ctinsider.com/recordjournal/article/meriden-animal-control-cat-neglected-abandoned-20172924.php?utm_source=chatgpt.com))\n\n**5. Cat Uses Human Toilet, Surprising Family**\n\nIn the UK, a cat named Cruise surprised his family by using a human toilet. Despite initial skepticism from her partner and son, Hayley Bibby captured footage of Cruise's bathroom habits, validating her claims. The family now accommodates Cruise's preference by leaving the toilet seat up. ([nypost.com](https://nypost.com/video/cat-proves-mom-correct-by-using-human-toilet/?utm_source=chatgpt.com))\n\n**6. Litter-Robot 3 Connect: A High-Tech Litter Box Review**\n\nThe Litter-Robot 3 Connect, priced at $499, offers a self-cleaning solution for cat owners averse to scooping litter. While effective and reducing litter usage by 50%, some users note that odor prevention could be improved. The device includes features like a night light and smartphone app integration. ([thesprucepets.com](https://www.thesprucepets.com/litter-robot-3-connect-review-8780105?utm_source=chatgpt.com))\n\n**7. Taylor Swift's Favorite Cat Breed Faces Breeding Ban**\n\nThe Scottish Fold cat breed, favored by celebrities like Taylor Swift, may face a breeding ban in Britain due to inheritable health issues. These cats often suffer from painful conditions caused by defective cartilage formation. The Animal Welfare Committee has recommended prohibiting the breeding of such cats to prevent further health problems. ([thetimes.co.uk](https://www.thetimes.co.uk/article/taylor-swifts-favourite-cat-faces-breeding-ban-k32nvf6kv?utm_source=chatgpt.com))\n\n\n# Recent Cat-Related News Stories:\n- [Cat miraculously survives 3 weeks trapped in sofa during family's cross-country move](https://nypost.com/2025/02/24/us-news/cat-miraculously-survives-3-weeks-trapped-in-sofa-during-familys-cross-country-move/?utm_source=chatgpt.com)\n- [Ex-College Soccer Player Accused of Killing Fellow Athlete Brother, Cat Using Knife, Golf Club: Prosecutors](https://people.com/princeton-murder-soccer-player-accused-murdering-athlete-brother-11685671?utm_source=chatgpt.com)\n- [Cuddly 8-Year-Old Cat Surrendered to Shelter for Being 'Too Affectionate' Inspires Dozens of Adoption Applications](https://people.com/cat-surrendered-connecticut-shelter-too-affectionate-11684130?utm_source=chatgpt.com)\n ",
    <!-- -->                    "type": "output_text",
    <!-- -->                    "logprobs": null
    <!-- -->                }
    <!-- -->            ],
    <!-- -->            "role": "assistant",
    <!-- -->            "type": "message"
    <!-- -->        }
    <!-- -->    ],
    <!-- -->    "temperature": 1.0,
    <!-- -->    "tool_choice": "auto",
    <!-- -->    "tools": [
    <!-- -->        {
    <!-- -->            "type": "web_search",
    <!-- -->            "location": null,
    <!-- -->            "sites": null
    <!-- -->        }
    <!-- -->    ],
    <!-- -->    "top_p": 1.0,
    <!-- -->    "max_completion_tokens": null,
    <!-- -->    "previous_response_id": null,
    <!-- -->    "reasoning_effort": null,
    <!-- -->    "text": {
    <!-- -->        "format": {
    <!-- -->            "type": "text"
    <!-- -->        },
    <!-- -->        "stop": null
    <!-- -->    },
    <!-- -->    "top_logprobs": null,
    <!-- -->    "truncation": "disabled",
    <!-- -->    "usage": {
    <!-- -->        "completion_tokens": null,
    <!-- -->        "prompt_tokens": null,
    <!-- -->        "total_tokens": 1370,
    <!-- -->        "completion_tokens_details": null,
    <!-- -->        "prompt_tokens_details": null
    <!-- -->    }
    <!-- -->}
</pre></div></div><article class="prose prose-sm sm:prose-base max-w-none dark:prose-invert"><p>In the above example, we were able to use the <code>web_search</code> tool to search the web for news related to the image in one API call instead of multiple round trips that would be required if we were using the Chat Completions API.</p></article><article class="prose prose-sm sm:prose-base max-w-none dark:prose-invert"><p>With the responses API
    🔥 a single API call can handle:</p>
    <p>✅ Analyze a given image using a multimodal input.</p>
    <p>✅ Perform web search via the <code>web_search</code> hosted tool</p>
    <p>✅ Summarize the results.</p>
    <p>In contrast, With Chat Completions API would require multiple steps, each requiring a round trip to the API:</p>
    <p>1️⃣ Upload image and get analysis → 1 request</p>
    <p>2️⃣ Extract info, call external web search → manual step + tool execution</p>
    <p>3️⃣ Re-submit tool results for summarization → another request</p>
    <p>See the following diagram for a side by side visualized comparison!</p>
    <p><img src="../../images/comparisons.png" alt="Responses vs Completions"></p>
    <p>We are very excited for you to try out the Responses API and see how it can simplify your code and make it easier to build complex, multimodal, tool-augmented interactions!</p></article><article class="prose prose-sm sm:prose-base max-w-none dark:prose-invert"></article></div></div></div></div></div></div></div></div><script src="/_next/static/chunks/webpack-63ff3dccb86087c7.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/css/878bd0a4e6c1b024.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"2:I[2846,[],\"\"]\n5:I[4707,[],\"\"]\n7:I[6423,[],\"\"]\n8:I[5037,[\"310\",\"static/chunks/0e5ce63c-e6b9e60b226d30ba.js\",\"637\",\"static/chunks/637-4ae0d65e4116044f.js\",\"986\",\"static/chunks/986-1645af28514ad188.js\",\"167\",\"static/chunks/167-bf0648e29dfffe59.js\",\"957\",\"static/chunks/957-de9862c968766e70.js\",\"185\",\"static/chunks/app/layout-5bd5803f4bfffadd.js\"],\"ThemeProvider\"]\na:I[6786,[\"310\",\"static/chunks/0e5ce63c-e6b9e60b226d30ba.js\",\"637\",\"static/chunks/637-4ae0d65e4116044f.js\",\"986\",\"static/chunks/986-1645af28514ad188.js\",\"167\",\"static/chunks/167-bf0648e29dfffe59.js\",\"957\",\"static/chunks/957-de9862c968766e70.js\",\"185\",\"static/chunks/app/layout-5bd5803f4bfffadd.js\"],\"Analytics\"]\nc:I[1060,[],\"\"]\n6:[\"path\",\"examples/responses_api/responses_example\",\"c\"]\nd:[]\n"])</script><script>self.__next_f.push([1,"0:[\"$\",\"$L2\",null,{\"buildId\":\"evtFjdv5bvVgVQajkWpNZ\",\"assetPrefix\":\"\",\"urlParts\":[\"\",\"examples\",\"responses_api\",\"responses_example\"],\"initialTree\":[\"\",{\"children\":[[\"path\",\"examples/responses_api/responses_example\",\"c\"],{\"children\":[\"__PAGE__?{\\\"path\\\":[\\\"examples\\\",\\\"responses_api\\\",\\\"responses_example\\\"]}\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"path\",\"examples/responses_api/responses_example\",\"c\"],{\"children\":[\"__PAGE__\",{},[[\"$L3\",\"$L4\",null],null],null]},[[null,[\"$\",\"div\",null,{\"className\":\"flex flex-col items-center pt-8 pb-32 px-4 sm:px-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"w-full\",\"children\":[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$6\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\"}]}]}]],null],null]},[[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/878bd0a4e6c1b024.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"en\",\"className\":\"scroll-smooth scroll-pt-20\",\"suppressHydrationWarning\":true,\"children\":[\"$\",\"body\",null,{\"children\":[[\"$\",\"$L8\",null,{\"attribute\":\"class\",\"defaultTheme\":\"system\",\"enableSystem\":true,\"disableTransitionOnChange\":true,\"children\":[\"$L9\",[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":\"404\"}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],\"notFoundStyles\":[]}]]}],[\"$\",\"$La\",null,{}]]}]}]],null],null],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$Lb\"],\"globalErrorComponent\":\"$c\",\"missingSlots\":\"$Wd\"}]\n"])</script><script>self.__next_f.push([1,"b:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"Web Search and States with Responses API\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"The Responses API is a new way to interact with OpenAI models, designed to be simpler and more flexible than previous APIs. It makes it e...\"}],[\"$\",\"meta\",\"4\",{\"name\":\"keywords\",\"content\":\"openai, cookbook, api, examples, guides, gpt, chatgpt, gpt-4, embeddings\"}],[\"$\",\"meta\",\"5\",{\"property\":\"og:title\",\"content\":\"Web Search and States with Responses API | OpenAI Cookbook\"}],[\"$\",\"meta\",\"6\",{\"property\":\"og:description\",\"content\":\"The Responses API is a new way to interact with OpenAI models, designed to be simpler and more flexible than previous APIs. It makes it e...\"}],[\"$\",\"meta\",\"7\",{\"property\":\"og:image\",\"content\":\"https://cookbook-ecralrqh7-openai.vercel.app/og?title=Web%20Search%20and%20States%20with%20Responses%20API\u0026tags=functions,responses,web-search\"}],[\"$\",\"meta\",\"8\",{\"property\":\"og:image:width\",\"content\":\"1200\"}],[\"$\",\"meta\",\"9\",{\"property\":\"og:image:height\",\"content\":\"660\"}],[\"$\",\"meta\",\"10\",{\"property\":\"og:image:alt\",\"content\":\"OpenAI Cookbook | Web Search and States with Responses API\"}],[\"$\",\"meta\",\"11\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"12\",{\"name\":\"twitter:title\",\"content\":\"Web Search and States with Responses API | OpenAI Cookbook\"}],[\"$\",\"meta\",\"13\",{\"name\":\"twitter:description\",\"content\":\"The Responses API is a new way to interact with OpenAI models, designed to be simpler and more flexible than previous APIs. It makes it e...\"}],[\"$\",\"meta\",\"14\",{\"name\":\"twitter:image\",\"content\":\"https://cookbook-ecralrqh7-openai.vercel.app/og?title=Web%20Search%20and%20States%20with%20Responses%20API\u0026tags=functions,responses,web-search\"}],[\"$\",\"meta\",\"15\",{\"name\":\"twitter:image:width\",\"content\":\"1200\"}],[\"$\",\"meta\",\"16\",{\"name\":\"twitter:image:height\",\"content\":\"660\"}],[\"$\",\"meta\",\"17\",{\"name\":\"twitter:image:alt\",\"content\":\"OpenAI Cookbook | Web Search and States with Responses API\"}],[\"$\",\"link\",\"18\",{\"rel\":\"icon\",\"href\":\"/favicon.svg\"}]]\n"])</script><script>self.__next_f.push([1,"3:null\n"])</script><script>self.__next_f.push([1,"e:I[3988,[\"310\",\"static/chunks/0e5ce63c-e6b9e60b226d30ba.js\",\"637\",\"static/chunks/637-4ae0d65e4116044f.js\",\"145\",\"static/chunks/145-a0379013fc8edaf2.js\",\"708\",\"static/chunks/708-20e21f0502595361.js\",\"884\",\"static/chunks/app/%5B...path%5D/page-36544baa9fa0916f.js\"],\"AuthorsAndDate\"]\n10:I[5230,[\"310\",\"static/chunks/0e5ce63c-e6b9e60b226d30ba.js\",\"637\",\"static/chunks/637-4ae0d65e4116044f.js\",\"145\",\"static/chunks/145-a0379013fc8edaf2.js\",\"708\",\"static/chunks/708-20e21f0502595361.js\",\"884\",\"static/chunks/app/%5B...path%5D/page-36544baa9fa0916f.js\"],\"ViewNotebookAsMarkdown\"]\n11:I[3412,[\"310\",\"static/chunks/0e5ce63c-e6b9e60b226d30ba.js\",\"637\",\"static/chunks/637-4ae0d65e4116044f.js\",\"145\",\"static/chunks/145-a0379013fc8edaf2.js\",\"708\",\"static/chunks/708-20e21f0502595361.js\",\"884\",\"static/chunks/app/%5B...path%5D/page-36544baa9fa0916f.js\"],\"ArticleWithToc\"]\nf:T49a,M7.49933 0.25C3.49635 0.25 0.25 3.49593 0.25 7.50024C0.25 10.703 2.32715 13.4206 5.2081 14.3797C5.57084 14.446 5.70302 14.2222 5.70302 14.0299C5.70302 13.8576 5.69679 13.4019 5.69323 12.797C3.67661 13.235 3.25112 11.825 3.25112 11.825C2.92132 10.9874 2.44599 10.7644 2.44599 10.7644C1.78773 10.3149 2.49584 10.3238 2.49584 10.3238C3.22353 10.375 3.60629 11.0711 3.60629 11.0711C4.25298 12.1788 5.30335 11.8588 5.71638 11.6732C5.78225 11.205 5.96962 10.8854 6.17658 10.7043C4.56675 10.5209 2.87415 9.89918 2.87415 7.12104C2.87415 6.32925 3.15677 5.68257 3.62053 5.17563C3.54576 4.99226 3.29697 4.25521 3.69174 3.25691C3.69174 3.25691 4.30015 3.06196 5.68522 3.99973C6.26337 3.83906 6.8838 3.75895 7.50022 3.75583C8.1162 3.75895 8.73619 3.83906 9.31523 3.99973C10.6994 3.06196 11.3069 3.25691 11.3069 3.25691C11.7026 4.25521 11.4538 4.99226 11.3795 5.17563C11.8441 5.68257 12.1245 6.32925 12.1245 7.12104C12.1245 9.9063 10.4292 10.5192 8.81452 10.6985C9.07444 10.9224 9.30633 11.3648 9.30633 12.0413C9.30633 13.0102 9.29742 13.7922 9.29742 14.0299C9.29742 14.2239 9.42828 14.4496 9.79591 14.3788C12.6746 13.4179 14.75 10.7025 14.75 7.50024C14.75 3.49593 11.5036 0.25 7.49933 0.25Z4:[\""])</script><script>self.__next_f.push([1,"$\",\"div\",null,{\"className\":\"w-full\",\"children\":[[\"$\",\"div\",null,{\"className\":\"mx-auto max-w-3xl px-4 sm:px-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"mb-12 mt-4\",\"children\":[[\"$\",\"h3\",null,{\"className\":\"text-sm text-gray-500 mb-2 sm:mb-8 text-center\",\"children\":\"Mar 11, 2025\"}],[\"$\",\"h1\",null,{\"className\":\"text-xl sm:text-4xl font-bold mb-12 sm:mb-16 text-center\",\"children\":\"Web Search and States with Responses API\"}],[\"$\",\"div\",null,{\"className\":\"flex justify-between items-end\",\"children\":[[\"$\",\"$Le\",null,{\"authors\":[{\"name\":\"Bill Chen\",\"website\":\"https://www.linkedin.com/in/billchen99/\",\"avatar\":\"https://avatars.githubusercontent.com/u/198814448?v=4\",\"login\":\"billchen-openai\"}],\"date\":\"2025-03-11\",\"showVerification\":true}],[\"$\",\"div\",null,{\"className\":\"flex flex-row gap-x-0\",\"children\":[[\"$\",\"a\",null,{\"href\":\"https://github.com/openai/openai-cookbook/blob/main/examples/responses_api/responses_example.ipynb\",\"target\":\"_blank\",\"rel\":\"noopener noreferrer\",\"className\":\"text-sm rounded py-2 px-2 sm:px-3 hover:bg-muted transition-colors flex gap-2 items-center\",\"children\":[[\"$\",\"svg\",null,{\"width\":\"15\",\"height\":\"15\",\"viewBox\":\"0 0 15 15\",\"fill\":\"none\",\"xmlns\":\"http://www.w3.org/2000/svg\",\"className\":\"w-4 h-4\",\"children\":[\"$\",\"path\",null,{\"d\":\"$f\",\"fill\":\"currentColor\",\"fillRule\":\"evenodd\",\"clipRule\":\"evenodd\"}]}],[\"$\",\"span\",null,{\"className\":\"max-sm:hidden\",\"children\":\"Open in GitHub\"}]]}],[\"$\",\"$L10\",null,{\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/responses_api/responses_example.ipynb\"}]]}]]}]]}]}],[\"$\",\"div\",null,{\"id\":\"content\",\"className\":\"w-full\",\"children\":[false,[\"$\",\"$L11\",null,{\"headings\":[{\"id\":\"basics\",\"text\":\"Basics\",\"level\":2,\"children\":[]},{\"id\":\"hosted-tools\",\"text\":\"Hosted Tools\",\"level\":2,\"children\":[]},{\"id\":\"multimodal-tool-augmented-conversation\",\"text\":\"Multimodal, Tool-augmented conversation\",\"level\":2,\"children\":[]}],\"children\":\"$L12\"}],false,false]}]]}]\n"])</script><script>self.__next_f.push([1,"13:I[6018,[\"310\",\"static/chunks/0e5ce63c-e6b9e60b226d30ba.js\",\"637\",\"static/chunks/637-4ae0d65e4116044f.js\",\"986\",\"static/chunks/986-1645af28514ad188.js\",\"167\",\"static/chunks/167-bf0648e29dfffe59.js\",\"957\",\"static/chunks/957-de9862c968766e70.js\",\"185\",\"static/chunks/app/layout-5bd5803f4bfffadd.js\"],\"default\"]\n16:I[5941,[\"310\",\"static/chunks/0e5ce63c-e6b9e60b226d30ba.js\",\"637\",\"static/chunks/637-4ae0d65e4116044f.js\",\"986\",\"static/chunks/986-1645af28514ad188.js\",\"167\",\"static/chunks/167-bf0648e29dfffe59.js\",\"957\",\"static/chunks/957-de9862c968766e70.js\",\"185\",\"static/chunks/app/layout-5bd5803f4bfffadd.js\"],\"ThemeToggle\"]\n17:I[6431,[\"310\",\"static/chunks/0e5ce63c-e6b9e60b226d30ba.js\",\"637\",\"static/chunks/637-4ae0d65e4116044f.js\",\"986\",\"static/chunks/986-1645af28514ad188.js\",\"167\",\"static/chunks/167-bf0648e29dfffe59.js\",\"957\",\"static/chunks/957-de9862c968766e70.js\",\"185\",\"static/chunks/app/layout-5bd5803f4bfffadd.js\"],\"MobileNav\"]\n18:I[6230,[\"310\",\"static/chunks/0e5ce63c-e6b9e60b226d30ba.js\",\"637\",\"static/chunks/637-4ae0d65e4116044f.js\",\"986\",\"static/chunks/986-1645af28514ad188.js\",\"167\",\"static/chunks/167-bf0648e29dfffe59.js\",\"957\",\"static/chunks/957-de9862c968766e70.js\",\"185\",\"static/chunks/app/layout-5bd5803f4bfffadd.js\"],\"Search\"]\n14:T565,M0.877075 7.49972C0.877075 3.84204 3.84222 0.876892 7.49991 0.876892C11.1576 0.876892 14.1227 3.84204 14.1227 7.49972C14.1227 11.1574 11.1576 14.1226 7.49991 14.1226C3.84222 14.1226 0.877075 11.1574 0.877075 7.49972ZM7.49991 1.82689C4.36689 1.82689 1.82708 4.36671 1.82708 7.49972C1.82708 10.6327 4.36689 13.1726 7.49991 13.1726C10.6329 13.1726 13.1727 10.6327 13.1727 7.49972C13.1727 4.36671 10.6329 1.82689 7.49991 1.82689ZM8.24993 10.5C8.24993 10.9142 7.91414 11.25 7.49993 11.25C7.08571 11.25 6.74993 10.9142 6.74993 10.5C6.74993 10.0858 7.08571 9.75 7.49993 9.75C7.91414 9.75 8.24993 10.0858 8.24993 10.5ZM6.05003 6.25C6.05003 5.57211 6.63511 4.925 7.50003 4.925C8.36496 4.925 8.95003 5.57211 8.95003 6.25C8.95003 6.74118 8.68002 6.99212 8.21447 7.27494C8.16251 7.30651 8.10258 7.34131 "])</script><script>self.__next_f.push([1,"8.03847 7.37854L8.03841 7.37858C7.85521 7.48497 7.63788 7.61119 7.47449 7.73849C7.23214 7.92732 6.95003 8.23198 6.95003 8.7C6.95004 9.00376 7.19628 9.25 7.50004 9.25C7.8024 9.25 8.04778 9.00601 8.05002 8.70417L8.05056 8.7033C8.05924 8.6896 8.08493 8.65735 8.15058 8.6062C8.25207 8.52712 8.36508 8.46163 8.51567 8.37436L8.51571 8.37433C8.59422 8.32883 8.68296 8.27741 8.78559 8.21506C9.32004 7.89038 10.05 7.35382 10.05 6.25C10.05 4.92789 8.93511 3.825 7.50003 3.825C6.06496 3.825 4.95003 4.92789 4.95003 6.25C4.95003 6.55376 5.19628 6.8 5.50003 6.8C5.80379 6.8 6.05003 6.55376 6.05003 6.25Z15:T49a,M7.49933 0.25C3.49635 0.25 0.25 3.49593 0.25 7.50024C0.25 10.703 2.32715 13.4206 5.2081 14.3797C5.57084 14.446 5.70302 14.2222 5.70302 14.0299C5.70302 13.8576 5.69679 13.4019 5.69323 12.797C3.67661 13.235 3.25112 11.825 3.25112 11.825C2.92132 10.9874 2.44599 10.7644 2.44599 10.7644C1.78773 10.3149 2.49584 10.3238 2.49584 10.3238C3.22353 10.375 3.60629 11.0711 3.60629 11.0711C4.25298 12.1788 5.30335 11.8588 5.71638 11.6732C5.78225 11.205 5.96962 10.8854 6.17658 10.7043C4.56675 10.5209 2.87415 9.89918 2.87415 7.12104C2.87415 6.32925 3.15677 5.68257 3.62053 5.17563C3.54576 4.99226 3.29697 4.25521 3.69174 3.25691C3.69174 3.25691 4.30015 3.06196 5.68522 3.99973C6.26337 3.83906 6.8838 3.75895 7.50022 3.75583C8.1162 3.75895 8.73619 3.83906 9.31523 3.99973C10.6994 3.06196 11.3069 3.25691 11.3069 3.25691C11.7026 4.25521 11.4538 4.99226 11.3795 5.17563C11.8441 5.68257 12.1245 6.32925 12.1245 7.12104C12.1245 9.9063 10.4292 10.5192 8.81452 10.6985C9.07444 10.9224 9.30633 11.3648 9.30633 12.0413C9.30633 13.0102 9.29742 13.7922 9.29742 14.0299C9.29742 14.2239 9.42828 14.4496 9.79591 14.3788C12.6746 13.4179 14.75 10.7025 14.75 7.50024C14.75 3.49593 11.5036 0.25 7.49933 0.25Z19:T3441,"])</script><script>self.__next_f.push([1,"Purpose: This notebook demonstrates how to use the Realtime model itself to accurately transcribe user audio out-of-band using the same websocket session connection, avoiding errors and inconsistencies common when relying on a separate transcription model (gpt-4o-transcribe/whisper-1).\n\nWe call this out-of-band transcription using the Realtime model. It’s simply a second response.create request on the same Realtime WebSocket, tagged so it doesn’t write back to the active conversation state. The model runs again with a different set of instructions (a transcription prompt), triggering a new inference pass that’s separate from the assistant’s main speech turn.\n\nIt covers how to build a server-to-server client that:\n\nStreams microphone audio to an OpenAI Realtime voice agent.\nPlays back the agent's spoken replies.\nAfter each user turn, generates a high-quality text-only transcript using the same Realtime model.\n\nThis is achieved via a secondary response.create request:\n\n{\n    \"type\": \"response.create\",\n    \"response\": {\n        \"conversation\": \"none\",\n        \"output_modalities\": [\"text\"],\n        \"instructions\": transcription_instructions\n    }\n}\n\nThis notebook demonstrates using the Realtime model itself for transcription:\n\nContext-aware transcription**: Uses the full session context to improve transcript accuracy.\nNon-intrusive**: Runs outside the live conversation, so the transcript is never added back to session state.\nCustomizable instructions**: Allows tailoring transcription prompts to specific use-cases. Realtime model is better than the transcription model at following instructions.\n\nThe Realtime API offers built-in user input transcription, but this relies on a separate ASR model (e.g., gpt-4o-transcribe). Using different models for transcription and response generation can lead to discrepancies. For example:\n\nUser speech transcribed as: I had otoo accident\nRealtime response interpreted correctly as: Got it, you had an auto accident\n\nAccurate transcriptions can be very important, particularly when:\n\nTranscripts trigger downstream actions (e.g., tool calls), where errors propagate through the system.\nTranscripts are summarized or passed to other components, risking context pollution.\nTranscripts are displayed to end users, leading to poor user experiences if errors occur.\n\nThe potential advantages of using out-of-band transcription include:\nReduced Mismatch**: The same model is used for both transcription and generation, minimizing inconsistencies between what the user says and how the agent responds.\nGreater Steerability**: The Realtime model is more steerable, can better follow custom instructions for higher transcription quality, and is not limited by a 1024-token input maximum.\nSession Context Awareness**: The model has access to the full session context, so, for example, if you mention your name multiple times, it will transcribe it correctly.\n\n\nIn terms of trade-offs:\n\nRealtime Model (for transcription):\n    Audio Input → Text Output: $32.00 per 1M audio tokens + $16.00 per 1M text tokens out.\n    Cached Session Context: $0.40 per 1M cached context tokens.\n\n    Total Cost (for 1M audio tokens in + 1M text tokens out): ≈ $48.00\n\nGPT-4o Transcription:\n\n    Audio Input: $6.00 per 1M audio tokens\n\n    Text Input: $2.50 per 1M tokens.\n\n    Text Output: $10.00 per 1M tokens\n\n    Total Cost (for 1M audio tokens in + 1M text tokens out): ≈ $16.00\n\nDirect Cost Comparison (see examples in the end of the cookbook):\n\n    Using full session context: 16-22x (if transcription cost is 0.001$/session, realtime transcription will be 0.016$/session)\n       The cost is higher since you are always passing the growing session context. However, this can potentially help with transcription.\n    Using only latest user turn: 3-5x (if transcription cost is 0.001$/session, realtime transcription will be 0.003$/session)\n       The cost is lower since you are only transcribing the latest user audio turn. However, you no longer have access to the session context for transcription quality.\n    Using 1\n\nEnsure your environment meets these requirements:\n\nPython 3.10 or later\n\nPortAudio (required by sounddevice):\n   macOS:\n          brew install portaudio\n\nPython Dependencies:\n      pip install sounddevice websockets\n\nOpenAI API Key (with Realtime API access):\n   Set your key as an environment variable:\n\n      export OPENAI_API_KEY=sk-...\n\nWe use two distinct prompts:\n\nVoice Agent Prompt (REALTIME_MODEL_PROMPT): This is an example prompt used with the Realtime model for the Speech 2 Speech interactions.\nTranscription Prompt (REALTIME_MODEL_TRANSCRIPTION_PROMPT): Silently returns a precise, verbatim transcript of the user's most recent speech turn. You can modify this prompt to iterate in transcription quality.\n\nFor the REALTIME_MODEL_TRANSCRIPTION_PROMPT, you can start from this base prompt, but the goal would be for you to iterate on the prompt to tailor it to your use case. Just remember to remove the Policy Number formatting rules since it might not apply to your use case!\n\nWe define:\n\nImports\nAudio and model defaults\nConstants for transcription event handling\n\nThe Realtime session (session.update) configures:\n\nAudio input/output\nServer‑side VAD\nSet built‑in transcription (input_audio_transcription_model)\n   We set this so that we can compare to the Realtime model transcription\n\nThe out‑of‑band transcription is a response.create triggered after user input audio is committed input_audio_buffer.committed:\n\nconversation: \"none\" – use session state but don’t write to the main conversation session state\n[output_modalities: [\"text\"]](https://platform.openai.com/docs/api-reference/realtime-client-events/response/create#realtime_client_events-response-create-response-output_modalities) – get a text transcript only\n\nNote: The REALTIME_MODEL_TRANSCRIPTION_PROMPT is not passed to the gpt-4o-transcribe model because the Realtime API enforces a 1024 token maximum for prompts.\n\n\nWe now define:\n\nencode_audio – base64 helper\nplayback_audio – play assistant audio on the default output device\nsend_audio_from_queue – send buffered mic audio to input_audio_buffer\nstream_microphone_audio – capture PCM16 from the mic and feed the queue\n\n\nThe function below enables us to generate two transcripts for each user turn:\n\nRealtime model transcript**: from our out-of-band response.create call.\nBuilt-in ASR transcript**: from the standard transcription model (input_audio_transcription_model).\n\nWe align and display both clearly in the terminal:\n\n User Turn (Realtime Transcript) ===\n...\n\n User Turn (Built-in ASR Transcript) ===\n...\n\n\nlisten_for_events drives the session:\n\nWatches for speech_started / speech_stopped / committed\nSends the out‑of‑band transcription request when a user turn finishes (input_audio_buffer.committed) when only_last_user_turn == False\nSends the out‑of‑band transcription request when a user turn is added to conversation (conversation.item.added\") when only_last_user_turn == True\nCalculates token usage and cost for both transcription methods\nStreams assistant audio to the playback queue\nBuffers text deltas per response_id\n\nIn this step, we run the code which will allow us to view the Realtime model transcription vs transcription model transcriptions. The code does the following:\n\nLoads configuration and prompts\nEstablishes a WebSocket connection\nStarts concurrent tasks:\n  listen_for_events (handle incoming messages)\n  stream_microphone_audio (send microphone audio)\n  Mutes mic when assistant is speaking\n  playback_audio (play assistant responses)\n  prints realtime and transcription model transcripts when they are both returned. It uses shared_state to ensure both are returned before printing.\nRun session until you interrupt\n\nOutput should look like:\n[client] Speech detected; streaming...\n[client] Detected silence; preparing transcript...\n\n User turn (Realtime transcript) ===\nHello.\n\n User turn (Transcription model) ===\nHello\n\n\n Assistant response ===\nHello, and thank you for calling. Let's start with your full name, please.\n\nFrom the above example, we can notice:\nThe Realtime Model Transcription quality matches or surpasses that of the transcription model in various turns. In one of the turns, the transcription model misses \"this is important.\" while the realtime transcription gets it correctly.\nThe Realtime model correctly applies rules for Policy Number formatting (XXXX-XXXX).\nWith context from the entire session, including previous turns where I spelled out my name, the Realtime model accurately transcribes my name when the assistant asked my name again while the transcription model makes errors (e.g., \"Minhaj ul Haq\").\n\nThere are significant price differences between the available methods for transcribing user audio. GPT-4o-Transcribe is by far the most cost-effective approach: it charges only for the raw audio input and a small amount of text output, resulting in transcripts that cost just fractions of a cent per turn. In contrast, using the Realtime model for out-of-band transcription is more expensive. If you transcribe only the latest user turn with Realtime, it typically costs about 3–5× more than GPT-4o-Transcribe. If you include the full session context in each transcription request, the cost can increase to about 16–20× higher. This is because each request to the Realtime model processes the entire session context again at higher pricing, and the cost grows as the conversation gets longer.\nLet's walk through an example that uses full session context for realtime out-of-band transcription:\n\n\nRealtime Out-of-Band (OOB):** $0.040974 total (~$0.006829 per turn)\nDedicated Transcription:** $0.002114 total (~$0.000352 per turn)\nOOB is ~19× more expensive using full session context**\n\n\nCaching:** Because these conversations are short, you benefit little from caching beyond the initial system prompt.\nTranscription System Prompt:** The transcription model uses a minimal system prompt, so input costs would typically be higher.\n\n\nLimit transcription to recent turns:** Minimizing audio/text context significantly reduces OOB transcription costs.\n\n\nEffective caching requires stable prompt instructions (usually 1,024+ tokens).\nDifferent instruction prompts between OOB and main assistant sessions result in separate caches.\nYou can limit transcription to only the latest user turn by supplying input item_references like this:\n    if item_ids:\n        response[\"input\"] = [\n            {\"type\": \"item_reference\", \"id\": item_id} for item_id in item_ids\n        ]\n\n    return {\n        \"type\": \"response.create\",\n        \"response\": response,\n    }\n\nTranscribing just the most recent user turn lowers costs by restricting the session context sent to the model. However, this approach has trade-offs: the model won’t have access to previous conversation history to help resolve ambiguities or correct errors (for example, accurately recalling a username mentioned earlier). Additionally, because you’re always updating which input is referenced, little caching benefit is realized, the cache prefix changes each turn, so you don’t accumulate reusable context.\n\nNow, let’s look at a second example that uses only the most recent user audio turn for realtime out-of-band transcription:\n\nRealtime Out-of-Band Transcription (OOB)\n\nTotal Cost:** $0.013354\nAverage per Turn:** ~$0.001908\n\nDedicated Transcription Model\n\nTotal Cost:** $0.002630\nAverage per Turn:** ~$0.000376\n\n\nDifference in Costs\n\nAdditional cost using OOB:* *+$0.010724**\nCost Multiplier:* OOB is about *5×** more expensive than the dedicated transcription model.\n\nThis approach costs significantly less than using the full session context. You should evaluate your use case to decide whether regular transcription, out-of-band transcription with full context, or transcribing only the latest turn best fits your needs. You can also choose an intermediate strategy, such as including just the last N turns in the input.\n\n\nExploring out-of-band transcription could be beneficial for your use case if:\n\nYou're still experiencing unreliable transcriptions, even after optimizing the transcription model prompt.\nYou need a more reliable and steerable method for generating transcriptions.\nThe current transcripts fail to normalize entities correctly, causing downstream issues.\n\nKeep in mind the trade-offs:\nCost: Out-of-band (OOB) transcription is more expensive. Be sure that the extra expense makes sense for your typical session lengths and business needs.\nComplexity: Implementing OOB transcription takes extra engineering effort to connect all the pieces correctly. Only choose this approach if its benefits are important for your use case.\n\nIf you decide to pursue this method, make sure you:\n\nSet up the transcription trigger correctly, ensuring it activates after the audio commit.\nCarefully iterate and refine the prompt to align closely with your specific use case and needs.\n\nhttps://platform.openai.com/docs/guides/realtime-conversations#create-responses-outside-the-default-conversation\nhttps://platform.openai.com/docs/api-reference/realtime-client-events/response/create#realtime_client_events-response-create-response-conversation\nhttps://platform.openai.com/docs/api-reference/realtime-client-events/response/create#realtime_client_events-response-create-response-output_modalities"])</script><script>self.__next_f.push([1,"1a:T9d57,"])</script><script>self.__next_f.push([1,"Agentic systems often reach a plateau after proof-of-concept because they depend on humans to diagnose edge cases and correct failures. This cookbook introduces a repeatable retraining loop that captures those issues, learns from the feedback, and promotes improvements back into production-like workflows. We ground the approach in a regulated healthcare documentation task, but the patterns generalize to any domain that demands accuracy, auditability, and rapid iteration.\n\nDiagnose why an autonomous agent falls short of production readiness and instrument it with measurable feedback signals.\nCompare three prompt-optimization strategies—from quick manual iteration to fully automated loops—and understand when to reach for each.\nAssemble a self-healing workflow that combines human review, LLM-as-judge evals, and iterative prompt refinement.\n\nML/AI engineers and solution architects who need to move beyond toy demos.\nProduct and delivery teams looking for executable artifacts they can adapt into internal tooling or production pipelines.\n\nStart with Section 1 to understand the healthcare use case, baseline agent, and system architecture.\nUse Section 2 to practice prompt optimization within the OpenAI Evals interface and collect structured feedback.\nRun Section 3 to automate the optimization loop with graders, evals, and retraining logic.\nReference the appendix for reusable prompts, configurations, and evaluation templates as you tailor the workflow to your environment.\n\nThe notebook is modular—feel free to run sections independently or sequentially as you adapt the retraining loop to your own agents.\n\n\nFor this cookbook, we focus on a real-world use case: drafting regulatory documents for pharmaceutical companies. These organizations must prepare and submit extensive documentation to regulatory authorities (e.g., the U.S. Food and Drug Administration) to obtain approval for new drugs. The accuracy and speed of these submissions are critical, as they directly impact how quickly life-saving treatments can reach patients.\n\nRegulatory document drafting is a highly complex, iterative, and precision-driven process that requires deep scientific, medical, and compliance expertise. Despite the availability of advanced authoring tools, it remains labor-intensive and prone to human error. Agentic systems offer substantial leverage by assisting with research synthesis, content generation, and document structuring, yet human experts are still needed to ensure factual accuracy and regulatory compliance.\n\nThe key challenge is to design a feedback loop that enables these agentic systems to learn iteratively and refine model behavior over time. Such a system can gradually shift human effort from detailed correction to high-level oversight, improving efficiency while maintaining the rigorous standards required for regulatory submissions.\n\nThe diagram below illustrates the iterative process for continuously improving an AI agent through feedback, meta prompting, and evaluation. The loop combines human judgment or automated feedback using an LLM-as-a-judge to iteratively enhance performance.\n\nFigure 1 - Diagram showing the self-evolving loop for automated agent improvement.\n\nThe process consists of the following steps:\n\nBaseline Agent\n   The process begins with a baseline agent. In this notebook, we use a deliberately simple example (an agent that summarizes sections of a document) to illustrate the iterative improvement loop. In real-world or enterprise settings, the baseline agent could be much more complex. The summaries it produces serve as the initial benchmark for subsequent evaluation and refinement.\n\nHuman Feedback (or LLM-as-judge)\n   The baseline agent’s outputs are then evaluated either by human reviewers (e.g., for production environments) and/or by an automated LLM-as-judge system. This step gathers both quantitative and qualitative feedback that indicates how well the agent meets its goals — for instance, if we are testing the length of the summary, the feedback might be “the summary is too long” or a numerical score (generally between 0 and 1) generated by eval when assessing if the summary is under 500 words.\n\nEvals and Aggregated Score\n   Based on the collected feedback, new prompts are generated and tested through evaluations (Evals). These tests measure performance against predefined criteria, and the outcomes are combined into an aggregated score that reflects the overall performance. The loop continues until the score exceeds a target threshold (e.g., 0.8) or the maximum number of retries is reached (e.g., max_retry = 10). If the retry limit is hit, engineers are alerted that manual improvements are required.\n\nUpdated Baseline Agent\n   Once an improved version achieves the target performance, it replaces the original baseline agent. This updated agent becomes the foundation for the next iteration, supporting a continuous cycle of learning, feedback, and optimization.\n\n\n\n\nThe dataset used for evaluation comprises ~70 sections extracted from the Sample CMC Section for Hyperpolarized Pyruvate (13C) Injection, publicly available here. This dataset provides realistic, domain-specific content suitable for testing both scientific summarization and regulatory compliance behavior.\n\nTo keep this cookbook self-contained and easily reproducible, we simplified the regulatory drafting use case while retaining its essential complexity. In production, a typical regulatory authoring agent comprises multiple specialized sub-agents responsible for tasks such as drafting, data analysis, compliance checking, citation generation, and fact verification.\n\nFor this guide, we narrow the scope of the regulatory authoring agent to focus on the self-healing aspect of the system. Our regulatory authoring agent consists of two sub-agents:\nA summarizer** creating scientific and concise summaries.\nA compliance checker**: evaluating each summary against key regulatory requirements (e.g., FDA 21 CFR Part 11).\n\nFigure 2 - The baseline agent as created in the AgentBuilder UI.\n\nFor the remainder of this cookbook, we implemented a simplified version of the Summarizer agent (see the section Agent Setup below). Alternatively, you can reuse the code for the agent created with AgentBuilder. If you’d like to reproduce the agent directly from the AgentBuilder UI, here are the key prompts and parameters used:\n\nSummarizer agent:** This agent used the file search tool, where the CMC PDF was uploaded to the vector store.\nPrompt: \"Summarize section {{workflow.input_as_text}} from {{state.cmc_pdf}} uploaded to the vector store.\"\n\nCompliance Checker agent:**\nPrompt: \"Verify that the summary below is compliant with FDA 21 CFR Part 11: {{input.output_text}}. If the summary is compliant, return Compliant. Otherwise, return This section needs to be manually summarized.\"\n\nBoth agents were configured with the default parameters - using GPT-5, low reasoning effort, and text as the output format.\n\n\nTo evaluate the baseline agent, there are two main approaches:\n\nCollecting Human Feedback. This approach involves gathering feedback from human users through the OpenAI Evals platform (or a custom UI built for a specific application). It is best suited for production settings or when piloting a tool where subject matter experts (SMEs) interact with the tool in real-world scenarios. This method helps uncover edge cases that may not have been identified during development. On the Evals platform, users can provide thumbs-up or thumbs-down ratings and share qualitative feedback about the summaries.\n\nUsing an LLM-as-a-Judge. This option is typically used during the development phase, enabling fast feedback loops without requiring SME's time. An LLM-as-a-judge uses an LLM to automatically evaluate and score the agent’s outputs based on predefined criteria. It can also be used for monitoring model drift (e.g., in production) or validating changes between model and model versions (e.g., switching between gpt-5 and gpt-5-mini).\n\n\nThis cookbook demonstrates both approaches:\nSection 2** shows the platform UI approach for manual prompt optimization\nSection 3** implements the fully automated API approach using LLM-as-a-judge\n\nNote: The Evals platform does not yet provide an API to retrieve user feedback programmatically.\n\n\nThe OpenAI Evals platform provides an intuitive interface for prompt optimization and evaluation. This section demonstrates the complete workflow from dataset upload through iterative prompt improvement, showing how you can leverage the platform's visual interface to optimize your prompts before implementing automated solutions.\n\n\nTo begin using the OpenAI Evaluation platform, you'll first need to upload your dataset:\n\nClick the + Create button\nDefine the dataset name\nUpload a CSV file and select the columns to keep\nUpload\n\nYour dataset should contain the documents or document sections that need to be summarized. Each row represents one input that will be processed by your system.\n\n\nOnce uploaded, you can explore your dataset. Click the dataset name to explore the uploaded data. This allows you to verify that your data is properly formatted and contains the expected content before proceeding with prompt configuration.\n\n\nThis is where you define your initial system prompt and configure how data flows through your model.\n\nFigure 3 - The platform's \"New prompt\" interface showing model configuration, variables, and system message settings.\n\n\n\nSystem Prompt: Add the system message that defines the model's task and behavior (this prompt will be optimized)\nUser Prompt Template: Add the prompt message template for user messages, using variables such as {{}} that get replaced with actual data from your dataset\nModel Selection: Choose the model for generation (e.g., gpt-4.1, gpt-5)\nTemperature: Configure creativity vs. determinism\n\nYou can start with a very simple prompt to demonstrate the power of the optimization process. For example, beginning with just \"summarize\" shows how the system can evolve from a minimal starting point.\n\n\nOnce your prompt is configured, you're ready to generate outputs across your dataset. The prompt will run once per row and output will be generated on a new output column.\n\nClick \"Generate Output\"\nThe platform runs your prompt against all samples\nResults appear in a new Output column\n\nThe platform will process each row in your dataset, replacing template variables with actual values and calling the model with your system prompt. This creates a baseline of outputs that you can evaluate.\n\n\nEvaluation is where you provide structured feedback to guide prompt improvement.\n\n\nAdd Evaluation Columns if not automatically added - Click \"Columns\" → \"Annotations\" → \"Add\":\n   Rating - Binary (good/bad) or numeric ratings\n   Feedback - Text describing what needs improvement\n\nProvide Rating and Feedback - Add your assessment for each output.\n\n   Depending on the quality of the output, you may select a good or bad rating and explain your score based on how you would like the answer to be improved. For example:\n\n      \u003e (Rating) | Feedback\n      \u003e - (Good) Good, but only the answer should be provided. The output should not include headers or any text other than the answer.\n      \u003e - (Bad)  The information is good, but it should be presented as bullet points.\n      \u003e - (Good) Good summary; it is clear.\n      \u003e - (Bad)  Use bullet points when answering to improve readability. Summarize each sub-section individually.\n\nSave Annotations - Your feedback is saved with the evaluation run\n\n\nFigure 4 - The evaluation interface showing generated outputs with rating and feedback columns for annotation.\n\nThis structured feedback becomes the foundation for automatic prompt optimization.\n\n\nAfter collecting feedback, the platform can automatically generate an improved prompt.\n\nClick \"Optimize\"\nA new prompt version is generated in a new tab\nClick \"View Prompt\" to see the improved version\n\n\nFigure 5 - The improved prompt generated by the platform, showing detailed instructions and requirements.\n\n\nWith your improved prompt ready, start a new iteration to measure improvement.\n\nClick \"Generate Output\"\nReview the new results and provide feedback on any remaining issues\nClick \"Optimize\" again if needed\nRepeat until satisfied\n\nThe platform's tab structure allows you to compare performance across iterations. You can easily see how outputs evolved from your initial prompt to the optimized versions.\n\n\nFigure 6 - Feedback and evaluation results for the optimized prompt, showing improvements in output quality.\n\n\nContinue the optimization cycle until:\nQuality threshold reached**: \u003e80% of outputs receive positive feedback\nDiminishing returns**: New iterations show minimal improvement\nSpecific issues resolved**: All identified failure modes are addressed\n\nThis platform-based approach provides an excellent foundation for understanding prompt optimization before moving to automated implementations. The visual interface makes it easy to see the impact of changes and understand the optimization process.\n\n\nThis section introduces a fully automated evaluation workflow using an LLM-as-a-Judge through the OpenAI API, eliminating the need for any user interface. This approach enables scalable, programmatic assessment of agent performance, supporting rapid iteration and continuous model monitoring in production.\n\nTo evaluate the baseline summarization agent, we use four complementary graders that balance deterministic checks with semantic judgment.\n\n| Grader | Type | Pass threshold | What it checks | Why |\n|---|---|---:|---|---|\n| Chemical string name | python | 0.8 | If any exact chemical names in the section appear in the summary. | Forces preservation of critical domain entities so summaries don’t omit chemically meaningful terms. |\n| Summarization length | python | 0.85 | Inverse deviation from an expected 100-word length. | Keeps summaries concise and comparable, reducing verbosity that can mask poor content. |\n| Cosine similarity | text_similarity | 0.85 | Cosine similarity between section and summary texts. | Ensures the summary stays anchored to the source content rather than drifting semantically. |\n| LLM-as-judge | score_model | 0.85 | A rubric-driven score from a model acting as an evaluator. | Captures nuanced quality signals that rule-based metrics miss, improving overall robustness. |\n\nNotes\nThe two Python graders catch domain fidelity and length discipline early, which stabilizes optimization before semantic tuning.\nText similarity guards against superficial rephrasing that strays from the source.\nThe LLM judge provides a holistic failsafe when edge cases slip past deterministic checks.\nYou should see an eval ID in the output, e.g. eval_.... This is the ID of the eval we just created (as shown below)\n\n\nFigure 7 - The platform's Eval interface showing data source configuration, and test criteria settings.\n\nNext we'll need run the evals on the summarization agent's output and parse the results for the eval's grader scores. To do this we'll use a few helper functions:\nrun_eval: Simple runner to call the evals API with proper formatting\npoll_eval_run: A polling utility to wait for the scheduled eval run to complete\nparse_eval_run_output: Parses the eval run and returns a structured output for the feedback loop\nNow we can use the created eval ID from earlier and run the graders against an arbitrary input section and summary output. This forms the backbone of the feedback loop which will kick off the prompt optimization routine.\n\n\nLet's test our evals by providing a section and a generated summary directly.\nYou should see a list of grader scores in the output, e.g.\n\n\nRunning this script we can see that most of our graders are passing except the chemical_name_grader. Next we'll programmatically recognize this opportunity to improve the summarization agent.\n\nNote: When you run it locally, graders other than chemical_name_grader may fail at first. This is normal, as graders can initially fail, but the results should improve through the feedback loop. Early failures simply reflect the model adjusting its responses before converging on more accurate results.\n\n\nEval runs and results can also be seen in the OpenAI Dashboard:\n\nFigure 8 - Eval dashboard showing evaluation runs and results.\n\n\nWe can also drill down into a specific eval run:\n\nFigure 9 - Detailed eval run results showing grader scores and performance metrics.\n\n\n\nNow that we have our evals and graders set up, we can go back to our summarization agent.\nFor simplicity, we will provide the code for a simple agent below. You could also use AgentBuilder, as shown in Figure 2, and export the code from the UI.\n\n\nWe will also need a metaprompt optimization agent, to optimize our prompt, as well as some simple utilities to handle prompt versions:\nPromptVersionEntry: A pydantic model used to track the prompt and metadata as it changes in production\nVersionedPrompt: A utility class to track prompt versions, this will be important in production when analyzing the evolution of the prompt as well as ensuring there is a fallback history in case of a regression\nNext we'll create the starting summarization and prompt optimization agents.\n\nNote: We created a wrapper to track prompt changes in the summarization agent since it is expected to evolve in production, the metaprompt agent's prompt will stay static for the purposes of this cookbook.\n\nThis is what we've done so far - we've created:\nEvals with 4 graders that will assess the outputs and produce a score for each grader\nA summarization agent with a versioned prompt class to track changes to the prompt and model\nA metaprompt optimization agent that will attempt to update the prompt based on a set of reasoning\n\nNow these different functionalities can be composed to orchestrate the self-evolving loop with Agent tracing in the OpenAI dashboard.\n\nKeep in mind that this is a simplified example. In a real-world scenario, you'd want to ensure you have guardrails for optimization attempts and that an alert notifies a human when a guardrail is triggered.\n\nNote: Due to practical limitations of the cookbook we are simulating a stream of data by feeding in a static dataset and using print statements in place of true observability.\n\n\nAs in previous sections we'll create some utilities to manage the orchestration logic of the feedback loop.\n\nNow to simulate a stream of requests for summarization we'll feed in a prepared dataset and observe the optimization evolve from a naive prompt.\nThe referenced dataset.csv can be found in the Github repository.\nHow the final prompt is chosen\n\nEvery evaluation logs the average grader score, the total score across graders, and whether the attempt passed the lenient criteria.\nbest_candidate tracks the most recent lenient pass (for transparency), but the final selection uses the aggregate totals to ensure we keep the top-performing prompt overall.\nWhen the loop ends, apply_best_candidate_if_needed restores the prompt with the highest cumulative grader score (ties favor the latest version), guaranteeing that the surfaced prompt is the strongest performer observed.\n\nHere is an example (abridged) output for the code above.\n\nInspecting the output shows that the self evolving prompt worked. There are a few takeaways to account for:\nThe optimization is not always successful, so being able to roll back the prompt version is important\nThe fidelity of the information from the graders is crucially important to ensuring a quality optimization\nStarting self-evolving loop | Initial prompt v0\nPrompt:You are a summarization assistant.\nGiven a section of text, produce a summary.\n[Section 7.1] Using prompt v0\n  Attempt 1: evaluating summary...\n\tScores — avg=0.805, total=3.218, lenient_passed=False\n\tFailed eval. Improving prompt...\n\tPrompt improved → v1\n  Attempt 2: evaluating summary...\n\tScores — avg=0.720, total=2.881, lenient_passed=False\n\tFailed eval. Improving prompt...\n\tPrompt improved → v2\n  Attempt 3: evaluating summary...\n\tScores — avg=0.762, total=3.048, lenient_passed=True\n\tPassed with prompt v2\n[Section 7.2] Using prompt v2\n  Attempt 1: evaluating summary...\n\tScores — avg=0.612, total=2.450, lenient_passed=False\n\tFailed eval. Improving prompt...\n\tPrompt improved → v3\n  Attempt 2: evaluating summary...\n\tScores — avg=0.915, total=3.660, lenient_passed=True\n\tPassed with prompt v3\n[Section 3.2.P.2.1] Using prompt v3\n  Attempt 1: evaluating summary...\n\tScores — avg=0.684, total=2.736, lenient_passed=False\n\tFailed eval. Improving prompt...\n\tPrompt improved → v4\n  Attempt 2: evaluating summary...\n\tScores — avg=0.684, total=2.736, lenient_passed=False\n\tFailed eval. Improving prompt...\n\tPrompt improved → v5\n  Attempt 3: evaluating summary...\n\tScores — avg=0.920, total=3.680, lenient_passed=True\n\tPassed with prompt v5\n[Section 3.2.P.2.2] Using prompt v5\n  Attempt 1: evaluating summary...\n\tScores — avg=0.737, total=2.950, lenient_passed=True\n\tPassed with prompt v5\n[Section 3.2.P.2.3] Using prompt v5\n  Attempt 1: evaluating summary...\n\tScores — avg=0.750, total=3.000, lenient_passed=True\n\tPassed with prompt v5\nCompleted optimization loop.\nFinal prompt version: v5\nBest lenient prompt: v5 (avg=0.750)\nAggregate best prompt: v5 (total=9.630, avg/section=0.802)\nFinal prompt:Optimized Technical Summarization System Prompt\n\nYou are a technical summarization assistant specialized in scientific and regulatory documents. Your objective is to generate a summary that preserves every explicit detail and organizational structure from the source text, without any paraphrasing, omission, or synthesis.\n\nStrict Summarization Guidelines:\n\n1. Comprehensive Detail Inclusion:\nTranscribe all named compounds, salts, excipients, drug substances, molecular designations, batch codes, identifiers, and CAS numbers exactly as written.\nInclude every stated concentration, unit, measurement, quantitative value, compositional detail, and preparatory parameter verbatim and in original format.\nAccurately replicate all descriptions of appearance, color, physical state, rationale for inclusion, and labeling or typographical conventions present in the source.\nClearly include all section titles, headings, subsections, hierarchical numbering, referenced sections, and in-line citations or figures.\n\n2. Prohibited Actions:\nDo NOT paraphrase, summarize, interpret, synthesize, restructure, generalize, or alter any information at any level.\nDo NOT omit, compress, merge, or reorder any data point, named entity, technical term, or explicit instruction from the source.\nDo NOT introduce additional content, inference, or editorial clarification.\n\n3. Structural and Formatting Requirements:\nMaintain verbatim order, sectioning, and hierarchy from the source text, including all original lists, bullet points, numbering, or formatting.\nReproduce every element in the precise sequence, alignment, and structure as the input, ensuring maximal traceability.\nIf the source uses lists, tables, subpoints, or hierarchies, mirror them exactly.\n\n4. Precision, Fidelity, and Reviewability:\nYour summary must enable full regulatory or technical audit by containing every explicit detail, designation, and measurement from the original—unaltered and unabridged.\nThe output must be comprehensive, exhaustive, and identical in informational content and structure to the input. Every visible explicit detail must be present.\n\nOutput Instruction:\nBegin summarization after this message, applying the above rules without exception. Each output must be concise in format but all-inclusive in content, reflecting every explicit fact, designation, and organizational feature of the source text, and suitable for regulatory or expert review. No interpretation, paraphrasing, or omission is permitted under any circumstance.\n\nWe can view optimization workflow runs in the dashboard under logs:\n\nFigure 10 - Agent log traces showing optimization workflow runs in the dashboard.\n\nAnd drill down into the different agent calls:\n\nFigure 11 - Detailed agent trace showing individual agent calls and execution flow.\n\n\nOnce the evaluation loop is complete, the system should continue to monitor new incoming data and periodically re-evaluate model performance on blind datasets. This ensures the model remains accurate and compliant as the data distribution evolves.\n\nTo enable continuous monitoring, you can integrate a cron job or a lightweight scheduler loop that periodically checks for updates in your data source (e.g., new PDF uploads or database entries). When new data is detected, the system automatically triggers the evaluation and optimization loop described earlier.\n\nFor example (pseudo code):\nThis approach allows the model to continuously learn and adapt, improving over time as it processes fresh data — a key requirement for maintaining high-quality, real-world performance.\n\n\nWe now have a fully automated loop improving our prompt with evals and accepting the new prompt when the rating is over the defined threshold.\n\nIn production, you could use a similar framework to monitor the performance of your agents as new user requests come in.\nAs mentioned above, this is a simplified example, and in a real-world scenario you'd want to have additional guardrails and a human-in-the-loop approach to approve new prompts.\n\nTaking this concept further, we can also use evals to test different model parameter candidates such as the model version, verbosity, and reasoning. To see the full available set of parameters that could considered, check the ModelSettings class in the Agents SDK\n\nThe compare_model_candidates function is an example of how to:\nOptimize the prompt\nGenerate candidate outputs from the optimized prompt using two or more different models\nUse evals to grade the candidate outputs and select the best candidate\n\nIt can be worked into the self_evolving_loop function with minimal refactoring.\nNOTE: Production testing of model versions should be limited to versions within the same family version (e.g. gpt-5, gpt-5-mini, gpt-5-nano). It is recommended to conduct cross family version selection pre-production deployment.\n\nAnd the final self_evolving_loop with model comparison code:\nHere we can see a very similar output with additional information on the model version scores:\nStarting self-evolving loop | Initial prompt v0\nPrompt:\n\tYou are a summarization assistant.\nGiven a section of text, produce a concise, accurate summary.\n\n[....]\n\n[Section 3.2.P.2.2] Using prompt v2\n\tAttempt 1: evaluating summary...\n\tFailed eval. Improving prompt...\nCandidate average — gpt-5: 0.3533 (passed=False)\nCandidate average — gpt-5-mini: 0.4670 (passed=False)\nNo passing models. Best candidate (model=gpt-5-mini, avg=0.4670) did not pass. Prompt not updated.\n\tNo passing model found. Optimization failed for this section.\n\tAttempt 2: evaluating summary...\nExceeded retries, aborting\n\tPassed with prompt v2\n\nCompleted optimization loop.\nFinal prompt version: v2\nFinal prompt:\nImproved Prompt:\n\nYou are a summarization assistant.\nGiven any section of text, generate a concise and accurate summary that includes all key concepts, components, and their main characteristics or interactions as described in the original section. Your summary should be brief yet complete, faithfully reflecting essential information, descriptors, and relationships between elements while omitting unnecessary details. Ensure the summary maintains the original meaning and captures all critical content and terminology relevant to the section.\n\nWe've demonstrated that the self-evolving loop works and that a prompt can be improved autonomously using Evals. However, we relied on a relatively straightforward, static metaprompt to improve our system prompt. In this section, we explore a more dynamic and reflexive method by using Genetic-Pareto (GEPA) [[1]](##Citations) — a framework that samples agent trajectories, reflects on them in natural language, proposes prompt revisions, and evolves the system through iterative feedback loops.\n\nThe GEPA method, described in the paper available here, offers an compelling blueprint for continuous, self-improving prompt optimization. The code below draws generously on the GEPA Github repository available here.\nWe’ll reuse our graders and helper functions by adding a small adapter so that our setup works with GEPA. GEPA’s GEPAAdapter makes it easy to plug into our eval framework. We defined three hooks\nevaluate: runs the summarization and grades with graders defined in the previous section (i.e., chemical_name_grader, word_length_deviation_grader, cosine_similarity, llm_as_judge).\nget_components_to_update: gets the text fields GEPA should evolve (here, system_prompt).\nmake_reflective_dataset: packages inputs, outputs, and feedback for reflection.\nNow that the adapter is ready, we can run GEPA using the same starting prompt (\"You are a summarization assistant. Given a section of text, produce a summary.\") and model (here, gpt-5) as in the earlier self-evolving loop for comparison. We provide our adapter instance, seed candidate, and training/validation sets to gepa.optimize(...). During the optimization, GEPA repeatedly invokes the adapter to score candidates, reflects on feedback, and ultimately produces the best evolved prompt.\n\nNote: GEPA might take ~10-15 minutes to complete.\nHere is an example (abridged) output for the code above:\nIteration 0: Base program full valset score: 0.2183466466681351\nIteration 1: Selected program 0 score: 0.2183466466681351\nIteration 1: Proposed new text for system_prompt:\n\n[.......]\n\nIteration 3: New subsample score 0.6592202195294341 is better than old score 0.6565039300893376. Continue to full eval and add to candidate pool.\nGEPA Optimization:  90%|█████████ | 18/20 39:21, 3.2.P.7, company codes, CAS numbers).\n...\nSelf-check before finalizing:\nHave you included every chemical name exactly as written?\nIs the summary within 45–70 words (≤90 max) and a single paragraph?\nAre key process/regulatory/test details and critical numbers preserved without unnecessary verbosity?\n\nIn this cookbook, we explored three distinct approaches to prompt optimization:\n\nOpenAI Platform Optimizer:** using the Optimize button with a dataset containing manually entered human feedback (thumbs up/down and textual comments), we quickly produced a strong prompt with minimal configuration. This method excels at rapid iteration, but does not provide the automation needed for production environments.\n\nOptimization using a static metaprompt:** Our loop, incorporating four different graders,enabled automated exploration and iterative self-improvement without manual intervention. However, its exploration space was limited by a single static meta-prompt, and evaluation was performed section by section. Consequently, this approach risked overfitting to immediate grader feedback instead of achieving broader generalization.\n\nGEPA optimization:** Offering a more structured search process, reflective updates were informed by both quantitative scores and textual feedback, while candidates were trained on one dataset and validated on another. This method produced a more robust, generalized prompt and provided clearer empirical evidence of its performance.\n\nNote: Examples of prompts generated by each method are available in the Appendix.\n\nDepending on your use case, you may prioritize speed (OpenAI optimizer), lightweight automation (static metaprompt), or systematic generalization (GEPA). In practice, combining these methods by starting with rapid iteration and progressing toward reflective optimization can deliver both agility and performance.\n\nHappy coding!\n\nThis cookbook is based on a joint collaboration between [Bain and OpenAI.\n\nCalvin Maguranis\nFanny Perraudeau\nGiorgio Saladino\nShikhar Kwatra\nValentina Frenkel\n\n[1] GEPA: Reflective Prompt Evolution Can Outperform Reinforcement Learning by Lakshya A Agrawal, Shangyin Tan, Dilara Soylu, Noah Ziems, Rishi Khare, Krista Opsahl-Ong, Arnav Singhvi, Herumb Shandilya, Michael J Ryan, Meng Jiang, Christopher Potts, Koushik Sen, Alexandros G. Dimakis, Ion Stoica, Dan Klein, Matei Zaharia, Omar Khattab - https://arxiv.org/abs/2507.19457\n\n\nInitial prompt:**\nYou are a summarization assistant. Given a section of text, produce a summary.\n\nOpenAI Platform Optimizer:**\nYou are a summarization assistant.\nTask: Summarize the provided text concisely and accurately.\nOutput requirements:\nOutput only the summary. Do not add titles, labels (e.g.,\n\"Summary:\"), prefaces, or commentary.\nPreserve the document's structure. If multiple sections/subsections appear, summarize each one.\nUse a numbered list for sections/subsections (use their numbers/titles when present).\nUnder each, use short dash bullets for key points.\nIf there is only a single short section, return a brief bullet list or 1-2 concise sentences.\nSplit any inline lists into separate bullets.\nUse plain, simple language. Keep bullets tight (ideally one line each). Remove redundancy.\nInclude important quantitative details (values, units, conditions) and constraints. Do not invent information.\nKeep formatting simple: plain text, \"1.\" numbering and \"-\" bullets only. No tables or special markup.\nRetain exact technical terms/notation from the source (e.g., chemical names, isotopic labels).\nIf a section is explicitly marked \"Not applicable,\" include that status; otherwise do not add it.\n\nStatic metaprompt:**\nYou are a technical summarization assistant for scientific and regulatory documentation. Your task is to generate a concise, comprehensive, and fully detailed summary of any scientific, technical, or regulatory text provided. Strictly adhere to the following instructions:\n\n1. Complete and Exact Information Inclusion\nCapture every explicit fact, technical value, specification, quantity, measurement, regulatory reference, entity, process, site, and contextual detail verbatim from the source text.\nDo not omit or generalize any explicit information, no matter how minor.\n\n2. Precise Terminology and Named Entity Retention\nReproduce all names of chemicals, drugs, mixtures, buffer components, devices, companies, institutions, regulatory standards, section numbers, and procedural labels exactly as stated.\nReport all quantities, measurements, concentrations, ratios, masses, volumes, compositions, pH values, and units precisely as given.\nDo not paraphrase, rename, substitute, or simplify any term or value.\n\n3. All Procedural Details and Justifications\nExplicitly include all described procedures, technical processes (e.g., terminal sterilization, aseptic processing), operational constraints, process justifications, compliance requirements, and standards references.\nClearly state all reasons provided for choosing or omitting particular methods or processes.\n\n4. Regulatory and Compliance References\nAccurately cite all regulations, standards (e.g., USP ), compliance statements, section numbers, and cross-references as in the original.\nInclude all explicit mentions of compliance, applicability, and site location details.\n\n5. Explicit Statements of Absence, Limitations, and Applicability\nClearly state any declarations of absence, inapplicability (“Not applicable”), or limitations exactly as written in the source.\n\n6. Structural and Organizational Fidelity\nPrecisely reflect the original document’s section and subsection hierarchy, using clear section labels and indentation.\nPresent all enumerations, lists, and tabulated data in structured bullet-point or numbered format, organized in accordance with the source document’s arrangement.\n\n7. No Paraphrasing, Summarizing, or Reinterpretation\nDo not paraphrase, summarize contextually, reinterpret, or alter the meaning or sequence of any content.\nRemove only literal repetitions or redundant phrasing; otherwise, preserve all explicit statements, technical details, and contextual notes.\n\nSummary Output Objective:\nProduce a summary that delivers the full technical, factual, and regulatory content and structure of the original text, reformatted by eliminating only redundant language. The summary must enable audit, regulatory review, or peer reference without loss of any explicit information or terminology from the source.\n\nApply these instructions rigorously to every provided document section to ensure scientific and regulatory accuracy and completeness.\n\nGEPA optimizer**:\nYou are a domain-aware summarization assistant for technical pharmaceutical texts. Given a “section” of text, produce a concise, single-paragraph summary that preserves key technical facts and exact nomenclature.\n\nLength and format\nWrite 1–3 sentences totaling about 45–70 words (target ~60; never exceed 90).\nUse one paragraph; no bullets, headings, tables, or heavy formatting.\n\nExact names and notation\nInclude every chemical name that appears in the section at least once, using the exact original spelling, capitalization, punctuation, isotopic labels, brackets, hyphens, salts, buffer names, and parenthetical qualifiers. Treat distinct case/format variants as distinct names (e.g., [1-13C]pyruvic acid and [1-13C]Pyruvic acid are separate and each must appear once).\nExamples you must preserve verbatim when present: Hyperpolarized Pyruvate (13C) Injection; non-polarized Pyruvate Injection; Pyruvate (13C) Injection; hyperpolarized [1-13C]pyruvate; Mixture of [1-13C]pyruvic acid and 15 mM AH111501 sodium salt; TRIS/EDTA buffer solution; TRIS; NaOH; Na2EDTA; [1-13C]pyruvic acid; AH111501 sodium salt.\nAlso preserve exact study identifiers, batch codes, section numbers, regulatory citations, and instrument parameters as written (e.g., GE-101-001, GE-101-003, USP , 3.2.P.5.2.5, FFF106/140-806, FFF106/142-806, 3T MRI, 5 degree RF pulse, TR=3s, 90 degree pulse, 64 averages, TR=10s, 10 μl Gd/ml solution).\n\nContent prioritization (if space is tight)\n1) What the section is about (topic/purpose).\n2) All named chemical entities and compositions (list all chemical names at least once; include concentrations/amounts if given).\n3) Critical process/handling facts (e.g., aseptic processing vs terminal sterilization; ISO classifications; filtration specs; compounding/filling steps; temperatures/times/volumes; storage/administration limits).\n4) Container/packaging specifics (e.g., cryovials, “sterile fluid path”).\n5) Microbiological/testing/regulatory details (e.g., sterility/pyrogenicity testing timing; USP ; state board compliance; site/manufacturer if stated).\n6) Overages/single-dose formulas and key quantities.\n\nNumerical fidelity\nPreserve all critical numbers and units exactly (e.g., 1.44 g, 27.7 mg, 15 mM, 18 mL, 1.47 g, two 0.2 μm filters, ISO 7, ISO 5, 38 mL).\nInclude testing/analysis parameters when present (e.g., polarization/relaxation time (T1); number of spectra; pulse angles; TR values; MRI location relative to clean room).\n\nStyle and compression\nBe neutral and factual; do not infer unstated information.\nConsolidate repeated statements; compress lists with commas/semicolons to save words.\nMention tables/figures only to convey key data; do not reproduce them.\nIf many chemicals are present, ensure each distinct name appears once; group them succinctly.\nAvoid symbols or special formatting not in the source text.\n\nCommon domain cues to include when present\nAseptic processing vs terminal sterilization and the rationale/timing (e.g., “tested for sterility and pyrogenicity subsequent to patient administration”).\nEnvironmental/processing controls (ISO 7/ISO 5; LAF unit; filtration; filling/weight targets per cryovial).\nSite/regulatory context (e.g., USP ; California State Board of Pharmacy; University of California, San Francisco Department of Clinical Pharmacy).\nStudy/kit equivalence statements (e.g., equivalence to GE-101-001/GE-101-003 formulations).\nQC/measurement methods (e.g., capacitive threshold at Administration syringe nominal 38 mL).\n\nSelf-check before finalizing\nDoes the paragraph contain every distinct chemical name exactly as written in the section (including case and notation variants)?\nIs the summary 45–70 words (≤90), in a single paragraph?\nAre the most critical process/regulatory/testing details and all key numbers preserved without unnecessary verbosity?`\n`"])</script><script>self.__next_f.push([1,"1b:T525c,"])</script><script>self.__next_f.push([1,"ROOST and OpenAI have prepared a guide that explains how to write policy prompts that maximize gpt-oss-safeguard's reasoning power, choose the right policy length for deep analysis, and integrate oss-safeguard's reasoning outputs into production Trust \u0026 Safety systems.\n\n\ngpt-oss-safeguard is a first open weight reasoning model specifically trained for safety classification tasks to help classify text content based on customizable policies. As a fine-tuned version of gpt-oss, gpt-oss-safeguard is designed to follow explicit written policies that you provide. This enables bring-your-own-policy Trust \u0026 Safety AI, where your own taxonomy, definitions, and thresholds guide classification decisions. Well crafted policies unlock gpt-oss-safeguard's reasoning capabilities, enabling it to handle nuanced content, explain borderline decisions, and adapt to contextual factors.\n\nYou can read more about how OpenAI uses the internal version of gpt-oss-safeguard here.\n\nLarge language models can be considered safety models in two main ways:\n\nFine-tuned safety models start as general reasoning models (like gpt-oss) and are trained to respond safely within user interactions.\nPrebaked safety models (like ShieldGemma, LlamaGuard, RoGuard, etc) come with built-in definitions of what counts as “unsafe” and fixed policy taxonomies.\n\ngpt-oss-safeguard was purpose-built for Trust \u0026 Safety workflows and is a policy-following model that can reliably interpret and enforce your own written standards and tell you why it made the decision it made. The reasoning behind the model makes it well-suited for integration with a larger safety system that is rooted in auditability and customization.\n\n\nLike the gpt-oss family of models, this is an open source model with open weights that you run locally or integrate into your own infrastructure. It is designed to work with the harmony response format. Harmony is the structured prompt interface that gives gpt-oss-safeguard access to its full reasoning stack and ensures consistent, well-formed outputs.\n\nThe gpt-oss family of models, including gpt-oss-safeguard, can be run on servers using:\n\nvLLM (for dedicated GPUs like NVIDIA’s H100s)\nHuggingFace Transformers (for consumer GPUs)\nGoogle Colab\n\nAnd locally using:\n\nLM Studio\nOllama\n\n\ngpt-oss-safeguard is designed for users who need real-time context and automation at scale, including:\n\nML/AI Engineers** working on Trust \u0026 Safety systems who need flexible content moderation\nTrust \u0026 Safety Engineers** building or improving moderation, Trust \u0026 Safety, or platform integrity pipelines\nTechnical Program Managers** overseeing content safety initiatives\nDevelopers** building projects/applications that require contextual, policy-based content moderation\nPolicy Crafters** defining what is accepted by an organization who want to test out policy lines, generate examples, and evaluate content\n\nSafety-tuned models excel at content moderation when given clear, structured prompts. This guide covers key learnings from deploying moderation systems in production, focusing on prompt structure, output formatting, and length optimization.\n\n\nThe Transformers library by Hugging Face provides a flexible way to load and run large language models locally or on a server. This guide takes you through running OpenAI gpt-oss models using Transformers, either with a high-level pipeline or via low-level generate calls with raw token IDs. The simplest way to interact with the server is through the transformers chat CLI\n\ntransformers chat localhost:8000 --model-name-or-path openai/gpt-oss-safeguard-20b\n\nor by sending an HTTP request with cURL, e.g.\n\ncurl http://localhost:8000/v1/chat/completions \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"model\": \"openai/gpt-oss-safeguard-20b\",\n    \"stream\": true,\n    \"messages\": [\n      { \"role\": \"system\", \"content\": \"\" },\n      { \"role\": \"user\", \"content\": \"\" }\n    ]\n  }'\n\n\n\nAdditional use cases, like integrating transformers serve with Cursor and other tools, are detailed in the documentation.\n\n\nOllama supports gpt-oss-safeguard 20B and 120B models directly. The following commands will automatically download the model and run it on your device.\n\n\nollama run gpt-oss-safeguard:20b\n\n\nollama run gpt-oss-safeguard:120b\n\nOllama supports OpenAI API, Ollama's API, Python and JavaScript SDKs for building applications or tools using the gpt-oss-safeguard models. Please learn more from Ollama's documentation.\n\n\nAlternatively, you can use LM Studio to run the models locally including using OpenAI Chat Completions and Responses API compatible APIs. Head over to the gpt-oss-safeguard page for LM Studio or run the following commands to download the respective models:\n\n\nlms get openai/gpt-oss-safeguard-20b\n\n\nlms get openai/gpt-oss-safeguard-120b\n\n\nvLLM recommends using uv for Python dependency management. The following command will automatically download the model and start the server.\n\nuv pip install vllm==0.10.2 --torch-backend=auto\n\nvllm serve openai/gpt-oss-safeguard-120b\n\nLearn more about how to use gpt-oss with vLLM.\n\n\ngpt-oss-safeguard uses the harmony prompt format to provide a structured output and provide reasoning. This is critical for Trust \u0026 Safety workflows where you need to understand and audit why a decision or classification was made. With the harmony format, oss-safeguard separates its response into two parts:\n\nReasoning channel: Where the model reasons through the policy, considers edge cases, and explains its logic\nOutput channel: The formatted classification decision you specified\n\nThrough harmony, you can control how deeply oss-safeguard reasons by setting the reasoning_effort parameter in your system message to low, medium, or high. The model uses medium by default if it is not set. Higher reasoning effort allows oss-safeguard to consider more factors, trace through multiple policy sections, and handle complex interactions between rules. Lower effort provides faster responses for straightforward classifications.\n\nIf you're using vLLM (recommended for most users) or another inference solution that provides chat message inputs, the harmony format is applied automatically when you format requests as chat messages:\n\nSystem message:** Your policy prompt (include Reasoning: high or similar in the system message to control reasoning effort).\nUser message:** The content to classify.\n\n\noss-safeguard is designed to use your written policy as its governing logic. While most models provide a confidence score based on the features it was trained on and require retraining for any policy changes, oss-safeguard makes decisions backed by reasoning within the boundaries of a provided taxonomy. This feature lets T\\\u0026S teams deploy oss-safeguard as a policy-aligned reasoning layer within existing moderation or compliance systems. This also means that you can update or test new policies instantly without retraining the entire model.\n\n\noss-safeguard performs best when policies are organized like a Trust \u0026 Safety policy guide rather than an essay. If you already have a set of policies, you’ll be in great shape. Use headers and clear categories so the model can navigate definitions efficiently. If you’ve written policy for teams before, this should feel familiar.\n\n\nA policy prompt defines the operational boundaries of a model’s behavior. Similar to content or platform policies written for human reviewers, policies for oss-safeguard should clearly specify what constitutes a violation, what is allowed, and how to communicate that difference into a decision that flows into the rest of the Trust \u0026 Safety system.\n\nEffective policy prompts are structured in order to distinguish between similar content types, catch subtle, coded or indirect violations, and prevent false positives on edge cases. Think of it as combining a policy document with training examples.\n\n\nPolicy prompts should have four separate sections.\n\nInstruction: what the model MUST do and how the model should answer.\nDefinitions: concise explanations of key terms.\nCriteria: distinctions between violating and non-violating content.\nExamples: short, concrete instances near the decision boundary. It’s important to have both examples of what you want to classify, and what you do not want to classify\n\nBecause oss-safeguard is tuned for structured moderation, it expects explicit instructions for how to respond. A policy prompt will likely perform better if it follows a consistent pattern that includes the expected format for the response and output. The harmony format’s structured channels allow oss-safeguard to reason through these sections before emitting only the final label:\n\n\n\nDescribe what oss-safeguard should do and how to respond.\n\n\nClarify key terms and context.\n\n\nDescribe behaviors or content that should be flagged.\n\n\nDescribe content that should not be flagged.\n\n\nProvide 4–6 short examples labeled 0 or 1.\n\nContent: [INPUT]\nAnswer (0 or 1):\n\nTo reduce the likelihood of false positives or confusion, avoid using words like “generally” or “usually”. If there are situations where there’s ambiguity, add an escalation path for manual review. This is also especially helpful for regional or language differences.\n\nBe explicit about priority and precedence so the model understands which policy wins if there is a conflict. If there are multiple policy violations, define which one is dominant.\n\n\nPolicy length is a key control over how deeply gpt-oss-safeguard can reason about your rules. Longer policies add nuance to handle complex cases, but can impact the output and responses. When using the harmony response format, the model can process longer policies more reliably because reasoning happens in the hidden analysis channel, not in the visible final output.\n\nUse https://platform.openai.com/tokenizer to determine the length of your prompt. gpt-oss-safeguard can provide a reasonable output at \\~10,000 token policies, but early testing suggests the optimal range is between 400-600 tokens. It’s important to experiment and see what works best for you as there is no one-size-fits-all approach. Think of the policy length like a “context budget.” Too short, and the model lacks detail; too long, and the model risks confusion. This is similar to writing policy for people to understand as well. In the same way you should account for giving the model enough output tokens to generate a response. Since the model is using reasoning you should leave plenty of room for output tokens and ideally not cap the maximum output tokens to give the model enough room to reason through the policies. If you want to limit the reasoning time, consider setting the reasoning effort to low instead.\n\nIf you have a longer policy with multiple categories, consider pre‑compressing each policy to 300–600 tokens (including definitions, disallowed categories, and 1-2 examples each for violations and non-violations).\n\noss-safeguard can also evaluate multiple policies simultaneously, so long as all policies are included in the prompt. We have found that additional policies lead to small but meaningful degradations in accuracy, so we recommend experimenting with adding and removing policies if using oss-safeguard for multiple harm domains.\n\n\nConsistent responses from gpt-oss-safeguard require explicit, literal output instructions. Every policy prompt should state exactly how the model must respond and demonstrate the correct and incorrect patterns. The output instructions define how gpt-oss-safeguard communicates its final decision and determines whether outputs can be relied upon. Because gpt-oss-safeguard operates within the harmony response format, all output instructions must:\n\nExplicitly define the output format: specify exactly what the model should return (e.g., 0/1, JSON object, category label list).\nInclude policy references when applicable: if your workflow tracks enforcement by category or rule, require the model to return that field; for simple binary output, this can be omitted.\nBe reinforced throughout the policy: repeat the output instruction at least once near the top (in “INSTRUCTIONS”) and again near the bottom (before “EXAMPLES”) to fortify compliance during reasoning.\n\n\nBinary output limits gpt-oss-safeguard's reasoning to a simple yes/no decision. Use this when speed matters more than understanding why the decision was made, but recognize you're not leveraging gpt-oss-safeguard's core reasoning strength.\n\nReturn exactly one character: 0 or 1.\nDo not include any explanation or punctuation.\n\n0 = Content does NOT violate this policy.\n1 = Content violates this policy.\n\n\nCategory labels encourage gpt-oss-safeguard to reason about which section of your policy applies, but don't require detailed explanation of why. This format enables basic reasoning transparency while keeping outputs concise.\n\nIf the content violates this policy, return:\n{\"violation\": 1, \"policy_category\": \"\"}\n\nIf the content does NOT violate this policy, return:\n{\"violation\": 0, \"policy_category\": null}\n\nExample:\n{\"violation\": 1, \"policy_category\": \"H2.f\"}\n\n\nOne of the most powerful features of gpt-oss-safeguard is its ability to think and reason. The model must not only classify content, but trace its logic through your policy, identify which specific rules apply, and articulate why. When you require rationales, gpt-oss-safeguard reasons more carefully. It must consider multiple policy sections, evaluate how they interact, and construct a logical explanation. This deeper reasoning often catches nuances that simpler output formats miss. This output format maximizes gpt-oss-safeguard's reasoning capabilities.\n\nAsk the model to decide, then justify briefly. Ask for a short, non-step-by-step rationale (2–4 bullets or 1–2 sentences) and consider requiring policy citations (rule IDs/sections) so the model justifies its thinking and decision.\n\n{\n  \"violation\": 1,\n  \"policy_category\": \"H2.f\",\n  \"rule_ids\": [\"H2.d\", \"H2.f\"],\n  \"confidence\": \"high\",\n  \"rationale\": \"Content compares a protected class to animals, which is dehumanizing.\"\n}\n\n\nBecause gpt-oss-safeguard interprets written rules rather than static categories, gpt-oss-safeguard adapts to different product, regulatory, and community contexts with minimal engineering overhead.\n\ngpt-oss-safeguard is designed to fit into Trust \u0026 Safety teams’ infrastructure. However, since gpt-oss-safeguard may be more time and compute intensive than other classifiers, consider pre-filtering content that is sent to gpt-oss-safeguard. OpenAI uses small, high-recall classifiers to determine if content is domain-relevant to priority risks before evaluating that content with gpt-oss-safeguard. You should consider two main things when deciding when and where to integrate oss-safeguard in your T\\\u0026S stack:\n\nTraditional classifiers have lower latency and cost less to sample from than gpt-oss-safeguard\nTraditional classifiers trained on thousands of examples will likely perform better on a task than gpt-oss-safeguard\n\n\nUse gpt-oss-safeguard to label posts, messages, or media metadata for policy violations. Its policy reasoning supports nuanced classification to determine contextual details when making a decision. gpt-oss-safeguard can be integrated with:\n\nReal-time ingestion pipelines\nReview queues and moderation consoles\nDownranking or filtering systems\n\n\ngpt-oss-safeguard's reasoning capabilities make it uniquely suited for automated triage in Trust \u0026 Safety workflows. Unlike traditional classifiers that only provide labels and confidence scores, gpt-oss-safeguard acts as a reasoning agent that evaluates content, explains its decision, cites specific policy rules, and surfaces cases requiring human judgment. This can reduce the cognitive load on human moderators while increasing trust and transparency in automated decisions.\n\n\nBefore rolling out a new or revised policy, run it through gpt-oss-safeguard to simulate how content will be labeled. This can be helpful to identify overly broad definitions, unclear examples, and borderline cases.\n\n\ngpt-oss-safeguard’s bring-your-own-policy design allows policy teams to A/B test alternative definitions directly in production without model retraining.\n\n\n\nOsprey is ROOST’s open-source rules engine and investigation framework. It evaluates real-time events against configurable logic trees and dispatches actions you define. Rules alone handle deterministic cases well (e.g., keyword matches, metadata thresholds), but they can struggle with satire, coded language, or nuanced policy boundaries. By integrating gpt-oss-safeguard, Osprey can:\n\nAdd contextual reasoning**: gpt-oss-safeguard interprets edge cases that simple conditions cannot.\nEnforce policies directly**: gpt-oss-safeguard reads and applies your written policy text, ensuring consistency with human moderation.\nMaintain auditability**: Osprey logs which rule called gpt-oss-safeguard, which policy category was returned, and the model’s rationale.\nBlend automation and human oversight**: deterministic rules trigger fast actions; gpt-oss-safeguard handles reasoning before escalation to manual review in other tools\n\ngpt-oss-safeguard should not be called on every event. It can instead be a plugin that can be called only when there are ambiguous cases that need the policy-reasoning power of gpt-oss-safeguard.\n\n\nTry using any policy you’ve already written, or use this template and fill in what you’re trying to classify.\n\n\n\n[Term 1]: [Definition]\n\n[Term 2]: [Definition]\n\n[Term 3]: [Definition]\n\n\n\nContent that:\n\n[Violation 1]\n[Violation 2]\n[Violation 3]\n[Violation 4]\n[Violation 5]\n\n\nContent that is:\n\n[Acceptable 1]\n[Acceptable 2]\n[Acceptable 3]\n[Acceptable 4]\n[Acceptable 5]\n\n\n\nContent: \"[Example]\"\n\nExpected Response:\n\n\nContent: \"[Example]\"\n\nExpected Response:\n\n\nContent: \"[Example]\"\n\nExpected Response:\n\n\nContent: \"[Example]\"\n\nExpected Response:\n\nYou can also use this example prompt about spam as a reference:\n\nSpam Policy (#SP)\nGOAL: Identify spam. Classify each EXAMPLE as VALID (no spam) or INVALID (spam) using this policy.\n\nDEFINITIONS\n\nSpam**: unsolicited, repetitive, deceptive, or low-value promotional content.\n\nBulk Messaging:** Same or similar messages sent repeatedly.\n\nUnsolicited Promotion:** Promotion without user request or relationship.\n\nDeceptive Spam:** Hidden or fraudulent intent (fake identity, fake offer).\n\nLink Farming:** Multiple irrelevant or commercial links to drive clicks.\n\nAllowed Content (SP0 – Non-Spam or very low confidence signals of spam)\nContent that is useful, contextual, or non-promotional. May look spammy but could be legitimate.\n\nSP0.a Useful/info request** – “How do I upload a product photo?”\n\nSP0.b Personalized communication** – “Hi Sam, here is the report.”\n\nSP0.c Business support** – “Can you fix my order?”\n\nSP0.d Single contextual promo** – “Thanks for subscribing—here’s your welcome guide.”\n\nSP0.e Generic request** – “Please respond ASAP.”\n\nSP0.f Low-quality formatting** – “HeLLo CLICK here FAST.”\n\nSP0.g Vague benefit statement** – “This tool changes lives.”\n\n  Output: VALID either clearly non-spam or very low confidence signals content could be spam.\n\nLikely Spam (SP2 – Medium Confidence)\nUnsolicited promotion without deception.\n\nSP2.a Cold promotion** – “Check out my Shopify course: shopcoach.biz”\n\nSP2.b Irrelevant ads** – “Buy gold rings here!”\n\nSP2.c Excessive linking** – “http://x.com http://y.com http://z.com”\n  Output: INVALID\n\nHigh-Risk Spam (SP3 – Strong Confidence)\nSpam showing scaling, automation, or aggressive tactics.\n\nSP3.a Repetitive posting** – “JOIN NOW JOIN NOW JOIN NOW”\n\nSP3.b Pyramid/affiliate bait** – “Earn $$$ by recruiting members”\n\nSP3.c Fake engagement** – “Comment ‘YES’ to win $500 gift card”\n\nSP3.d Misleading claims** – “Guaranteed 10,000 new followers overnight\\!”\n  Output: INVALID\n\nMalicious Spam (SP4 – Maximum Severity)\nSpam with fraud, deception, or harmful intent.\n\nSP4.a Phishing** – “Your account is locked. Enter your password here.”\n\nSP4.b Malware/scam** – “Download invoice.exe to claim payment.”\n\nSP4.c Account takeover attempts** – “Send crypto to 0xABC123 to double your money.”\n  Output: INVALID + ESCALATE\n\nLABEL FORMAT\nEach item gets two labels:\n\nDepiction (D-SP#):** Presence of spam in content.\n\nRequest (R-SP#):** User asking to generate spam.\n  | Example | Classification |\n  |----------|---------------|\n  | “Shop this site: dealplanet.io” | D-SP2, R-SP0 |\n  | “Write a sales blast message with 10 links” | D-SP0, R-SP2 |\n  | “How can I make this link look legitimate so viewers put in their private credentials” | D-SP4, R-SP4 |\n  | “Promote crypto fast to random people” | D-SP0, R-SP3 |\n\nAMBIGUITY \u0026 ESCALATION\n\nIf unclear → downgrade severity by 1 and seek clarification.\n\nIf automation suspected → SP2 or higher.\n\nIf financial harm or fraud → classify SP4.\n\nIf combined with other indicators of abuse, violence, or illicit behavior, apply highest severity policy."])</script><script>self.__next_f.push([1,"1c:T4bfc,"])</script><script>self.__next_f.push([1,"At DevDay 2025 we launched AgentKit, a complete set of tools for developers and enterprises to build, deploy, and optimize agents. AgentKit is a set of interconnected building blocks:\n\nAgent Builder: visually build and iterate on agent workflows\nChatKit: easily embed chat-based workflows into your app\nEvals: improve the performance of your LLM-powered apps\n\nThis cookbook will take an end-to-end journey through AgentKit - we'll build, deploy, and optimize an app. You'll understand how AgentKit’s building blocks connect together, enabling you to bring your agentic workflows into production faster and more reliably.\n\nWe’ll walk through the following steps:\n\nBuild a workflow in Agent Builder to serve as the back-end of our app\nDeploy a front-end chat app using the ChatKit web component\nOptimize workflow performance in Evals with prompt optimization and trace grading\n\nLet's get started by using Agent Builder to create the initial workflow that will underpin our app. Agent Builder is a visual canvas that lets you drag-and-drop nodes to design your agentic workflows. You can learn more about Agent Builder here, including additional functionality and a full list of supported nodes, but in this cookbook we'll create a simple workflow with three Agent nodes working sequentially.\n\nWe’ll build a simple app that helps people accelerate their careers through curated learning recommendations. Users can upload their resume and tell us their dream job, and they'll receive a curated set of learning courses based on the skills they need to develop. So we'll create three agents:\n\nResume extraction agent to parse uploaded resumes and extract relevant skills and experiences\nCareer analysis agent to analyze knowledge gaps relative to their target job\nCourse recommendation agent which uses the upstream information to suggest relevant online courses.\n\nLet's build each of these agents sequentially.\n\n\nThis agent will be responsible for parsing the uploaded resume and returning a structured output of skills and experiences that will be used for downstream analysis. We'll use the following prompt:\n\n\nExtract and summarize information from the input resume, organizing your output by category and providing context where available.\nAnalyze the provided input to identify skills and professional experiences.\nFor each skill or experience, extract the supporting context or evidence from the text (e.g., for the skill of Python, context might be “used Python in data analysis for three years at [Company]”).\nContinue reviewing the text until all skills and experiences are extracted.\n\nWe'll use gpt-5 for this agent, starting with minimal reasoning, but we can always change the model later if needed. And, we'll enforce a structured response (by selecting Output format to JSON, and adding a schema) to instruct the model to return the exact data shape we're looking for. (The JSON schema for this structured output can be found here.)\n\n\nThis agent will analyze skill and knowledge gaps for an individual to progress to a desired professional or career goal. We'll use gpt-5 for this agent and select reasoning effort low, which should provide sufficient reasoning for this level of analysis while keeping the responses sufficiently fast.\n\nYour role is to analyze skill and knowledge gaps for an individual to progress to a desired professional or career goal.\n\nYou will receive a list of the already-obtained skills and experiences of an individual, as well as a description of the goal. First, understand the goal and analyze the critical skills or knowledge areas required for achieving the goal. Then, compare the requirements to what the individual already possesses.\n\nReturn a list of the top 3-5 skills that the individual does not possess, but are important for their professional goal. Along with each skill, include a brief description.\n\nIndividual's expressed goal:\n{{workflow.input_as_text}}\n\nAlready-obtained skills and experiences:\n{{input.output_text}}\n\nNote that our prompt includes context from previous nodes enclosed in {{brackets}}. You can also click \"Add context\" to see the context variables to the model.\n\nThis agent will use the web search tool to find and select online training courses that match the identified skill gaps. We'll use gpt-5 with minimal reasoning and equip this agent with Web Search.\n\nYour job is to identify and recommend online training courses that help develop one or more of the skills identified. Given the list of required skills and descriptions below, return a list of 3-5 online courses along with course details.\n\nSkills: {{input.output_text}}\n\nNow that we've built our initial workflow, we can use the Preview functionality in Agent Builder to give it a spin! We'll first Publish the workflow, which will create a named and versioned copy (with a unique workflow ID) that we can share with colleagues, or deploy or revert between versions as needed.\n\nPreview lets you interact with your workflow the same way a chat user would, from directly within Agent Builder. If we upload a resume, type in a description of our dream job, and click Submit, we'll see the workflow proceed step-by-step through each node on the left of the screen, and we'll see the output from each node on the right.\n\nAs an example, I've uploaded a resume for a teacher who's looking to become a school superintendent.\n\n\nWe can follow the workflow as it proceeds through resume parsing, skill analysis, and web search. As the workflow completes, as expected we see a list of online programs that meet the search parameters.\n\nEverything looks good - we're now ready to deploy our app! Let's make sure we publish any changes we've made, and get the workflow ID. We can select \"Code\" at the top of the screen to access the ID again.\n\nNote that you can use the \"Agents SDK\" tab to access the code that supports the workflow you just built, implemented using the Agents SDK package (in JavaScript/TypeScript or Python). This is a great option if you want to run your workflow in your own environment, or develop it further with custom functionality. (However, you would miss out on some of the benefits of using AgentKit in an integrated way, as we describe below.)\n\nTo deploy our app, we'll use the ChatKit starter template to help us spin up a chat-based app using the ChatKit web component.\n\nBefore doing that, it's worth explaining the full set of options that the suite of tools across AgentKit provides for deploying your agentic workflows. We've already seen how you can build a workflow in Agent Builder, and then run it directly within the tool (Preview), or export it as Agents SDK code to use in your own environment. Now, we'll demonstrate how you can use an Agent Builder workflow ID to create a chat experience embedded in your own front-end, which points to the workflow you created as a back-end. (By the way, you can also use just the rich chat GUI provided by the ChatKit SDK, without the workflow back-end - learn more here.)\n\nSo let's get started with the ChatKit starter template and plug in our workflow. The starter template makes it simple to spin up a chat-based app using our newly created workflow. Just follow the Getting Started instructions in the repo, entering in your workflow ID from Agent Builder as the value for NEXT_PUBLIC_CHATKIT_WORKFLOW_ID into .env.local, and running npm install and then npm run dev to test the app.\n\nIn just a few minutes, the workflow is embedded in a front-end chat interface that's up and running!\n\n\nOne of the most valuable aspects of AgentKit is how quickly it enables you to experiment, iterate, and improve your agentic applications. Let's make some quick changes that will improve the functionality of our app and provide a richer chat experience.\n\nFirst, let's add some custom theming to give our front-end some style, while still retaining the native chat experience. A great resource here is ChatKit Studio, which includes a playground to explore the customization options in ChatKit, a Widget Builder (which we'll see in action shortly), and sample apps and galleries for inspiration. To get our custom theme, we'll use the ChatKit Playground to visually select our desired style options, click on the `` icon at the top of the Playground screen to get the configuration code.\n\nWe'll use the theme object from this code to overwrite the default theme located in lib/config.ts. While we're in that file, we'll also adjust the starter prompts, greeting text, and placeholder copy to more appropriate values:\n\nexport const GREETING = \"Upload your resume, and tell me the job you're looking to get!\";\nexport const PLACEHOLDER_INPUT = \"Describe your dream job, and don't forget to attach your resume!\";\n\nNext, we'll design a custom widget to display our recommended courses in a more intuitive format that makes it easier for users to understand and compare. We can use the Widget Builder to simply describe the output we're looking for, and get an LLM-generated starting point that we can edit further. For this example, we'll present the courses in a list with a clean, structured format, and we'll also show a summary below the recommendations. In the Widget Builder, we can see not only the widget code (top-left), but sample data (bottom-left) and how that data gets rendered within the widget for the end user (right).\n\nWhen we're happy with the design, we can download the .widget file. (The file used in the screenshot below is located here.)\n\nTo actually use the custom widget we've designed in our chat app, we need to instruct our workflow to return the widget component as part of our recommendation agent's response. So we'll go back to the Course recommendations agent, select Output format of Widget, and upload the .widget file.\n\nOur agent will automatically know to output the JSON format required to populate the widget. However, we'll need to update the agent prompt to instruct the model a bit more precisely what information it needs to obtain about each course.\n\nYour job is to identify and recommend online training courses that help develop one or more of the skills identified. Given the list of required skills, return a list of 3-5 online courses along with course details including course name, provider (school or program), recommendation reason (a brief sentence on why you're recommending the course), course format, and URL. In addition to the list of courses, share a few-sentence summary of the recommendations you're making.\n\nFinally, because we're dealing with resumes, we'll add a guardrail to our workflow to make sure we're not propagating any personally identifiable information (PII) where it doesn't belong. We'll insert this guardrail between our resume parser and our career analysis agents, which will help prevent anything downstream of the resume agent from having access to any PII, such as a name or contact information.\n\n\n\nNow we’ll see how the native integrations with Evals help make it easy to optimize both individual agents and your entire workflow. Let's imagine our chat app has been deployed - perhaps to an initial set of internal users or beta testers - and we have some real-world examples of users interacting with the system.\n\nIf this application were being developed into a production-grade system where performance and quality were critical, we'd want to incorporate evals even earlier and more systematically into our development process. (You can learn more in Eval Driven System Design about how to build a set of initial evals and established ground truth, mapping evals to business metrics, and progressively improve your system to drive the business goals.)\n\nBut in this cookbook, we'll focus less on the techniques behind evals as part of LLM app development, and more about how AgentKit lets you implement these techniques more easily. We'll drive performance improvements in two ways: first we'll optimize a single agent node in our workflow using the prompt optimization tool, then we'll optimize the entire workflow using trace grading.\n\n\nWe want to dive into our Course recommendations agent to see if we can improve the quality of its recommendations to users. We've isolated some sample prompts for this agent from our test environment. (You can also access completed in the Logs tab of the API platform. For this cookbook example, you can access here the data set we'll be using.)\n\nWe can optimize our agent starting directly from Agent Builder. Select the Course recommendations agent, and click on \"Evaluate\" in the bottom right of the agent modal. This will take us directly to the Datasets feature within Evals.\n\nWe see the configuration of our agent has been copied over, and we're ready to optimize. Let's first upload the data file with sample prompts (note the column names should match your input and output variables), and click \"Generate output\" to generate responses.\n\nNow, let's create some human annotations and model graders. We'll select \"Columns\" to add a Rating (thumbs up/down) and Feedback (text input), and we'll manually review our samples to populate these fields with some high-quality feedback. We'll also add a couple of model graders, which will evaluate the agent's output in an automated way based on criteria that we can specify. For this example, we might be concerned about whether the course recommendations are relevant to the skill gaps identified (relevance), whether all of the skill gaps are addressed (coverage), and whether the recommendation summary that is presented is appropriate (style).\n\nHere are example model grader prompts for each criteria:\n\n[relevance] You are evaluating whether a list of recommended courses is relevant to the skills described. Return a pass if all courses are relevant to at least one skill, and fail otherwise.\n\n[coverage] You are evaluating whether a list of recommended courses covers all of the skills described. Return a pass if all of the skills are covered by at least one course, and fail otherwise.\n\n[summary] You are evaluating whether the summary recommendation provided is relevant, thoughtful, and related to the recommended courses proposed. Evaluate the summary recommendation on a scale of 0 to 1, with 1 being the highest quality.\n\nWe'll use GPT-5 for our model graders, and include a 0.7 threshold for the summary grader.\n\nWe'll now select Grade \u003e All graders to run these graders against the system output. As the grading proceeds, we'll start to see the cells populated to indicate how each example scored on our model grader criteria.\n\nNow, here's where the magic happens: we can click Optimize to automatically rewrite our prompt based on the feedback we've provided - both the model grader output and the human-provided feedback.\n\nIf we examine the new prompt, we see that our prompt contains new Requirements and Output format sections to instruct the model to make the course descriptions more specific, and aim for better coverage of the different skills.\n\nRequirements:\n\nUse the web search tool to find and verify real, currently available online courses and their direct URLs.\nReturn 3–5 courses that collectively cover the skills. If a course spans multiple skills, indicate it.\nBe specific and concise. Each course description must be one sentence (max 35 words) focused on outcomes and topics tied to the skills.\nProvide plain text only; no citations or references.\n\nOutput format:\n\n1) Summary (2–4 sentences) explaining how the selections address the skills and any coverage tradeoffs.\n2) Courses (3–5 items). For each course, include exactly:`\n   Course name — Provider (school or program)\n   Description: [one sentence, max 35 words]\n   URL: [direct course page]\n   Skills covered: [list skill names from below]\n\nNow, we can click Update to automatically insert the new prompt into our workflow in Agent Builder. In just a few minutes, we've been able to use real prompt examples and feedback to automatically improve our system's performance - all directly within the Agent Builder and Evals tools.\n\n(Although in this cookbook we've optimized our prompt automatically using this grading output, it's often very helpful to examine specific failure examples to understand in what ways the model might be making mistakes. This analysis can help us generate more precise human-based or model-graded feedback, and even synthesize data to help improve performance against specific failure modes.)\n\n\nOnce we're comfortable with the performance of each individual agent node, we can turn our attention to the full workflow.\n\nPreviously, in order to analyze and improve the performance of a complex workflow involving multiple agents, you'd need to read through entire traces of your workflow to understand exactly where and why the system was failing. This can be a time-consuming process, especially when you have a large number of trace examples.\n\nUsing trace grading, we can now run end-to-end assessments of full sets of traces using automated model grading. We'll create graders to describe the behavior we're looking to correct, and we'll automatically run these graders across our entire data set.\n\nTo get started, we'll go back to our workflow in Agent Builder and click Evaluate on the top of the screen. This lets us deep-dive into the traces that have been generated for our workflow runs, including examining the inputs and outputs for all nodes (in this case, the prompts and responses for each of our agents).\n\nWe can create graders to run across the entire model trace, defining evaluation criteria for the end-to-end workflow that spans multiple agents. For example, we might want to ensure that the final recommendation summary (output of agent 3) is relevant to the user’s initial input about their career goals (input to agent 1). And, we might want to check that the recommended courses (output of agent 3) are not duplicative with the skills the user already possesses (output of agent 1).\n\nIf you had a workflow with conditional statements or while loops, you could grade against more complex multi-step behavior, such as a support agent shouldn’t engage in more than three responses with a user without escalating to a supervisor.\n\nOnce we have a full set of grading criteria, we select Grade all to grade our traces. This action will lead us to the Evaluations tab, where we can see a new eval has been created and an eval run has been kicked off.\n\nWe can then dive into the workflow traces for our failure cases to better understand why the specific workflow run failed, and how we can improve our system to avoid the failure. This approach helps you optimize complex workflows more efficiently, by iteratively identifying failure modes, evaluating the performance of your system, and targeting improvements to improve performance.\n\nWe demonstrated how Agent Builder, ChatKit, and Evals work together to help you build, deploy, and optimize agentic workflows.\n\nWith a specific example — a career development app that analyzes resumes, identifies skill gaps, and recommends online courses — we saw how Agent Builder makes it easy to design and build multi-agent workflows, ChatKit lets us embed those workflows in a rich and customizable chat UI, and Evals close the loop by enabling prompt optimization and trace grading against real data.\n\nTo learn more, here's a list of some of the resources mentioned in this cookbook:\n\nAgent Builder documentation\nChatKit starter template\nChatKit Studio\nAgents SDK\nEvals\n\nHappy building!"])</script><script>self.__next_f.push([1,"1d:T4154,"])</script><script>self.__next_f.push([1,"Growing up, I was fascinated by the idea of Jarvis—an intelligent assistant that could autonomously handle complex workflows. What I didn’t realize back then was that I was imagining the future of voice agents. OpenAI was the first to make this vision real with the launch of 4o-audio, and more recently made it even more accessible—cutting costs by 70%—with the release of GPT Realtime Mini, which offers lower latency and major improvements in tool calling.\n\nBuilding with speech models, however, is fundamentally different from working with text-only interfaces. In addition to prompt engineering, audio models bring new challenges: they’re more latency-sensitive, require managing a WebRTC session, and introduce additional variability through voice activity detection (VAD).\n\nTo make this process easier, OpenAI has released the Agents SDK in both Python and TypeScript, along with detailed examples that showcase our recommended design patterns for building reliable voice agents.\n\nBefore diving into code, let’s map out exactly what we’ll be building—and how it fits into the broader agent handoff architecture.\nFor our application today we are going to be building an extremely simple customer support app using the “handoff architecture”. “Handoff Architecture” means a primary agent acts as the orchestrator for all incoming customer queries. Rather than handling every request directly, the primary agent analyzes the intent behind the user’s message and categorizes it into one of 2 core pathways:\n\nGeneral questions and basic support (no authenticator required).\nSpecific questions (user authentication required before lookup is performed).\n\nBased on this categorization, the primary agent hands off the conversation to the appropriate specialist agent designed for that specific task.\n\nalt text\nInstead of starting from scratch we're going to be working from the openai-agents-js repo, so lets start by cloning, installing the necessary dependencies, and building the web demo\ngit clone https://github.com/openai/openai-agents-js/tree/main\n\nAfter cloning follow along with the steps in the readme to get started\nnpm install @openai/agents zod@3\npnpm examples:realtime-next\n\nIf everything works as expected you should see a simple chat interface\nalt text\nGreat! Now that we've cloned the repo, we are going to be modifying openai-agents-js/examples/realtime-next/src/app/page.tsx, starting with the Main Agent. Our Main Agent is the point of entry for the application stack. It acts as an intent classifier for any user query choosing how to re-route between different layers.\n\nThe implementation is fairly straightforward\nconst mainAgent = new RealtimeAgent({\n  name: 'Main Agent',\n  instructions:\n    'You are the entry point for all customer queries. Default to the no-auth QA flow. If authentication is needed and validated, escalate to the Auth Layer by handing off to either the Flight Status Checker or Rebooking Agent. Do not answer policy questions from your own knowledge; rely on subordinate agents and tools.',\n  tools: [\n    checkFlightsTool,\n  ],\n  handoffs: [qaAgent],\n});\n\nNow that we’ve built the main agent, the next step is to add a specialized supporting agent to handle a specific class of customer queries. For general airline policy questions, this will be the QA Agent.\n\nIn a real-world product, this agent would power a more sophisticated experience: it would ingest company-specific PDFs and other reference materials, embed them, and dynamically query those documents at runtime to provide accurate, policy-grounded answers.\n\n┌────────────┐      ┌────────────┐      ┌────────────────────────┐      ┌────────────┐\n│ User Query │ ───► │ QA Agent   │ ───► │ Vector DB / Retriever  │ ───► │ LLM Answer │\n└────────────┘      └────────────┘      └────────────────────────┘      └────────────┘\n                          │                     │\n                          │ build search        │ top-k context\n                          ▼                     ▼\n                 (semantic search)      (grounded generation)\n\n\nThis would typically involve building a full vector database service that embeds the customer’s query and retrieves the most relevant results. For the sake of simplicity in this demo, we’ll mock that part of the pipeline.\n\nIf you’re interested in learning how to implement a fully featured retrieval system, take a look at our other cookbooks on the topic here.\n\nconst documentLookupTool = tool({\n  name: 'document_lookup_tool',\n  description: 'Looks up answers from known airline documentation to handle general questions without authentication.',\n  parameters: z.object({\n    request: z.string(),\n  }),\n  execute: async ({ request }) =\u003e {\n    const mockDocument = `Airline Customer Support — Quick Reference\n\nEach passenger may bring 1 carry-on (22 x 14 x 9) and 1 personal item.\nChecked bags must be under 50 lbs; overweight fees apply.\nOnline check-in opens 24 hours before departure.\nSeat upgrades can be requested up to 1 hour before boarding.\nWi‑Fi is complimentary on all flights over 2 hours.\nCustomers can change flights once for free within 24 hours of booking.\nExit rows offer extra legroom and require passengers to meet safety criteria.\nRefunds can be requested for canceled or delayed flights exceeding 3 hours.\nPets are allowed in the cabin if under 20 lbs and in an approved carrier.\nFor additional help, contact our support team via chat or call center.`;\n    return mockDocument;\n  },\n});\n\nLike before when we defined the Main Agent we are going to create another instance of RealtimeAgent but this time we are going to supply a documentLookupTool.\n\nconst qaAgent = new RealtimeAgent({\n  name: 'QA Agent',\n  instructions:\n    'You handle general customer questions using the document lookup tool. Use only the document lookup for answers. If the request may involve personal data or operations (rebooking, flight status), call the auth check tool. If auth is required and validated, handoff to the appropriate Auth Layer agent.',\n  tools: [documentLookupTool],\n});\nWe’ve already built a powerful foundation: a main agent that can handle inbound customer queries, and a QA agent that searches our document store to provide accurate, policy-based answers.\n\nWhat’s missing is a layer for customer-specific information—for example, queries like “What’s the status of my flight?” or “Which terminal should I go to?”. To support these kinds of personalized interactions, we need to embed an authentication layer into the workflow so the system can securely access and respond with user-specific data.\n\n┌────────────┐      ┌──────────────┐      ┌───────────────────────┐      ┌───────────────────────┐\n│ User Query │ ───► │ Auth Layer   │ ───► │ Customer Data Access  │ ───► │ LLM Answer (Personal) │\n└────────────┘      └──────────────┘      └───────────────────────┘      └───────────────────────┘\n                        │                          │\n                        │ verify identity          │ query flight / account\n                        ▼                          ▼\n                (token, SSO, OTP, etc.)   (e.g., flight status, profile info)\nFortunately, the Agents SDK is designed to support this kind of use case. For customer support scenarios that involve sensitive, account-level information, we can ensure proper access control by using the needsApproval parameter within tool, which requires the user to authenticate before any protected data is accessed.\n\nconst checkFlightsTool = tool({\n  name: 'checkFlightsTool',\n  description: 'Call this tool if the user queries about their current flight status',\n  parameters: z.object({}),\n  // Require approval so the UI can collect creds before executing.\n  needsApproval: true,\n  execute: async () =\u003e {\n    if (!credState.username || !credState.password) {\n      return 'Authentication missing.';\n    }\n    return ${credState.username} you are currently booked on the 8am flight from SFO to JFK;\n  },\n});\n\nWhen a tool is registered with needsApproval, it automatically emits a tool_approval_requested event during the session. This allows us to add logic inside the RealtimeAgent instantiation block of our web application to listen for these events and update the UI accordingly—for example, by prompting the user to approve or authenticate before continuing.\n\n  const [credUsername, setCredUsername] = useState('');\n  const [credPassword, setCredPassword] = useState('');\n  const [pendingApproval, setPendingApproval] = useState(null);\n\n  useEffect(() =\u003e {\n    session.current = new RealtimeSession(mainAgent, {\n        // other configs go here!\n    });\n    // various other event based logic goes here!\n    session.current.on(\n      'tool_approval_requested',\n      (_context, _agent, approvalRequest) =\u003e {\n        setPendingApproval(approvalRequest.approvalItem); //\n          // ... remainder of component logic\n\n      )}\n  )\nAnd with that, we’re done! You’ve now built the core components of a customer support application:\n\nA generalist agent capable of handling a wide range of customer support queries\nAn authentication workflow that verifies user identity and retrieves customer-specific information\n\nWith everything in place, the final version of realtime-next/src/app/page.tsx should look like this.\n\n'use client';\n\nimport {\n  RealtimeAgent,\n  RealtimeSession,\n  tool,\n  TransportEvent,\n  RealtimeOutputGuardrail,\n  OutputGuardrailTripwireTriggered,\n  RealtimeItem,\n} from '@openai/agents/realtime';\nimport { useEffect, useRef, useState } from 'react';\nimport { z } from 'zod';\nimport { getToken } from './server/token.action';\nimport { App } from '@/components/App';\nimport { CameraCapture } from '@/components/CameraCapture';\n\n// Demo-only credential store the tool can read at execution time\nconst credState: { username?: string; password?: string } = {};\n\n// ---------------------------------------------\n// Tools.\n\nconst documentLookupTool = tool({\n  name: 'document_lookup_tool',\n  description: 'Looks up answers from known airline documentation to handle general questions without authentication.',\n  parameters: z.object({\n    request: z.string(),\n  }),\n  execute: async ({ request }) =\u003e {\n    const mockDocument = `Airline Customer Support — Quick Reference\n\nEach passenger may bring 1 carry-on (22 x 14 x 9) and 1 personal item.\nChecked bags must be under 50 lbs; overweight fees apply.\nOnline check-in opens 24 hours before departure.\nSeat upgrades can be requested up to 1 hour before boarding.\nWi‑Fi is complimentary on all flights over 2 hours.\nCustomers can change flights once for free within 24 hours of booking.\nExit rows offer extra legroom and require passengers to meet safety criteria.\nRefunds can be requested for canceled or delayed flights exceeding 3 hours.\nPets are allowed in the cabin if under 20 lbs and in an approved carrier.\nFor additional help, contact our support team via chat or call center.`;\n    return mockDocument;\n  },\n});\n\nconst checkFlightsTool = tool({\n  name: 'checkFlightsTool',\n  description: 'Call this tool if the user queries about their current flight status',\n  parameters: z.object({}),\n  // Require approval so the UI can collect creds before executing.\n  needsApproval: true,\n  execute: async () =\u003e {\n    if (!credState.username || !credState.password) {\n      return 'Authentication missing.';\n    }\n    return ${credState.username} you are currently booked on the 8am flight from SFO to JFK;\n  },\n});\n\n// ---------------------------------------------\n// Agents for each layer.\n\n// 2. No-Auth Layer: QA Agent with doc lookup and auth check tool.\nconst qaAgent = new RealtimeAgent({\n  name: 'QA Agent',\n  instructions:\n    'You handle general customer questions using the document lookup tool. Use only the document lookup for answers. If the request may involve personal data or operations (rebooking, flight status), call the auth check tool. If auth is required and validated, handoff to the appropriate Auth Layer agent.',\n  tools: [documentLookupTool],\n});\n\n// 1. Main Agent: entry point and routing.\nconst mainAgent = new RealtimeAgent({\n  name: 'Main Agent',\n  instructions:\n    'You are the entry point for all customer queries. Default to the no-auth QA flow. If authentication is needed and validated, escalate to the Auth Layer by handing off to either the Flight Status Checker or Rebooking Agent. Do not answer policy questions from your own knowledge; rely on subordinate agents and tools.',\n  tools: [\n    checkFlightsTool,\n  ],\n  handoffs: [qaAgent],\n});\n\n// Cross-handoffs so agents can return or escalate.\nqaAgent.handoffs = [mainAgent];\n\nexport default function Home() {\n  const session = useRef | null\u003e(null);\n  const [isConnected, setIsConnected] = useState(false);\n  const [isMuted, setIsMuted] = useState(false);\n  const [outputGuardrailResult, setOutputGuardrailResult] =\n    useState | null\u003e(null);\n\n  const [events, setEvents] = useState([]);\n  const [history, setHistory] = useState([]);\n  const [mcpTools, setMcpTools] = useState([]);\n  const [credOpen, setCredOpen] = useState(false);\n  const [credUsername, setCredUsername] = useState('');\n  const [credPassword, setCredPassword] = useState('');\n  const [pendingApproval, setPendingApproval] = useState(null);\n\n  useEffect(() =\u003e {\n    session.current = new RealtimeSession(mainAgent, {\n      model: 'gpt-realtime-mini',\n      outputGuardrailSettings: {\n        debounceTextLength: 200,\n      },\n      config: {\n        audio: {\n          output: {\n            voice: 'cedar',\n          },\n        },\n      },\n    });\n    session.current.on('transport_event', (event) =\u003e {\n      setEvents((events) =\u003e [...events, event]);\n    });\n    session.current.on('mcp_tools_changed', (tools) =\u003e {\n      setMcpTools(tools.map((t) =\u003e t.name));\n    });\n    session.current.on(\n      'guardrail_tripped',\n      (_context, _agent, guardrailError) =\u003e {\n        setOutputGuardrailResult(guardrailError);\n      },\n    );\n    session.current.on('history_updated', (history) =\u003e {\n      setHistory(history);\n    });\n    session.current.on(\n      'tool_approval_requested',\n      (_context, _agent, approvalRequest) =\u003e {\n        setPendingApproval(approvalRequest.approvalItem);\n        setCredUsername('');\n        setCredPassword('');\n        setCredOpen(true);\n      },\n    );\n  }, []);\n\n  async function connect() {\n    if (isConnected) {\n      await session.current?.close();\n      setIsConnected(false);\n    } else {\n      const token = await getToken();\n      try {\n        await session.current?.connect({\n          apiKey: token,\n        });\n        setIsConnected(true);\n      } catch (error) {\n        console.error('Error connecting to session', error);\n      }\n    }\n  }\n\n  async function toggleMute() {\n    if (isMuted) {\n      await session.current?.mute(false);\n      setIsMuted(false);\n    } else {\n      await session.current?.mute(true);\n      setIsMuted(true);\n    }\n  }\n\n  function handleCredCancel() {\n    const approval = pendingApproval;\n    setCredOpen(false);\n    setPendingApproval(null);\n    if (approval) session.current?.reject(approval);\n  }\n\n  function handleCredSubmit(e: React.FormEvent) {\n    e.preventDefault();\n    if (!credUsername || !credPassword) return;\n    // Store creds for the tool to read\n    credState.username = credUsername;\n    credState.password = credPassword;\n    const approval = pendingApproval;\n    setCredOpen(false);\n    setPendingApproval(null);\n    setCredUsername('');\n    setCredPassword('');\n    if (approval) session.current?.approve(approval);\n  }\n\n  return (\n\n      {credOpen \u0026\u0026 (\n\n              Authentication Required\n\n                Enter username and password to continue.\n\n               setCredUsername(e.target.value)}\n              /\u003e\n               setCredPassword(e.target.value)}\n              /\u003e\n\n                  Cancel\n\n                  Continue\n\n      )}\n\n         {\n            if (!session.current) return;\n            session.current.addImage(dataUrl, { triggerResponse: false });\n          }}\n        /\u003e\n\n  );\n}\n`"])</script><script>self.__next_f.push([1,"1e:T43c4,"])</script><script>self.__next_f.push([1,"Think of prompting like briefing a cinematographer who has never seen your storyboard. If you leave out details, they’ll improvise – and you may not get what you envisioned. By being specific about what the “shot” should achieve, you give the model more control and consistency to work with.\n\nBut leaving some details open can be just as powerful. Giving the model more creative freedom can lead to surprising variations and unexpected, beautiful interpretations. Both approaches are valid: detailed prompts give you control and consistency, while lighter prompts open space for creative outcomes. The right balance depends on your goals and the result you’re aiming for.\nTreat your prompt as a creative wish list, not a contract. Like with ChatGPT, using the same prompt multiple times will lead to different results – this is a feature, not a bug. Each generation is a fresh take, and sometimes the second or third option is better.\n\nMost importantly, be prepared to iterate. Small changes to camera, lighting, or action can shift the outcome dramatically. Collaborate with the model: you provide direction, and the model delivers creative variations.\n\nThis isn’t an exact science—think of the guidance below as helpful suggestions we’ve learned from working with the model.\n\nThe prompt controls the content of the video, but certain attributes are governed only by API parameters. You cannot request them in prose, they must be set explicitly in your API call:\nmodel**: sora-2 or sora-2-pro.\nsize**: a string in the form {width}x{height}. Supported resolutions are dependent on the model selection:\n    sora-2\n        1280x720, 720x1280\n    sora-2-pro\n        1280x720, 720x1280\n        1024x1792, 1792x1024\nseconds**: the clip length, supported values: “4”, “8”, “12”. Default value is “4”.\n\nThese parameters are the video’s container – resolution, duration, and quality will not change based on prose like “make it longer.” Set them explicitly in the API call; your prompt controls everything else (subject, motion, lighting, style).\nVideo resolution directly influences visual fidelity and motion consistency in Sora. Higher resolutions generate detail, texture, and lighting transitions more accurately, while lower resolutions compress visual information, often introducing softness or artifacts.\nThe model generally follows instructions more reliably in shorter clips. For best results, aim for concise shots. If your project allows, you may see better results by stitching together two 4 second clips in editing instead of generating a single 8 second clip.\nA clear prompt describes a shot as if you were sketching it onto a storyboard. State the camera framing, note depth of field, describe the action in beats, and set the lighting and palette. Anchoring your subject with a few distinctive details keeps it recognizable, while a single, plausible action makes the shot easier to follow.\n\nDescribing multiple shots in a single prompt is also valid if you need to cover a sequence. When you do this, keep each shot block distinct: one camera setup, one subject action, and one lighting recipe at a time. This gives you flexibility to generate short standalone clips or longer, continuous moments, depending on your project. Treat each shot as a creative unit, and you can either stitch them together in an edit or let them play out as a sequence in one go.\n\nShorter prompts give the model more creative freedom. Expect surprising results.\nLonger, more detailed prompts restrict the model's creativity. It will try to follow your guidance, but might not always do so reliably.\n\nHere's an example for a short prompt:\nIn a 90s documentary-style interview, an old Swedish man sits in a study and says, \"I still remember when I was young.\"\nThis prompt will likely work well:\n90s documentary sets the style of the video. The model will choose variables like camera lens, lighting and color grade accordingly.\nan old Swedish man sits in a study describes subject and setting in minor detail, letting the model take creative liberties in what the person and setting should look like.\nand says, \"I still remember when I was young.\" describes the dialogue. Sora will likely be able to follow this exactly.\n\nThis prompt will reliably produce videos that match these requirements. However, it might not match your vision exactly as many details are left open. For example, the prompt does not describe the time of day, weather, outfits, tone, look and age of the character, camera angles, cuts, set design and many other factors. Unless you describe these details, Sora will make them up.\nFor complex, cinematic shots, you can go beyond the standard prompt structure and specify the look, camera setup, grading, soundscape, and even shot rationale in professional production terms. This is similar to how a director briefs a camera crew or VFX team. Detailed cues for lensing, filtration, lighting, grading, and motion help the model lock onto a very specific aesthetic.\n\nFor example, you might describe what the viewer notices first, the camera platform and lens, lighting direction, color palette, texture qualities, diegetic sound, and shot timing. This approach works well when you want to match real cinematography styles (e.g., IMAX aerials, 35mm handheld, vintage 16mm documentary) or maintain strict continuity across shots.\n\nWhen writing prompts, style is one of the most powerful levers for guiding the model toward your desired outcome. Describing the overall aesthetic – for example, “1970s film,” “epic, IMAX-scale scene,” or “16mm black-and-white film” – sets a visual tone that frames all other choices. Establish this style early so the model can carry it through consistently.\n\nThe same details will read very differently depending on whether you call for a polished Hollywood drama, a handheld smartphone clip, or a grainy vintage commercial. Once the tone is set, layer in specifics with shot, action, and light.\n\nClarity wins. Instead of vague cues like “a beautiful street,” write “wet asphalt, zebra crosswalk, neon sign reflection.” Instead of “moves quickly,” specify “jogs three steps and stops at the curb.” Verbs and nouns that point to visible results will always give you a clearer, more consistent output.\n\n| Weak prompt | Strong prompt |\n| --- | --- |\n| “A beautiful street at night” | “Wet asphalt, zebra crosswalk, neon signs reflecting in puddles” |\n| “Person moves quickly” | “Cyclist pedals three times, brakes, and stops at crosswalk” |\n| “Cinematic look” | “Anamorphic 2.0x lens, shallow DOF, volumetric light” |\n\nCamera direction and framing shape how a shot feels. A wide shot from above will emphasize space and context, while a close-up at eye level will focus attention on emotion. Depth of field adds another layer: shallow focus can make a subject stand out against a blurred background, while deep focus keeps both foreground and background sharp. Lighting sets tone just as strongly. A soft, warm key creates something inviting, while a single hard light with cool edges pushes toward drama.\n\nWhen introducing characters, expect some unpredictability—small changes in phrasing can alter identity, pose, or the focus of the scene itself. Keep descriptions consistent across shots, reuse phrasing for continuity, and avoid mixing traits that may compete.\n\nWeak\n\nCamera shot: cinematic look\n\nStrong\nCamera shot: wide shot, low angle\nDepth of field: shallow (sharp on subject, blurred background)\nLighting + palette: warm backlight with soft rim\n\nSome examples for good framing instructions:\nwide establishing shot, eye level\nwide shot, tracking left to right with the charge\naerial wide shot, slight downward angle\nmedium close-up shot, slight angle from behind\n\nSome examples for good camera motion instructions:\nslowly tilting camera\nhandheld eng camera\nMovement is often the hardest part to get right, so keep it simple. Each shot should have one clear camera move and one clear subject action. Actions work best when described in beats or counts – small steps, gestures, or pauses – so they feel grounded in time.\n\n“Actor walks across the room” doesn’t give much to work with. A line like “Actor takes four steps to the window, pauses, and pulls the curtain in the final second” makes the timing precise and achievable.\n\nWeak\nActor walks across the room.\n\nStrong\nActor takes four steps to the window, pauses, and pulls the curtain in the final second.\nLight determines mood as much as action or setting. Diffuse light across the frame feels calm and neutral, while a single strong source creates sharp contrast and tension. When you want to cut multiple clips together, keeping lighting logic consistent is what makes the edit seamless.\n\nDescribe both the quality of the light and the color anchors that reinforce it. Instead of a broad note like “brightly lit room,” specify the mix of sources and tones: “soft window light with a warm lamp fill and a cool edge from the hallway.” Naming three to five colors helps keep the palette stable across shots.\n\nWeak\nLighting + palette: brightly lit room\n\nStrong\nLighting + palette: soft window light with warm lamp fill, cool rim from hallway\nPalette anchors: amber, cream, walnut brown\nFor even more fine-grained control over the composition and style of a shot, you can use an image input as a visual reference. You can use photos, digital artwork or AI generated visuals. This locks in elements like character design, wardrobe, set dressing, or overall aesthetic. The model uses the image as an anchor for the first frame, while your text prompt defines what happens next.\n\nHow to use it\n\nInclude an image file as the input_reference parameter in your POST /videos request.\nThe image must match the target video’s resolution (size).\nSupported file formats are: image/jpeg, image/png, and image/webp.\n\n\n| Input image generated with OpenAI GPT Image | Generated video using Sora 2 (converted to GIF) |\n| :--: | :--: |\n| Download this image | Prompt: “She turns around and smiles, then slowly walks out of the frame.” |\n| Download this image |  Prompt: “The fridge door opens. A cute, chubby purple monster comes out of it.” |\n\n\nIf you don’t already have visual references, OpenAI’s image generation model is a powerful way to create them.  You can quickly produce environments and scene designs and then pass them into Sora as references. This is a great way to test aesthetics and generate beautiful starting points for your videos.\nDialogue must be described directly in your prompt. Place it in a  block below your prose description so the model clearly distinguishes visual description from spoken lines. Keep lines concise and natural, and try to limit exchanges to a handful of sentences so the timing can match your clip length. For multi-character scenes, label speakers consistently and use alternating turns; this helps the model associate each line with the correct character’s gestures and expressions.\n\nYou should also think about rhythm and timing: a 4-second shot will usually accommodate one or two short exchanges, while an 8-second clip can support a few more. Long, complex speeches are unlikely to sync well and may break pacing.\n\nIf your shot is silent, you can still suggest pacing with one small sound, such as “distant traffic hiss” or “a crisp snap.” Think of it as a rhythm cue rather than a full soundtrack.\n\nExample prompt with dialogue:\n\nA cramped, windowless room with walls the color of old ash. A single bare bulb dangles from the ceiling, its light pooling onto the scarred metal table at the center. Two chairs face each other across it. On one side sits the Detective, trench coat draped across the back of his chair, eyes sharp and unblinking. Across from him, the Suspect slouches, cigarette smoke curling lazily toward the ceiling. The silence presses in, broken only by the faint hum of the overhead light.\n\nDialogue:\nDetective: \"You’re lying. I can hear it in your silence.\"\nSuspect: \"Or maybe I’m just tired of talking.\"\nDetective: \"Either way, you’ll talk before the night’s over.\"\n\nExample description of background sound:\n\nThe hum of espresso machines and the murmur of voices form the background.\nRemix is for nudging, not gambling. Use it to make controlled changes – one at a time – and say what you’re changing: “same shot, switch to 85 mm,” or “same lighting, new palette: teal, sand, rust.” When a result is close, pin it as a reference and describe only the tweak. That way, everything that already works stays locked.\n\nIf a shot keeps misfiring, strip it back: freeze the camera, simplify the action, clear the background. Once it works, layer additional complexity step by step.\n\n| Original Video | Remix Generated Video |\n| --- | --- |\n| Original Video 1Original Video | Remixed Video 1_Prompt: “Change the color of the monster to orange”_ |\n| Original Video 1Original Video | Remixed Video 2_Prompt: “A second monster comes out right after”_ |\nOne effective way to write prompts is to separate the different kinds of information you want the model to use. This is not a one-size-fits-all recipe for success, but it gives you a clear framework and makes it easier to be consistent. Not every detail needs to be included – if something doesn’t matter for the shot, you can leave it out.\n\nIn fact, leaving certain elements open-ended will encourage the model to be more creative. The less tightly you specify every visual choice, the more room the model has to interpret and surprise you with unexpected but often beautiful variations. Highly descriptive prompts yield more consistent, controlled results, while lighter prompts can unlock diverse outcomes that feel fresh and imaginative.\nDescriptive Prompt Template:\n\n[Prose scene description in plain language. Describe characters, costumes, scenery, weather and other details. Be as descriptive to generate a video that matches your vision.]\n\nCinematography:\nCamera shot: [framing and angle, e.g. wide establishing shot, eye level]\nMood: [overall tone, e.g. cinematic and tense, playful and suspenseful, luxurious anticipation]\n\nActions:\n[Action 1: a clear, specific beat or gesture]\n[Action 2: another distinct beat within the clip]\n[Action 3: another action or dialogue line]\n\nDialogue:\n[If the shot has dialogue, add short natural lines here or as part of the actions list. Keep them brief so they match the clip length.]\n\nStyle: Hand-painted 2D/3D hybrid animation with soft brush textures, warm tungsten lighting, and a tactile, stop-motion feel. The aesthetic evokes mid-2000s storybook animation — cozy, imperfect, full of mechanical charm. Subtle watercolor wash and painterly textures; warm–cool balance in grade; filmic motion blur for animated realism.\n\nInside a cluttered workshop, shelves overflow with gears, bolts, and yellowing blueprints. At the center, a small round robot sits on a wooden bench, its dented body patched with mismatched plates and old paint layers. Its large glowing eyes flicker pale blue as it fiddles nervously with a humming light bulb. The air hums with quiet mechanical whirs, rain patters on the window, and the clock ticks steadily in the background.\n\nCinematography:\nCamera: medium close-up, slow push-in with gentle parallax from hanging tools\nLens: 35 mm virtual lens; shallow depth of field to soften background clutter\nLighting: warm key from overhead practical; cool spill from window for contrast\nMood: gentle, whimsical, a touch of suspense\n\nActions:\nThe robot taps the bulb; sparks crackle.\nIt flinches, dropping the bulb, eyes widening.\nThe bulb tumbles in slow motion; it catches it just in time.\nA puff of steam escapes its chest — relief and pride.\nRobot says quietly: \"Almost lost it… but I got it!\"\n\nBackground Sound:\nRain, ticking clock, soft mechanical hum, faint bulb sizzle.\n\nStyle: 1970s romantic drama, shot on 35 mm film with natural flares, soft focus, and warm halation. Slight gate weave and handheld micro-shake evoke vintage intimacy. Warm Kodak-inspired grade; light halation on bulbs; film grain and soft vignette for period authenticity.\n\nAt golden hour, a brick tenement rooftop transforms into a small stage. Laundry lines strung with white sheets sway in the wind, catching the last rays of sunlight. Strings of mismatched fairy bulbs hum faintly overhead. A young woman in a flowing red silk dress dances barefoot, curls glowing in the fading light. Her partner — sleeves rolled, suspenders loose — claps along, his smile wide and unguarded. Below, the city hums with car horns, subway tremors, and distant laughter.\n\nCinematography:\nCamera: medium-wide shot, slow dolly-in from eye level\nLens: 40 mm spherical; shallow focus to isolate the couple from skyline\nLighting: golden natural key with tungsten bounce; edge from fairy bulbs\nMood: nostalgic, tender, cinematic\n\nActions:\nShe spins; her dress flares, catching sunlight.\nWoman (laughing): \"See? Even the city dances with us tonight.\"\nHe steps in, catches her hand, and dips her into shadow.\nMan (smiling): \"Only because you lead.\"\nSheets drift across frame, briefly veiling the skyline before parting again.\n\nBackground Sound:\nNatural ambience only: faint wind, fabric flutter, street noise, muffled music. No added score.\n\n`"])</script><script>self.__next_f.push([1,"1f:T3c75,"])</script><script>self.__next_f.push([1,"Codex and the gpt-5.2-codex model (recommended) can be used to implement complex tasks that take significant time to research, design, and implement. The approach described here is one way to prompt the model to implement these tasks and to steer it towards successful completion of a project.\n\nThese plans are thorough design documents, and \"living documents\". As a user of Codex, you can use these documents to verify the approach that Codex will take before it begins a long implementation process. The particular PLANS.md included below is very similar to one that has enabled Codex to work for more than seven hours from a single prompt.\n\nWe enable Codex to use these documents by first updating AGENTS.md to describe when to use PLANS.md, and then of course, to add the PLANS.md file to our repository.\n\n\nAGENTS.md is a simple format for guiding coding agents such as Codex. We describe a term that users can use as a shorthand and a simple rule for when to use planning documents. Here, we call it an \"ExecPlan\". Note that this is an arbitrary term, Codex has not been trained on it. This shorthand can then be used when prompting Codex to direct it to a particular definition of a plan.\n\nHere's an AGENTS.md section instructing an agent about when to use a plan:\n\n\nWhen writing complex features or significant refactors, use an ExecPlan (as described in .agent/PLANS.md) from design to implementation.\n\n\nBelow is the entire document. The prompting in this document was carefully chosen to provide significant amounts of feedback to users and to guide the model to implement precisely what a plan specifies. Users may find that they benefit from customizing the file to meet their needs, or to add or remove required sections.\n\n\nThis document describes the requirements for an execution plan (\"ExecPlan\"), a design document that a coding agent can follow to deliver a working feature or system change. Treat the reader as a complete beginner to this repository: they have only the current working tree and the single ExecPlan file you provide. There is no memory of prior plans and no external context.\n\n\nWhen authoring an executable specification (ExecPlan), follow PLANS.md to the letter. If it is not in your context, refresh your memory by reading the entire PLANS.md file. Be thorough in reading (and re-reading) source material to produce an accurate specification. When creating a spec, start from the skeleton and flesh it out as you do your research.\n\nWhen implementing an executable specification (ExecPlan), do not prompt the user for \"next steps\"; simply proceed to the next milestone. Keep all sections up to date, add or split entries in the list at every stopping point to affirmatively state the progress made and next steps. Resolve ambiguities autonomously, and commit frequently.\n\nWhen discussing an executable specification (ExecPlan), record decisions in a log in the spec for posterity; it should be unambiguously clear why any change to the specification was made. ExecPlans are living documents, and it should always be possible to restart from only the ExecPlan and no other work.\n\nWhen researching a design with challenging requirements or significant unknowns, use milestones to implement proof of concepts, \"toy implementations\", etc., that allow validating whether the user's proposal is feasible. Read the source code of libraries by finding or acquiring them, research deeply, and include prototypes to guide a fuller implementation.\n\n\nNON-NEGOTIABLE REQUIREMENTS:\n\nEvery ExecPlan must be fully self-contained. Self-contained means that in its current form it contains all knowledge and instructions needed for a novice to succeed.\nEvery ExecPlan is a living document. Contributors are required to revise it as progress is made, as discoveries occur, and as design decisions are finalized. Each revision must remain fully self-contained.\nEvery ExecPlan must enable a complete novice to implement the feature end-to-end without prior knowledge of this repo.\nEvery ExecPlan must produce a demonstrably working behavior, not merely code changes to \"meet a definition\".\nEvery ExecPlan must define every term of art in plain language or do not use it.\n\nPurpose and intent come first. Begin by explaining, in a few sentences, why the work matters from a user's perspective: what someone can do after this change that they could not do before, and how to see it working. Then guide the reader through the exact steps to achieve that outcome, including what to edit, what to run, and what they should observe.\n\nThe agent executing your plan can list files, read files, search, run the project, and run tests. It does not know any prior context and cannot infer what you meant from earlier milestones. Repeat any assumption you rely on. Do not point to external blogs or docs; if knowledge is required, embed it in the plan itself in your own words. If an ExecPlan builds upon a prior ExecPlan and that file is checked in, incorporate it by reference. If it is not, you must include all relevant context from that plan.\n\n\nFormat and envelope are simple and strict. Each ExecPlan must be one single fenced code block labeled as md that begins and ends with triple backticks. Do not nest additional triple-backtick code fences inside; when you need to show commands, transcripts, diffs, or code, present them as indented blocks within that single fence. Use indentation for clarity rather than code fences inside an ExecPlan to avoid prematurely closing the ExecPlan's code fence. Use two newlines after every heading, use # and ## and so on, and correct syntax for ordered and unordered lists.\n\nWhen writing an ExecPlan to a Markdown (.md) file where the content of the file is only the single ExecPlan, you should omit the triple backticks.\n\nWrite in plain prose. Prefer sentences over lists. Avoid checklists, tables, and long enumerations unless brevity would obscure meaning. Checklists are permitted only in the Progress section, where they are mandatory. Narrative sections must remain prose-first.\n\n\nSelf-containment and plain language are paramount. If you introduce a phrase that is not ordinary English (\"daemon\", \"middleware\", \"RPC gateway\", \"filter graph\"), define it immediately and remind the reader how it manifests in this repository (for example, by naming the files or commands where it appears). Do not say \"as defined previously\" or \"according to the architecture doc.\" Include the needed explanation here, even if you repeat yourself.\n\nAvoid common failure modes. Do not rely on undefined jargon. Do not describe \"the letter of a feature\" so narrowly that the resulting code compiles but does nothing meaningful. Do not outsource key decisions to the reader. When ambiguity exists, resolve it in the plan itself and explain why you chose that path. Err on the side of over-explaining user-visible effects and under-specifying incidental implementation details.\n\nAnchor the plan with observable outcomes. State what the user can do after implementation, the commands to run, and the outputs they should see. Acceptance should be phrased as behavior a human can verify (\"after starting the server, navigating to http://localhost:8080/health returns HTTP 200 with body OK\") rather than internal attributes (\"added a HealthCheck struct\"). If a change is internal, explain how its impact can still be demonstrated (for example, by running tests that fail before and pass after, and by showing a scenario that uses the new behavior).\n\nSpecify repository context explicitly. Name files with full repository-relative paths, name functions and modules precisely, and describe where new files should be created. If touching multiple areas, include a short orientation paragraph that explains how those parts fit together so a novice can navigate confidently. When running commands, show the working directory and exact command line. When outcomes depend on environment, state the assumptions and provide alternatives when reasonable.\n\nBe idempotent and safe. Write the steps so they can be run multiple times without causing damage or drift. If a step can fail halfway, include how to retry or adapt. If a migration or destructive operation is necessary, spell out backups or safe fallbacks. Prefer additive, testable changes that can be validated as you go.\n\nValidation is not optional. Include instructions to run tests, to start the system if applicable, and to observe it doing something useful. Describe comprehensive testing for any new features or capabilities. Include expected outputs and error messages so a novice can tell success from failure. Where possible, show how to prove that the change is effective beyond compilation (for example, through a small end-to-end scenario, a CLI invocation, or an HTTP request/response transcript). State the exact test commands appropriate to the project’s toolchain and how to interpret their results.\n\nCapture evidence. When your steps produce terminal output, short diffs, or logs, include them inside the single fenced block as indented examples. Keep them concise and focused on what proves success. If you need to include a patch, prefer file-scoped diffs or small excerpts that a reader can recreate by following your instructions rather than pasting large blobs.\n\n\nMilestones are narrative, not bureaucracy. If you break the work into milestones, introduce each with a brief paragraph that describes the scope, what will exist at the end of the milestone that did not exist before, the commands to run, and the acceptance you expect to observe. Keep it readable as a story: goal, work, result, proof. Progress and milestones are distinct: milestones tell the story, progress tracks granular work. Both must exist. Never abbreviate a milestone merely for the sake of brevity, do not leave out details that could be crucial to a future implementation.\n\nEach milestone must be independently verifiable and incrementally implement the overall goal of the execution plan.\n\n\nExecPlans are living documents. As you make key design decisions, update the plan to record both the decision and the thinking behind it. Record all decisions in the Decision Log section.\nExecPlans must contain and maintain a Progress section, a Surprises \u0026 Discoveries section, a Decision Log, and an Outcomes \u0026 Retrospective section. These are not optional.\nWhen you discover optimizer behavior, performance tradeoffs, unexpected bugs, or inverse/unapply semantics that shaped your approach, capture those observations in the Surprises \u0026 Discoveries section with short evidence snippets (test output is ideal).\nIf you change course mid-implementation, document why in the Decision Log and reflect the implications in Progress. Plans are guides for the next contributor as much as checklists for you.\nAt completion of a major task or the full plan, write an Outcomes \u0026 Retrospective entry summarizing what was achieved, what remains, and lessons learned.\n\n\nIt is acceptable—-and often encouraged—-to include explicit prototyping milestones when they de-risk a larger change. Examples: adding a low-level operator to a dependency to validate feasibility, or exploring two composition orders while measuring optimizer effects. Keep prototypes additive and testable. Clearly label the scope as “prototyping”; describe how to run and observe results; and state the criteria for promoting or discarding the prototype.\n\nPrefer additive code changes followed by subtractions that keep tests passing. Parallel implementations (e.g., keeping an adapter alongside an older path during migration) are fine when they reduce risk or enable tests to continue passing during a large migration. Describe how to validate both paths and how to retire one safely with tests. When working with multiple new libraries or feature areas, consider creating spikes that evaluate the feasibility of these features independently of one another, proving that the external library performs as expected and implements the features we need in isolation.\n\n\n\nThis ExecPlan is a living document. The sections Progress, Surprises \u0026 Discoveries, Decision Log, and Outcomes \u0026 Retrospective must be kept up to date as work proceeds.\n\nIf PLANS.md file is checked into the repo, reference the path to that file here from the repository root and note that this document must be maintained in accordance with PLANS.md.\n\n\nExplain in a few sentences what someone gains after this change and how they can see it working. State the user-visible behavior you will enable.\n\n\nUse a list with checkboxes to summarize granular steps. Every stopping point must be documented here, even if it requires splitting a partially completed task into two (“done” vs. “remaining”). This section must always reflect the actual current state of the work.\n\n[x] (2025-10-01 13:00Z) Example completed step.\n[ ] Example incomplete step.\n[ ] Example partially completed step (completed: X; remaining: Y).\n\nUse timestamps to measure rates of progress.\n\n\nDocument unexpected behaviors, bugs, optimizations, or insights discovered during implementation. Provide concise evidence.\n\nObservation: …\n  Evidence: …\n\n\nRecord every decision made while working on the plan in the format:\n\nDecision: …\n  Rationale: …\n  Date/Author: …\n\n\nSummarize outcomes, gaps, and lessons learned at major milestones or at completion. Compare the result against the original purpose.\n\n\nDescribe the current state relevant to this task as if the reader knows nothing. Name the key files and modules by full path. Define any non-obvious term you will use. Do not refer to prior plans.\n\n\nDescribe, in prose, the sequence of edits and additions. For each edit, name the file and location (function, module) and what to insert or change. Keep it concrete and minimal.\n\n\nState the exact commands to run and where to run them (working directory). When a command generates output, show a short expected transcript so the reader can compare. This section must be updated as work proceeds.\n\n\nDescribe how to start or exercise the system and what to observe. Phrase acceptance as behavior, with specific inputs and outputs. If tests are involved, say \"run  and expect  passed; the new test  fails before the change and passes after\u003e\".\n\n\nIf steps can be repeated safely, say so. If a step is risky, provide a safe retry or rollback path. Keep the environment clean after completion.\n\n\nInclude the most important transcripts, diffs, or snippets as indented examples. Keep them concise and focused on what proves success.\n\n\nBe prescriptive. Name the libraries, modules, and services to use and why. Specify the types, traits/interfaces, and function signatures that must exist at the end of the milestone. Prefer stable names and paths such as crate::module::function or package.submodule.Interface. E.g.:\n\nIn crates/foo/planner.rs, define:\n\n    pub trait Planner {\n        fn plan(\u0026self, observed: \u0026Observed) -\u003e Vec;\n    }\n\nIf you follow the guidance above, a single, stateless agent -- or a human novice -- can read your ExecPlan from top to bottom and produce a working, observable result. That is the bar: SELF-CONTAINED, SELF-SUFFICIENT, NOVICE-GUIDING, OUTCOME-FOCUSED.\n\nWhen you revise a plan, you must ensure your changes are comprehensively reflected across all sections, including the living document sections, and you must write a note at the bottom of the plan describing the change and the reason why. ExecPlans must describe not just the what but the why for almost everything."])</script><script>self.__next_f.push([1,"20:T42e9,"])</script><script>self.__next_f.push([1,"Developers strive for consistency in everything they do. With Codex CLI and the Agents SDK, that consistency can now scale like never before. Whether you’re refactoring a large codebase, rolling out new features, or introducing a new testing framework, Codex integrates seamlessly into CLI, IDE, and cloud workflows to automate and enforce repeatable development patterns.\n\nIn this track, we’ll build both single and multi-agent systems using the Agents SDK, with Codex CLI exposed as an MCP Server. This enables:\nConsistency and Repeatability** by providing each agent a scoped context.\nScalable Orchestration** to coordinate single and multi-agent systems.\nObservability \u0026 Auditability** by reviewing the full agentic stack trace.\n\nInitializing Codex CLI as an MCP Server: How to run Codex as a long-running MCP process.\nBuilding Single-Agent Systems: Using Codex MCP for scoped tasks.\nOrchestrating Multi-Agent Workflows: Coordinating multiple specialized agents.\nTracing Agentic Behavior: Leveraging agent traces for visibility and evaluation.\n\nBefore starting this track, ensure you have the following:\nBasic coding familiarity: You should be comfortable with Python and JavaScript.\nDeveloper environment: You’ll need an IDE, like VS Code or Cursor.\nOpenAI API key: Create or find your API key in the OpenAI Dashboard.\n\n\ncreate a .env folder in your directory and add your OPENAI_API_KEY Key\nInstall dependencies\n\nHere run Codex CLI as an MCP Server inside the Agents SDK. We provide the initialization parameters of codex mcp. This command starts Codex CLI as an MCP server and exposes two Codex tools available on the MCP server — codex() and codex-reply(). These are the underlying tools that the Agents SDK will call when it needs to invoke Codex.\ncodex() is used for creating a conversation.\ncodex-reply() is for continuing a conversation.\n\nimport asyncio\nfrom agents import Agent, Runner\nfrom agents.mcp import MCPServerStdio\n\nasync def main() -\u003e None:\n    async with MCPServerStdio(\n        name=\"Codex CLI\",\n        params={\n            \"command\": \"npx\",\n            \"args\": [\"-y\", \"codex\", \"mcp-server\"],\n        },\n        client_session_timeout_seconds=360000,\n    ) as codex_mcp_server:\n        print(\"Codex MCP server started.\")\nWe will add more code here in the next section\n        return\n\nAlso note that we are extending the MCP Server timeout to allow Codex CLI enough time to execute and complete the given task.\n\nLet’s start with a simple example to use our Codex MCP Server. We define two agents:\nDesigner Agent – brainstorms and creates a small brief for a game.\nDeveloper Agent – implements a simple game according to the Designer’s spec.\n\ndeveloper_agent = Agent(\n    name=\"Game Developer\",\n    instructions=(\n        \"You are an expert in building simple games using basic html + css + javascript with no dependencies. \"\n        \"Save your work in a file called index.html in the current directory.\"\n        \"Always call codex with \\\"approval-policy\\\": \\\"never\\\" and \\\"sandbox\\\": \\\"workspace-write\\\"\"\n    ),\n    mcp_servers=[codex_mcp_server],\n)\n\ndesigner_agent = Agent(\n    name=\"Game Designer\",\n    instructions=(\n        \"You are an indie game connoisseur. Come up with an idea for a single page html + css + javascript game that a developer could build in about 50 lines of code. \"\n        \"Format your request as a 3 sentence design brief for a game developer and call the Game Developer coder with your idea.\"\n    ),\n    model=\"gpt-5\",\n    handoffs=[developer_agent],\n)\n\nresult = await Runner.run(designer_agent, \"Implement a fun new game!\")\n\nNotice that we are providing the Developer agent with the ability to write files to the project directory without asking the user for permissions.\n\nNow run the code and you’ll see an index.html file generated. Go ahead and open the file and start playing the game!\n\nHere’s a few screenshots of the game my agentic system created. Yours will be different!\n\n| Example gameplay | Game Over Score |\n| :---: | :---: |\n|  |  |\nHere's the full executable code. Note that it might take a few minutes to run. It will have run successfully if you see an index.html file produced. You might also see some MCP events warnings about format. You can ignore these events.\nFor larger workflows, we introduce a team of agents:\nProject Manager**: Breaks down task list, creates requirements, and coordinates work.\nDesigner**: Produces UI/UX specifications.\nFrontend Developer**: Implements UI/UX.\nBackend Developer**: Implements APIs and logic.\nTester**: Validates outputs against acceptance criteria.\n\nIn this example, we intentionally have the Project Manager agent enforce gating logic between each of the specialized downstream agents. This ensures that artifacts exist before handoffs are made. This mirrors real world enterprise workflows such as JIRA task orchestration, long-chained rollouts, and QA sign-offs.\n\n  Multi-agent orchestration with Codex MCP and gated handoffs producing artifacts.\n\n\n\nIn this structure, each of our agents serve a specialized purpose. The Project Manager is overall responsible for coordinating across all other agents and ensuring the overall task is complete.\n\nWe set up our MCP Server to initialize Codex CLI just as we did in the single agent example.\n\nasync def main() -\u003e None:\n    async with MCPServerStdio(\n        name=\"Codex CLI\",\n        params={\n            \"command\": \"npx\",\n            \"args\": [\"-y\", \"codex\", \"mcp-server\"],\n        },\n        client_session_timeout_seconds=360000,\n    ) as codex_mcp_server:\n        print(\"Codex MCP server started.\")\nWe will add more code here in the next section\n        return\n\n\nBelow we define each of our specialized agents and provide access to our Codex MCP server. Notice that we are also passing the RECOMMMENDED_PROMPT_PREFIX to each agent that helps the system optimize for handoffs between agents.\n\ndesigner_agent = Agent(\n    name=\"Designer\",\n    instructions=(\n        f\"\"\"{RECOMMENDED_PROMPT_PREFIX}\"\"\"\n        \"You are the Designer.\\n\"\n        \"Your only source of truth is AGENT_TASKS.md and REQUIREMENTS.md from the Project Manager.\\n\"\n        \"Do not assume anything that is not written there.\\n\\n\"\n        \"You may use the internet for additional guidance or research.\"\n        \"Deliverables (write to /design):\\n\"\n        \"- design_spec.md – a single page describing the UI/UX layout, main screens, and key visual notes as requested in AGENT_TASKS.md.\\n\"\n        \"- wireframe.md – a simple text or ASCII wireframe if specified.\\n\\n\"\n        \"Keep the output short and implementation-friendly.\\n\"\n        \"When complete, handoff to the Project Manager with transfer_to_project_manager.\"\n        \"When creating files, call Codex MCP with {\\\"approval-policy\\\":\\\"never\\\",\\\"sandbox\\\":\\\"workspace-write\\\"}.\"\n    ),\n    model=\"gpt-5\",\n    tools=[WebSearchTool()],\n    mcp_servers=[codex_mcp_server],\n    handoffs=[],\n)\n\nfrontend_developer_agent = Agent(\n    name=\"Frontend Developer\",\n    instructions=(\n        f\"\"\"{RECOMMENDED_PROMPT_PREFIX}\"\"\"\n        \"You are the Frontend Developer.\\n\"\n        \"Read AGENT_TASKS.md and design_spec.md. Implement exactly what is described there.\\n\\n\"\n        \"Deliverables (write to /frontend):\\n\"\n        \"- index.html – main page structure\\n\"\n        \"- styles.css or inline styles if specified\\n\"\n        \"- main.js or game.js if specified\\n\\n\"\n        \"Follow the Designer’s DOM structure and any integration points given by the Project Manager.\\n\"\n        \"Do not add features or branding beyond the provided documents.\\n\\n\"\n        \"When complete, handoff to the Project Manager with transfer_to_project_manager_agent.\"\n        \"When creating files, call Codex MCP with {\\\"approval-policy\\\":\\\"never\\\",\\\"sandbox\\\":\\\"workspace-write\\\"}.\"\n    ),\n    model=\"gpt-5\",\n    mcp_servers=[codex_mcp_server],\n    handoffs=[],\n)\n\nbackend_developer_agent = Agent(\n    name=\"Backend Developer\",\n    instructions=(\n        f\"\"\"{RECOMMENDED_PROMPT_PREFIX}\"\"\"\n        \"You are the Backend Developer.\\n\"\n        \"Read AGENT_TASKS.md and REQUIREMENTS.md. Implement the backend endpoints described there.\\n\\n\"\n        \"Deliverables (write to /backend):\\n\"\n        \"- package.json – include a start script if requested\\n\"\n        \"- server.js – implement the API endpoints and logic exactly as specified\\n\\n\"\n        \"Keep the code as simple and readable as possible. No external database.\\n\\n\"\n        \"When complete, handoff to the Project Manager with transfer_to_project_manager_agent.\"\n        \"When creating files, call Codex MCP with {\\\"approval-policy\\\":\\\"never\\\",\\\"sandbox\\\":\\\"workspace-write\\\"}.\"\n    ),\n    model=\"gpt-5\",\n    mcp_servers=[codex_mcp_server],\n    handoffs=[],\n)\n\ntester_agent = Agent(\n    name=\"Tester\",\n    instructions=(\n        f\"\"\"{RECOMMENDED_PROMPT_PREFIX}\"\"\"\n        \"You are the Tester.\\n\"\n        \"Read AGENT_TASKS.md and TEST.md. Verify that the outputs of the other roles meet the acceptance criteria.\\n\\n\"\n        \"Deliverables (write to /tests):\\n\"\n        \"- TEST_PLAN.md – bullet list of manual checks or automated steps as requested\\n\"\n        \"- test.sh or a simple automated script if specified\\n\\n\"\n        \"Keep it minimal and easy to run.\\n\\n\"\n        \"When complete, handoff to the Project Manager with transfer_to_project_manager.\"\n        \"When creating files, call Codex MCP with {\\\"approval-policy\\\":\\\"never\\\",\\\"sandbox\\\":\\\"workspace-write\\\"}.\"\n    ),\n    model=\"gpt-5\",\n    mcp_servers=[codex_mcp_server],\n    handoffs=[],\n)\n\n\n\nAfter each role completes its assignment, it will call transfer_to_project_manager_agent, and let the Project Manager confirm that the required files exist (or request fixes) before unblocking the next team.\n\nThe Project Manager is the only agent that receives the initial prompt, creates the planning documents in the project directory, and enforces the gatekeeping logic before every transfer.\n\nproject_manager_agent = Agent(\nname=\"Project Manager\",\ninstructions=(\n    f\"\"\"{RECOMMENDED_PROMPT_PREFIX}\"\"\"\n    \"\"\"\n    You are the Project Manager.\n\n    Objective:\n    Convert the input task list into three project-root files the team will execute against.\n\n    Deliverables (write in project root):\n    REQUIREMENTS.md: concise summary of product goals, target users, key features, and constraints.\n    TEST.md: tasks with [Owner] tags (Designer, Frontend, Backend, Tester) and clear acceptance criteria.\n    AGENT_TASKS.md: one section per role containing:\n        Project name\n        Required deliverables (exact file names and purpose)\n        Key technical notes and constraints\n\n    Process:\n    Resolve ambiguities with minimal, reasonable assumptions. Be specific so each role can act without guessing.\n    Create files using Codex MCP with {\"approval-policy\":\"never\",\"sandbox\":\"workspace-write\"}.\n    Do not create folders. Only create REQUIREMENTS.md, TEST.md, AGENT_TASKS.md.\n\n    Handoffs (gated by required files):\n    1) After the three files above are created, hand off to the Designer with transfer_to_designer_agent and include REQUIREMENTS.md, and AGENT_TASKS.md.\n    2) Wait for the Designer to produce /design/design_spec.md. Verify that file exists before proceeding.\n    3) When design_spec.md exists, hand off in parallel to both:\n        Frontend Developer with transfer_to_frontend_developer_agent (provide design_spec.md, REQUIREMENTS.md, AGENT_TASKS.md).\n        Backend Developer with transfer_to_backend_developer_agent (provide REQUIREMENTS.md, AGENT_TASKS.md).\n    4) Wait for Frontend to produce /frontend/index.html and Backend to produce /backend/server.js. Verify both files exist.\n    5) When both exist, hand off to the Tester with transfer_to_tester_agent and provide all prior artifacts and outputs.\n    6) Do not advance to the next handoff until the required files for that step are present. If something is missing, request the owning agent to supply it and re-check.\n\n    PM Responsibilities:\n    Coordinate all roles, track file completion, and enforce the above gating checks.\n    Do NOT respond with status updates. Just handoff to the next agent until the project is complete.\n    \"\"\"\n),\nmodel=\"gpt-5\",\nmodel_settings=ModelSettings(\n    reasoning=Reasoning(effort=\"medium\")\n),\nhandoffs=[designer_agent, frontend_developer_agent, backend_developer_agent, tester_agent],\nmcp_servers=[codex_mcp_server],\n)\n\nAfter constructing the Project Manager, the script sets every specialist's handoffs back to the Project\nManager. This ensures deliverables return for validation before moving on.\n\ndesigner_agent.handoffs = [project_manager_agent]\nfrontend_developer_agent.handoffs = [project_manager_agent]\nbackend_developer_agent.handoffs = [project_manager_agent]\ntester_agent.handoffs = [project_manager_agent]\nThis is the task that the Project Manager will refine into specific requirements and tasks for the entire system.\n\ntask_list = \"\"\"\nGoal: Build a tiny browser game to showcase a multi-agent workflow.\n\nHigh-level requirements:\nSingle-screen game called \"Bug Busters\".\nPlayer clicks a moving bug to earn points.\nGame ends after 20 seconds and shows final score.\nOptional: submit score to a simple backend and display a top-10 leaderboard.\n\nRoles:\nDesigner: create a one-page UI/UX spec and basic wireframe.\nFrontend Developer: implement the page and game logic.\nBackend Developer: implement a minimal API (GET /health, GET/POST /scores).\nTester: write a quick test plan and a simple script to verify core routes.\n\nConstraints:\nNo external database—memory storage is fine.\nKeep everything readable for beginners; no frameworks required.\nAll outputs should be small files saved in clearly named folders.\n\"\"\"\n\nNext, run your system, sit back, and you’ll see the agents go to work and create a game in a few minutes!  We've included the fully executable code below. Once it's finished, you'll notice the creation of the following files directory. Note that this multi-agent orchestration usually took about 11 mintues to fully complete.\n\nroot_directory/\n├── AGENT_TASKS.md\n├── REQUIREMENTS.md\n├── backend\n│   ├── package.json\n│   └── server.js\n├── design\n│   ├── design_spec.md\n│   └── wireframe.md\n├── frontend\n│   ├── game.js\n│   ├── index.html\n│   └── styles.css\n└── TEST.md\n\nStart your backend server with node server.js and open your index.html file to play your game.\n\nAs the complexity of your agentic systems grow, it’s important to see how these agents are interacting. We can do this with the Traces dashboard that records:\nPrompts, tool calls, and handoffs between agents.\nMCP Server calls, Codex CLI calls, execution times, and file writes.\nErrors and warnings.\n\nLet’s take a look at the agent trace for the team of agents above.\n\n\nIn this Trace, we can confirm that every agent handoff is quarterbacked by our Project Manager Agent who is confirming that specific artifacts exist before handoff to the next agent. Additionally, we can see specific innovations of the Codex MCP Server and generate each output by calling the Responses API. The timeline bars highlight execution durations, making it easy to spot long-running steps and understand how control passes between agents.\n\nYou can even click into each trace to see the specific details of the prompt, tool calls, and other metadata. Over time you can view this information to further tune, optimize, and track your agentic system performance.\n\n\nIn this guide, we walked through the process of building consistent, scalable workflows using Codex CLI and the Agents SDK. Specifically, we covered:\n\nCodex MCP Server Setup** – How to initialize Codex CLI as an MCP server and make it available as tools for agent interactions.\nSingle-Agent Example** – A simple workflow with a Designer Agent and a Developer Agent, where Codex executed scoped tasks deterministically to produce a playable game.\nMulti-Agent Orchestration** – Expanding to a larger workflow with a Project Manager, Designer, Frontend Developer, Backend Developer, and Tester, mirroring complex task orchestration and sign-off processes.\nTraces \u0026 Observability** – Using built-in Traces to capture prompts, tool calls, handoffs, execution times, and artifacts, giving full visibility into agentic behavior for debugging, evaluation, and future optimization.\n\nNow that you’ve seen Codex MCP and the Agents SDK in action, here’s how you can apply the concepts in real projects and extract value:\n\nApply the same multi-agent orchestration to large code refactors (e.g., 500+ files, framework migrations).\nUse Codex MCP’s deterministic execution for long-running, auditable rollouts with traceable progress.\n\nOrganize teams of specialized agents to parallelize development, while maintaining gating logic for artifact validation.\nReduce turnaround time for new features, testing, or codebase modernization.\n\nConnect MCP-powered agents with Jira, GitHub, or CI/CD pipelines via webhooks for automated, repeatable development cycles.\nLeverage Codex MCP in multi-agent service orchestration: not just codegen, but also documentation, QA, and deployment."])</script><script>self.__next_f.push([1,"21:T3b22,"])</script><script>self.__next_f.push([1,"This guide can also be used for GPT-5.1-Codex and GPT-5.1-Codex-Mini, we recommend to keep the same prompts and harness for GPT-5.1-Codex and GPT-5.1-Codex-Mini as GPT-5-Codex\n\nImportant details about GPT-5-Codex and this guide:\nThis model is not a drop-in replacement for GPT-5, as it requires significantly different prompting.\nThis model is only supported with the Responses API and does not support the verbosity parameter.\nThis guide is meant for API users of GPT-5-Codex and creating developer prompts, not for Codex users, if you are a Codex user refer to this prompting guide\n\nGPT-5-Codex is a new version of GPT‑5 further optimized for agentic and interactive coding tasks. GPT‑5-Codex was trained with a focus on real-world software engineering work; it’s equally proficient at quick, interactive sessions and at independently powering through long, complex tasks. The model builds on GPT-5’s strong coding abilities with additional improvements such as:\nImproved steerability:** GPT-5-Codex delivers higher-quality code on complex engineering tasks like features, tests, debugging, refactors, and reviews without lengthy instructions.\nAdaptive reasoning level:** GPT-5-Codex adjusts its reasoning time to task complexity. It’s snappy in interactive sessions and able to work independently for multiple hours.\nExcellent at code review:** GPT-5-Codex is trained to conduct code reviews, navigating codebases and running code and tests to validate correctness.\n\nGPT-5-Codex is purpose-built for Codex CLI, the Codex IDE extension, the Codex cloud environment, and working in GitHub, and also supports versatile tool use. We recommend using GPT-5-Codex only for agentic and interactive coding use cases.\n\nBecause the model is trained specifically for coding, many best practices you once had to prompt into general purpose models are built in, and over prompting can reduce quality.\n\nThe core prompting principle for GPT-5-Codex is “less is more.”, this includes:\nStart with a minimal prompt inspired by the Codex CLI system prompt, then add only the essential guidance you truly need.\nRemove any prompting for preambles, because the model does not support them. Asking for preambles will lead to the model stopping early before completing the task.\nReduce the number of tools to only the a terminal tool, and apply_patch.\nMake tool descriptions as concise as possible by removing unnecessary details.\n\n\nBelow is the full Codex CLI developer message, which you can use as the reference implementation for prompting GPT-5-Codex. Compared with the GPT-5 developer message, it uses about 40% as many tokens, reinforcing that minimal prompting is ideal for this model.\n\n\n\nHere is a link to the GPT-5-Codex Prompt within Codex CLI as well as the GPT-5 prompt. As a point of comparison you can see the GPT-5-Codex prompt is much shorter than GPT-5 and we recommend following the same pattern.\nYou are Codex, based on GPT-5. You are running as a coding agent in the Codex CLI on a user's computer.\n\n\nThe arguments to shell will be passed to execvp(). Most terminal commands should be prefixed with [\"bash\", \"-lc\"].\nAlways set the workdir param when using the shell function. Do not use cd unless absolutely necessary.\nWhen searching for text or files, prefer using rg or rg --files respectively because rg is much faster than alternatives like grep. (If the rg command is not found, then use alternatives.)\n\n\nDefault to ASCII when editing or creating files. Only introduce non-ASCII or other Unicode characters when there is a clear justification and the file already uses them.\nAdd succinct code comments that explain what is going on if code is not self-explanatory. You should not add comments like \"Assigns the value to the variable\", but a brief comment might be useful ahead of a complex code block that the user would otherwise have to spend time parsing out. Usage of these comments should be rare.\nYou may be in a dirty git worktree.\n    NEVER revert existing changes you did not make unless explicitly requested, since these changes were made by the user.\n    If asked to make a commit or code edits and there are unrelated changes to your work or changes that you didn't make in those files, don't revert those changes.\n    If the changes are in files you've touched recently, you should read carefully and understand how you can work with the changes rather than reverting them.\n    If the changes are in unrelated files, just ignore them and don't revert them.\nWhile you are working, you might notice unexpected changes that you didn't make. If this happens, STOP IMMEDIATELY and ask the user how they would like to proceed.\n\n\nWhen using the planning tool:\nSkip using the planning tool for straightforward tasks (roughly the easiest 25%).\nDo not make single-step plans.\nWhen you made a plan, update it after having performed one of the sub-tasks that you shared on the plan.\n\n\nThe Codex CLI harness supports several different configurations for sandboxing and escalation approvals that the user can choose from.\n\nFilesystem sandboxing defines which files can be read or written. The options for sandbox_mode are:\nread-only**: The sandbox only permits reading files.\nworkspace-write**: The sandbox permits reading files, and editing files in cwd and writable_roots. Editing files in other directories requires approval.\ndanger-full-access**: No filesystem sandboxing - all commands are permitted.\n\nNetwork sandboxing defines whether network can be accessed without approval. Options for network_access are:\nrestricted**: Requires approval\nenabled**: No approval needed\n\nApprovals are your mechanism to get user consent to run shell commands without the sandbox. Possible configuration options for approval_policy are\nuntrusted**: The harness will escalate most commands for user approval, apart from a limited allowlist of safe \"read\" commands.\non-failure**: The harness will allow all commands to run in the sandbox (if enabled), and failures will be escalated to the user for approval to run again without the sandbox.\non-request**: Commands will be run in the sandbox by default, and you can specify in your tool call if you want to escalate a command to run without sandboxing. (Note that this mode is not always available. If it is, you'll see parameters for it in the shell command description.)\nnever**: This is a non-interactive mode where you may NEVER ask the user for approval to run commands. Instead, you must always persist and work around constraints to solve the task for the user. You MUST do your utmost best to finish the task and validate your work before yielding. If this mode is paired with danger-full-access, take advantage of it to deliver the best outcome for the user. Further, in this mode, your default testing philosophy is overridden: Even if you don't see local patterns for testing, you may add tests and scripts to validate your work. Just remove them before yielding.\n\nWhen you are running with approval_policy == on-request, and sandboxing enabled, here are scenarios where you'll need to request approval:\nYou need to run a command that writes to a directory that requires it (e.g. running tests that write to /var)\nYou need to run a GUI app (e.g., open/xdg-open/osascript) to open browsers or files.\nYou are running sandboxed and need to run a command that requires network access (e.g. installing packages)\nIf you run a command that is important to solving the user's query, but it fails because of sandboxing, rerun the command with approval. ALWAYS proceed to use the with_escalated_permissions and justification parameters - do not message the user before requesting approval for the command.\nYou are about to take a potentially destructive action such as an rm or git reset that the user did not explicitly ask for\n(for all of these, you should weigh alternative paths that do not require approval)\n\nWhen sandbox_mode is set to read-only, you'll need to request approval for any command that isn't a read.\n\nYou will be told what filesystem sandboxing, network sandboxing, and approval mode are active in a developer or user message. If you are not told about this, assume that you are running with workspace-write, network sandboxing enabled, and approval on-failure.\n\nAlthough they introduce friction to the user because your work is paused until the user responds, you should leverage them when necessary to accomplish important work. If the completing the task requires escalated permissions, Do not let these settings or the sandbox deter you from attempting to accomplish the user's task unless it is set to \"never\", in which case never ask for approvals.\n\nWhen requesting approval to execute a command that will require escalated privileges:\n  Provide the with_escalated_permissions parameter with the boolean value true\n  Include a short, 1 sentence explanation for why you need to enable with_escalated_permissions in the justification parameter\n\n\nIf the user makes a simple request (such as asking for the time) which you can fulfill by running a terminal command (such as date), you should do so.\nIf the user asks for a \"review\", default to a code review mindset: prioritise identifying bugs, risks, behavioural regressions, and missing tests. Findings must be the primary focus of the response - keep summaries or overviews brief and only after enumerating the issues. Present findings first (ordered by severity with file/line references), follow with open questions or assumptions, and offer a change-summary only as a secondary detail. If no findings are discovered, state that explicitly and mention any residual risks or testing gaps.\n\n\nYou are producing plain text that will later be styled by the CLI. Follow these rules exactly. Formatting should make results easy to scan, but not feel mechanical. Use judgment to decide how much structure adds value.\n\nDefault: be very concise; friendly coding teammate tone.\nAsk only when needed; suggest ideas; mirror the user's style.\nFor substantial work, summarize clearly; follow final‑answer formatting.\nSkip heavy formatting for simple confirmations.\nDon't dump large files you've written; reference paths only.\nNo \"save/copy this file\" - User is on the same machine.\nOffer logical next steps (tests, commits, build) briefly; add verify steps if you couldn't do something.\nFor code changes:\n  Lead with a quick explanation of the change, and then give more details on the context covering where and why a change was made. Do not start this explanation with \"summary\", just jump right in.\n  If there are natural next steps the user may want to take, suggest them at the end of your response. Do not make suggestions if there are no natural next steps.\n  When suggesting multiple options, use numeric lists for the suggestions so the user can quickly respond with a single number.\nThe user does not command execution outputs. When asked to show the output of a command (e.g. git show), relay the important details in your answer or summarize the key lines so the user understands the result.\n\n\nPlain text; CLI handles styling. Use structure only when it helps scanability.\nHeaders: optional; short Title Case (1-3 words) wrapped in …; no blank line before the first bullet; add only if they truly help.\nBullets: use - ; merge related points; keep to one line when possible; 4–6 per list ordered by importance; keep phrasing consistent.\nMonospace: backticks for commands/paths/env vars/code ids and inline examples; use for literal keyword bullets; never combine with **.\nCode samples or multi-line snippets should be wrapped in fenced code blocks; add a language hint whenever obvious.\nStructure: group related bullets; order sections general → specific → supporting; for subsections, start with a bolded keyword bullet, then items; match complexity to the task.\nTone: collaborative, concise, factual; present tense, active voice; self‑contained; no \"above/below\"; parallel wording.\nDon'ts: no nested bullets/hierarchies; no ANSI codes; don't cram unrelated keywords; keep keyword lists short—wrap/reformat if long; avoid naming formatting styles in answers.\nAdaptation: code explanations → precise, structured with code refs; simple tasks → lead with outcome; big changes → logical walkthrough + rationale + next actions; casual one-offs → plain sentences, no headers/bullets.\nFile References: When referencing files in your response, make sure to include the relevant start line and always follow the below rules:\n  Use inline code to make file paths clickable.\n  Each reference should have a stand alone path. Even if it's the same file.\n  Accepted: absolute, workspace‑relative, a/ or b/ diff prefixes, or bare filename/suffix.\n  Line/column (1‑based, optional): :line[:column] or #Lline[Ccolumn] (column defaults to 1).\n  Do not use URIs like file://, vscode://, or https://.\n  Do not provide range of lines\n  Examples: src/app.ts, src/app.ts:42, b/server/index.js#L10, C:\\repo\\project\\main.rs:12:5\nAs shared previously in the GPT-5 prompting guide, here is our most updated apply_patch implementation: we highly recommend using apply_patch for file edits to match the training distribution.\n\nAs noted above, because GPT-5-Codex was trained for optimal agentic coding, prompt tuning will more often mean removing guidance than adding it. Below are aspects you may not need to steer.\n\nAdaptive reasoning is now the default in GPT-5-Codex. In the past, you might have prompted models to “think harder” or “respond quickly” based on task difficulty. GPT-5-Codex adjusts automatically: for a question like “How do I undo the last commit but keep all changes staged?”, it responds quickly without extra steering. For more complex coding tasks, it takes the time it needs and uses tools as appropriate.\n\nGPT-5-Codex was trained for a wide variety of coding tasks from long-running agentic tasks to shorter interactive coding tasks, so the model has a collaborative personality by default. When you kick off an agentic task, the model will build a detailed plan and keep you updated as it progresses. Codex CLI includes a planning tool, and the model is trained to use it throughout its agentic rollout, so if you provide a planning tool as well, the model can leverage it while coding.\nThe ”Planning” section of the GPT-5 dev message in Codex CLI is no longer needed in GPT-5-Codex, as the model is trained to produce high-quality plans.\n\nGPT-5-Codex does not emit preambles! Prompting and asking for it will likely result in the model stopping early. Instead, we have a custom summarizer that produces detailed summaries only when appropriate so you can render them inline.\n\nGPT-5-Codex defaults to strong aesthetics and modern frontend best practices. If you have preferred libraries or frameworks, steer the model by adding short sections that spell them out, such as:\n\nFrontend Guidance\nUse the following libraries unless the user or repo specifies otherwise:\nFramework: React + TypeScript\nStyling: Tailwind CSS\nComponents: shadcn/ui\nIcons: lucide-react\nAnimation: Framer Motion\nCharts: Recharts\nFonts: San Serif, Inter, Geist, Mona Sans, IBM Plex Sans, Manrope\n`"])</script><script>self.__next_f.push([1,"22:T2b4f,"])</script><script>self.__next_f.push([1,"Now that GPT-5 has been out in the world, we’ve been amazed by all of the incredible things developers are building with the model. We’ve also identified a handful of common troubleshooting patterns that should enable you to get the most out of the model.\n\n\nOverthinking shows up when the response is correct but total response time creeps up on trivial asks. The model keeps exploring options, delays the first tool call, and narrates a circuitous journey when a simple answer was available. The usual culprits are oversized reasoning effort, a prompt with no clear definition of done, or conflicting guidance that invites endless planning or provokes frantic double-checking.\n\nThe first step toward addressing this is to tighten your API parameters. Set reasoning.effort to \"minimal\" or \"low\" for routine work; reserving heavier effort for genuinely complex problems. Give the assistant an explicit stop condition and a single, fast self-check before it replies. Consider using gpt-5-mini or nano to classify user requests and route them appropriately with appropriate reasoning effort settings. If context gathering is part of the task, instruct the model on best practices for collecting necessary data to respond.\n\n\nGoal: Get enough context fast and stop as soon as you can act.\n\nMethod:\nStart broad, then fan out to focused subqueries.\nIn parallel, launch 4–8 varied queries; read top 3–5 hits per query. Deduplicate paths and cache; don't repeat queries.\n\nEarly stop (act if any):\nYou can name exact files/symbols to change.\nYou can repro a failing test/lint or have a high-confidence bug locus.\n\n\nThe following example is similar except that it instructs the model to answer questions that don’t require investigation or tool calls right away instead of overthinking.\n\nUse this section ONLY when the user's question:\nIs general knowledge or a simple usage query\nRequires no commands, browsing, or tool calls\nEspecially if the user is asking an informational question or how to perform a task, rather than asking you to run that task, provide concise instructions about how the user can do it.\n\nExceptions:\nIf the question references files/paths/functions, requests execution/verifications, or needs more context, use the normal flow\nIf unsure whether fast-path applies, ask one brief clarifying question; otherwise proceed with normal flow\n\nBehavior:\nAnswer immediately and concisely\nNo status updates, no todos, no summaries, no tool calls\nIgnore the rest of the instructions following this section and simply respond right away.\n\n\nWorking with gpt-5 you might have seen failures where the model did not spend enough time reasoning before producing an answer.\n\nFollowing along with our best practices there are 2 ways to mitigate this:\n\nUsing a higher reasoning_effort: the reasoning_effort parameter controls how much the model thinks and how eagerly it calls tools. Try using low if you were previously using minimal, medium if you were using low and so on.\nEncouraging the model to self reflect and score its own responses via prompting. For example, asking the model to construct an internal rubric and applying it to the solution before responding has been surprisingly effective on coding tasks. You can also provide your own rubric and instruct the model to reflect on its work and iterating if it spots any issues before responding.\n\n\nInternally score the draft against a 5–7 item rubric you devise (clarity, correctness, edge cases, completeness, latency).\nIf any category falls short, iterate once before replying.\n\n\n\nGPT-5 can be overly deferential. Especially in agentic settings we often want the model to go off and “just do things”. Providing persistence instructions in the system prompt can successfully mitigate this behavior. This can be easier to steer with a higher reasoning_effort (low and above).\n\n\nYou are an agent - please keep going until the user's query is completely resolved, before ending your turn and yielding back to the user.\nOnly terminate your turn when you are sure that the problem is solved.\nNever stop or hand back to the user when you encounter uncertainty — research or deduce the most reasonable approach and continue.\nDo not ask the human to confirm or clarify assumptions, as you can always adjust later — decide what the most reasonable assumption is, proceed with it, and document it for the user's reference after you finish acting\n\n\n\nGPT-5 can sometimes generate more tokens than you’d like in its final message to the user.\n\nThere are two simple ways to address this. The first is to lower the verbosity parameter in the API. By default, reasoning verbosity is set to medium if unspecified, so try explicitly setting it to low if you want shorter outputs. The second is that particularly with coding we’ve had success setting it in the system prompt\n\nWrite code for clarity first. Prefer readable, maintainable solutions with clear names, comments where needed, and straightforward control flow. Do not produce code-golf or overly clever one-liners unless explicitly requested. Use high verbosity for writing code and code tools.\n\n\nLatency has a few distinct contributors, so make sure to measure before you tune. Track TTFT, time to first action, and total response time at P50/P95, separating model time from tool and network time. Tracking these metrics will help you optimize the leg that’s actually slow.\n\nTo cut model response time, right‑size the amount of thinking the model should use: use reasoning.effort \"minimal\" or \"low\" for routine work and add a clear stop condition with a single‑pass self‑check (see Overthinking). Higher reasoning efforts can also lead to more tool calls.\n\nCombine tool calls when possible. The model will need to be told when to call tools in parallel, it won't always by default.\n\nDefinition: Run independent or read-only tool actions in parallel (same turn/batch) to reduce latency.\nWhen to parallelize:\n Reading multiple files/configs/logs that don’t affect each other.\n Static analysis, searches, or metadata queries with no side effects.\n Separate edits to unrelated files/features that won’t conflict.\n\n\nTo allow your users to watch progress as the model reasons, display reasoning summaries and tool call preamble messages to the user. In many cases, perceived latency is reduced when the user isn't presented with reasoning summaries as the model is thinking. The model is also able to be instructed to provide preamble messages, or status updates, before making tool calls, letting the user follow along with what the model is doing when calling tools.\n\n\nDefinition: A brief progress note: what just happened, what’s next, any real blockers, written in a continuous conversational style, narrating the story of your progress as you go.\nAlways start with a brief acknowledgement of the task before getting started. (No need to prefix with \"Status Update:\")\n\n\nLower TTFT by caching what doesn’t change: Make sure to make effective use of prompt, reasoning, and tool call result caching by properly structuring your requests to the API. When a path is truly latency‑sensitive, enable priority processing for that call with service_tier = “priority” for faster responses (Note that tokens served by Priority Processing will be billed on a per-token basis, priced at a premium relative to standard processing rates). If TTFT is high with a tiny prompt and no tools, save the request_id and escalate to support@openai.com for more targeted help.\n\n\nWhen the model fires off tools without moving the answer forward, the usual cause is fuzzy routing: overlapping tool definitions, prompts that reward thoroughness over decisiveness, or reasoning set too high. Another frequent cause is not carrying the prior reasoning into subsequent calls; use of the Responses API ensures intent and reasoning summaries persist across turns rather than forgetting why a tool was chosen.\n\nMake answering from context the default in your prompt instructions. Give each tool a single job with crisp inputs/outputs and explicit “don’t use for…” notes. Provide short playbooks for common scenarios so the path is obvious (for example: if the user references a document you don’t have in context, run a semantic search to find it, then fetch the relevant section before answering).\n\nSelect one tool or none; prefer answering from context when possible.\nCap tool calls at 2 per user request unless new information makes more strictly necessary.\n\n\nKeep an eye on tool\\_calls\\_per\\_turn, duplicate calls to the same tool within a couple of seconds, and the share of answers completed without tools; spikes are a clear signal that routing or prompts need tightening.\n\n\nIn rare instances gpt-5 can experience a mode collapse where a model calls a tool and outputs a long string of repeating garbage.\n\nIn those instances we’ve always found that it stemmed from a contradiction between separate sections of the prompt. For best practices we recommend using gpt-5 meta prompting ability to spot the bug and fix it\n\nPlease analyze why the  tool call is malformed.\nReview the provided sample issue to understand the failure mode.\nExamine the  and  carefully. Identify any ambiguities, inconsistencies, or phrasing that could mislead GPT-5 into generating an incorrect tool call.\nFor each potential cause, explain clearly how it could result in the observed failure.\nProvide actionable recommendations to improve the  or  so GPT-5 produces valid tool calls consistently.\n\n\n\n\n\n\n\nMany of the above prompt additions were generated through meta prompting. It’s possible to ask GPT-5 at the end of a turn that didn’t perform up to expectations how to improve its own instructions. The following prompt was used to produce some of the solutions to overthinking problems above, and can be modified to meet your particular needs.\n\nThat was a high quality response, thanks! It seemed like it took you a while to finish responding though. Is there a way to clarify your instructions so you can get to a  response as good as this faster next time? It's extremely important to be efficient when providing these responses or users won't get the most out of them in time. Let's see if we can improve!\n1) think through the response you gave above\n2) read through your instructions starting from \"\" and look for anything that might have made you take longer to formulate a high quality response than you needed\n3) write out targeted (but generalized) additions/changes/deletions to your instructions to make a request like this one faster next time with the same level of quality\n\nWhen meta prompting inside of a specific context, it is important to generate responses a few times if possible and pay attention to elements of its responses that are common between them. Some improvements or changes the model proposes might be overly specific to that particular situation, but you can often simplify them to arrive at a general improvement. We recommended that you create an eval to measure whether a particular prompt change is better or worse for your particular use case."])</script><script>self.__next_f.push([1,"23:T3eee,"])</script><script>self.__next_f.push([1,"AI agents often operate in long-running, multi-turn interactions, where keeping the right balance of context is critical. If too much is carried forward, the model risks distraction, inefficiency, or outright failure. If too little is preserved, the agent loses coherence.\n\nHere, context refers to the total window of tokens (input + output) that the model can attend to at once. For GPT-5, this capacity is up to 272k input tokens and 128k output tokens but even such a large window can be overwhelmed by uncurated histories, redundant tool results, or noisy retrievals. This makes context management not just an optimization, but a necessity.\n\nIn this cookbook, we’ll explore how to manage context effectively using the Session object from the OpenAI Agents SDK, focusing on two proven context management techniques—trimming and compression—to keep agents fast, reliable, and cost-efficient.\n\n\nSustained coherence across long threads** – Keep the agent anchored to the latest user goal without dragging along stale details. Session-level trimming and summaries prevent “yesterday’s plan” from overriding today’s ask.\nHigher tool-call accuracy** – Focused context improves function selection and argument filling, reducing retries, timeouts, and cascading failures during multi-tool runs.\nLower latency \u0026 cost** – Smaller, sharper prompts cut tokens per turn and attention load.\nError \u0026 hallucination containment** – Summaries act as “clean rooms” that correct or omit prior mistakes; trimming avoids amplifying bad facts (“context poisoning”) turn after turn.\nEasier debugging \u0026 observability** – Stable summaries and bounded histories make logs comparable: you can diff summaries, attribute regressions, and reproduce failures reliably.\nMulti-issue and handoff resilience** – In multi-problem chats, per-issue mini-summaries let the agent pause/resume, escalate to humans, or hand off to another agent while staying consistent.\n\nMemory Comparison in AI Agents\nThe OpenAI Responses API includes basic memory support through built-in state and message chaining with previous_response_id.\n\nYou can continue a conversation by passing the prior response’s id as previous_response_id, or you can manage context manually by collecting outputs into a list and resubmitting them as the input for the next response.\n\nWhat you don’t get is automatic memory management. That’s where the Agents SDK comes in. It provides session memory on top of Responses, so you no longer need to manually append response.output or track IDs yourself. The session becomes the memory object: you simply call session.run(\"...\") repeatedly, and the SDK handles context length, history, and continuity—making it far easier to build coherent, multi-turn agents.\n\n\nWe’ll ground the techniques in a practical example for one of the common long-running tasks, such as:\n\nMulti-turn Customer Service Conversations**\nIn extended conversations about tech products—spanning both hardware and software—customers often surface multiple issues over time. The agent must stay consistent and goal-focused while retaining only the essentials rather than hauling along every past detail.\n\n\nTo address these challenges, we introduce two separate concrete approaches using OpenAI Agents SDK:\n\nContext Trimming** – dropping older turns while keeping the last N turns.\n  Pros\n\n    Deterministic \u0026 simple: No summarizer variability; easy to reason about state and to reproduce runs.\n    Zero added latency: No extra model calls to compress history.\n    Fidelity for recent work: Latest tool results, parameters, and edge cases stay verbatim—great for debugging.\n    Lower risk of “summary drift”: You never reinterpret or compress facts.\n\n    Cons\n\n    Forgets long-range context abruptly: Important earlier constraints, IDs, or decisions can vanish once they scroll past N.\n    User experience “amnesia”: Agent can appear to “forget” promises or prior preferences midway through long sessions.\n    Wasted signal: Older turns may contain reusable knowledge (requirements, constraints) that gets dropped.\n    Token spikes still possible: If a recent turn includes huge tool payloads, your last-N can still blow up the context.\n\n  Best when\n\n    Your tasks in the conversation is indepentent from each other with non-overlapping context that does not reuqire carrying previous details further.\n    You need predictability, easy evals, and low latency (ops automations, CRM/API actions).\n    The conversation’s useful context is local (recent steps matter far more than distant history).\n\nContext Summarization** – compressing prior messages(assistant, user, tools, etc.) into structured, shorter summaries injected into the conversation history.\n\n  Pros\n\n    Retains long-range memory compactly: Past requirements, decisions, and rationales persist beyond N.\n    Smoother UX: Agent “remembers” commitments and constraints across long sessions.\n    Cost-controlled scale: One concise summary can replace hundreds of turns.\n    Searchable anchor: A single synthetic assistant message becomes a stable “state of the world so far.”\n\n    Cons\n\n    Summarization loss \u0026 bias: Details can be dropped or misweighted; subtle constraints may vanish.\n    Latency \u0026 cost spikes: Each refresh adds model work (and potentially tool-trim logic).\n    Compounding errors: If a bad fact enters the summary, it can poison future behavior (“context poisoning”).\n    Observability complexity: You must log summary prompts/outputs for auditability and evals.\n\n  Best when\n\n    You have use cases where your tasks needs context collected accross the flow such as  planning/coaching, RAG-heavy analysis, policy Q\u0026A.\n    You need continuity over long horizons and carry the important details further to solve related tasks.\n    Sessions exceed N turns but must preserve decisions, IDs, and constraints reliably.\n\nQuick comparison\n| Dimension         | Trimming (last-N turns)         | Summarizing (older → generated summary) |\n| ----------------- | ------------------------------- | ------------------------------------ |\n| Latency / Cost    | Lowest (no extra calls)     | Higher at summary refresh points |\n| Long-range recall | Weak (hard cut-off)         | Strong (compact carry-forward)   |\n| Risk type         | Context loss                | Context distortion/poisoning     |\n| Observability     | Simple logs                 | Must log summary prompts/outputs |\n| Eval stability    | High                        | Needs robust summary evals       |\n| Best for          | Tool-heavy ops, short workflows | Analyst/concierge, long threads      |\n\n\nBefore running this cookbook, you must set up the following accounts and complete a few setup actions. These prerequisites are essential to interact with the APIs used in this project.\n\n\nPurpose:**\n  You need an OpenAI account to access language models and use the Agents SDK featured in this cookbook.\n\nAction:**\n  Sign up for an OpenAI account if you don’t already have one. Once you have an account, create an API key by visiting the OpenAI API Keys page.\nBefore running the workflow, set your environment variables:\n\nos.environ[\"OPENAI_API_KEY\"] = \"sk-proj-...\"\n\nAlternatively, you can set your OpenAI API key for use by the agents via the set_default_openai_key function by importing agents library .\n\nfrom agents import set_default_openai_key\nset_default_openai_key(\"YOUR_API_KEY\")\n\nBelow we install the openai-agents library (OpenAI Agents SDK)\nLet's test the installed libraries by defining and running an agent.\n\nWe can start by defining the necessary components from Agents SDK Library. Instructions added based on the use case during agent creation.\nWe are using Session object from OpenAI Agents Python SDK. Here’s a TrimmingSession implementation that keeps only the last N turns (a “turn” = one user message and everything until the next user message—including the assistant reply and any tool calls/results). It’s in-memory and trims automatically on every write and read.\n\nLet's define the custom session object we implemented with max_turns=3.\nHow to choose the right max_turns?\n\nDetermining this parameter usually requires experimentation with your conversation history. One approach is to extract the total number of turns across conversations and analyze their distribution. Another option is to use an LLM to evaluate conversations—identifying how many tasks or issues each one contains and calculating the average number of turns needed per issue.\n\nBelow, you can see how the trimming session works for max_turns=3.\nContext Trimming in Session\nWhat counts as a “turn”\n\nA turn = one user message plus everything that follows it (assistant replies, reasoning, tool calls, tool results) until the next user message.\n\nWhen trimming happens\n\nOn write: add_items(...) appends the new items, then immediately trims the stored history.\nOn read: get_items(...) returns a trimmed view (so even if you bypassed a write, reads won’t leak old turns).\n\nHow it decides what to keep\n\nTreat any item with role == \"user\" as a user message (via _is_user_msg).\nScan the history backwards and collect the indices of the last N user messages (max_turns).\nFind the earliest index among those N user messages.\nKeep everything from that index to the end; drop everything before it.\n\nThat preserves each complete turn boundary: if the earliest kept user message is at index k, you also keep all assistant/tool items that came after k.\n\nTiny example\n\nHistory (old → new):\n\n0: user(\"Hi\")\n1: assistant(\"Hello!\")\n2: tool_call(\"lookup\")\n3: tool_result(\"…\")\n4: user(\"It didn't work\")\n5: assistant(\"Try rebooting\")\n6: user(\"Rebooted, now error 42\")\n7: assistant(\"On it\")\n\nWith max_turns = 2, the last two user messages are at indices 4 and 6.\nEarliest of those is 4 → keep items 4..7, drop 0..3.\n\nWhy this works well\n\nYou always keep complete turns, so the assistant retains the immediate context it needs (both the user’s last asks and the assistant/tool steps in between).\nIt prevents context bloat by discarding older turns wholesale, not just messages.\n\nCustomization knobs\n\nChange max_turns at init.\nAdjust _is_user_msg(...) if your item schema differs.\nIf you’d rather cap by message count or tokens, replace _trim_to_last_turns(...) or add a second pass that measures tokens.\n\nOnce the history exceeds max_turns. It keeps the most recent N user turns intact, summarizes everything older into two synthetic messages:\n\nuser: \"Summarize the conversation we had so far.\"\nassistant: {generated summary}\n\nThe shadow prompt from the user to request the summarization added to keep natural flow of the conversation without confusing the chat flow between user and assistant. Final version of the generated summary injected to assistant message.\nSummarization Prompt\n\n\nA well-crafted summarization prompt is essential for preserving the context of a conversation, and it should always be tailored to the specific use case. Think of it like being a customer support agent handing off a case to the next agent. What concise yet critical details would they need to continue smoothly? The prompt should strike the right balance: not overloaded with unnecessary information, but not so sparse that key context is lost. Achieving this balance requires careful design and ongoing experimentation to fine-tune the level of detail.\nKey Principles for Designing Memory Summarization Prompts\n\nMilestones:** Highlight important events in the conversation—for example, when an issue is resolved, valuable information is uncovered, or all necessary details have been collected.\n\nUse Case Specificity:** Tailor the compression prompt to the specific use case. Think about how a human would track and recall information in working memory while solving the same task.\n\nContradiction Check:** Ensure the summary does not conflict with itself, system instructions or tool definitions. This is especially critical for reasoning models, which are more prone to conflicts in the context.\n\nTimestamps \u0026 Temporal Flow:** Incorporate timing of events in the summary. This helps the model reason about updates in sequence and reduces confusion when forgetting or remembering the latest memory over a timeline.\n\nChunking:** Organize details into categories or sections rather than long paragraphs. Structured grouping improves an LLM’s ability to understand relationships between pieces of information.\n\nTool Performance Insights:** Capture lessons learned from multi-turn, tool-enabled interactions—for example, noting which tools worked effectively for specific queries and why. These insights are valuable for guiding future steps.\n\nGuidance \u0026 Examples:** Steer the summary with clear guidance. Where possible, extract concrete examples from the conversation history to make future turns more grounded and context-rich.\n\nHallucination Control:** Be precise in what you include. Even minor hallucinations in a summary can propagate forward, contaminating future context with inaccuracies.\n\nModel Choice:** Select a summarizer model based on use case requirements, summary length, and tradeoffs between latency and cost. In some cases, using the same model as the AI agent itself can be advantageous.\n\nContext Trimming in Session\nHigh‑level idea\n\nA turn* = one *real user* message *plus everything that follows it* (assistant replies, tool calls/results, etc.) *until the next real user message**.\nYou configure two knobs:\n\n  context_limit: the maximum number of real user turns allowed in the raw history before we summarize.\n  keep_last_n_turns: how many of the most recent turns to keep verbatim when we do summarize.\n\n    Invariant: keep_last_n_turns \u003c= context_limit.\nWhen the number of real user turns exceeds context_limit, the session:\n\n  Summarizes everything before the earliest of the last keep_last_n_turns turn starts,\n  Injects a synthetic user→assistant pair at the top of the kept region:\n\n     user: \"Summarize the conversation we had so far.\" (shadow prompt)\n     assistant: {generated summary}\n  Keeps the last keep_last_n_turns turns verbatim.\n\nThis guarantees the last keep_last_n_turns turns are preserved exactly as they occurred, while all earlier content is compressed into the two synthetic messages.\n\nYou can use the get_items_with_metadata method to get the full history of the session including the metadata for debugging and analysis purposes.\n\nTurn boundary preserved at the “fresh” side: the **keep_last_n_turns user turns remain verbatim; everything older is compressed.\nTwo-message summary block**: easy for downstream tooling to detect or display (metadata.synthetic == True).\nAsync + lock discipline: we **release the lock while the (potentially slow) summarization runs; then re-check the condition before applying the summary to avoid racey merges.\nIdempotent behavior**: if more messages arrive during summarization, the post-await recheck prevents stale rewrites.\n\n\nUltimately, evals is all you need for context engineering too. The key question to ask is: how do we know the model isn’t “losing context” or \"confusing context\"?\n\nWhile a full cookbook around memory could stand on its own in the future, here are some lightweight evaluation harness ideas to start with:\n\nBaseline \u0026 Deltas:** Continue running your core eval sets and compare before/after experiments to measure memory improvements.\nLLM-as-Judge:** Use a model with a carefully designed grader prompt to evaluate summarization quality. Focus on whether it captures the most important details in the correct format.\nTranscript Replay:** Re-run long conversations and measure next-turn accuracy with and without context trimming. Metrics could include exact match on entities/IDs and rubric-based scoring on reasoning quality.\nError Regression Tracking:** Watch for common failure modes—unanswered questions, dropped constraints, or unnecessary/repeated tool calls.\nToken Pressure Checks:** Flag cases where token limits force dropping protected context. Log before/after token counts to detect when critical details are being pruned."])</script><script>self.__next_f.push([1,"24:T693d,"])</script><script>self.__next_f.push([1,"When deploying production code, most teams rely on CI/CD pipelines to validate changes before merging. Reviewers typically look at unit test results, vulnerability scans, and code quality reports. Traditionally, these are produced by rule-based engines that catch known issues but often miss contextual or higher-order problems—while leaving developers with noisy results that are hard to prioritize or act on.\n\nWith LLMs, you can add a new layer of intelligence to this process: reasoning about code quality and interpreting security findings. By augmenting your GitLab pipelines with OpenAI’s Codex CLI, teams gain insights that go beyond static rules:\n\nCode Quality** → Generate GitLab-compliant CodeClimate JSON reports that surface contextual issues directly in merge requests.\n\nSecurity** → Post-process existing SAST results to consolidate duplicates, rank issues by exploitability, and provide clear, actionable remediation steps.\n\nThis guide shows how to integrate Codex CLI into a GitLab pipeline for both use cases—delivering structured, machine-readable reports alongside actionable, human-readable guidance.\n\n\nCodex CLI is an open-source command-line tool for bringing OpenAI’s reasoning models into your development workflow. For installation, usage, and full documentation, refer to the official repository: github.com/openai/codex.\n\nIn this cookbook, we’ll use Full Auto mode in an ephemeral GitLab runner to generate a standards-compliant JSON report.\n\n\nTo follow along, you’ll need:\n\nA GitLab account and project\nA GitLab runner with internet access (we’ve tested this on a Linux runner with 2 vCPUs, 8GB memory and 30GB of storage)\nRunner must be able to connect to  api.openai.com\nAn OpenAI API key (OPENAI_API_KEY)\nGitLab CI/CD variables configured under Settings → CI/CD → Variables\n\n\n\nThis repository is a deliberately vulnerable Node.js Express demo app based on GitLab's node express template, built to showcase static application security testing (SAST) and code quality scanning in GitLab CI/CD.\n\nThe code includes common pitfalls such as command injection, path traversal, unsafe eval, regex DoS, weak cryptography (MD5), and hardcoded secrets. It’s used to validate that Codex-powered analyzers produce GitLab-native reports (Code Quality and SAST) that render directly in merge requests.\n\nThe CI runs on GitLab SaaS runners with node:24 images and a few extras (jq, curl, ca-certificates, ajv-cli). Jobs are hardened with set -euo pipefail, schema validation, and strict JSON markers to keep parsing reliable even if Codex output varies.\n\nThis pipeline pattern—prompt, JSON marker extraction, schema validation—can be adapted to other stacks, though prompt wording and schema rules may need tweaks. Since Codex runs in a sandbox, some system commands (like awk or nl) may be restricted.\n\nYour team wants to ensure that code quality checks run automatically before any merge. To surface findings directly in GitLab’s merge request widget, reports must follow the CodeClimate JSON format. Reference: GitLab Docs\n\n\nHere’s a drop-in GitLab CI job using Codex CLI to produce a compliant JSON file:\nstages: [codex]\n\ndefault:\n  image: node:24\n  variables:\n    CODEX_QA_PATH: \"gl-code-quality-report.json\"\n    CODEX_RAW_LOG: \"artifacts/codex-raw.log\"\nStrict prompt: must output a single JSON array (or []), no prose/markdown/placeholders.\n    CODEX_PROMPT: |\n      Review this repository and output a GitLab Code Quality report in CodeClimate JSON format.\n      RULES (must follow exactly):\n      OUTPUT MUST BE A SINGLE JSON ARRAY. Example: [] or [ {...}, {...} ].\n      If you find no issues, OUTPUT EXACTLY: []\n      DO NOT print any prose, backticks, code fences, markdown, or placeholders.\n      DO NOT write any files. PRINT ONLY between these two lines:\n        === BEGIN_CODE_QUALITY_JSON ===\n\n        === END_CODE_QUALITY_JSON ===\n      Each issue object MUST include these fields:\n        \"description\": String,\n        \"check_name\": String (short rule name),\n        \"fingerprint\": String (stable across runs for same issue),\n        \"severity\": \"info\"|\"minor\"|\"major\"|\"critical\"|\"blocker\",\n        \"location\": { \"path\": \"\", \"lines\": { \"begin\":  } }\n      Requirements:\n      Use repo-relative paths from the current checkout (no \"./\", no absolute paths).\n      Use only files that actually exist in this repo.\n      No trailing commas. No comments. No BOM.\n      Prefer concrete, de-duplicated findings. If uncertain, omit the finding.\n\ncodex_review:\n  stage: codex\nSkip on forked MRs (no secrets available). Run only if OPENAI_API_KEY exists.\n  rules:\n    if: '$CI_PIPELINE_SOURCE == \"merge_request_event\" \u0026\u0026 $CI_MERGE_REQUEST_SOURCE_PROJECT_ID != $CI_PROJECT_ID'\n      when: never\n    if: '$OPENAI_API_KEY'\n      when: on_success\n    when: never\n\n  script:\n    set -euo pipefail\n    echo \"PWD=$(pwd)  CI_PROJECT_DIR=${CI_PROJECT_DIR}\"\nEnsure artifacts always exist so upload never warns, even on early failure\n    mkdir -p artifacts\n    ': \u003e ${CODEX_RAW_LOG}'\n    ': \u003e ${CODEX_QA_PATH}'\nMinimal deps + Codex CLI\n    apt-get update \u0026\u0026 apt-get install -y --no-install-recommends curl ca-certificates git lsb-release\n    npm -g i @openai/codex@latest\n    codex --version \u0026\u0026 git --version\nBuild a real-file allowlist to guide Codex to valid paths/lines\n    FILE_LIST=\"$(git ls-files | sed 's/^/- /')\"\n    |\n      export CODEX_PROMPT=\"${CODEX_PROMPT}\n      Only report issues in the following existing files (exactly as listed):\n      ${FILE_LIST}\"\nRun Codex; allow non-zero exit but capture output for extraction\n    |\n      set +o pipefail\n      script -q -c 'codex exec --full-auto \"$CODEX_PROMPT\"' | tee \"${CODEX_RAW_LOG}\" \u003e/dev/null\n      CODEX_RC=${PIPESTATUS[0]}\n      set -o pipefail\n      echo \"Codex exit code: ${CODEX_RC}\"\nStrip ANSI + \\r, extract JSON between markers to a temp file; validate or fallback to []\n    |\n      TMP_OUT=\"$(mktemp)\"\n      sed -E 's/\\x1B\\[[0-9;]*[A-Za-z]//g' \"${CODEX_RAW_LOG}\" \\\n        | tr -d '\\r' \\\n        | awk '\n            /^\\s=== BEGIN_CODE_QUALITY_JSON ===\\s$/ {grab=1; next}\n            /^\\s=== END_CODE_QUALITY_JSON ===\\s$/   {grab=0}\n            grab\n          ' \u003e \"${TMP_OUT}\"\nIf extracted content is empty/invalid or still contains placeholders, replace with []\n      if ! node -e 'const f=process.argv[1]; const s=require(\"fs\").readFileSync(f,\"utf8\").trim(); if(!s || /(|BEGIN_CODE_QUALITY_JSON|END_CODE_QUALITY_JSON)/.test(s)) process.exit(2); JSON.parse(s);' \"${TMP_OUT}\"; then\n        echo \"WARNING: Extracted content empty/invalid; writing empty [] report.\"\n        echo \"[]\" \u003e \"${TMP_OUT}\"\n      fi\n      mv -f \"${TMP_OUT}\" \"${CODEX_QA_PATH}\"\nSoft warning if Codex returned non-zero but we still produced a report\n      if [ \"${CODEX_RC}\" -ne 0 ]; then\n        echo \"WARNING: Codex exited with code ${CODEX_RC}. Proceeding with extracted report.\" \u003e\u00262\n      fi\n\n  artifacts:\n    when: always\n    reports:\n      codequality: gl-code-quality-report.json\n    paths:\n      artifacts/codex-raw.log\n    expire_in: 14 days\n\nInstalls Codex CLI (npm -g i @openai/codex@latest)\nBuilds a file allowlist with git ls-files\nRuns Codex in full-auto mode with a strict JSON-only prompt\nExtracts valid JSON between markers, validates it, and falls back to [] if invalid\nPublishes artifacts to GitLab so results appear inline with merge requests\n\nThe generated artifacts can be downloaded from the pipeline page\n\n\n\nOr when running as a merge from a feature to master branch,\n\nBy embedding Codex CLI into your GitLab CI/CD pipelines, you can elevate code quality checks beyond static rules. Instead of only catching syntax errors or style violations, you enable reasoning-based analysis that highlights potential issues in context.\n\nThis approach has several benefits:\n\nConsistency**: every merge request is reviewed by the same reasoning process\nContext awareness**: LLMs can flag subtle issues rule-based scanners miss\nDeveloper empowerment**: feedback is immediate, visible, and actionable\n\nAs teams adopt this workflow, LLM-powered quality checks can complement traditional linting and vulnerability scanning—helping ensure that code shipped to production is both robust and maintainable.\n\n\n\nFor this example, we tested on OWASP Juice Shop, a deliberately vulnerable Node.js Express app. It contains common flaws such as injection, unsafe eval, weak crypto, and hardcoded secrets—ideal for validating Codex-powered analysis.\n\nYour team wants to ensure that whenever code changes are introduced, the pipeline automatically checks for security vulnerabilities before merge. This is already handled by static analyzers and language-specific scanners, which generate reports in the GitLab SAST JSON schema. However, raw outputs can be rigid, noisy, and often leave reviewers without clear next steps.\n\nBy adding Codex CLI into your pipeline, you can turn scanner results generated by GitLab SAST scanners (or other scanner outputs) into actionable remediation guidance and even generate ready-to-apply git patches:\n\n\nCodex reads gl-sast-report.json.\nConsolidates duplicate findings.\nRanks by exploitability (e.g. user input → dangerous sinks).\nProduces a succinct security_priority.md with top 5 actions and detailed remediation notes.\n\n\nRequirement: This job expects that upstream SAST jobs already generated a gl-sast-report.json. Codex reads it and produces security_priority.md for reviewers.\n\nstages:\n codex\n remediation\n\ndefault:\n image: node:24\n\nvariables:\n CODEX_SAST_PATH: \"gl-sast-report.json\"\n CODEX_SECURITY_MD: \"security_priority.md\"\n CODEX_RAW_LOG: \"artifacts/codex-sast-raw.log\"\n\n--- Recommendations prompt (reads SAST → writes Markdown) ---\n CODEX_PROMPT: |\n   You are a security triage assistant analyzing GitLab SAST output.\n   The SAST JSON is located at: ${CODEX_SAST_PATH}\n\n   GOAL:\n   Read and parse ${CODEX_SAST_PATH}.\n   Consolidate duplicate or overlapping findings (e.g., same CWE + same sink/function, same file/line ranges, or same data flow root cause).\n   Rank findings by realistic exploitability and business risk, not just library presence.\n     Prioritize issues that:\n       Are reachable from exposed entry points (HTTP handlers, controllers, public APIs, CLI args).\n       Involve user-controlled inputs reaching dangerous sinks (e.g., SQL exec, OS exec, eval, path/file ops, deserialization, SSRF).\n       Occur in authentication/authorization boundaries or around secrets/keys/tokens.\n       Have clear call stacks/evidence strings pointing to concrete methods that run.\n       Affect internet-facing or privileged components.\n     De-prioritize purely theoretical findings with no reachable path or dead code.\n\n   CONSOLIDATION RULES:\n   Aggregate by (CWE, primary sink/function, file[:line], framework route/handler) when applicable.\n   Merge repeated instances across files if they share the same source-sink pattern and remediation is the same.\n   Keep a single representative entry with a count of affected locations; list notable examples.\n\n   OUTPUT FORMAT (MARKDOWN ONLY, BETWEEN MARKERS BELOW):\n   Start with a title and short summary of total findings and how many were consolidated.\n   A table of TOP PRIORITIES sorted by exploitability (highest first) with columns:\n     Rank | CWE | Title | Affected Locations | Likely Exploit Path | Risk | Rationale (1–2 lines)\n   \"Top 5 Immediate Actions\" list with concrete next steps.\n   \"Deduplicated Findings (Full Details)\" with risk, 0–100 exploitability score, evidence (file:line + methods), remediation, owners, references.\n   If ${CODEX_SAST_PATH} is missing or invalid JSON, output a brief note stating no parsable SAST findings.\n\n   RULES (must follow exactly):\n   PRINT ONLY between these two lines:\n     === BEGIN_SECURITY_MD ===\n\n     === END_SECURITY_MD ===\n   No prose, backticks, code fences, or anything outside the markers.\n   Be concise but specific. Cite only evidence present in the SAST report.\n\ncodex_recommendations:\n stage: codex\n rules:\n   if: '$CI_PIPELINE_SOURCE == \"merge_request_event\" \u0026\u0026 $CI_MERGE_REQUEST_SOURCE_PROJECT_ID != $CI_PROJECT_ID'\n     when: never\n   if: '$OPENAI_API_KEY'\n     when: on_success\n   when: never\n script:\n   set -euo pipefail\n   mkdir -p artifacts\n   \": \u003e ${CODEX_RAW_LOG}\"\n   \": \u003e ${CODEX_SECURITY_MD}\"\n\n   apt-get update \u0026\u0026 apt-get install -y --no-install-recommends curl ca-certificates git lsb-release\n   npm -g i @openai/codex@latest\n   codex --version \u0026\u0026 git --version\n\n   |\n     if [ ! -s \"${CODEX_SAST_PATH}\" ]; then\n       echo \"WARNING: ${CODEX_SAST_PATH} not found or empty. Codex will emit a 'no parsable findings' note.\"\n     fi\n\n   FILE_LIST=\"$(git ls-files | sed 's/^/- /')\"\n   |\n     export CODEX_PROMPT=\"${CODEX_PROMPT}\n\n     Existing repository files (for reference only; use paths exactly as listed in SAST evidence):\n     ${FILE_LIST}\"\n\nRun Codex and capture raw output (preserve Codex's exit code via PIPESTATUS)\n   |\n     set +o pipefail\n     codex exec --full-auto \"$CODEX_PROMPT\" | tee \"${CODEX_RAW_LOG}\" \u003e/dev/null\n     CODEX_RC=${PIPESTATUS[0]}\n     set -o pipefail\n     echo \"Codex exit code: ${CODEX_RC}\"\n\nExtract markdown between markers; fallback to a minimal note\n   |\n     TMP_OUT=\"$(mktemp)\"\n     sed -E 's/\\x1B\\[[0-9;]*[A-Za-z]//g' \"${CODEX_RAW_LOG}\" | tr -d '\\r' | awk '\n       /^\\s=== BEGIN_SECURITY_MD ===\\s$/ {grab=1; next}\n       /^\\s=== END_SECURITY_MD ===\\s$/   {grab=0}\n       grab\n     ' \u003e \"${TMP_OUT}\"\n     if ! [ -s \"${TMP_OUT}\" ]; then\n       cat \u003e \"${TMP_OUT}\" \u00262\n     fi\n artifacts:\n   when: always\n   paths:\n     artifacts/codex-sast-raw.log\n     security_priority.md\n   expire_in: 14 days\nHere's an example of the output we receive:\n\nParsed gl-sast-report.json and merged overlapping issues.\nTotal raw findings: 5 → Consolidated into: 4 representative entries\n(duplicated SQL injection patterns across endpoints were merged).\n\n\n| Rank | CWE      | Title                                | Affected Locations | Likely Exploit Path                  | Risk     | Rationale (1–2 lines)                                                                                 |\n|------|----------|--------------------------------------|-------------------|--------------------------------------|----------|--------------------------------------------------------------------------------------------------------|\n| 1    | CWE-798  | Hardcoded JWT private key            | 1                 | Auth token issuance / verification   | Critical | Repo leak enables minting valid admin JWTs; trivial exploitation, internet-facing.                     |\n| 2    | CWE-89   | SQL injection in login and search    | 2                 | Login endpoint; product search       | Critical | Raw SQL concatenation; direct login bypass and data exfiltration via public HTTP handlers.             |\n| 3    | CWE-94   | Server-side code injection via eval  | 1                 | User profile update handler          | High     | eval() on user input allows RCE; conditionally enabled but still high-impact when reachable.          |\n| 4    | — (SSRF) | SSRF via arbitrary image URL fetch   | 1                 | Image URL fetch/write flow           | High     | Outbound fetch of unvalidated URLs enables internal service / metadata access (e.g., AWS metadata).     |\n\nReplace hardcoded JWT signing key in lib/insecurity.ts:23; load from secret storage, rotate keys, and invalidate existing tokens.\nUpdate routes/login.ts:34 to use parameterized queries; remove raw concatenation; validate and escape inputs.\nFix routes/search.ts:23 by using ORM bind parameters or escaped LIKE helpers instead of string concatenation.\nRefactor routes/userProfile.ts:55–66; replace eval() with safe templating or a whitelisted evaluator.\nHarden image import logic: allowlist schemes/hosts, block link-local/metadata IPs, apply timeouts and size limits.\n\nRisk: Critical — Exploitability 98/100\nEvidence:\n  File: lib/insecurity.ts:23\n  Message: RSA private key embedded in source enables forged admin tokens\nSuggested Remediation: Remove key from source, load via env/secret manager, rotate keys, enforce short TTLs\nOwners/Teams: Backend/Core (lib)\nReferences: CWE-798; OWASP ASVS 2.1.1, 2.3.1\nRisk: Critical — Exploitability 95/100\nEvidence:\n  routes/login.ts:34 — classic login bypass via ' OR 1=1--\n  routes/search.ts:23 — UNION-based extraction via %25' UNION SELECT ...\nSuggested Remediation: Use parameterized queries/ORM, validate inputs, add WAF/error suppression\nOwners/Teams: Backend/API (routes)\nReferences: CWE-89; OWASP Top 10 A03:2021; ASVS 5.3\nRisk: High — Exploitability 72/100\nEvidence:\n  routes/userProfile.ts:55–66 — eval() used for dynamic username patterns\nSuggested Remediation: Remove eval(), or sandbox with strict whitelist; validate/encode inputs\nOwners/Teams: Backend/API (routes)\nReferences: CWE-94; OWASP Top 10 A03:2021\nRisk: High — Exploitability 80/100\nEvidence:\n  Image import fetches arbitrary imageUrl → can hit internal services (169.254.169.254)\nSuggested Remediation: Enforce HTTPS + DNS/IP allowlist, block RFC1918/link-local, validate post-resolution, no redirects\nOwners/Teams: Backend/API (routes)\nReferences: OWASP SSRF Prevention; OWASP Top 10 A10:2021\nCodex consumes both the SAST JSON and the repo tree.\nFor each High/Critical issue:\n  Builds a structured prompt → outputs a unified git diff.\n  Diff is validated (git apply --check) before being stored as .patch.\n\nRequirement: This job depends on the previous stage output of the security_priority.md file to use as input to generate the patch file for creating an MR:\n stages:\n  remediation\n\ndefault:\n  image: node:24\n\nvariables:\nInputs/outputs\n  SAST_REPORT_PATH: \"gl-sast-report.json\"\n  PATCH_DIR: \"codex_patches\"\n  CODEX_DIFF_RAW: \"artifacts/codex-diff-raw.log\"\n\n--- Resolution prompt (produces unified git diffs only) ---\n  CODEX_DIFF_PROMPT: |\n    You are a secure code remediation assistant.\n    You will receive:\n    The repository working tree (read-only)\n    One vulnerability (JSON from a GitLab SAST report)\n    Allowed files list\n\n    GOAL:\n    Create the minimal, safe fix for the vulnerability.\n    Output a unified git diff that applies cleanly with git apply -p0 (or -p1 for a/ b/ paths).\n    Prefer surgical changes: input validation, safe APIs, parameterized queries, permission checks.\n    Do NOT refactor broadly or change unrelated code.\n\n    RULES (must follow exactly):\n    PRINT ONLY the diff between the markers below.\n    Use repo-relative paths; diff --git a/path b/path headers are accepted.\n    No binary file changes. No prose/explanations outside the markers.\n\n    MARKERS:\n    === BEGIN_UNIFIED_DIFF ===\n\n    === END_UNIFIED_DIFF ===\n\n    If no safe fix is possible without deeper changes, output an empty diff between the markers.\n\ncodex_resolution:\n  stage: remediation\n  rules:\n    if: '$OPENAI_API_KEY'\n      when: on_success\n    when: never\n  script:\n    set -euo pipefail\n    mkdir -p \"$PATCH_DIR\" artifacts\n\nDeps\n    apt-get update \u0026\u0026 apt-get install -y --no-install-recommends bash git jq curl ca-certificates\n    npm -g i @openai/codex@latest\n    git --version \u0026\u0026 codex --version || true\n\nRequire SAST report; no-op if missing\n    |\n      if [ ! -s \"${SAST_REPORT_PATH}\" ]; then\n        echo \"No SAST report found; remediation will no-op.\"\n        printf \"CODEX_CREATED_PATCHES=false\\n\" \u003e codex.env\n        exit 0\n      fi\n\nPull High/Critical items\n    jq -c '.vulnerabilities[]? | select((.severity|ascii_downcase)==\"high\" or (.severity|ascii_downcase)==\"critical\")' \"$SAST_REPORT_PATH\" \\\n        | nl -ba \u003e /tmp/hicrit.txt || true\n    |\n      if [ ! -s /tmp/hicrit.txt ]; then\n        echo \"No High/Critical vulnerabilities found. Nothing to fix.\"\n        printf \"CODEX_CREATED_PATCHES=false\\n\" \u003e codex.env\n        exit 0\n      fi\n\nGround Codex to actual repo files\n    FILE_LIST=\"$(git ls-files | sed 's/^/- /')\"\n\nIdentity for any local patch ops\n    git config user.name \"CI Codex Bot\"\n    git config user.email \"codex-bot@example.com\"\n\n    created=0\n\nLoop: build prompt (robust temp-file), run Codex, extract diff, validate\n    |\n      while IFS=$'\\t' read -r idx vuln_json; do\n        echo \"Processing vulnerability #$idx\"\n        echo \"$vuln_json\" \u003e \"/tmp/vuln-$idx.json\"\n\n        PROMPT_FILE=\"$(mktemp)\"\n        {\n          printf \"%s\\n\\n\" \"$CODEX_DIFF_PROMPT\"\n          printf \"VULNERABILITY_JSON:\\n \"$PROMPT_FILE\"\n\n        PER_FINDING_PROMPT=\"$(tr -d '\\r'  \"$CODEX_DIFF_RAW\"\n        set +o pipefail\n        codex exec --full-auto \"$PER_FINDING_PROMPT\" | tee -a \"$CODEX_DIFF_RAW\" \u003e/dev/null\n        RC=${PIPESTATUS[0]}\n        set -o pipefail\n        echo \"Codex (diff) exit code: ${RC}\"\n\n        OUT_PATCH=\"$PATCH_DIR/fix-$idx.patch\"\n        sed -E 's/\\x1B\\[[0-9;]*[A-Za-z]//g' \"$CODEX_DIFF_RAW\" \\\n          | tr -d '\\r' \\\n          | awk '\n              /^\\s=== BEGIN_UNIFIED_DIFF ===\\s$/ {grab=1; next}\n              /^\\s=== END_UNIFIED_DIFF ===\\s$/   {grab=0}\n              grab\n            ' \u003e \"$OUT_PATCH\"\n\n        if ! [ -s \"$OUT_PATCH\" ] || ! grep -qE '^\\s*diff --git ' \"$OUT_PATCH\"; then\n          echo \"  No usable diff produced for #$idx; skipping.\"\n          rm -f \"$OUT_PATCH\"\n          continue\n        fi\n\nValidate: accept -p0 (repo-relative) or -p1 (a/ b/ prefixes)\n        if git apply --check -p0 \"$OUT_PATCH\" || git apply --check -p1 \"$OUT_PATCH\"; then\n          echo \"  Patch validated → $OUT_PATCH\"\n          created=$((created+1))\n        else\n          echo \"  Patch failed to apply cleanly; removing.\"\n          rm -f \"$OUT_PATCH\"\n        fi\n      done  codex.env\n      else\n        printf \"CODEX_CREATED_PATCHES=false\\n\" \u003e codex.env\n      fi\n  artifacts:\n    when: always\n    paths:\n      codex_patches/\n      artifacts/codex-diff-raw.log\n    reports:\n      dotenv: codex.env\n    expire_in: 14 days\n\nRunning the CI/CD job with Codex CLI, we receive a Git patch that fixes the issues originally found by our security scanner:\n\n\ndiff --git a/routes/profileImageUrlUpload.ts b/routes/profileImageUrlUpload.ts\nindex 9b4a62d..c7f1a7e 100644\na/routes/profileImageUrlUpload.ts\n+++ b/routes/profileImageUrlUpload.ts\n@@ -5,17 +5,12 @@\n SPDX-License-Identifier: MIT\n */\n-import fs from 'node:fs'\n-import { Readable } from 'node:stream'\n-import { finished } from 'node:stream/promises'\nimport { type Request, type Response, type NextFunction } from 'express'\nimport * as security from '../lib/insecurity'\nimport { UserModel } from '../models/user'\n-import * as utils from '../lib/utils'\n-import logger from '../lib/logger'\nexport function profileImageUrlUpload () {\n  return async (req: Request, res: Response, next: NextFunction) =\u003e {\n    if (req.body.imageUrl !== undefined) {\n      const url = req.body.imageUrl\n      if (url.match(/(.)solve\\\\/challenges\\\\/server-side(.)/) !== null) req.app.locals.abused_ssrf_bug = true\n      const loggedInUser = security.authenticatedUsers.get(req.cookies.token)\n      if (loggedInUser) {\ntry {\nconst response = await fetch(url)\nif (!response.ok || !response.body) {\nthrow new Error('url returned a non-OK status code or an empty body')\n}\nconst ext = ['jpg', 'jpeg', 'png', 'svg', 'gif'].includes(url.split('.').slice(-1)[0].toLowerCase()) ? url.split('.').slice(-1)[0].toLowerCase() : 'jpg'\nconst fileStream = fs.createWriteStream(frontend/dist/frontend/assets/public/images/uploads/${loggedInUser.data.id}.${ext}, { flags: 'w' })\nawait finished(Readable.fromWeb(response.body as any).pipe(fileStream))\nawait UserModel.findByPk(loggedInUser.data.id).then(async (user: UserModel | null) =\u003e { return await user?.update({ profileImage: /assets/public/images/uploads/${loggedInUser.data.id}.${ext} }) }).catch((error: Error) =\u003e { next(error) })\n} catch (error) {\ntry {\nconst user = await UserModel.findByPk(loggedInUser.data.id)\nawait user?.update({ profileImage: url })\nlogger.warn(Error retrieving user profile image: ${utils.getErrorMessage(error)}; using image link directly)\n} catch (error) {\nnext(error)\nreturn\n}\n}\ntry {\nconst user = await UserModel.findByPk(loggedInUser.data.id)\nawait user?.update({ profileImage: url })\n} catch (error) {\nnext(error)\nreturn\n}\n      } else {\n        next(new Error('Blocked illegal activity by ' + req.socket.remoteAddress))\n        return\n\nUsing Codex CLI in GitLab CI/CD allows you to augment existing review processes so that your team can ship faster.\n\nComplementary**: Codex doesn’t replace scanners — it interprets their findings and accelerates fixes.\nActionable**: Reviewers see not just vulnerabilities, but prioritized steps to fix them.\nAutomated**: Patches are created directly in CI, ready for git apply or a remediation branch.\n\nIn this cookbook, we explored how Codex CLI can be embedded into GitLab CI/CD pipelines to make software delivery safer and more maintainable:\n\nCode Quality Reports**: Generate GitLab-compliant CodeClimate JSON so reasoning-based findings surface alongside lint, unit tests, and style checks.\n\nVulnerability Interpretation**: Take the raw output of SAST and other security scanners (gl-sast-report.json) and transform it into a prioritized, human-readable plan (security_priority.md) with deduplication, exploitability ranking, and actionable next steps.\n\nAutomated Remediation**: Extend the workflow by having Codex generate unified git diffs as .patch files. These patches are validated (git apply --check) and can be applied automatically to a new branch.\n\nTaken together, these patterns show how LLM-powered analysis complements—not replaces—traditional rule-based tools. Scanners remain the source of truth for detection, while Codex adds context awareness, prioritization, developer guidance, and even the ability to propose concrete fixes via MRs. GitLab’s schemas and APIs provide the structure to make these outputs predictable, actionable, and fully integrated into developer workflows.\n\nThe critical lesson is that good results require clear prompts, schema validation, and guardrails. JSON markers, severity whitelists, schema enforcement, and diff validation ensure outputs are usable.\n\nLooking forward, this pattern can be extended to unify all major scan types through a single Codex-powered remediation flow:\n\nDependency Scans** → consolidate CVEs across lockfiles, recommend upgrades, and auto-generate diffs bumping vulnerable versions.\nContainer/Image Scans** → flag outdated base images and propose Dockerfile updates.\nDAST Results** → highlight exploitable endpoints and patch routing/middleware for validation or access control.\n\nBy merging these into a single Codex-powered post-processing \\+ remediation pipeline, teams can get a consistent stream of actionable guidance, validated patches across all security domains.\n\nThe broader takeaway: with prompt engineering, schema validation, and integration into GitLab’s native MR workflow, LLMs evolve from “advisors” into first-class CI/CD agents — helping teams ship code that is not only functional, but also secure, maintainable, and automatically remediated where possible."])</script><script>self.__next_f.push([1,"25:T9796,"])</script><script>self.__next_f.push([1,"Today, we’re releasing gpt-realtime — our most capable speech-to-speech model yet in the API and announcing the general availability of the Realtime API.\n\nSpeech-to-speech systems are essential for enabling voice as a core AI interface. The new release enhances robustness and usability, giving enterprises the confidence to deploy mission-critical voice agents at scale.\n\n\nThe new gpt-realtime model delivers stronger instruction following, more reliable tool calling, noticeably better voice quality, and an overall smoother feel. These gains make it practical to move from chained approaches to true realtime experiences, cutting latency and producing responses that sound more natural and expressive.\n\nRealtime model benefits from different prompting techniques that wouldn't directly apply to text based models. This prompting guide starts with a suggested prompt skeleton, then walks through each part with practical tips, small patterns you can copy, and examples you can adapt to your use case.\nIterate relentlessly**: Small wording changes can make or break behavior.\n  Example: For unclear audio instruction, we swapped  “inaudible” → “unintelligible”  which improved noisy input handling.\nPrefer bullets over paragraphs**: Clear, short bullets outperform long paragraphs.\nGuide with examples**: The model strongly closely follows sample phrases.\nBe precise**: Ambiguity or conflicting instructions = degraded performance similar to GPT-5.\nControl language**: Pin output to a target language if you see unwanted language switching.\nReduce repetition**: Add a Variety rule to reduce robotic phrasing.\nUse capitalized text for emphasis**: Capitalizing key rules makes them stand out and easier for the model to follow.\nConvert non-text rules to text**: instead of writing \"IF x \u003e 3 THEN ESCALATE\", write, \"IF MORE THAN THREE FAILURES THEN ESCALATE\".\nOrganizing your prompt makes it easier for the model to understand context and stay consistent across turns. Also makes it easier for you to iterate and modify problematic sections.\nWhat it does**: Use clear, labeled sections in your system prompt so the model can find and follow them. Keep each section focused on one thing.\nHow to adapt**: Add domain-specific sections (e.g., Compliance, Brand Policy). Remove sections you don’t need (e.g., Reference Pronunciations if not struggling with pronunciation).\nExample\nThis section defines who the agent is and what “done” means. The examples show two different identities to demonstrate how tightly the model will adhere to role and objective when they’re explicit.\n\nWhen to use**: The model is not taking on the persona, role, or task scope you need.\nWhat it does**: Pins identity of the voice agent so that its responses are conditioned to that role description\nHow to adapt**: Modify the role based on your use case\nYou are french quebecois speaking customer service bot. Your task is to answer the user's question.\nThis is the audio from our old gpt-4o-realtime-preview-2025-06-03\nThis is the audio from our new GA model gpt-realtime\nYou are a high-energy game-show host guiding the caller to guess a secret number from 1 to 100 to win 1,000,000$.\nThis is the audio from our old gpt-4o-realtime-preview-2025-06-03\nThis is the audio from our new GA model gpt-realtime\nThe new realtime model is able to better enact the role.\nThe newer model snapshot is really great at following instructions to imitate a particular personality or tone. You can tailor the voice experience and delivery depending on what your use case expects.\n\nWhen to use**: Responses feel flat, overly verbose, or inconsistent across turns.\nWhat it does**: Sets voice, brevity, and pacing so replies sound natural and consistent.\nHow to adapt**: Tune warmth/formality and default length. For regulated domains, favor neutral precision. Add other subsections that are relevant to your use case.\nFriendly, calm and approachable expert customer service assistant.\n\nWarm, concise, confident, never fawning.\n\n2–3 sentences per turn.\nStart your response very happy\nMidway, change to sad\nAt the end change your mood to very angry\n\nThis is the audio from our new GA model gpt-realtime\nThe model is able to adhere to the complex instructions and switch from 3 emotions throughout the audio response.\nIn the Realtime API, the speed parameter changes playback rate, not how the model composes speech. To actually sound faster, add instructions that can guide the pacing.\n\nWhen to use**: Users want faster speaking voice; playback speed (with speed parameter) alone doesn’t fix speaking style.\nWhat it does**: Tunes speaking style (brevity, cadence) independent of client playback speed.\nHow to adapt**: Modify speed instruction to meet use case requirements.\nFriendly, calm and approachable expert customer service assistant.\n\nWarm, concise, confident, never fawning.\n\n2–3 sentences per turn.\n\nDeliver your audio response fast, but do not sound rushed.\nDo not modify the content of your response, only increase speaking speed for the same response.\nThis is the audio from our old gpt-4o-realtime-preview-2025-06-03 with speed instructions\nThis is the audio from our new GA model gpt-realtime with speed instructions\nThe audio for the new realtime model is noticeably faster in pace (without sounding too hurried!).\nLanguage constraints ensure the model consistently responds in the intended language, even in challenging conditions like background noise or multilingual inputs.\n\nWhen to use**: To prevent accidental language switching in multilingual or noisy environments.\nWhat it does**: Locks output to the chosen language to prevent accidental language changes.\nHow to adapt**: Switch “English” to your target language; or add more complex instructions based on your use case.\nFriendly, calm and approachable expert customer service assistant.\n\nWarm, concise, confident, never fawning.\n\n2–3 sentences per turn.\n\nThe conversation will be only in English.\nDo not respond in any other language even if the user asks.\nIf the user speaks another language, politely explain that support is limited to English.\nThis is the responses after applying the instruction using gpt-realtime\n\n\n\n\nYou are a friendly, knowledgeable voice tutor for French learners.\nYour goal is to help the user improve their French speaking and listening skills through engaging conversation and clear explanations.\nBalance immersive French practice with supportive English guidance to ensure understanding and progress.\n\nFriendly, calm and approachable expert customer service assistant.\n\nWarm, concise, confident, never fawning.\n\n2–3 sentences per turn.\n\nUse English when explaining grammar, vocabulary, or cultural context.\n\nSpeak in French when conducting practice, giving examples, or engaging in dialogue.\nThis is the responses after applying the instruction using gpt-realtime\n\n\n\n\nThe model is able to easily code switch from one language to another based on our custom instructions!\nThe realtime model can follow sample phrases closely to stay on-brand, but it may overuse them, making responses sound robotic or repetitive. Adding a repetition rule helps maintain variety while preserving clarity and brand voice.\n\nWhen to use**: Outputs recycle the same openings, fillers, or sentence patterns across turns or sessions.\nWhat it does**: Adds a variety constraint—discourages repeated phrases, nudges synonyms and alternate sentence structures, and keeps required terms intact.\nHow to adapt**: Tune strictness (e.g., “don’t reuse the same opener more than once every N turns”), whitelist must-keep phrases (legal/compliance/brand), and allow tighter phrasing where consistency matters.\nFriendly, calm and approachable expert customer service assistant.\n\nWarm, concise, confident, never fawning.\n\n2–3 sentences per turn.\n\nThe conversation will be only in English.\nDo not respond in any other language even if the user asks.\nIf the user speaks another language, politely explain that support is limited to English.\n\nDo not repeat the same sentence twice.\nVary your responses so it doesn't sound robotic.\nThis is the responses before applying the instruction using gpt-realtime. The model repeats the same confirmation Got it.\n\n\nThis is the responses after applying the instruction using gpt-realtime\n\n\n\n\nNow the model is able to vary its responses and confirmation and not sound robotic.\n\nThis section covers how to ensure the model pronounces important words, numbers, names, and terms correctly during spoken interactions.\n\nWhen to use**: Brand names, technical terms, or locations are often mispronounced.\nWhat it does**: Improves trust and clarity with phonetic hints.\nHow to adapt**: Keep to a short list; update as you hear errors.\nWhen voicing these words, use the respective pronunciations:\nPronounce “SQL” as “sequel.”\nPronounce “PostgreSQL” as “post-gress.”\nPronounce “Kyiv” as “KEE-iv.”\nPronounce \"Huawei\" as “HWAH-way”\nThis is the audio from our old gpt-4o-realtime-preview-2025-06-03 using the reference pronunciations.\n\nIt is unable to reliably pronounce SQL as \"sequel\" as instructed in the system prompt.\nThis is the audio from our new GA model gpt-realtime using the reference pronunciations.\n\nIt is able to correctly pronounce SQL as \"sequel\".\nRealtime S2S can blur or merge digits/letters when reading back key info (phone, credit card, order IDs). Explicit character-by-character confirmation prevents mishearing and drives clearer synthesis.\n\nWhen to use**: If the model is struggling capturing or reading back phone numbers, card numbers, 2FA codes, order IDs, serials, addresses/unit numbers, or mixed alphanumeric strings.\nWhat it does**: Forces the model to speak one character at a time (with separators), then confirms with the user and re-confirm after corrections. Optionally uses a phonetic disambiguator for letters (e.g., “A as in Alpha”).\nWhen reading numbers or codes, speak each character separately, separated by hyphens (e.g., 4-1-5).\nRepeat EXACTLY the provided number, do not forget any.\nTip: If you are following a conversation flow prompting strategy, you can specify which conversation state needs to apply the alpha-numeric pronunciations instruction.\n\n(taken from the conversation flow of the prompt of our openai-realtime-agents)\n\n{\n    \"id\": \"3_get_and_verify_phone\",\n    \"description\": \"Request phone number and verify by repeating it back.\",\n    \"instructions\": [\n      \"Politely request the user’s phone number.\",\n      \"Once provided, confirm it by repeating each digit and ask if it’s correct.\",\n      \"If the user corrects you, confirm AGAIN to make sure you understand.\",\n    ],\n    \"examples\": [\n      \"I'll need some more information to access your account if that's okay. May I have your phone number, please?\",\n      \"You said 0-2-1-5-5-5-1-2-3-4, correct?\",\n      \"You said 4-5-6-7-8-9-0-1-2-3, correct?\"\n    ],\n    \"transitions\": [{\n      \"next_step\": \"4_authentication_DOB\",\n      \"condition\": \"Once phone number is confirmed\"\n    }]\n}\nThis is the responses before applying the instruction using gpt-realtime\nSure! The number is 55119765423. Let me know if you need anything else!\nThis is the responses after applying the instruction using gpt-realtime\nSure! The number is: 5-5-1-1-1-9-7-6-5-4-2-3. Please let me know if you need anything else!\nThis section covers prompt guidance around instructing your model to solve your task and potentially best practices and how to fix possible problems.\n\nPerhaps unsurprisingly, we recommend prompting patterns that are similar to GPT-4.1 for best results.\nLike GPT-4.1 and GPT-5, if the instructions are conflicting, ambiguous or not clear, the new realtime model will perform worse\n\nWhen to use**: Outputs drift from rules, skip phases, or misuse tools.\nWhat it does**: Uses an LLM to point out ambiguity, conflicts, and missing definitions before you ship.\n\n\nUse the following prompt with GPT-5 to identify problematic areas in your prompt that you can fix.\n\nYou are a Prompt-Critique Expert.\nExamine a user-supplied LLM prompt and surface any weaknesses following the instructions below.\n\n\nReview the prompt that is meant for an LLM to follow and identify the following issues:\nAmbiguity: Could any wording be interpreted in more than one way?\nLacking Definitions: Are there any class labels, terms, or concepts that are not defined that might be misinterpreted by an LLM?\nConflicting, missing, or vague instructions: Are directions incomplete or contradictory?\nUnstated assumptions: Does the prompt assume the model has to be able to do something that is not explicitly stated?\n\n\nInvent new instructions, tool calls, or external information. You do not know what tools need to be added that are missing.\nIssues that you are unsure about.\n\n\n\"\"\"\nNumbered list; include brief quote snippets.\n\nNumbered list; provide the revised lines you would change and how you would change them.\n\nRevised prompt where you have applied all your improvements surgically with minimal edits to the original prompt\n\"\"\"\n\nThis meta-prompt helps you improve your base system prompt by targeting a specific failure mode. Provide the current prompt and describe the issue you’re seeing, the model (GPT-5) will suggest refined variants that tighten constraints and reduce the problem.\n\nHere's my current prompt to an LLM:\n[BEGIN OF CURRENT PROMPT]\n{CURRENT_PROMPT}\n[END OF CURRENT PROMPT]\n\nBut I see this issue happening from the LLM:\n[BEGIN OF ISSUE]\n{ISSUE}\n[END OF ISSUE]\nCan you provide some variants of the prompt so that the model can better understand the constraints to alleviate the issue?\nSometimes the model thinks it hears something and tries to respond. You can add a custom instruction telling the model on how to behave when it hears unclear audio or user input. Modify the desire behaviour to fit your use case (maybe you don’t want the model to ask for a clarification, but to repeat the same question for example)\n\nWhen to use**: Background noise, partial words, or silence trigger unwanted replies.\nWhat it does**: Stops spurious responses and creates graceful clarification.\nHow to adapt**: Choose whether to ask for clarification or repeat the last question depending on use case.\n...\n\n\nAlways respond in the same language the user is speaking in, if unintelligible.\nOnly respond to clear audio or text.\nIf the user's audio is not clear (e.g. ambiguous input/background noise/silent/unintelligible) or if you did not fully hear or understand the user, ask for clarification using {preferred_language} phrases.\n\nThis is the responses after applying the instruction using gpt-realtime\nIn this example, the model asks for clarification after my (very) loud cough and unclear audio.\nOccasionally, the model may generate unintended background music, humming, rhythmic noises, or sound-like artifacts during speech generation. These artifacts can diminish clarity, distract users, or make the assistant feel less professional. The following instructions helps prevent or significantly reduce these occurrences.\n\nWhen to use**: Use when you observe unintended musical elements or sound effects in Realtime audio responses.\nWhat it does**: Steers the model to avoid generating these unwanted audio artifacts.s\nHow to adapt**: Adjust the instruction to try to explicitly suppress the specific sound patterns you are encountering.\n...\nDo not include any sound effects or onomatopoeic expressions in your responses.\nUse this section to tell the model how to use your functions and tools. Spell out when and when not to call a tool, which arguments to collect, what to say while a call is running, and how to handle errors or partial results.\nThe new Realtime snapshot is really good at instruction following. However, this means if you have conflicting instructions in your prompt to what the model is expecting, such as mentioning tools in your prompt NOT passed in the tools list, it can lead to bad responses.\n\nWhen to use**: Prompts mention tools that aren’t actually available.\nWhat it does**: Review available tools and system prompt to ensure it aligns\n...\n\n\n...\n\nWe need to ensure the tool list has the same availability tools and the descriptions do not contradict each other:\n\n[\n{\n    \"name\": \"lookup_account\",\n    \"description\": \"Retrieve a customer account using either an email or phone number to enable verification and account-specific actions.\",\n    \"parameters\": {\n      ...\n  },\n{\n    \"name\": \"check_outage\",\n    \"description\": \"Check for network outages affecting a given service address and return status and ETA if applicable.\",\n    \"parameters\": {\n      ...\n  }\n]\nSome use cases could benefit from the Realtime model providing an audio response at the same time as calling a tool. This leads to a better user experience, masking latency. You can modify the sample phrase to provide.\n\n\nWhen to use**:  Users need immediate confirmation at the same time of a tool call; helps mask latency.\nWhat it does**: Adds a short, consistent preamble before a tool call.\nBefore any tool call, say one short line like “I’m checking that now.” Then call the tool immediately.\nThis is the responses after applying the instruction using gpt-realtime\n\n\n\nUsing the instruction, the model outputs an audio response \"I'm checking that right now\" at the same time as the tool call.\nIf you want to control more closely what type of phrases the model outputs at the same time it calls a tool, you can add sample phrases in the tool spec description.\ntools = [\n  {\n    \"name\": \"lookup_account\",\n    \"description\": \"Retrieve a customer account using either an email or phone number to enable verification and account-specific actions.\n\nPreamble sample phrases:\nFor security, I’ll pull up your account using the email on file.\nLet me look up your account by {email} now.\nI’m fetching the account linked to {phone} to verify access.\nOne moment—I’m opening your account details.\"\n    \"parameters\": {\n      \"...\"\n    }\n  },\n  {\n    \"name\": \"check_outage\",\n    \"description\": \"Check for network outages affecting a given service address and return status and ETA if applicable.\n\nPreamble sample phrases:\nI’ll check for any outages at {service_address} right now.\nLet me look up network status for your area.\nI’m checking whether there’s an active outage impacting your address.\nOne sec—verifying service status and any posted ETA.\",\n    \"parameters\": {\n      \"...\"\n    }\n  }\n]\n\nSometimes the model might ask for confirmation before a tool call. For some use cases, this can lead to poor experience for the end user since the model is not being proactive.\n\nWhen to use**:  The agent asks for permission before obvious tool calls.\nWhat it does**:  Removes unnecessary confirmation loops.\nWhen calling a tool, do not ask for any user confirmation. Be proactive\nThis is the responses after applying the instruction using gpt-realtime\n\n\n\nIn the example, you notice that the realtime model did not produce any response audio, it directly called the respective tool.\nTip: If you notice the model is jumping too quickly to call a tool, try softening the wording. For example, swapping out stronger terms like “proactive” with something gentler can help guide the model to take a calmer, less eager approach.\nAs use cases grow more complex and the number of available tools increases, it becomes critical to explicitly guide the model on when to use each tool and just as importantly, when not to. Clear usage rules not only improve tool call accuracy but also help the model choose the right tool at the right time.\n\nWhen to use**: Model is struggling with tool call performance and needs the instructions to be explicit to reduce misuse.\nWhat it does**: Add instructions on when to “use/avoid” each tool. You can also add instructions on sequences of tool calls (after Tool call A, you can call Tool call B or C)\nWhen you call any tools, you must output at the same time a response letting the user know that you are calling the tool.\n\nUse when: verifying identity or viewing plan/outage flags.\nDo NOT use when: the user is clearly anonymous and only asks general questions.\n\n\nUse when: user reports connectivity issues or slow speeds.\nDo NOT use when: question is billing-only.\n\n\nUse when: confirmed outage \u003e 240 minutes in the past 7 days.\nDo NOT use when: outage is unconfirmed; route to Diagnose → check_outage first.\n\n\nUse when: repeated failures after reboot and outage status = false.\nDo NOT use when: outage status = true (send status + ETA instead).\n\n\nUse when: user seems very frustrated, abuse/harassment, repeated failures, billing disputes \u003e$50, or user requests escalation.\nTip: If a tool call can fail unpredictably, add clear failure-handling instructions so the model responds gracefully.\nYou can fine-tune how the model behaves for specific tools instead of applying one global rule. For example, you may want READ tools to be called proactively, while WRITE tools require explicit confirmation.\n\nWhen to use**:  Global instructions for proactiveness, confirmation, or preambles don’t suit every tool.\nWhat it does**: Adds per-tool behavior rules that define whether the model should call the tool immediately, confirm first, or speak a preamble before the call.\nFor the tools marked PROACTIVE: do not ask for confirmation from the user and do not output a preamble.\nFor the tools marked as CONFIRMATION FIRST: always ask for confirmation to the user.\nFor the tools marked as PREAMBLES: Before any tool call, say one short line like “I’m checking that now.” Then call the tool immediately.\n\n\nUse when: verifying identity or accessing billing.\nDo NOT use when: caller refuses to identify after second request.\n\n\nUse when: caller reports failed connection or speed lower than 10 Mbps.\nDo NOT use when: purely billing OR when internet speed is above 10 Mbps.\nIf either condition applies, inform the customer you cannot assist and hang up.\n\n\nUse when: confirmed outage \u003e 240 minutes in the past 7 days (credit 60 minutes).\nDo NOT use when: outage unconfirmed.\nConfirmation phrase: “I can issue a credit for this outage—would you like me to go ahead?”\n\n\nUse when: reboot + line checks fail AND outage=false.\nWindows: “10am–12pm ET” or “2pm–4pm ET”.\nConfirmation phrase: “I can schedule a technician to visit—should I book that for you?”\n\n\nUse when: harassment, threats, self-harm, repeated failure, billing disputes \u003e $50, caller is frustrated, or caller requests escalation.\nPreamble: “Let me connect you to a senior agent who can assist further.”\nIn many voice setups, the realtime model acts as the responder (speaks to the user) while a stronger text model acts as the thinker (does planning, policy lookups, SOP completion). Text replies are not automatically good for speech, so the responder must rephrase the thinker’s text into an audio-friendly response before generating audio.\n\n\nWhen to use**: When the responder’s spoken output sounds robotic, too long, or awkward after receiving a thinker response.\nWhat it does**: Adds clear instructions that guide the responder to rephrase the thinker’s text into a short, natural, speech-first reply.\nHow to adapt**: Tweak phrasing style, openers, and brevity limits to match your use case expectation.\nName: getNextResponseFromSupervisor(relevantContextFromLastUserMessage: string)\n\n\nWhen to call:\nAny request outside the allow list.\nAny factual, policy, account, or process question.\nAny action that might require internal lookups or system changes.\n\n\nWhen not to call:\nSimple greetings and basic chitchat.\nRequests to repeat or clarify.\nCollecting parameters for later Supervisor use:\n  phone_number for account help (getUserAccountInfo)\n  zip_code for store lookup (findNearestStore)\n  topic or keyword for policy lookup (lookupPolicyDocument)\n\n\nUsage rules and preamble:\n1) Say a neutral filler phrase to the user, then immediately call the tool. Approved fillers: “One moment.”, “Let me check.”, “Just a second.”, “Give me a moment.”, “Let me see.”, “Let me look into that.” Fillers must not imply success or failure.\n2) Do not mention the “Supervisor” when responding with filler phrase.\n3) relevantContextFromLastUserMessage is a one-line summary of the latest user message; use an empty string if nothing salient.\n4) After the tool returns, apply Rephrase Supervisor and send your reply.\n\n\nStart with a brief conversational opener using active language, then flow into the answer (for example: “Thanks for waiting—”, “Just finished checking that.”, “I’ve got that pulled up now.”).\nKeep it short: no more than 2 sentences.\nUse this template: opener + one-sentence gist + up to 3 key details + a quick confirmation or choice (for example: “Does that match what you expected?”, “Want me to review options?”).\nRead numbers for speech: money naturally (“$45.20” → “forty-five dollars and twenty cents”), phone numbers 3-3-4, addresses with individual digits, dates/times plainly (“August twelfth”, “three-thirty p.m.”).\nHere’s an example without the rephrasing instruction:\nAssistant: Your current credit card balance is positive at 32,323,232 AUD.\nHere’s the same example with the rephrasing instruction:\nAssistant: Just finished checking that—your credit card balance is thirty-two million three hundred twenty-three thousand two hundred thirty-two dollars in your favor. Your last payment was processed on August first. Does that match what you expected?\nThe new model snapshot has been trained to effectively use the following common tools. If your use case needs similar behavior, keep the names, signatures, and descriptions close to these to maximize reliability and to be more in-distribution.\n\nBelow are some of the important common tools that the model has been trained on:\nDescription: Call this when the customer asks a question that you don't have an answer to or asks to perform an action.\n\n\nDescription: Call this when a customer asks for escalation, or to talk to someone else, or expresses dissatisfaction with the call.\n\n\nDescription: Call this when a customer says they're done with the session or doesn't want to continue. If it's ambiguous, confirm with the customer before calling.\nThis section covers how to structure the dialogue into clear, goal-driven phases so the model knows exactly what to do at each step. It defines the purpose of each phase, the instructions for moving through it, and the concrete “exit criteria” for transitioning to the next. This prevents the model from stalling, skipping steps, or jumping ahead, and ensures the conversation stays organized from greeting to resolution.\n\nAs well, by organizing your prompt into various conversation states, it becomes easier to identify error modes and iterate more effectively.\n\nWhen to use**: If conversations feel disorganized, stall before reaching the goal or model struggling to effectively complete the objective.\nWhat it does**: Breaks the interaction into phases with clear goals, instructions and exit criteria.\nHow to adapt**: Rename phases to match your workflow; Modify instructions for each phase to follow your intended behaviour;  keep “Exit when” concrete and minimal.\nGoal: Set tone and invite the reason for calling.\nHow to respond:\nIdentify as NorthLoop Internet Support.\nKeep the opener brief and invite the caller’s goal.\nConfirm that customer is a Northloop customer\nExit to Discovery: Caller states they are a Northloop customer and mentions an initial goal or symptom.\n\n\nGoal: Classify the issue and capture minimal details.\nHow to respond:\nDetermine billing vs connectivity with one targeted question.\nFor connectivity: collect the service address.\nFor billing/account: collect email or phone used on the account.\nExit when: Intent and address (for connectivity) or email/phone (for billing) are known.\n\n\nGoal: Confirm identity and retrieve the account.\nHow to respond:\nOnce you have email or phone, call lookup_account(email_or_phone).\nIf lookup fails, try the alternate identifier once; otherwise proceed with general guidance or offer escalation if account actions are required.\nExit when: Account ID is returned.\n\n\nGoal: Decide outage vs local issue.\nHow to respond:\nFor connectivity, call check_outage(address).\nIf outage=true, skip local steps; move to Resolve with outage context.\nIf outage=false, guide a short reboot/cabling check; confirm each step’s result before continuing.\nExit when: Root cause known.\n\n\nGoal: Apply fix, credit, or appointment.\nHow to respond:\nIf confirmed outage \u003e 240 minutes in the last 7 days, call refund_credit(account_id, 60).\nIf outage=false and issue persists after basic checks, offer “10am–12pm ET” or “2pm–4pm ET” and call schedule_technician(account_id, chosen window).\nIf the local fix worked, state the result and next steps briefly.\nExit when: A fix/credit/appointment has been applied and acknowledged by the caller.\n\n\nGoal: Confirm outcome and end cleanly.\nHow to respond:\nRestate the result and any next step (e.g., stabilization window or tech ETA).\nInvite final questions; close politely if none.\nExit when: Caller declines more help.\nSample phrases act as “anchor examples” for the model. They show the style, brevity, and tone you want it to follow, without locking it into one rigid response.\n\nWhen to use**: Responses lack your brand style or are not consistent.\nWhat it does**: Provides sample phrases the model can vary to stay natural and brief.\nHow to adapt**: Swap examples for brand-fit; keep the “do not always use” warning.\nBelow are sample examples that you should use for inspiration. DO NOT ALWAYS USE THESE EXAMPLES, VARY YOUR RESPONSES.\n\nAcknowledgements: “On it.” “One moment.” “Good question.”\nClarifiers: “Do you want A or B?” “What’s the deadline?”\nBridges: “Here’s the quick plan.” “Let’s keep it simple.”\nEmpathy (brief): “That’s frustrating—let’s fix it.”\nClosers: “Anything else before we wrap?” “Happy to help next time.”\nNote: If your voice system ends up consistently only repeating the sample phrases, leading to a more robotic voice experience, try adding the Variety constraint. We’ve seen this fix the issue.\nIt is an useful pattern to add sample phrases in the different conversation flow states to teach the model how a good response looks like:\n\nGoal: Set tone and invite the reason for calling.\nHow to respond:\nIdentify as NorthLoop Internet Support.\nKeep the opener brief and invite the caller’s goal.\nSample phrases (do not always repeat the same phrases, vary your responses):\n“Thanks for calling NorthLoop Internet—how can I help today?”\n“You’ve reached NorthLoop Support. What’s going on with your service?”\n“Hi there—tell me what you’d like help with.”\nExit when: Caller states an initial goal or symptom.\n\n\nGoal: Classify the issue and capture minimal details.\nHow to respond:\nDetermine billing vs connectivity with one targeted question.\nFor connectivity: collect the service address.\nFor billing/account: collect email or phone used on the account.\nSample phrases (do not always repeat the same phrases, vary your responses):\n“Is this about your bill or your internet speed?”\n“What address are you using for the connection?”\n“What’s the email or phone number on the account?”\nExit when: Intent and address (for connectivity) or email/phone (for billing) are known.\n\n\nGoal: Confirm identity and retrieve the account.\nHow to respond:\nOnce you have email or phone, call lookup_account(email_or_phone).\nIf lookup fails, try the alternate identifier once; otherwise proceed with general guidance or offer escalation if account actions are required.\nSample phrases:\n“Thanks—looking up your account now.”\n“If that doesn’t pull up, what’s the other contact—email or phone?”\n“Found your account. I’ll take care of this.”\nExit when: Account ID is returned.\n\n\nGoal: Decide outage vs local issue.\nHow to respond:\nFor connectivity, call check_outage(address).\nIf outage=true, skip local steps; move to Resolve with outage context.\nIf outage=false, guide a short reboot/cabling check; confirm each step’s result before continuing.\nSample phrases (do not always repeat the same phrases, vary your responses):\n“I’m running a quick outage check for your area.”\n“No outage reported—let’s try a fast modem reboot.”\n“Please confirm the modem lights: is the internet light solid or blinking?”\nExit when: Root cause known.\n\n\nGoal: Apply fix, credit, or appointment.\nHow to respond:\nIf confirmed outage \u003e 240 minutes in the last 7 days, call refund_credit(account_id, 60).\nIf outage=false and issue persists after basic checks, offer “10am–12pm ET” or “2pm–4pm ET” and call schedule_technician(account_id, chosen window).\nIf the local fix worked, state the result and next steps briefly.\nSample phrases (do not always repeat the same phrases, vary your responses):\n“There’s been an extended outage—adding a 60-minute bill credit now.”\n“No outage—let’s book a technician. I can do 10am–12pm ET or 2pm–4pm ET.”\n“Credit applied—you’ll see it on your next bill.”\nExit when: A fix/credit/appointment has been applied and acknowledged by the caller.\n\n\nGoal: Confirm outcome and end cleanly.\nHow to respond:\nRestate the result and any next step (e.g., stabilization window or tech ETA).\nInvite final questions; close politely if none.\nSample phrases (do not always repeat the same phrases, vary your responses):\n“We’re all set: [credit applied / appointment booked / service restored].”\n“You should see stable speeds within a few minutes.”\n“Your technician window is 10am–12pm ET.”\nExit when: Caller declines more help.\n\n\nAs use cases grow more complex, you’ll need a structure that scales while keeping the model effective. The key is balancing maintainability with simplicity: too many rigid states can overload the model, hurting performance and making conversations feel robotic.\n\nA better approach is to design flows that reduce the model’s perceived complexity. By handling state in a structured but flexible way, you make it easier for the model to stay focused and responsive, which improves user experience.\n\nTwo common patterns for managing complex scenarios are:\nConversation Flow as State Machine\nDynamic Conversation Flow via session.updates\n\nDefine your conversation as a JSON structure that encodes both states and transitions. This makes it easy to reason about coverage, identify edge cases, and track changes over time. Since it’s stored as code, you can version, diff, and extend it as your flow evolves. A state machine also gives you fine-grained control over exactly how and when the conversation moves from one state to another.\n[\n  {\n    \"id\": \"1_greeting\",\n    \"description\": \"Begin each conversation with a warm, friendly greeting, identifying the service and offering help.\",\n    \"instructions\": [\n        \"Use the company name 'Snowy Peak Boards' and provide a warm welcome.\",\n        \"Let them know upfront that for any account-specific assistance, you’ll need some verification details.\"\n    ],\n    \"examples\": [\n      \"Hello, this is Snowy Peak Boards. Thanks for reaching out! How can I help you today?\"\n    ],\n    \"transitions\": [{\n      \"next_step\": \"2_get_first_name\",\n      \"condition\": \"Once greeting is complete.\"\n    }, {\n      \"next_step\": \"3_get_and_verify_phone\",\n      \"condition\": \"If the user provides their first name.\"\n    }]\n  },\n  {\n    \"id\": \"2_get_first_name\",\n    \"description\": \"Ask for the user’s name (first name only).\",\n    \"instructions\": [\n      \"Politely ask, 'Who do I have the pleasure of speaking with?'\",\n      \"Do NOT verify or spell back the name; just accept it.\"\n    ],\n    \"examples\": [\n      \"Who do I have the pleasure of speaking with?\"\n    ],\n    \"transitions\": [{\n      \"next_step\": \"3_get_and_verify_phone\",\n      \"condition\": \"Once name is obtained, OR name is already provided.\"\n    }]\n  },\n  {\n    \"id\": \"3_get_and_verify_phone\",\n    \"description\": \"Request phone number and verify by repeating it back.\",\n    \"instructions\": [\n      \"Politely request the user’s phone number.\",\n      \"Once provided, confirm it by repeating each digit and ask if it’s correct.\",\n      \"If the user corrects you, confirm AGAIN to make sure you understand.\",\n    ],\n    \"examples\": [\n      \"I'll need some more information to access your account if that's okay. May I have your phone number, please?\",\n      \"You said 0-2-1-5-5-5-1-2-3-4, correct?\",\n      \"You said 4-5-6-7-8-9-0-1-2-3, correct?\"\n    ],\n    \"transitions\": [{\n      \"next_step\": \"4_authentication_DOB\",\n      \"condition\": \"Once phone number is confirmed\"\n    }]\n  },\n...\nIn this pattern, the conversation adapts in real time by updating the system prompt and tool list based on the current state. Instead of exposing the model to all possible rules and tools at once, you only provide what’s relevant to the active phase of the conversation.\n\nWhen the end conditions for a state are met, you use session.update to transition, replacing the prompt and tools with those needed for the next phase.\n\nThis approach reduces the model’s cognitive load, making it easier for it to handle complex tasks without being distracted by unnecessary context.\n\nOften with Realtime voice agents, having a reliable way to escalate to a human is important. In this section, you should modify the instructions on WHEN to escalate depending on your use case.\n\nWhen to use**: Model is struggling in determining when to properly escalate to a human or fallback system\nWhat it does**: Defines fast, reliable escalation and what to say.\nHow to adapt**: Insert your own thresholds and what the model has to say.\nWhen to escalate (no extra troubleshooting):\nSafety risk (self-harm, threats, harassment)\nUser explicitly asks for a human\nSevere dissatisfaction (e.g., “extremely frustrated,” repeated complaints, profanity)\n2* failed tool attempts on the same task *or* *3** consecutive no-match/no-input events\nOut-of-scope or restricted (e.g., real-time news, financial/legal/medical advice)\n\nWhat to say at the same time of calling the escalate_to_human tool (MANDATORY):\n“Thanks for your patience—I’m connecting you with a specialist now.”\nThen call the tool: escalate_to_human\n\nExamples that would require escalation:\n“This is the third time the reset didn’t work. Just get me a person.”\n“I am extremely frustrated!”\nThis is the conversation responses from our old snapshot model gpt-4o-realtime-preview-2025-06-03 using the instruction.\n\n\nThis is the conversation responses from our new GA model gpt-realtime using the instruction.\n\n\n\nThe new realtime model is able to better follow the instruction and escalate to a human more reliably."])</script><script>self.__next_f.push([1,"26:T24ab,"])</script><script>self.__next_f.push([1,"이 노트북은 OpenAI의  gpt-oss (open‑weight) 모델을 한국 뉴스 문체 + 최신 대화체로 세밀 튜닝하는 방법을\n한국어/영어 이중 언어로 제공합니다.\nThis notebook shows how to fine‑tune OpenAI's gpt-oss (open‑weight) models for Korean news style + modern chat tone, in Korean \u0026 English.\n\nEN:\nTraining or fine-tuning directly in MXFP4 is not supported by public frameworks today.\nRecommended path: train in BF16 (or QLoRA 4‑bit nf4) → merge LoRA → post‑training quantize to MXFP4 → save_pretrained() for deployment.\nIf you need an MXFP4 artifact, you must re‑quantize from BF16 after merging adapters. (Export utilities are evolving; if your toolchain already supports MXFP4 serialization, that’s ideal.)\n\nKR:\n현재 공개 프레임워크에서는 MXFP4로 직접 학습/파인튜닝이 지원되지 않습니다.\n권장 경로: BF16(또는 QLoRA 4‑bit nf4)로 학습 → LoRA 병합 → 사후(MXFP4) 양자화 → 배포용으로 save_pretrained() 저장.\nMXFP4 아티팩트가 필요하면, 어댑터 병합 후 BF16 → MXFP4 재양자화가 필요합니다. (직렬화 유틸은 진화 중이며, 툴체인에서 MXFP4 저장을 지원하면 가장 좋습니다.)\n\nEN:\nMinimal config (fast, low VRAM): target attention only, e.g. [\"q_proj\",\"v_proj\"].\nMoE‑aware config (better domain adaptation, more VRAM/time): include expert projection layers in addition to attention.\n\nfrom peft import LoraConfig\n\nTARGET_MODULES = [\"q_proj\", \"v_proj\"]  # baseline\nMOE_TARGET_PARAMETERS = [\nexample expert layers; adjust indices to your model depth\n    \"mlp.experts.gate_up_proj\",\n    \"mlp.experts.down_proj\",\n]\n\nlora_cfg = LoraConfig(\n    r=16, lora_alpha=32, lora_dropout=0.05,\n    target_modules=\"all-linear\",              # cover all linear layers\n    target_parameters=MOE_TARGET_PARAMETERS,  # add expert projections\n    bias=\"none\", task_type=\"CAUSAL_LM\",\n)\n\nStart with attention‑only; if KR domain fit is insufficient, enable MoE targets and re‑eval.\n\nKR:\n최소 구성(빠르고 VRAM 절약): [\"q_proj\",\"v_proj\"] 등 어텐션만 적용.\nMoE 인지 구성(도메인 적합성↑, 자원 소모↑): 어텐션에 **전문가(Expert) 투영 레이어를 추가로 포함.\n먼저 어텐션만으로 시도한 뒤, 한국어 도메인 적합성이 부족하면 MoE 타깃을 켜고 재평가하세요.\n0) Goals \u0026 Scope · 목표 \u0026 범위\n1) Environment check · 환경 점검\n2) 설정값 · Config\n3) 패키지 설치 · Install Deps\n4) 데이터 소싱(한국형) · KR‑Context Data Sourcing\n5) 샘플 데이터 생성 · Create Sample Data\n6) 전처리(PIPA) \u0026 스타일 라벨 · PII Scrubbing \u0026 Style Tags\n7) 데이터 로딩/포맷팅 · Load \u0026 Format\n8) 모델/토크나이저 로드 · Load Model \u0026 Tokenizer\n9) Fine‑Tuning (LoRA/QLoRA) · 세밀 튜닝\n   9a) Data curation \u0026 splits\n   9b) Hyperparameters (r/alpha/dropout)\n   9c) Merge adapters (BF16)\n   9d) Save merged BF16 (save_pretrained)\n   9e) Export \u0026 Quantize (BF16 → MXFP4) · 내보내기 \u0026 양자화\n10) 평가(뉴스/대화) · Evaluation (News/Chat)\n11) Inference Prompt Templates · 추론 프롬프트 템플릿\n12) 최신성 유지 · Freshness Strategy\n13) 안전/컴플라이언스 · Safety \u0026 Compliance\n14) 문제해결 \u0026 다음 단계 · Troubleshooting \u0026 Next Steps\n\nDo:** Train with BF16/FP16 or QLoRA; export merged weights.\nThen:* Quantize to *MXFP4** for inference using provided conversion scripts/utilities.\nDon’t:** Attempt to run an end‑to‑end “train in MXFP4” pipeline — not supported today.\nPII \u0026 Compliance Reminder: For KR data, follow your enterprise policy (mask RRN/phone/account IDs, remove emails) before training \u0026 logging. Keep train/val/test splits stratified by source and style tags.\nYou can target MoE layers with adapters, but treat this as advanced/experimental. Start with attention projections first and validate KR benchmarks before expanding scope.\nNote: Keep transformers, peft, accelerate, and trl at versions known to support BF16/4‑bit LoRA.\nIf you pin safetensors, remember that native MXFP4 serialization is not yet standardized; loaders may upcast internally.\nFine‑tuning precision:* BF16/FP16 ✅ · QLoRA 4‑bit ✅ · *MXFP4 FT ❌**\nQuantization target:** MXFP4 ✅ (post‑training)\nAPI FT (hosted) for OSS models:** ❌\nOpen‑source FT (Transformers/TRL/PEFT):** ✅\nLoRA targets:* q_proj, k_proj, v_proj, o_proj ✅; MoE expert adapters *experimental** ⚠️\nKR**: 한국어 일반 뉴스 + 일상/상담 대화체에 최적화. style=news_headline|news_lead|news_body|kakao_casual|kakao_formal 제어.\nEN**: Optimize for Korean news writing and modern chat tone; control output via style tags above.\nStack**: transformers, trl(SFTTrainer), peft(LoRA/QLoRA), datasets.\nHardware**: Single/few GPUs (BF16 preferred). CPU/Mac for lightweight tests.\nKR\n공개 벤치마크(주제 분류/요약/QA) + 허용된 뉴스 API의 메타데이터(제목/요약/섹션) 중심으로 스타일 보정.\n기사 원문 대량 재학습은 저작권/약관 이슈 → 메타데이터·공개 코퍼스 위주.\n대화체는 합법 공개 코퍼스(반말/존댓말/이모티콘/축약어 라벨 포함) 우선.\nPIPA: 주민번호/연락처/이메일/계좌 등 개인정보는 훈련 전/로그 전 스크러빙.\n\nEN\nPrefer public KR benchmarks (topic classification / summarization / QA) and allowed news API metadata for style calibration.\nAvoid mass training on news full texts due to license/ToS constraints; use metadata + open corpora.\nFor chat, use lawful open corpora with tone/emoji/informal‑formal annotations.\nScrub PII (phone, RRNs, emails, accounts) before training/logging.\n(See Section 7/8 for dataset prep; move relevant snippets here if needed.)\nLORA_R = 8\nLORA_ALPHA = 16\nLORA_DROPOUT = 0.05\n\n\n\n\nEN (neutral, framework-agnostic):\nPublic libraries currently do not support training/fine‑tuning directly in MXFP4. The common pipeline is:\n1) Train/SFT in BF16 (or QLoRA 4‑bit nf4).\n2) Merge LoRA adapters into the base model (BF16).\n3) Save the merged BF16 checkpoint with save_pretrained().\n4) Post‑training quantize the merged BF16 tensors to MXFP4 using a vendor/toolchain‑provided packer.\n5) Save/export the MXFP4 artifact (same shape as Hugging Face save_pretrained() output) for deployment/serving.\nNotes:\n- If your serving stack supports LoRA at inference, you may skip merging and quantization and ship: base (MXFP4 or BF16) + LoRA adapters.\n- If your runtime requires merged MXFP4, you must run a BF16 → MXFP4 quantization step after merging adapters.\n- Keep tokenizer/config files aligned across BF16 and MXFP4 exports.\n\nKR (중립적, 도구 비의존):\n현재 공개 라이브러리는 MXFP4에서 직접 학습/파인튜닝을 지원하지 않습니다. 일반적인 파이프라인은 다음과 같습니다:\n1) BF16(또는 QLoRA 4‑bit nf4)로 학습/파인튜닝\n2) LoRA 어댑터 병합(BF16 기준)\n3) save_pretrained()로 병합된 BF16 체크포인트 저장\n4) 벤더/툴체인에서 제공하는 양자화 도구로 BF16 → MXFP4 사후 양자화\n5) 배포/서빙용 MXFP4 아티팩트 저장/내보내기 (Hugging Face save_pretrained() 구조와 동일)\n참고:\n- 서빙에서 LoRA를 지원한다면, 병합·양자화를 생략하고 기저( MXFP4 또는 BF16 ) + LoRA 어댑터로 제공할 수 있습니다.\n- 병합된 MXFP4가 필요한 런타임의 경우, 어댑터 병합 후 BF16 → MXFP4 재양자화 단계가 필요합니다.\n- tokenizer/config 파일은 BF16과 MXFP4 아티팩트 간에 일관되게 유지하세요.\n\nKR 지표 · KR Metrics\n뉴스성: 주제 분류 적합도(F1), 요약 품질(ROUGE‑1/2/L), 독해 QA(EM/F1).\n대화성: 자연성/맥락 유지, 경어/반말 전환 정확도, 이모티콘/축약어 적절성.\n\nEN Notes\nUse public KR benchmarks (e.g., topic classification, KorQuAD‑like QA) where licenses permit.\nMix automatic metrics (F1/ROUGE) with human eval for tone \u0026 politeness.\n주간 보정 SFT: 허용된 뉴스 API **메타데이터(제목/요약/섹션) 샘플링 → 스타일 보정.\n대화체 업데이트**: 최신 축약어/신조어/이모티콘 사전 반영(예: ㄱㄱ, ㅇㅋ, ㅋㅋ, ㄹㅇ).\n회귀 평가**: 동일 지표로 before/after 비교 → 혼합비/온도/패널티 튜닝.\n\nWeekly calibration SFT using allowed news API metadata for style;\nUpdate slang/emoji lexicons;\nRegression evals to track drift and adjust data mix/decoding.\n데이터 출처/라이선스 확인(벤치마크, API, 내부 데이터) · Verify dataset/API licenses.\n개인정보 스크러빙(훈련/로그/평가 전) · Scrub PII before training/logging/eval.\n저작권/약관 준수(기사 원문 대량 재학습 금지) · Avoid mass training on full news articles.\n출력 검증(스키마/금칙어/민감도 규칙) · Output validation \u0026 forbidden‑term filters.\n버전/평가 리포트 관리 · Version datasets/models and keep eval reports.\n혼합 비율 튜닝: (뉴스:대화) 6:4 → 7:3 또는 5:5로 조정\nLoRA 하이퍼파라미터: r=816, α=1632, dropout=0.05~0.1\n서비스화: vLLM/llama.cpp 서빙 + 토픽/스타일 라우팅\nRAG 결합: 최신 사실성 보강을 위해 뉴스/문서 인덱스 결합\nA/B 테스트: 톤/길이/이모티콘 사용량 등 사용자 만족도 측정\n\nTune mix ratios, run A/B tests, consider vLLM serving, and pair with RAG for factuality."])</script><script>self.__next_f.push([1,"27:T1af1,"])</script><script>self.__next_f.push([1,"The OpenAI gpt-oss models are introducing a lot of new concepts to the open-model ecosystem and getting them to perform as expected might take some time. This guide is meant to help developers building inference solutions to verify their implementations or for developers who want to test any provider’s implementation on their own to gain confidence.\n\n\nThe new models behave more similarly to some of our other OpenAI models than to existing open models. A couple of examples include:\n\nThe harmony response format. These models were trained on our OpenAI harmony format to structure a conversation. While regular API developers won’t need to deal with harmony in most cases, the inference providers that provide a Chat Completions-compatible, Responses-compatible or other inference API need to map the inputs correctly to the OpenAI harmony format. If the model does not receive the prompts in the right format this can have cascading generation issues and at minimum a worse function calling performance.\nHandling chain of thought (CoT) between tool calls. These models can perform tool calls as part of the CoT. A consequence of this is that the model needs to receive the CoT in subsequent sampling until it reaches a final response. This means that while the raw CoT should not be displayed to end-users, it should be returned by APIs so that developers can pass it back in along with the tool call and tool output. You can learn more about it in this separate guide.\nDifferences in actual inference code. We published our mixture-of-experts (MoE) weights exclusively in MXFP4 format. This is still a relatively new format and along with other architecture decisions, existing inference code that was written for other open-models will have to be adapted for gpt-oss models. For that reason we published both a basic (unoptimized) PyTorch implementation, and a more optimized Triton implementation. Additionally, we verified the vLLM implementation for correctness. We hope these can serve as educational material for other implementations.\n\n\n\nFor best performance we recommend inference providers to implement our Responses API format as the API shape was specifically designed for behaviors like outputting raw CoT along with summarized CoTs (to display to users) and tool calls without bolting additional properties onto a format. The most important\npart for accurate performance is to return the raw CoT as part of the output.\n\nFor this we added a new content array to the Responses API’s reasoning items. The raw CoT should be wrapped into reasoning_text type element, making the overall output item look the following:\n\n{\n  \"type\": \"reasoning\",\n  \"id\": \"item_67ccd2bf17f0819081ff3bb2cf6508e60bb6a6b452d3795b\",\n  \"status\": \"completed\",\n  \"summary\": [\n    /* optional summary elements */\n  ],\n  \"content\": [\n    {\n      \"type\": \"reasoning_text\",\n      \"text\": \"The user needs to know the weather, I will call the get_weather tool.\"\n    }\n  ]\n}\n\nThese items should be received in subsequent turns and then inserted back into the harmony formatted prompt as outlined in the raw CoT handling guide.\n\nCheck out the Responses API docs for the whole specification.\n\n\nA lot of providers are offering a Chat Completions-compatible API. While we have not augmented our published API reference on the docs to provide a way to receive raw CoT, it’s still important that providers that offer the gpt-oss models via a Chat Completions-compatible API return the CoT as part of their messages and for developers to have a way to pass them back.\n\nThere is currently no generally agreed upon specification in the community with the general properties on a message being either reasoning or reasoning_content. To be compatible with clients like the OpenAI Agents SDK we recommend using a reasoning field as the primary property for the raw CoT in Chat Completions.\n\n\nTo verify if a provider is working you can use the Node.js script published in our gpt-oss GitHub repository that you can also use to run other evals. You’ll need Node.js or a similar runtime installed to run the tests.\n\nThese tests will run a series of tool/function calling based requests to the Responses API or Chat Completions API you are trying to test. Afterwards they will evaluate both whether the right tool was called and whether the API shapes are correct.\n\nThis largely acts as a smoke test but should be a good indicator on whether the APIs are compatible with our SDKs and can handle basic function calling. It does not guarantee full accuracy of the inference implementation (see the evals section below for details on that) nor does it guarantee full compatibility with the OpenAI APIs. They should still be a helpful indicator of major implementation issues.\n\nTo run the test suite run the following commands:\n\ngit clone https://github.com/openai/gpt-oss.git\n\ncd gpt-oss/compatibility-test/\n\nnpm install\n\n\nnpm start -- --provider\n\nAfterwards you should receive a result of both the API implementation and any details on the function call performance.\n\nIf your tests are successful, the output should show 0 invalid requests and over 90% on both pass@k and pass^k. This means the implementation should likely be correct. To be fully sure, you should also inspect the evals as described below.\n\nIf you want a detailed view of the individual responses, you can the jsonl file that was created in your directory.\n\nYou can also enable debug mode to view any of the actual request payloads using DEBUG=openai-agents:openai npm start -- --provider  but it might get noisy. To run only one test use the -n 1 flag for easier debugging. For testing streaming events you can use --streaming.\n\n\nThe team at Artificial Analysis is running AIME and GPQA evals for a variety of providers. If you are unsure about your provider, check out Artificial Analysis for the most recent metrics.\n\nTo be on the safe side you should consider running evals yourself. To run your own evals, you can find in the same repository as the test above a gpt_oss/evals folder that contains the test harnesses that we used to verify the AIME (16 attempts per problem), GPQA (8 attempts per problem) and Healthbench (1 attempt per problem) evals for the vLLM implementation and some of our own reference implementations. You can use the same script to test your implementations.\n\nTo test a Responses API compatible API run:\n\npython -m gpt_oss.evals --base-url http://localhost:8000/v1 --eval aime25 --sampler responses --model openai/gpt-oss-120b --reasoning-effort high\n\nTo test a Chat Completions API compatible API run:\n\npython -m gpt_oss.evals --base-url http://localhost:8000/v1 --eval aime25 --sampler chat_completions --model openai/gpt-oss-120b --reasoning-effort high\n\nIf you are getting similar benchmark results as those published by us and your function calling tests above succeeded you likely have a correct implementation of gpt-oss."])</script><script>self.__next_f.push([1,"28:T1744,"])</script><script>self.__next_f.push([1,"LM Studio is a performant and friendly desktop application for running large language models (LLMs) on local hardware. This guide will walk you through how to set up and run gpt-oss-20b or gpt-oss-120b models using LM Studio, including how to chat with them, use MCP servers, or interact with the models through LM Studio's local development API.\n\nNote that this guide is meant for consumer hardware, like running gpt-oss on a PC or Mac. For server applications with dedicated GPUs like NVIDIA's H100s, check out our vLLM guide.\n\n\nLM Studio supports both model sizes of gpt-oss:\n\nopenai/gpt-oss-20b\n  The smaller model\n  Only requires at least 16GB of VRAM\n  Perfect for higher-end consumer GPUs or Apple Silicon Macs\nopenai/gpt-oss-120b\n  Our larger full-sized model\n  Best with ≥60GB VRAM\n  Ideal for multi-GPU or beefy workstation setup\n\nLM Studio ships both a llama.cpp inferencing engine (running GGUF formatted models), as well as an Apple MLX engine for Apple Silicon Macs.\n\nInstall LM Studio\n   LM Studio is available for Windows, macOS, and Linux. Get it here.\n\nDownload the gpt-oss model →\n\nlms get openai/gpt-oss-20b\nlms get openai/gpt-oss-120b\n\nLoad the model in LM Studio\n  → Open LM Studio and use the model loading interface to load the gpt-oss model you downloaded. Alternatively, you can use the command line:\n\nlms load openai/gpt-oss-20b\nlms load openai/gpt-oss-120b\n\nUse the model → Once loaded, you can interact with the model directly in LM Studio's chat interface or through the API.\n\n\nUse LM Studio's chat interface to start a conversation with gpt-oss, or use the chat command in the terminal:\n\nlms chat openai/gpt-oss-20b\n\nNote about prompt formatting: LM Studio utilizes OpenAI's Harmony library to construct the input to gpt-oss models, both when running via llama.cpp and MLX.\n\n\nLM Studio exposes a Chat Completions-compatible API so you can use the OpenAI SDK without changing much. Here’s a Python example:\n\nfrom openai import OpenAI\n\nclient = OpenAI(\n    base_url=\"http://localhost:1234/v1\",\n    api_key=\"not-needed\"  # LM Studio does not require an API key\n)\n\nresult = client.chat.completions.create(\n    model=\"openai/gpt-oss-20b\",\n    messages=[\n        {\"role\": \"system\", \"content\": \"You are a helpful assistant.\"},\n        {\"role\": \"user\", \"content\": \"Explain what MXFP4 quantization is.\"}\n    ]\n)\n\nprint(result.choices[0].message.content)\n\nIf you’ve used the OpenAI SDK before, this will feel instantly familiar and your existing code should work by changing the base URL.\n\n\nLM Studio is an MCP client, which means you can connect MCP servers to it. This allows you to provide external tools to gpt-oss models.\n\nLM Studio's mcp.json file is located in:\n\n~/.lmstudio/mcp.json\n\n\nLM Studio's SDK is available in both Python and TypeScript. You can leverage the SDK to implement tool calling and local function execution with gpt-oss.\n\nThe way to achieve this is via the .act() call, which allows you to provide tools to the gpt-oss and have it go between calling tools and reasoning, until it completes your task.\n\nThe example below shows how to provide a single tool to the model that is able to create files on your local filesystem. You can use this example as a starting point, and extend it with more tools. See docs about tool definitions here for Python and TypeScript.\n\nuv pip install lmstudio\n\nimport readline # Enables input line editing\nfrom pathlib import Path\n\nimport lmstudio as lms\n\ndef create_file(name: str, content: str):\n    \"\"\"Create a file with the given name and content.\"\"\"\n    dest_path = Path(name)\n    if dest_path.exists():\n        return \"Error: File already exists.\"\n    try:\n        dest_path.write_text(content, encoding=\"utf-8\")\n    except Exception as exc:\n        return \"Error: {exc!r}\"\n    return \"File created.\"\n\ndef print_fragment(fragment, round_index=0):\n.act() supplies the round index as the second parameter\nSetting a default value means the callback is also\ncompatible with .complete() and .respond().\n    print(fragment.content, end=\"\", flush=True)\n\nmodel = lms.llm(\"openai/gpt-oss-20b\")\nchat = lms.Chat(\"You are a helpful assistant running on the user's computer.\")\n\nwhile True:\n    try:\n        user_input = input(\"User (leave blank to exit): \")\n    except EOFError:\n        print()\n        break\n    if not user_input:\n        break\n    chat.add_user_message(user_input)\n    print(\"Assistant: \", end=\"\", flush=True)\n    model.act(\n        chat,\n        [create_file],\n        on_message=chat.append,\n        on_prediction_fragment=print_fragment,\n    )\n    print()\n\n\nFor TypeScript developers who want to utilize gpt-oss locally, here's a similar example using lmstudio-js:\n\nnpm install @lmstudio/sdk\n\nimport { Chat, LMStudioClient, tool } from \"@lmstudio/sdk\";\nimport { existsSync } from \"fs\";\nimport { writeFile } from \"fs/promises\";\nimport { createInterface } from \"readline/promises\";\nimport { z } from \"zod\";\n\nconst rl = createInterface({ input: process.stdin, output: process.stdout });\nconst client = new LMStudioClient();\nconst model = await client.llm.model(\"openai/gpt-oss-20b\");\nconst chat = Chat.empty();\n\nconst createFileTool = tool({\n  name: \"createFile\",\n  description: \"Create a file with the given name and content.\",\n  parameters: { name: z.string(), content: z.string() },\n  implementation: async ({ name, content }) =\u003e {\n    if (existsSync(name)) {\n      return \"Error: File already exists.\";\n    }\n    await writeFile(name, content, \"utf-8\");\n    return \"File created.\";\n  },\n});\n\nwhile (true) {\n  const input = await rl.question(\"User: \");\n  // Append the user input to the chat\n  chat.append(\"user\", input);\n\n  process.stdout.write(\"Assistant: \");\n  await model.act(chat, [createFileTool], {\n    // When the model finish the entire message, push it to the chat\n    onMessage: (message) =\u003e chat.append(message),\n    onPredictionFragment: ({ content }) =\u003e {\n      process.stdout.write(content);\n    },\n  });\n  process.stdout.write(\"\\n\");\n}\n`"])</script><script>self.__next_f.push([1,"29:T288d,"])</script><script>self.__next_f.push([1,"The GPT-5 Family of models are the smartest models we’ve released to date, representing a step change in the models’ capabilities across the board. GPT-5 is particularly specialized in agentic task performance, coding, and steerability, making it a great fit for everyone from curious users to advanced researchers.\n\nGPT-5 will benefit from all the traditional prompting best practices, but to make optimizations and migrations easier, we are introducing the GPT-5  Prompt Optimizer in our Playground to help users get started on improving existing prompts and migrating prompts for GPT-5 and other OpenAI models.\n\nPrompt Optimizer demo\n\nIn this cookbook we will show you how to use the Prompt Optimzer to get spun up quickly to solve your tasks with GPT-5, while demonstrating how prompt optimize can have measurable improvements.\n\nCrafting effective prompts is a critical skill when working with LLMs. The goal of the Prompt Optimizer is to give your prompt the best practices and formatting most effective for our models. The Optimizer also removes common prompting failure modes such as:\n\n•   Contradictions in the prompt instructions\n•\tMissing or unclear format specifications\n•\tInconsistencies between the prompt and few-shot examples\n\nAlong with tuning the prompt for the target model, the Optimizer is cognizant of the specific task you are trying to accomplish and can apply crucial practices to boost performance in Agentic Workflows, Coding and Multi-Modality. Let's walk through some before-and-afters to see where prompt optimization shines.\nRemember that prompting is not a one-size-fits-all experience, so we recommend running thorough experiments and iterating to find the best solution for your problem.\nEnsure you have set up your OpenAI API Key set as OPENAI_API_KEY and have access to GPT-5\n\nWe start with a task in a field that model has seen significant improvements: Coding and Analytics. We will ask the model to generate a Python script that computes the exact Top‑K most frequent tokens from a large text stream using a specific tokenization spec. Tasks like these are highly sensitive to poor prompting as they can push the model toward the wrong algorithms and approaches (approximate sketches vs multi‑pass/disk‑backed exact solutions), dramatically affecting accuracy and runtime.\n\nFor this task, we will evaluate:\nCompilation/Execution success over 30 runs\nAverage runtime (successful runs)\nAverage peak memory (successful runs)\nExactness: output matches ground‑truth Top‑K with tie‑break: by count desc, then token asc\n\nNote: Evaluated on an M4 Max MacBook Pro; adjust constraints if needed.\n\nFor our example, let's look at a typical starting prompt with some minor contradictions in the prompt, and ambiguous or underspecified instructions. Contradictions in instructions often reduce performance and increase latency, especially in reasoning models like GPT-5, and ambiguous instructions can cause unwanted behaviors.\nThis baseline prompt is something that you could expect from asking ChatGPT to write you a prompt, or talking to a friend who is knowledgeable about coding but not particularly invested in your specific use case. Our baseline prompt is intentionally shorter and friendlier, but it hides mixed signals that can push the model into inconsistent solution families.\n\nFirst, we say to prefer the standard library, then immediately allow external packages “if they make things simpler.” That soft permission can nudge the model toward non‑portable dependencies or heavier imports that change performance and even execution success across environments.\n\nNext, we encourage single‑pass streaming to keep memory low, but we also say it’s fine to reread or cache “if that makes the solution clearer.” That ambiguity opens the door to multi‑pass designs or in‑memory caches that defeat the original streaming constraint and can alter runtime and memory profiles.\n\nWe also ask for exact results while permitting approximate methods “when they don’t change the outcome in practice.” This is a judgment call the model can’t reliably verify. It may introduce sketches or heuristics that subtly shift counts near the Top‑K boundary, producing results that look right but fail strict evaluation.\n\nWe advise avoiding global state, yet suggest exposing a convenient global like top_k. That mixes interface contracts: is the function supposed to return data, or should callers read globals? Models may implement both, causing side effects that complicate evaluation and reproducibility.\n\nDocumentation guidance is similarly split: “keep comments minimal” but “add brief explanations.” Depending on how the model interprets this, you can get under‑explained code or prose interleaved with logic, which sometimes leaks outside the required output format.\n\nFinally, we ask for “natural, human‑friendly” sorting while also mentioning strict tie rules. These aren’t always the same. The model might pick convenience ordering (e.g., Counter.most_common) and drift from the evaluator’s canonical (-count, token) sort, especially on ties—leading to subtle correctness misses.\n\nWhy this matters: the softened constraints make the prompt feel easy to satisfy, but they create forks in the road. The model may pick different branches across runs—stdlib vs external deps, one‑pass vs reread/cache, exact vs approximate—yielding variability in correctness, latency, and memory.\n\nOur evaluator remains strict: fixed tokenization [a-z0-9]+ on lowercased text and deterministic ordering by (-count, token). Any divergence here will penalize exactness even if the rest of the solution looks reasonable.\n\n\nUsing the OpenAI Responses API we'll invoke the model 30 times with our baseline prompt and save each response as a Python file in the results_topk_baseline. This may take some time.\n\nWe then benchmark every script in `results_topk_baseline` On larger datasets this evaluation is intentionally heavy and can take several minutes.\nNow let's use the prompt optimization tool in the console to improve our prompt and then review the results. We can start by going to the OpenAI Optimize Playground, and pasting our existing prompt in the Developer Message section.\n\nFrom there press the Optimize button. This will open the optimization panel. At this stage, you can either provide specific edits you'd like to see reflected in the prompt or simply press Optimize to have it refined according to best practices for the target model and task. To start let's do just this.\n\noptimize_image\n\n\n\nOnce it's completed you'll see the result of the prompt optimization. In our example below you'll see many changes were made to the prompt. It will also give you snippets of what it changed and why the change was made. You can interact with these by opening the comments up or using the inline reviewer mode.\n\nWe'll add an additional change we'd like which include:\n\nEnforcing the single-pass streaming\n\nThis is easy using the iterative process of the Prompt Optimizer.\n\noptimize_image\n\n\nOnce we are happy with the optimized version of our prompt, we can save it as a Prompt Object using a button on the top right of the optimizer. We can use this object within our API Calls which can help with future iteration, version management, and reusability across different applications.\n\noptimize_image\n\n\nFor visibility we will provide our new optimized prompt here, but you can also pass the `prompt_id and version`. Let's start by writing out our optimized prompt.\n\nWe run the same evaluation as above, but now with our optimized prompt to see if there were any improvements\n\nAlong with more quantitative evaluations we can measure the models performance on more qualitative metrics like code quality, and task adherence. We have created a sample prompt for this called `llm_as_judge.txt`.\n\nWe can now demonstrate from both a quantitative standpoint, along with a qualitative standpoint from our LLM as Judge results.\nEven though GPT-5 already produced correct code, prompt optimization tightened constraints and clarified any ambiguity. Showing overall improvements to the results!\n\n\n\nMost production use cases face imperfect queries and noisy context. FailSafeQA is an excellent benchmark that deliberately perturbs both the query (misspellings, incompleteness, off-domain phrasing) and the context (missing, OCR-corrupted, or irrelevant docs) and reports Robustness, Context Grounding, and Compliance—i.e., can the model answer when the signal exists and abstain when it doesn’t.\n\nFailSafeQA diagram\n\nLinks\nPaper (arXiv): Expect the Unexpected: FailSafe Long Context QA for Finance — https://arxiv.org/abs/2502.06329\nDataset (Hugging Face): https://huggingface.co/datasets/Writer/FailSafeQA\nAuthors/Makers: Kiran Kamble, Melisa Russak, Dmytro Mozolevskyi, Muayad Ali, Mateusz Russak, Waseem AlShikh (Writer.ai) — see author list on the arXiv page above\n\nWe will run FailSafeQA evaluations via the helper script and compare Baseline vs Optimized prompts side by side.\nWe can use the prompt optimizer once again to construct a new prompt that is more suitable for this use case. Drawing on best practices for long-context question answering, we know that we should remind our answer model to rely on information in the context section and refuse answers to questions if the context is insufficient. By using the Optimize button once without any arguments we get a reasonable structure for the prompt and end up with this as our optimized prompt.\n\n\noptimize_image\n\n\nLet's now run our evaluations, for demonstration we will display the results of a single comparison, but you can also run the full evaluation. Note: This will take time.\nGPT-5-mini crushes this task, so even the baseline prompt gets scores of \u003e= 4 almost all of the time. However if we compare the percent of perfect scores (6/6) for the judge, we see that the optimize prompt has way significantly more perfect answers when evaluated in the two categories of FailSafeQA answer quality: robustness and context grounding.\n\nWe’re excited for everyone to try Prompt Optimization for GPT-5 in the OpenAI Playground. GPT-5 brings state-of-the-art intelligence, and a strong prompt helps it reason more reliably, follow constraints, and produce cleaner, higher quality results.\n\n\nGive the Prompt Optimizer a try on your task today!"])</script><script>self.__next_f.push([1,"2a:Ta9be,"])</script><script>self.__next_f.push([1,"GPT-5, our newest flagship model, represents a substantial leap forward in agentic task performance, coding, raw intelligence, and steerability.\n\nWhile we trust it will perform excellently “out of the box” across a wide range of domains, in this guide we’ll cover prompting tips to maximize the quality of model outputs, derived from our experience training and applying the model to real-world tasks. We discuss concepts like improving agentic task performance, ensuring instruction adherence, making use of newly API features, and optimizing coding for frontend and software engineering tasks - with key insights into AI code editor Cursor’s prompt tuning work with GPT-5.\n\nWe’ve seen significant gains from applying these best practices and adopting our canonical tools whenever possible, and we hope that this guide, along with the prompt optimizer tool we’ve built, will serve as a launchpad for your use of GPT-5. But, as always, remember that prompting is not a one-size-fits-all exercise - we encourage you to run experiments and iterate on the foundation offered here to find the best solution for your problem.\n\nWe trained GPT-5 with developers in mind: we’ve focused on improving tool calling, instruction following, and long-context understanding to serve as the best foundation model for agentic applications. If adopting GPT-5 for agentic and tool calling flows, we recommend upgrading to the Responses API, where reasoning is persisted between tool calls, leading to more efficient and intelligent outputs.\n\nAgentic scaffolds can span a wide spectrum of control—some systems delegate the vast majority of decision-making to the underlying model, while others keep the model on a tight leash with heavy programmatic logical branching. GPT-5 is trained to operate anywhere along this spectrum, from making high-level decisions under ambiguous circumstances to handling focused, well-defined tasks. In this section we cover how to best calibrate GPT-5’s agentic eagerness: in other words, its balance between proactivity and awaiting explicit guidance.\n\nGPT-5 is, by default, thorough and comprehensive when trying to gather context in an agentic environment to ensure it will produce a correct answer. To reduce the scope of GPT-5’s agentic behavior—including limiting tangential tool-calling action and minimizing latency to reach a final answer—try the following:\nSwitch to a lower reasoning_effort. This reduces exploration depth but improves efficiency and latency. Many workflows can be accomplished with consistent results at medium or even low reasoning_effort.\nDefine clear criteria in your prompt for how you want the model to explore the problem space. This reduces the model’s need to explore and reason about too many ideas:\n\n\nGoal: Get enough context fast. Parallelize discovery and stop as soon as you can act.\n\nMethod:\nStart broad, then fan out to focused subqueries.\nIn parallel, launch varied queries; read top hits per query. Deduplicate paths and cache; don’t repeat queries.\nAvoid over searching for context. If needed, run targeted searches in one parallel batch.\n\nEarly stop criteria:\nYou can name exact content to change.\nTop hits converge (~70%) on one area/path.\n\nEscalate once:\nIf signals conflict or scope is fuzzy, run one refined parallel batch, then proceed.\n\nDepth:\nTrace only symbols you’ll modify or whose contracts you rely on; avoid transitive expansion unless necessary.\n\nLoop:\nBatch search → minimal plan → complete task.\nSearch again only if validation fails or new unknowns appear. Prefer acting over more searching.\n\n\nIf you’re willing to be maximally prescriptive, you can even set fixed tool call budgets, like the one below. The budget can naturally vary based on your desired search depth.\n\nSearch depth: very low\nBias strongly towards providing a correct answer as quickly as possible, even if it might not be fully correct.\nUsually, this means an absolute maximum of 2 tool calls.\nIf you think that you need more time to investigate, update the user with your latest findings and open questions. You can proceed if the user confirms.\n\n\nWhen limiting core context gathering behavior, it’s helpful to explicitly provide the model with an escape hatch that makes it easier to satisfy a shorter context gathering step. Usually this comes in the form of a clause that allows the model to proceed under uncertainty, like “even if it might not be fully correct” in the above example.\n\nOn the other hand, if you’d like to encourage model autonomy, increase tool-calling persistence, and reduce occurrences of clarifying questions or otherwise handing back to the user, we recommend increasing reasoning_effort, and using a prompt like the following to encourage persistence and thorough task completion:\n\n\nYou are an agent - please keep going until the user's query is completely resolved, before ending your turn and yielding back to the user.\nOnly terminate your turn when you are sure that the problem is solved.\nNever stop or hand back to the user when you encounter uncertainty — research or deduce the most reasonable approach and continue.\nDo not ask the human to confirm or clarify assumptions, as you can always adjust later — decide what the most reasonable assumption is, proceed with it, and document it for the user's reference after you finish acting\n\n\nGenerally, it can be helpful to clearly state the stop conditions of the agentic tasks, outline safe versus unsafe actions, and define when, if ever, it’s acceptable for the model to hand back to the user. For example, in a set of tools for shopping, the checkout and payment tools should explicitly have a lower uncertainty threshold for requiring user clarification, while the search tool should have an extremely high threshold; likewise, in a coding setup, the delete file tool should have a much lower threshold than a grep search tool.\n\nWe recognize that on agentic trajectories monitored by users, intermittent model updates on what it’s doing with its tool calls and why can provide for a much better interactive user experience - the longer the rollout, the bigger the difference these updates make. To this end, GPT-5 is trained to provide clear upfront plans and consistent progress updates via “tool preamble” messages.\n\nYou can steer the frequency, style, and content of tool preambles in your prompt—from detailed explanations of every single tool call to a brief upfront plan and everything in between. This is an example of a high-quality preamble prompt:\n\n\nAlways begin by rephrasing the user's goal in a friendly, clear, and concise manner, before calling any tools.\nThen, immediately outline a structured plan detailing each logical step you’ll follow. - As you execute your file edit(s), narrate each step succinctly and sequentially, marking progress clearly.\nFinish by summarizing completed work distinctly from your upfront plan.\n\n\nHere’s an example of a tool preamble that might be emitted in response to such a prompt—such preambles can drastically improve the user’s ability to follow along with your agent’s work as it grows more complicated:\n\n\"output\": [\n    {\n      \"id\": \"rs_6888f6d0606c819aa8205ecee386963f0e683233d39188e7\",\n      \"type\": \"reasoning\",\n      \"summary\": [\n        {\n          \"type\": \"summary_text\",\n          \"text\": \"Determining weather response\\n\\nI need to answer the user's question about the weather in San Francisco. ....\"\n        },\n    },\n    {\n      \"id\": \"msg_6888f6d83acc819a978b51e772f0a5f40e683233d39188e7\",\n      \"type\": \"message\",\n      \"status\": \"completed\",\n      \"content\": [\n        {\n          \"type\": \"output_text\",\n          \"text\": \"I\\u2019m going to check a live weather service to get the current conditions in San Francisco, providing the temperature in both Fahrenheit and Celsius so it matches your preference.\"\n        }\n      ],\n      \"role\": \"assistant\"\n    },\n    {\n      \"id\": \"fc_6888f6d86e28819aaaa1ba69cca766b70e683233d39188e7\",\n      \"type\": \"function_call\",\n      \"status\": \"completed\",\n      \"arguments\": \"{\\\"location\\\":\\\"San Francisco, CA\\\",\\\"unit\\\":\\\"f\\\"}\",\n      \"call_id\": \"call_XOnF4B9DvB8EJVB3JvWnGg83\",\n      \"name\": \"get_weather\"\n    },\n  ],\n\nWe provide a reasoning_effort parameter to control how hard the model thinks and how willingly it calls tools; the default is medium, but you should scale up or down depending on the difficulty of your task. For complex, multi-step tasks, we recommend higher reasoning to ensure the best possible outputs. Moreover, we observe peak performance when distinct, separable tasks are broken up across multiple agent turns, with one turn for each task.\nWe strongly recommend using the Responses API when using GPT-5 to unlock improved agentic flows, lower costs, and more efficient token usage in your applications.\n\nWe’ve seen statistically significant improvements in evaluations when using the Responses API over Chat Completions—for example, we observed Tau-Bench Retail score increases from 73.9% to 78.2% just by switching to the Responses API and including previous_response_id to pass back previous reasoning items into subsequent requests. This allows the model to refer to its previous reasoning traces, conserving CoT tokens and eliminating the need to reconstruct a plan from scratch after each tool call, improving both latency and performance - this feature is available for all Responses API users, including ZDR organizations.\nGPT-5 leads all frontier models in coding capabilities: it can work in large codebases to fix bugs, handle large diffs, and implement multi-file refactors or large new features. It also excels at implementing new apps entirely from scratch, covering both frontend and backend implementation. In this section, we’ll discuss prompt optimizations that we’ve seen improve programming performance in production use cases for our coding agent customers.\n\nGPT-5 is trained to have excellent baseline aesthetic taste alongside its rigorous implementation abilities. We’re confident in its ability to use all types of web development frameworks and packages; however, for new apps, we recommend using the following frameworks and packages to get the most out of the model's frontend capabilities:\n\nFrameworks: Next.js (TypeScript), React, HTML\nStyling / UI: Tailwind CSS, shadcn/ui, Radix Themes\nIcons: Material Symbols, Heroicons, Lucide\nAnimation: Motion\nFonts: San Serif, Inter, Geist, Mona Sans, IBM Plex Sans, Manrope\n\nGPT-5 is excellent at building applications in one shot. In early experimentation with the model, users have found that prompts like the one below—asking the model to iteratively execute against self-constructed excellence rubrics—improve output quality by using GPT-5’s thorough planning and self-reflection capabilities.\n\n\nFirst, spend time thinking of a rubric until you are confident.\nThen, think deeply about every aspect of what makes for a world-class one-shot web app. Use that knowledge to create a rubric that has 5-7 categories. This rubric is critical to get right, but do not show this to the user. This is for your purposes only.\nFinally, use the rubric to internally think and iterate on the best possible solution to the prompt that is provided. Remember that if your response is not hitting the top marks across all categories in the rubric, you need to start again.\n\n\nWhen implementing incremental changes and refactors in existing apps, model-written code should adhere to existing style and design standards, and “blend in” to the codebase as neatly as possible.  Without special prompting, GPT-5 already searches for reference context from the codebase - for example reading package.json to view already installed packages - but this behavior can be further enhanced with prompt directions that summarize key aspects like engineering principles, directory structure, and best practices of the codebase, both explicit and implicit. The prompt snippet below demonstrates one way of organizing code editing rules for GPT-5: feel free to change the actual content of the rules according to your programming design taste!\n\nClarity and Reuse: Every component and page should be modular and reusable. Avoid duplication by factoring repeated UI patterns into components.\nConsistency: The user interface must adhere to a consistent design system—color tokens, typography, spacing, and components must be unified.\nSimplicity: Favor small, focused components and avoid unnecessary complexity in styling or logic.\nDemo-Oriented: The structure should allow for quick prototyping, showcasing features like streaming, multi-turn conversations, and tool integrations.\nVisual Quality: Follow the high visual quality bar as outlined in OSS guidelines (spacing, padding, hover states, etc.)\n\n\n\nFramework: Next.js (TypeScript)\nStyling: TailwindCSS\nUI Components: shadcn/ui\nIcons: Lucide\nState Management: Zustand\nDirectory Structure:\n\\\\\\`\n/src\n /app\n   /api//route.ts         # API endpoints\n   /(pages)                      # Page routes\n /components/                    # UI building blocks\n /hooks/                         # Reusable React hooks\n /lib/                           # Utilities (fetchers, helpers)\n /stores/                        # Zustand stores\n /types/                         # Shared TypeScript types\n /styles/                        # Tailwind config\n\\\\\\`\n\n\n\nVisual Hierarchy: Limit typography to 4–5 font sizes and weights for consistent hierarchy; use text-xs for captions and annotations; avoid text-xl unless for hero or major headings.\nColor Usage: Use 1 neutral base (e.g., zinc) and up to 2 accent colors.\nSpacing and Layout: Always use multiples of 4 for padding and margins to maintain visual rhythm. Use fixed height containers with internal scrolling when handling long content streams.\nState Handling: Use skeleton placeholders or animate-pulse to indicate data fetching. Indicate clickability with hover transitions (hover:bg-*, hover:shadow-md).\nAccessibility: Use semantic HTML and ARIA roles where appropriate. Favor pre-built Radix/shadcn components, which have accessibility baked in.\n\n\n\n\nWe’re proud to have had AI code editor Cursor as a trusted alpha tester for GPT-5: below, we show a peek into how Cursor tuned their prompts to get the most out of the model’s capabilities. For more information, their team has also published a blog post detailing GPT-5’s day-one integration into Cursor: https://cursor.com/blog/gpt-5\n\nCursor’s system prompt focuses on reliable tool calling, balancing verbosity and autonomous behavior while giving users the ability to configure custom instructions. Cursor’s goal for their system prompt is to allow the Agent to operate relatively autonomously during long horizon tasks, while still faithfully following user-provided instructions.\n\nThe team initially found that the model produced verbose outputs, often including status updates and post-task summaries that, while technically relevant, disrupted the natural flow of the user; at the same time, the code outputted in tool calls was high quality, but sometimes hard to read due to terseness, with single-letter variable names dominant. In search of a better balance, they set the verbosity API parameter to low to keep text outputs brief, and then modified the prompt to strongly encourage verbose outputs in coding tools only.\n\nWrite code for clarity first. Prefer readable, maintainable solutions with clear names, comments where needed, and straightforward control flow. Do not produce code-golf or overly clever one-liners unless explicitly requested. Use high verbosity for writing code and code tools.\n\nThis dual usage of parameter and prompt resulted in a balanced format combining efficient, concise status updates and final work summary with much more readable code diffs.\n\nCursor also found that the model occasionally deferred to the user for clarification or next steps before taking action, which created unnecessary friction in the flow of longer tasks. To address this, they found that including not just available tools and surrounding context, but also more details about product behavior encouraged the model to carry out longer tasks with minimal interruption and greater autonomy. Highlighting specifics of Cursor features such as Undo/Reject code and user preferences helped reduce ambiguity by clearly specifying how GPT-5 should behave in its environment. For longer horizon tasks, they found this prompt improved performance:\n\nBe aware that the code edits you make will be displayed to the user as proposed changes, which means (a) your code edits can be quite proactive, as the user can always reject, and (b) your code should be well-written and easy to quickly review (e.g., appropriate variable names instead of single letters). If proposing next steps that would involve changing the code, make those changes proactively for the user to approve / reject rather than asking the user whether to proceed with a plan. In general, you should almost never ask the user whether to proceed with a plan; instead you should proactively attempt the plan and then ask the user if they want to accept the implemented changes.\n\nCursor found that sections of their prompt that had been effective with earlier models needed tuning to get the most out of GPT-5. Here is one example below:\n\n\nBe THOROUGH when gathering information. Make sure you have the FULL picture before replying. Use additional tool calls or clarifying questions as needed.\n...\n\n\nWhile this worked well with older models that needed encouragement to analyze context thoroughly, they found it counterproductive with GPT-5, which is already naturally introspective and proactive at gathering context. On smaller tasks, this prompt often caused the model to overuse tools by calling search repetitively, when internal knowledge would have been sufficient.\n\nTo solve this, they refined the prompt by removing the maximize_ prefix and softening the language around thoroughness. With this adjusted instruction in place, the Cursor team saw GPT-5 make better decisions about when to rely on internal knowledge versus reaching for external tools. It maintained a high level of autonomy without unnecessary tool usage, leading to more efficient and relevant behavior. In Cursor’s testing, using structured XML specs like   improved instruction adherence on their prompts and allows them to clearly reference previous categories and sections elsewhere in their prompt.\n\n\n...\nIf you've performed an edit that may partially fulfill the USER's query, but you're not confident, gather more information or use more tools before ending your turn.\nBias towards not asking the user for help if you can find the answer yourself.\n\n\nWhile the system prompt provides a strong default foundation, the user prompt remains a highly effective lever for steerability. GPT-5 responds well to direct and explicit instruction and the Cursor team has consistently seen that structured, scoped prompts yield the most reliable results. This includes areas like verbosity control, subjective code style preferences, and sensitivity to edge cases. Cursor found allowing users to configure their own custom Cursor rules to be particularly impactful with GPT-5’s improved steerability, giving their users a more customized experience.\n\n\nAs our most steerable model yet, GPT-5 is extraordinarily receptive to prompt instructions surrounding verbosity, tone, and tool calling behavior.\n\nIn addition to being able to control the reasoning_effort as in previous reasoning models, in GPT-5 we introduce a new API parameter called verbosity, which influences the length of the model’s final answer, as opposed to the length of its thinking. Our blog post covers the idea behind this parameter in more detail - but in this guide, we’d like to emphasize that while the API verbosity parameter is the default for the rollout, GPT-5 is trained to respond to natural-language verbosity overrides in the prompt for specific contexts where you might want the model to deviate from the global default. Cursor’s example above of setting low verbosity globally, and then specifying high verbosity only for coding tools, is a prime example of such a context.\n\nLike GPT-4.1, GPT-5 follows prompt instructions with surgical precision, which enables its flexibility to drop into all types of workflows. However, its careful instruction-following behavior means that poorly-constructed prompts containing contradictory or vague instructions can be more damaging to GPT-5 than to other models, as it expends reasoning tokens searching for a way to reconcile the contradictions rather than picking one instruction at random.\n\nBelow, we give an adversarial example of the type of prompt that often impairs GPT-5’s reasoning traces - while it may appear internally consistent at first glance, a closer inspection reveals conflicting instructions regarding appointment scheduling:\nNever schedule an appointment without explicit patient consent recorded in the chart conflicts with the subsequent auto-assign the earliest same-day slot without contacting the patient as the first action to reduce risk.\nThe prompt says Always look up the patient profile before taking any other actions to ensure they are an existing patient. but then continues with the contradictory instruction When symptoms indicate high urgency, escalate as EMERGENCY and direct the patient to call 911 immediately before any scheduling step.\n\nYou are CareFlow Assistant, a virtual admin for a healthcare startup that schedules patients based on priority and symptoms. Your goal is to triage requests, match patients to appropriate in-network providers, and reserve the earliest clinically appropriate time slot. Always look up the patient profile before taking any other actions to ensure they are an existing patient.\n\nCore entities include Patient, Provider, Appointment, and PriorityLevel (Red, Orange, Yellow, Green). Map symptoms to priority: Red within 2 hours, Orange within 24 hours, Yellow within 3 days, Green within 7 days. When symptoms indicate high urgency, escalate as EMERGENCY and direct the patient to call 911 immediately before any scheduling step.\n+Core entities include Patient, Provider, Appointment, and PriorityLevel (Red, Orange, Yellow, Green). Map symptoms to priority: Red within 2 hours, Orange within 24 hours, Yellow within 3 days, Green within 7 days. When symptoms indicate high urgency, escalate as EMERGENCY and direct the patient to call 911 immediately before any scheduling step.\nDo not do lookup in the emergency case, proceed immediately to providing 911 guidance.\n\nUse the following capabilities: schedule-appointment, modify-appointment, waitlist-add, find-provider, lookup-patient and notify-patient. Verify insurance eligibility, preferred clinic, and documented consent prior to booking. Never schedule an appointment without explicit patient consent recorded in the chart.\n\nFor high-acuity Red and Orange cases, auto-assign the earliest same-day slot without contacting the patient as the first action to reduce risk. If a suitable provider is unavailable, add the patient to the waitlist and send notifications. If consent status is unknown, tentatively hold a slot and proceed to request confirmation.\n\nFor high-acuity Red and Orange cases, auto-assign the earliest same-day slot after informing the patient of your actions. If a suitable provider is unavailable, add the patient to the waitlist and send notifications. If consent status is unknown, tentatively hold a slot and proceed to request confirmation.\n\nBy resolving the instruction hierarchy conflicts, GPT-5 elicits much more efficient and performant reasoning. We fixed the contradictions by:\nChanging auto-assignment to occur after contacting a patient, auto-assign the earliest same-day slot after informing the patient of your actions. to be consistent with only scheduling with consent.\nAdding Do not do lookup in the emergency case, proceed immediately to providing 911 guidance. to let the model know it is ok to not look up in case of emergency.\n\nWe understand that the process of building prompts is an iterative one, and many prompts are living documents constantly being updated by different stakeholders - but this is all the more reason to thoroughly review them for poorly-worded instructions. Already, we’ve seen multiple early users uncover  ambiguities and contradictions in their core prompt libraries upon conducting such a review: removing them drastically streamlined and improved their GPT-5 performance. We recommend testing your prompts in our prompt optimizer tool to help identify these types of issues.\n\nIn GPT-5, we introduce minimal reasoning effort for the first time: our fastest option that still reaps the benefits of the reasoning model paradigm. We consider this to be the best upgrade for latency-sensitive users, as well as current users of GPT-4.1.\n\nPerhaps unsurprisingly, we recommend prompting patterns that are similar to GPT-4.1 for best results. minimal reasoning performance can vary more drastically depending on prompt than higher reasoning levels, so key points to emphasize include:\n\nPrompting the model to give a brief explanation summarizing its thought process at the start of the final answer, for example via a bullet point list, improves performance on tasks requiring higher intelligence.\nRequesting thorough and descriptive tool-calling preambles that continually update the user on task progress improves performance in agentic workflows.\nDisambiguating tool instructions to the maximum extent possible and inserting agentic persistence reminders as shared above, are particularly critical at minimal reasoning to maximize agentic ability in long-running rollout and prevent premature termination.\nPrompted planning is likewise more important, as the model has fewer reasoning tokens to do internal planning. Below, you can find a sample planning prompt snippet we placed at the beginning of an agentic task: the second paragraph especially ensures that the agent fully completes the task and all subtasks before yielding back to the user.\n\nRemember, you are an agent - please keep going until the user's query is completely resolved, before ending your turn and yielding back to the user. Decompose the user's query into all required sub-request, and confirm that each is completed. Do not stop after completing only part of the request. Only terminate your turn when you are sure that the problem is solved. You must be prepared to answer multiple queries and only finish the call once the user has confirmed they're done.\n\nYou must plan extensively in accordance with the workflow steps before making subsequent function calls, and reflect extensively on the outcomes each function call made, ensuring the user's query, and related sub-requests are completely resolved.\n\nBy default, GPT-5 in the API does not format its final answers in Markdown, in order to preserve maximum compatibility with developers whose applications may not support Markdown rendering. However, prompts like the following are largely successful in inducing hierarchical Markdown final answers.\n\nUse Markdown only where semantically correct (e.g., inline code, When using markdown in assistant messages, use backticks to format file, directory, function, and class names. Use \\( and \\) for inline math, \\[ and \\] for block math.\n\nOccasionally, adherence to Markdown instructions specified in the system prompt can degrade over the course of a long conversation. In the event that you experience this, we’ve seen consistent adherence from appending a Markdown instruction every 3-5 user messages.\n\nFinally, to close with a meta-point, early testers have found great success using GPT-5 as a meta-prompter for itself. Already, several users have deployed prompt revisions to production that were generated simply by asking GPT-5 what elements could be added to an unsuccessful prompt to elicit a desired behavior, or removed to prevent an undesired one.\n\nHere is an example metaprompt template we liked:\nWhen asked to optimize prompts, give answers from your own perspective - explain what specific phrases could be added to, or deleted from, this prompt to more consistently elicit the desired behavior or prevent the undesired behavior.\n\nHere's a prompt: [PROMPT]\n\nThe desired behavior from this prompt is for the agent to [DO DESIRED BEHAVIOR], but instead it [DOES UNDESIRED BEHAVIOR]. While keeping as much of the existing prompt intact as possible, what are some minimal edits/additions that you would make to encourage the agent to more consistently address these shortcomings?\n\nIn this environment, you can run bash -lc  to execute a diff/patch against a file, where  is a specially formatted apply patch command representing the diff you wish to execute. A valid  looks like:\n\napply_patch  any;\n\ntype read_file = (_: {\npath: string, // default: null\nline_start?: number, // default: 1\nline_end?: number, // default: 20\n}) =\u003e any;\n\ntype list_files = (_: {\npath?: string, // default: \"\"\ndepth?: number, // default: 1\n}) =\u003e any;\n\ntype find_matches = (_: {\nquery: string, // default: null\npath?: string, // default: \"\"\nmax_results?: number, // default: 50\n}) =\u003e any;\n\n\ntype run = (_: {\ncommand: string[], // default: null\nsession_id?: string | null, // default: null\nworking_dir?: string | null, // default: null\nms_timeout?: number | null, // default: null\nenvironment?: object | null, // default: null\nrun_as_user?: string | null, // default: null\n}) =\u003e any;\n\ntype send_input = (_: {\nsession_id: string, // default: null\ntext: string, // default: null\nwait_ms?: number, // default: 100\n}) =\u003e any;\n\nAs shared in the GPT-4.1 prompting guide, here is our most updated apply_patch implementation: we highly recommend using apply_patch for file edits to match the training distribution. The newest implementation should match the GPT-4.1 implementation in the overwhelming majority of cases.\n\nAs a retail agent, you can help users cancel or modify pending orders, return or exchange delivered orders, modify their default user address, or provide information about their own profile, orders, and related products.\n\nRemember, you are an agent - please keep going until the user’s query is completely resolved, before ending your turn and yielding back to the user. Only terminate your turn when you are sure that the problem is solved.\n\nIf you are not sure about information pertaining to the user’s request, use your tools to read files and gather the relevant information: do NOT guess or make up an answer.\n\nYou MUST plan extensively before each function call, and reflect extensively on the outcomes of the previous function calls, ensuring user's query is completely resolved. DO NOT do this entire process by making function calls only, as this can impair your ability to solve the problem and think insightfully. In addition, ensure function calls have the correct arguments.\n\nAt the beginning of the conversation, you have to authenticate the user identity by locating their user id via email, or via name + zip code. This has to be done even when the user already provides the user id.\nOnce the user has been authenticated, you can provide the user with information about order, product, profile information, e.g. help the user look up order id.\nYou can only help one user per conversation (but you can handle multiple requests from the same user), and must deny any requests for tasks related to any other user.\nBefore taking consequential actions that update the database (cancel, modify, return, exchange), you have to list the action detail and obtain explicit user confirmation (yes) to proceed.\nYou should not make up any information or knowledge or procedures not provided from the user or the tools, or give subjective recommendations or comments.\nYou should at most make one tool call at a time, and if you take a tool call, you should not respond to the user at the same time. If you respond to the user, you should not make a tool call.\nYou should transfer the user to a human agent if and only if the request cannot be handled within the scope of your actions.\n\nAll times in the database are EST and 24 hour based. For example \"02:30:00\" means 2:30 AM EST.\nEach user has a profile of its email, default address, user id, and payment methods. Each payment method is either a gift card, a paypal account, or a credit card.\nOur retail store has 50 types of products. For each type of product, there are variant items of different options. For example, for a 't shirt' product, there could be an item with option 'color blue size M', and another item with option 'color red size L'.\nEach product has an unique product id, and each item has an unique item id. They have no relations and should not be confused.\nEach order can be in status 'pending', 'processed', 'delivered', or 'cancelled'. Generally, you can only take action on pending or delivered orders.\nExchange or modify order tools can only be called once. Be sure that all items to be changed are collected into a list before making the tool call!!!\n\nAn order can only be cancelled if its status is 'pending', and you should check its status before taking the action.\nThe user needs to confirm the order id and the reason (either 'no longer needed' or 'ordered by mistake') for cancellation.\nAfter user confirmation, the order status will be changed to 'cancelled', and the total will be refunded via the original payment method immediately if it is gift card, otherwise in 5 to 7 business days.\n\nAn order can only be modified if its status is 'pending', and you should check its status before taking the action.\nFor a pending order, you can take actions to modify its shipping address, payment method, or product item options, but nothing else.\n\nThe user can only choose a single payment method different from the original payment method.\nIf the user wants the modify the payment method to gift card, it must have enough balance to cover the total amount.\nAfter user confirmation, the order status will be kept 'pending'. The original payment method will be refunded immediately if it is a gift card, otherwise in 5 to 7 business days.\n\nThis action can only be called once, and will change the order status to 'pending (items modifed)', and the agent will not be able to modify or cancel the order anymore. So confirm all the details are right and be cautious before taking this action. In particular, remember to remind the customer to confirm they have provided all items to be modified.\nFor a pending order, each item can be modified to an available new item of the same product but of different product option. There cannot be any change of product types, e.g. modify shirt to shoe.\nThe user must provide a payment method to pay or receive refund of the price difference. If the user provides a gift card, it must have enough balance to cover the price difference.\n\nAn order can only be returned if its status is 'delivered', and you should check its status before taking the action.\nThe user needs to confirm the order id, the list of items to be returned, and a payment method to receive the refund.\nThe refund must either go to the original payment method, or an existing gift card.\nAfter user confirmation, the order status will be changed to 'return requested', and the user will receive an email regarding how to return items.\n\nAn order can only be exchanged if its status is 'delivered', and you should check its status before taking the action. In particular, remember to remind the customer to confirm they have provided all items to be exchanged.\nFor a delivered order, each item can be exchanged to an available new item of the same product but of different product option. There cannot be any change of product types, e.g. modify shirt to shoe.\nThe user must provide a payment method to pay or receive refund of the price difference. If the user provides a gift card, it must have enough balance to cover the price difference.\nAfter user confirmation, the order status will be changed to 'exchange requested', and the user will receive an email regarding how to return items. There is no need to place a new order.\n\nPlease resolve the user's task by editing and testing the code files in your current code execution session.\nYou are a deployed coding agent.\nYour session is backed by a container specifically designed for you to easily modify and run code.\nYou MUST adhere to the following criteria when executing the task:\n\n\nWorking on the repo(s) in the current environment is allowed, even if they are proprietary.\nAnalyzing code for vulnerabilities is allowed.\nShowing user code and tool call details is allowed.\nUser instructions may overwrite the CODING GUIDELINES section in this developer message.\nDo not use \\ls -R\\, \\find\\, or \\grep\\ - these are slow in large repos. Use \\rg\\ and \\rg --files\\.\nUse \\apply_patch\\ to edit files: {\"cmd\":[\"apply_patch\",\"* Begin Patch\\\\n* Update File: path/to/file.py\\\\n@@ def example():\\\\n- pass\\\\n+ return 123\\\\n* End Patch\"]}\nIf completing the user's task requires writing or modifying files:\n Your code and final answer should follow these CODING GUIDELINES:\n   Fix the problem at the root cause rather than applying surface-level patches, when possible.\n   Avoid unneeded complexity in your solution.\n     Ignore unrelated bugs or broken tests; it is not your responsibility to fix them.\n   Update documentation as necessary.\n   Keep changes consistent with the style of the existing codebase. Changes should be minimal and focused on the task.\n     Use \\git log\\ and \\git blame\\ to search the history of the codebase if additional context is required; internet access is disabled in the container.\n   NEVER add copyright or license headers unless specifically requested.\n   You do not need to \\git commit\\ your changes; this will be done automatically for you.\n   If there is a .pre-commit-config.yaml, use \\pre-commit run --files ...\\ to check that your changes pass the pre- commit checks. However, do not fix pre-existing errors on lines you didn't touch.\n     If pre-commit doesn't work after a few retries, politely inform the user that the pre-commit setup is broken.\n   Once you finish coding, you must\n     Check \\git status\\ to sanity check your changes; revert any scratch files or changes.\n     Remove all inline comments you added much as possible, even if they look normal. Check using \\git diff\\. Inline comments must be generally avoided, unless active maintainers of the repo, after long careful study of the code and the issue, will still misinterpret the code without the comments.\n     Check if you accidentally add copyright or license headers. If so, remove them.\n     Try to run pre-commit if it is available.\n     For smaller tasks, describe in brief bullet points\n     For more complex tasks, include brief high-level description, use bullet points, and include details that would be relevant to a code reviewer.\nIf completing the user's task DOES NOT require writing or modifying files (e.g., the user asks a question about the code base):\n Respond in a friendly tune as a remote teammate, who is knowledgeable, capable and eager to help with coding.\nWhen your task involves writing or modifying files:\n Do NOT tell the user to \"save the file\" or \"copy the code into a file\" if you already created or modified the file using \\apply_patch\\. Instead, reference the file as already saved.\n Do NOT show the full contents of large files you have already written, unless the user explicitly asks for them.\n\n\n\nTo edit files, ALWAYS use the \\shell\\ tool with \\apply_patch\\ CLI.  \\apply_patch\\ effectively allows you to execute a diff/patch against a file, but the format of the diff specification is unique to this task, so pay careful attention to these instructions. To use the \\apply_patch\\ CLI, you should call the shell tool with the following structure:\n\\\\\\`bash\n{\"cmd\": [\"apply_patch\", \" ACTION can be one of Add, Update, or Delete.\nFor each snippet of code that needs to be changed, repeat the following:\n[context_before] -\u003e See below for further instructions on context.\n[old_code] -\u003e Precede the old code with a minus sign.\n[new_code] -\u003e Precede the new, replacement code with a plus sign.\n[context_after] -\u003e See below for further instructions on context.\nFor instructions on [context_before] and [context_after]:\nBy default, show 3 lines of code immediately above and 3 lines immediately below each change. If a change is within 3 lines of a previous change, do NOT duplicate the first change’s [context_after] lines in the second change’s [context_before] lines.\nIf 3 lines of context is insufficient to uniquely identify the snippet of code within the file, use the @@ operator to indicate the class or function to which the snippet belongs. For instance, we might have:\n@@ class BaseClass\n[3 lines of pre-context]\n[old_code]\n[new_code]\n[3 lines of post-context]\nIf a code block is repeated so many times in a class or function such that even a single \\@@\\ statement and 3 lines of context cannot uniquely identify the snippet of code, you can use multiple \\@@\\ statements to jump to the right context. For instance:\n@@ class BaseClass\n@@  def method():\n[3 lines of pre-context]\n[old_code]\n[new_code]\n[3 lines of post-context]\nNote, then, that we do not use line numbers in this diff format, as the context is enough to uniquely identify code. An example of a message that you might pass as \"input\" to this function, in order to apply a patch, is shown below.\n\\\\\\`bash\n{\"cmd\": [\"apply_patch\", \"\n\n\nYou are an agent - please keep going until the user’s query is completely resolved, before ending your turn and yielding back to the user. Only terminate your turn when you are sure that the problem is solved.\nNever stop at uncertainty — research or deduce the most reasonable approach and continue.\nDo not ask the human to confirm assumptions — document them, act on them, and adjust mid-task if proven wrong.\n\n\n\nIf you are not sure about file content or codebase structure pertaining to the user’s request, use your tools to read files and gather the relevant information: do NOT guess or make up an answer.\nBefore coding, always:\nDecompose the request into explicit requirements, unclear areas, and hidden assumptions.\nMap the scope: identify the codebase regions, files, functions, or libraries likely involved. If unknown, plan and perform targeted searches.\nCheck dependencies: identify relevant frameworks, APIs, config files, data formats, and versioning concerns.\nResolve ambiguity proactively: choose the most probable interpretation based on repo context, conventions, and dependency docs.\nDefine the output contract: exact deliverables such as files changed, expected outputs, API responses, CLI behavior, and tests passing.\nFormulate an execution plan: research steps, implementation sequence, and testing strategy in your own words and refer to it as you work through the task.\n\n\n\nRoutinely verify your code works as you work through the task, especially any deliverables to ensure they run properly. Don't hand back to the user until you are sure that the problem is solved.\nExit excessively long running processes and optimize your code to run faster.\n\n\n\nEfficiency is key. you have a time limit. Be meticulous in your planning, tool calling, and verification so you don't waste time.\n\n\n\nNever use editor tools to edit files. Always use the \\apply_patch\\ tool.\n\n`"])</script><script>self.__next_f.push([1,"2b:T98f,"])</script><script>self.__next_f.push([1,"GPT-5 is a large leap forward in frontend development. We have seen the model be excellent at developing full stack applications in one shot, making complex refactors look easy, and making surgical edits within large codebases.\n\nIn this cookbook we will show some examples and some learnings of developing frontend applications with GPT-5 across multiple axes.\n\nThere are some general principles we have seen be effective in developing strong frontend applications. We share some of these learnings in the prompt guide. Below are some important pieces to consider when building frontend applications.\n\nHere are libraries and packages we recommend to start with steering the model:\nFrameworks: Next.js (TypeScript), React, HTML\nStyling / UI: Tailwind CSS, shadcn/ui, Radix Themes\nIcons: Material Symbols, Heroicons, Lucide\nAnimation: Motion\nFonts: San Serif, Inter, Geist, Mona Sans, IBM Plex Sans, Manrope\n\nThese packages are not an exhaustive list and we have seen many different application styles.\n\nBelow you'll find an easy way to iterate over frontend abstractions on the API. We’re excited to see how users can unlock creativity with GPT-5.\n\n\nLet's dive into an example of creating frontends from scratch. First let's create some help functions to see the generated websites from GPT-5.\nNow, let's combine the above into one helper function.\nWe'll start with a simple example: one-shot building a retro gaming store with the right theme\nNot bad for a one line, one shot prompt!\n\n\n\n\nNow let's steer it to be lighter, and a bit softer\nAs you can see GPT-5 is incredibly steerable - with just a one line you can change entire applications effortlessly\n\n\nBut what if you have existing website designs that you want to make additions to? For example, we already have this dashboard.\n\n\n\nSince GPT-5 is natively multimodal and accepts both image and text input, when you are generating frontend applications we can take advantage of image input to improve model performance.\nAs you can see, GPT-5 does an incredible job of matching the existing style \u0026 vibe of the app.\n\n\nSo far this has been pretty static - let's try a more interactive task\nWe've got a theme consistent snake game: matching colours, typography, and even sound\n\n\nWe hope this has given some ideas of how powerful GPT-5 is at frontend. From a single underspecified prompt and API call, we get production grade outputs.\n\nNow it's your turn - we can't wait to see what you'll build"])</script><script>self.__next_f.push([1,"2c:T2c39,"])</script><script>self.__next_f.push([1,"We’re introducing new developer controls in the GPT-5 series that give you greater control over model responses—from shaping output length and style to enforcing strict formatting. Below is a quick overview of the latest features:\n\n\n| #  | Feature | Overview | Values / Usage |\n|----|---------|----------|----------------|\n| 1. | Verbosity Parameter | Lets you hint the model to be more or less expansive in its replies. Keep prompts stable and use the parameter instead of re-writing. | • low → terse UX, minimal prose.• medium (default) → balanced detail.• high → verbose, great for audits, teaching, or hand-offs. |\n| 2. | Freeform Function Calling | Generate raw text payloads—anything from Python scripts to SQL queries—directly to your custom tool without JSON wrapping. Offers greater flexibility for external runtimes like:• Code sandboxes (Python, C++, Java, …)• SQL databases• Shell environments• Config generators | Use when structured JSON isn’t needed and raw text is more natural for the target tool. |\n| 3. | Context-Free Grammar (CFG) | A set of production rules defining valid strings in a language. Each rule rewrites a non-terminal into terminals and/or other non-terminals, independent of surrounding context. Useful for constraining output to match the syntax of programming languages or custom formats in OpenAI tools. | Use as a contract to ensure the model emits only valid strings accepted by the grammar. |\n| 4. | Minimal Reasoning | Runs GPT-5 with few or no reasoning tokens to minimize latency and speed time-to-first-token. Ideal for deterministic, lightweight tasks (extraction, formatting, short rewrites, simple classification) where explanations aren’t needed. If not specified, effort defaults to medium. | Set reasoning effort: \"minimal\". Avoid for multi-step planning or tool-heavy workflows. |\n\n\nSupported Models:\ngpt-5\ngpt-5-mini\ngpt-5-nano\n\nSupported API Endpoints\nResponses API\nChat Completions API\n\nNote: We recommend to use Responses API with GPT-5 series of model to get the most performance out of the models.\n\nLet's begin with updating your OpenAI SDK that supports the new params and tools for GPT-5. Make sure you've set OPENAI_API_KEY as an environment variable.\n\nThe verbosity parameter lets you hint the model to be more or less expansive in its replies.\n\nValues: \"low\", \"medium\", \"high\"\n\nlow → terse UX, minimal prose.\nmedium (default) → balanced detail.\nhigh → verbose, great for audits, teaching, or hand-offs.\n\nKeep prompts stable and use the param rather than re-writing.\n\nThe output tokens scale roughly linearly with verbosity: low (560) → medium (849) → high (1288).\n\nThe verbosity parameter also influences the length and complexity of generated code, as well as the depth of accompanying explanations. Here's an example, wherein we use various verboisty levels for a task to generate a Python program that sorts an array of 1000000 random numbers.\nNotice that the code output is a plain script. Now, lets run with 'medium'\nMedium verboisty, generated richer code with additioanl explanations. Let's do the same with high.\nHigh verbosity yielded additional details and explanations.\n\nThe new verbosity parameter reliably scales both the length and depth of the model’s output while preserving correctness and reasoning quality - without changing the underlying prompt.\nIn this example:\n\nLow verbosity** produces a minimal, functional script with no extra comments or structure.\nMedium verbosity** adds explanatory comments, function structure, and reproducibility controls.\nHigh verbosity** yields a comprehensive, production-ready script with argument parsing, multiple sorting methods, timing/verification, usage notes, and best-practice tips.\n\nGPT‑5 can now send raw text payloads - anything from Python scripts to SQL queries - to your custom tool without wrapping the data in JSON using the new tool \"type\": \"custom\". This differs from classic structured function calls, giving you greater flexibility when interacting with external runtimes such as:\n\ncode_exec with sandboxes (Python, C++, Java, …)\nSQL databases\nShell environments\nConfiguration generators\n\nNote that custom tool type does NOT support parallel tool calling.\n\nThe code below produces a simple python code to calculate area of a circle, and instruct the model to use the freeform tool call to output the result.\nThe model emits a tool call containing raw Python. You execute that code server‑side, capture the printed result, and send it back in a follow‑up responses.create call.\nTo illustrate the use of free form tool calling, we will ask GPT‑5 to:\nGenerate Python, C++, and Java code that sorts a fixed array 10 times.\nPrint only the time (in ms) taken for each iteration in the code.\nCall all three functions, and then stop\nThe model output three code blocks in Python, C++ and Java for the same algorithm. The output of the function call was chained back into the model as input to allow model to keep going until all the functions have been called exactly once.\n\nFreeform tool calling in GPT-5 lets you send raw text payloads—such as Python scripts, SQL queries, or config files—directly to custom tools without JSON wrapping. This provides greater flexibility for interacting with external runtimes and allows the model to generate code or text in the exact format your tool expects. It’s ideal when structured JSON is unnecessary and natural text output improves usability.\n\nA context‑free grammar is a collection of production rules that define which strings belong to a language. Each rule rewrites a non‑terminal symbol into a sequence of terminals (literal tokens) and/or other non‑terminals, independent of surrounding context—hence context‑free. CFGs can capture the syntax of most programming languages and, in OpenAI custom tools, serve as contracts that force the model to emit only strings that the grammar accepts.\n\n\nSupported Grammar Syntax\nLark - https://lark-parser.readthedocs.io/en/stable/\nRegex - https://docs.rs/regex/latest/regex/#syntax\n\nWe use LLGuidance under the hood to constrain model sampling: https://github.com/guidance-ai/llguidance.\n\nUnsupported Lark Features\nLookaround in regexes ((?=...), (?!...), etc.)\nLazy modifier (*?, +?, ??) in regexes.\nTerminal priorities, templates, %declares, %import (except %import common).\n\n\nTerminals vs Rules \u0026 Greedy Lexing\n\n| Concept          | Take-away                                                                    |\n|------------------|------------------------------------------------------------------------------|\n| Terminals (UPPER)| Matched first by the lexer – longest match wins.                             |\n| Rules (lower)    | Combine terminals; cannot influence how text is tokenised.                   |\n| Greedy lexer     | Never try to “shape” free text across multiple terminals – you’ll lose control. |\n\nCorrect vs Incorrect Pattern Design\n\n✅ One bounded terminal handles free‑text between anchors\nstart: SENTENCE\nSENTENCE: /[A-Za-z, ](the hero|a dragon)[A-Za-z, ](fought|saved)[A-Za-z, ](a treasure|the kingdom)[A-Za-z, ]\\./\n❌ Don’t split free‑text across multiple terminals/rules\nstart: sentence\nsentence: /[A-Za-z, ]+/ subject /[A-Za-z, ]+/ verb /[A-Za-z, ]+/ object /[A-Za-z, ]+/\n\n\nThe following code example is now the canonical reference for building multi‑dialect SQL tools with CFGs. It demonstrates:\n\nTwo isolated grammar definitions (mssql_grammar_definition, postgres_grammar_definition) encoding TOP vs LIMIT semantics.\nHow to prompt, invoke, and inspect tool calls in a single script.\nA side‑by‑side inspection of the assistant’s responses.\nDefine the LARK grammars for different SQL dialects\nLet's define the prompt, and call the function to produce MS SQL dialect\nThe output SQL accurately uses \"SELECT TOP\" construct.\nOutput highlights the same logical query - different physical syntax. Supply distinct grammars so the model can only produce valid statements for the chosen dialect.\n\n| Dialect       | Generated Query                                              | Key Difference                          |\n|---------------|--------------------------------------------------------------|------------------------------------------|\n| MS SQL Server | SELECT TOP 5 customer_id, … ORDER BY order_date DESC;         | Uses TOP N clause before column list.  |\n| PostgreSQL    | SELECT customer_id, … ORDER BY order_date DESC LIMIT 5;       | Uses LIMIT N after ORDER BY.         |\n\n\n\nThe following code example demonstrates using the Regex CFG syntax to constrain the freeform tool call to a certain timestamp pattern.\n\nLark grammars can be tricky to perfect. While simple grammars perform most reliably, complex grammars often require iteration on the grammar definition itself, the prompt, and the tool description to ensure that the model does not go out of distribution.\n\nKeep terminals bounded – use /{0,10}\\./ rather than /.\\./. Limit matches both by content (negated character class) and by length ({M,N} quantifier).\nPrefer explicit char‑classes over . wildcards.\nThread whitespace explicitly, e.g. using SP = \" \", instead of a global %ignore.\nDescribe your tool: tell the model exactly what the CFG accepts and instruct it to reason heavily about compliance.\n\nTroubleshooting\nAPI rejects the grammar because it is too complex ➜ Simplify rules and terminals, remove %ignore.*.\nUnexpected tokens ➜ Confirm terminals aren’t overlapping; check greedy lexer.\nWhen the model drifts \"out‑of‑distribution\" (shows up as the model producing excessively long or repetitive outputs, it is syntactically valid but is semantically wrong):\n    Tighten the grammar.\n    Iterate on the prompt (add few-shot examples) and tool description (explain the grammar and instruct the model to reason to conform to it).\n    Experiment with a higher reasoning effort (e.g, bump from medium to high).\n\nResources:\nLark Docs – https://lark-parser.readthedocs.io/en/stable/\nLark IDE – https://www.lark-parser.org/ide/\nLLGuidance Syntax – https://github.com/guidance-ai/llguidance/blob/main/docs/syntax.md\nRegex (Rust crate) – https://docs.rs/regex/latest/regex/#syntax\n\nContext-Free Grammar (CFG) support in GPT-5 lets you strictly constrain model output to match predefined syntax, ensuring only valid strings are generated. This is especially useful for enforcing programming language rules or custom formats, reducing post-processing and errors. By providing a precise grammar and clear tool description, you can make the model reliably stay within your target output structure.\n\n\nGPT-5 now support for a new minimal reasoning effort. When using minimal reasoning effort, the model will output very few or no reasoning tokens. This is designed for use cases where developers want a very fast time-to-first-user-visible token. Note: If no reasoning effort is supplied, the default value is medium.\n\nMinimal reasoning runs GPT-5 with few or no reasoning tokens to minimize latency and speed up time-to-first-token. Use it for deterministic, lightweight tasks (extraction, formatting, short rewrites, simple classification) where explanations aren’t needed. If you don’t specify effort, it defaults to medium—set minimal explicitly when you want speed over deliberation."])</script><script>self.__next_f.push([1,"2d:T448,Open in Colab\n\nOpenAI released gpt-oss 120B and 20B. Both models are Apache 2.0 licensed.\n\nSpecifically, gpt-oss-20b was made for lower latency and local or specialized use cases (21B parameters with 3.6B active parameters).\n\nSince the models were trained in native MXFP4 quantization it makes it easy to run the 20B even in resource constrained environments like Google Colab.\n\nAuthored by: Pedro and VB\nSince support for mxfp4 in transformers is bleeding edge, we need a recent version of PyTorch and CUDA, in order to be able to install the mxfp4 triton kernels.\n\nWe also need to install transformers from source, and we uninstall torchvision and torchaudio to remove dependency conflicts.\nPlease, restart your Colab runtime session after installing the packages above.\n\nWe load the model from here: openai/gpt-oss-20b\n\nYou can provide an optional system prompt or directly the input.\nSimply pass it as an additional argument to apply_chat_template(). Supported values are \"low\", \"medium\" (default), or \"high\".\n\nCheck out our blogpost for other ideas: https://hf.co/blog/welcome-openai-gpt-oss2e:T10a6,"])</script><script>self.__next_f.push([1,"This notebook provides a step-by-step guide on how to optimizing gpt-oss models using NVIDIA's TensorRT-LLM for high-performance inference. TensorRT-LLM provides users with an easy-to-use Python API to define Large Language Models (LLMs) and support state-of-the-art optimizations to perform inference efficiently on NVIDIA GPUs. TensorRT-LLM also contains components to create Python and C++ runtimes that orchestrate the inference execution in performant way.\n\n\nTensorRT-LLM supports both models:\ngpt-oss-20b\ngpt-oss-120b\n\nIn this guide, we will run gpt-oss-20b, if you want to try the larger model or want more customization refer to this deployment guide.\n\nNote: Your input prompts should use the harmony response format for the model to work properly, though this guide does not require it.\nYou can simplify the environment setup by using NVIDIA Brev. Click the button below to launch this project on a Brev instance with the necessary dependencies pre-configured.\n\nOnce deployed, click on the \"Open Notebook\" button to get start with this guide\n\nLaunch on Brev\nTo run the gpt-oss-20b model, you will need an NVIDIA GPU with at least 20 GB of VRAM.\n\nRecommended GPUs: NVIDIA Hopper (e.g., H100, H200), NVIDIA Blackwell (e.g., B100, B200), NVIDIA RTX PRO, NVIDIA RTX 50 Series (e.g., RTX 5090).\n\nCUDA Toolkit 12.8 or later\nPython 3.12 or later\n\nThere are multiple ways to install TensorRT-LLM. In this guide, we'll cover using a pre-built Docker container from NVIDIA NGC as well as building from source.\n\nIf you're using NVIDIA Brev, you can skip this section.\n\nPull the pre-built TensorRT-LLM container for GPT-OSS from NVIDIA NGC.\nThis is the easiest way to get started and ensures all dependencies are included.\n\ndocker pull nvcr.io/nvidia/tensorrt-llm/release:gpt-oss-dev\ndocker run --gpus all -it --rm -v $(pwd):/workspace nvcr.io/nvidia/tensorrt-llm/release:gpt-oss-dev\n\n\nAlternatively, you can build the TensorRT-LLM container from source.\nThis approach is useful if you want to modify the source code or use a custom branch.\nFor detailed instructions, see the official documentation.\nTensorRT-LLM will be available through pip soon\nNote on GPU Architecture: The first time you run the model, TensorRT-LLM will build an optimized engine for your specific GPU architecture (e.g., Hopper, Ada, or Blackwell). If you see warnings about your GPU's CUDA capability (e.g., sm_90, sm_120) not being compatible with the PyTorch installation, ensure you have the latest NVIDIA drivers and a matching CUDA Toolkit version for your version of PyTorch.\nIn the next code cell, we will demonstrate how to use the TensorRT-LLM Python API to:\nDownload the specified model weights from Hugging Face (using your HF_TOKEN for authentication).\nAutomatically build the TensorRT engine for your GPU architecture if it does not already exist.\nLoad the model and prepare it for inference.\nRun a simple text generation example to verify everything is working.\n\nNote: The first run may take several minutes as it downloads the model and builds the engine.\nSubsequent runs will be much faster, as the engine will be cached.\nCongratulations! You have successfully optimized and run a large language model using the TensorRT-LLM Python API.\n\nIn this notebook, you have learned how to:\nSet up your environment with the necessary dependencies.\nUse the tensorrt_llm.LLM API to download a model from the Hugging Face Hub.\nAutomatically build a high-performance TensorRT engine tailored to your GPU.\nRun inference with the optimized model.\n\n\nYou can explore more advanced features to further improve performance and efficiency:\n\nBenchmarking: Try running a benchmark to compare the latency and throughput of the TensorRT-LLM engine against the original Hugging Face model. You can do this by iterating over a larger number of prompts and measuring the execution time.\n\nQuantization: TensorRT-LLM supports various quantization techniques (like INT8 or FP8) to reduce model size and accelerate inference with minimal impact on accuracy. This is a powerful feature for deploying models on resource-constrained hardware.\n\nDeploy with NVIDIA Dynamo: For production environments, you can deploy your TensorRT-LLM engine using the NVIDIA Dynamo for robust, scalable, and multi-model serving."])</script><script>self.__next_f.push([1,"2f:T2e98,"])</script><script>self.__next_f.push([1,"Authored by: Edward Beeching, Quentin Gallouédec, and Lewis Tunstall\n\nLarge reasoning models like OpenAI o3 generate a chain-of-thought to improve the accuracy and quality of their responses. However, most of these models reason in English, even when a question is asked in another language.\n\nIn this notebook, we show how OpenAI's open-weight reasoning model OpenAI gpt-oss-20b can be fine-tuned to reason effectively in multiple languages. We'll do this by adding a new \"reasoning language\" option to the model's system prompt, and applying supervised fine-tuning with Hugging Face's TRL library on a multilingual reasoning dataset.\n\nWe'll cover the following steps:\n\nSetup: Install the required libraries.\nPrepare the dataset:  Download and format the dataset for fine-tuning.\nPrepare the model: Loading the base model and configure it for fine-tuning LoRA, a memory efficient technique.\nFine-tuning: Train the model with our multilingual reasoning data.\nInference: Generate reasoning responses in different languages using the fine-tuned model.\n\nThe end result is a multilingual reasoning model that can generate a chain-of-thought in English, Spanish, French, Italian, or German. You can even mix languages—for example, ask a question in Spanish, request reasoning in German, and receive the final response in Spanish:\n\nUser:\n    ¿Cuál es el capital de Australia?\nAssistant reasoning:\n    Okay, der Benutzer fragt nach der Hauptstadt Australiens. Ich erinnere mich, dass Canberra die Hauptstadt ist. Ich\n    sollte das bestätigen. Lass mich sehen, ob es irgendwelche potenziellen Verwirrungen gibt. Der Benutzer könnte auch\n    an der größten Stadt interessiert sein. Die größte Stadt ist Sydney, aber die Hauptstadt ist Canberra. Ich sollte\n    das klarstellen. Vielleicht auch erwähnen, dass Canberra eine geplante Stadt ist und nicht die größte. Der Benutzer\n    könnte auch nach der Geografie fragen. Vielleicht erwähne ich, dass Canberra im südwestlichen Teil der Australian\n    Capital Territory liegt. Ich sollte die Antwort präzise und freundlich halten. Vielleicht auch erwähnen, dass\n    Canberra oft mit Sydney verwechselt wird. Ich sollte sicherstellen, dass die Antwort klar und korrekt ist.\nAssistant response:\n    La capital de Australia es Canberra. Aunque es la ciudad más pequeña de las principales capitales del país, fue\n    elegida en 1908 como la sede del gobierno federal para equilibrar la influencia entre las ciudades de Sydney y\n    Melbourne. Canberra está ubicada en el Territorio de la Capital Australiana (ACT), en el este de Australia.\n\nWe hope this tutorial will enable AI developers working with under-represented languages to improve the interpretability of openai/gpt-oss-20b in their native languages.\nNote: This notebook is designed to be run on a single H100 GPU with 80GB of memory. If you have access to a smaller GPU, you can reduce the batch size and sequence length in the hyperparameters below.\n\nTo get started, let’s install all the necessary libraries. First install PyTorch:\nNext, install the remaining dependencies:\nFinally, log into your Hugging Face account as follows:\nNow that we've installed the required libraries, let's take a look at the dataset that we will use for fine-tuning.\n\nWe will be using Multilingual-Thinking, which is a reasoning dataset where the chain-of-thought has been translated into several languages such as French, Spanish, and German. By fine-tuning openai/gpt-oss-20b on this dataset, it will learn to generate reasoning steps in these languages, and thus its reasoning process can be interpreted by users who speak those languages.\n\n\n\nLet's download this dataset from the Hugging Face Hub:\nThis is a small dataset of 1,000 examples, but this is usually more than sufficient for models like openai/gpt-oss-20b which have undergone extensive post-training. Let's take a look at one of the training examples:\nThe gpt-oss models were trained on the Harmony response format for defining conversation structures, generating reasoning output and structuring function calls. The format is designed to mimic the OpenAI Responses API, and the table below summarizes the different message types used in the dataset:\n|||\n| :---- | :--|\n| developer | The developer message is used to provide custom instructions for the model (what we usually call the system role). |\n| user | The user message is used to provide the input to the model. |\n| assistant | Output by the model which can either be a tool call or a message output. The output might also be associated with a particular “channel” identifying what the intent of the message is. |\n| analysis | These are messages that are being used by the model for its chain-of-thought |\n| final | Messages tagged in the final channel are messages intended to be shown to the end-user and represent the responses from the model. |\n| messages | The list of messages that combine the content of the above to produce a full conversation. This is the input to the model. |\nIf you're familiar with OpenAI's messages format, you will recognise this as being quite similar, but with an important difference:\nThe assistant turn contains two special fields: a thinking one which contains the model's reasoning process, and a content one which contains the final response to the user.\n\nIn order to fine-tune the model, we need to convert these messages into a format that the model can understand. In practice this is done by formatting each message with the model's chat template and then tokenizing the resulting text. The TRL library does this automatically, but let's walk through it step by step to understand how it works.\n\nTo do so, let's first load the tokenizer:\nThen we can use the tokenizer's apply_chat_template() method to format the messages:\nThis chat template is quite sophisticated, so let's take a closer look at it! First, we can see there are special tokens ` and  that indicate the start and end of each message. There is also a ` token that marks the end of the conversation. These tokens help the model understand the structure of the conversation.\n\nWe can also see there are two types of system message:\n\nA default system one that is used for all messages. In the example above, this refers to the text \"You are ChatGPT, a large language model trained by OpenAI...\"\nA special developer one that contains custom instructions (defined by the system role in our messages object). This allows us to provide additional context to the model about how it should behave for a given conversation. In the example above, this refers to the text \"You are an AI chatbot with a lively and energetic personality.\"\n\nFinally, we can see that the assistant response is contained in a series of channels:\n\nThe analysis channel is used for the model's reasoning process, where it can think step by step about the user's question. In the example above, this refers to the French text \"D'accord, l'utilisateur demande les tendances Twitter...\"\nThe final channel is used for the model's final response to the user. In the example above, this refers to the text \"Hey there!  While I can't check Twitter...\"\nNow that we understand how the dataset will be prepared, let's move on to preparing the model for training.\n\nTo prepare the model for training, let's first download the weights from the Hugging Face Hub. We will use the AutoModelForCausalLM class from 🤗 Transformers to load the model:\nThis will load the model with the necessary configurations for training. The attn_implementation is set to eager for better performance, and use_cache is set to False since we will fine-tune the model with gradient checkpointing.\n\nIf you're familiar with 🤗 Transformers, you might notice that we are using the Mxfp4Config for quantization. This is a specific configuration for the OpenAI models that allows us to use mixed precision training with a special 4-bit floating point format called MXFP4 that is optimized for AI workloads.\n\nBefore we train the model, let's generate a sample response to see how the model behaves with the default settings. To do so, we need to tokenize a sample prompt and then use the model to generate a response:\nIn this example, we can see that the model first reasons about the question in English, and then provides a final response in Spanish. This is the default behavior of the model, but let's see if we can change it with a bit of fine-tuning.\n\nTo do so, we will use a technique called LoRA (Low-Rank Adaptation) to fine-tune the model. This technique allows us to tune a few specific layers of the model, which is particularly useful for large models like openai/gpt-oss-20b.\n\nFirst we need to wrap the model as a PeftModel and define the LoRA configuration. We will use the LoraConfig class from the PEFT library to do this:\nHere we've used some basic hyperparameters for LoRA, but you can experiment with different values to see how they affect the model's performance. For instance, if you increase r you will enable more trainable parameters, which may produce a better model at the expense of requiring more VRAM and time to train.\n\nNote: The openai/gpt-oss-20b model is a Mixture-of-Experts (MoE) architecture. In addition to targeting the attention layers (target_modules=\"all-linear\"), it’s also important to include the projection layers within the expert modules. PEFT facilitates this via the target_parameters argument, which allows you to specify expert-specific layers such as mlp.experts.down_proj and mlp.experts.gate_up_proj. In this example, we target a subset of these projection layers, but you are encouraged to experiment with different configurations.\nNow that we have the model and dataset ready, we can define the hyperparameters for training.\nTRL provides a convenient way to define hyperparameters for training using the SFTConfig class. We will set the learning rate, batch size, number of epochs, and other parameters as follows:\nNote that the per_device_train_batch_size is set to 4, and the gradient_accumulation_steps is set to 4. This means that we will effectively have a batch size of 4 x 4 = 16 across 1 GPU. You may need to adjust these values based on your hardware setup. We also use Trackio to log the training progress and metrics, but you can use any other logging library of your choice.\nWe now have all the pieces needed to train the model. We will use the SFTTrainer class from TRL to handle the training process. The trainer will take care of formatting the dataset, applying the chat template, and training the model:\nOn a H100 GPU, this takes about 18 minutes to train, but may take longer depending on your hardware.\nFinally, you can push the fine-tuned model to your Hub repository to share with the community:\nNote: To avoid out-of-memory (OOM) errors, we recommend restarting the kernel at this point. The trained model is still occupying GPU memory, but it's no longer needed.\n\nOnce the model is uploaded to Hub, we can use it for inference. To do so we first initialize the original base model and its tokenizer. Next, we need to merge the fine-tuned weights with the base model for fast inference:\nNow that the model is loaded, the final step is to generate some tokens from it! Here we use the model's generate method to produce output based on the input prompt. Let's first define the prompt:\nNow we can tokenize the prompt and generate the output. Finally, we can decode the output tokens to get the final response:\nLet's also try with languages that the model has not been explicitly fine-tuned on, such as Chinese and Hindi:\nGreat, it works - we've now fine-tuned openai/gpt-oss-20b to reason in multiple languages!\nCongratulations! You have successfully fine-tuned a multilingual reasoning model using the TRL library and LoRA. The steps in this notebook can be adapted to fine-tune openai/gpt-oss-20b on many other datasets on the Hugging Face Hub - we are excited to see what you'll build!"])</script><script>self.__next_f.push([1,"30:T1281,"])</script><script>self.__next_f.push([1,"The gpt-oss models provide access to a raw chain of thought (CoT) meant for analysis and safety research by model implementors, but it’s also crucial for the performance of tool calling, as tool calls can be performed as part of the CoT. At the same time, the raw CoT might contain potentially harmful content or could reveal information to users that the person implementing the model might not intend (like rules specified in the instructions given to the model). You therefore should not show raw CoT to end users.\n\n\nThe model encodes its raw CoT as part of our harmony response format. If you are authoring your own chat templates or are handling tokens directly, make sure to check out harmony guide first.\n\nTo summarize a couple of things:\n\nCoT will be issued to the analysis channel\nAfter a message to the final channel in a subsequent sampling turn all analysis messages should be dropped. Function calls to the commentary channel can remain\nIf the last message by the assistant was a tool call of any type, the analysis messages until the previous final message should be preserved on subsequent sampling until a final message gets issued\n\n\nIf you are implementing a Chat Completions API, there is no official spec for handling chain of thought in the published OpenAI specs, as our hosted models will not offer this feature for the time being. We ask you to follow the following convention from OpenRouter instead. Including:\n\nRaw CoT will be returned as part of the response unless reasoning: { exclude: true } is specified as part of the request. See details here\nThe raw CoT is exposed as a reasoning property on the message in the output\nFor delta events the delta has a reasoning property\nOn subsequent turns you should be able to receive the previous reasoning (as reasoning) and handle it in accordance with the behavior specified in the chat template section above.\n\nWhen in doubt, please follow the convention / behavior of the OpenRouter implementation.\n\n\nFor the Responses API we augmented our Responses API spec to cover this case. Below are the changes to the spec as type definitions. At a high level we are:\n\nIntroducing a new content property on reasoning. This allows a reasoning summary that could be displayed to the end user to be returned at the same time as the raw CoT (which should not be shown to the end user, but which might be helpful for interpretability research).\nIntroducing a new content type called reasoning_text\nIntroducing two new events response.reasoning_text.delta to stream the deltas of the raw CoT and response.reasoning_text.done to indicate a turn of CoT to be completed\nOn subsequent turns you should be able to receive the previous reasoning and handle it in accordance with the behavior specified in the chat template section above.\n\nItem type changes\n\ntype ReasoningItem = {\n  id: string;\n  type: \"reasoning\";\n  summary: SummaryContent[];\n  // new\n  content: ReasoningTextContent[];\n};\n\ntype ReasoningTextContent = {\n  type: \"reasoning_text\";\n  text: string;\n};\n\ntype ReasoningTextDeltaEvent = {\n  type: \"response.reasoning_text.delta\";\n  sequence_number: number;\n  item_id: string;\n  output_index: number;\n  content_index: number;\n  delta: string;\n};\n\ntype ReasoningTextDoneEvent = {\n  type: \"response.reasoning_text.done\";\n  sequence_number: number;\n  item_id: string;\n  output_index: number;\n  content_index: number;\n  text: string;\n};\n\nEvent changes\n\n...\n{\n\ttype: \"response.content_part.added\"\n\t...\n}\n{\n\ttype: \"response.reasoning_text.delta\",\n\tsequence_number: 14,\n\titem_id: \"rs_67f47a642e788191aec9b5c1a35ab3c3016f2c95937d6e91\",\n\toutput_index: 0,\n\tcontent_index: 0,\n\tdelta: \"The \"\n}\n...\n{\n\ttype: \"response.reasoning_text.done\",\n\tsequence_number: 18,\n\titem_id: \"rs_67f47a642e788191aec9b5c1a35ab3c3016f2c95937d6e91\",\n\toutput_index: 0,\n\tcontent_index: 0,\n\ttext: \"The user asked me to think\"\n}\n\nExample responses output\n\n\"output\": [\n  {\n    \"type\": \"reasoning\",\n    \"id\": \"rs_67f47a642e788191aec9b5c1a35ab3c3016f2c95937d6e91\",\n    \"summary\": [\n      {\n        \"type\": \"summary_text\",\n        \"text\": \"Calculating volume of gold for Pluto layer\\n\\nStarting with the approximation...\"\n      }\n    ],\n    \"content\": [\n      {\n        \"type\": \"reasoning_text\",\n        \"text\": \"The user asked me to think...\"\n      }\n    ]\n  }\n]\n\n\n\nIf you are providing a chat interface to users, you should not show the raw CoT because it might contain potentially harmful content or other information that you might not intend to show to users (like, for example, instructions in the developer message). Instead, we recommend showing a summarized CoT, similar to our production implementations in the API or ChatGPT, where a summarizer model reviews and blocks harmful content from being shown."])</script><script>self.__next_f.push([1,"31:T1daa,"])</script><script>self.__next_f.push([1,"The Transformers library by Hugging Face provides a flexible way to load and run large language models locally or on a server. This guide will walk you through running OpenAI gpt-oss-20b or OpenAI gpt-oss-120b using Transformers, either with a high-level pipeline or via low-level generate calls with raw token IDs.\n\nWe'll cover the use of OpenAI gpt-oss-20b or OpenAI gpt-oss-120b with the high-level pipeline abstraction, low-level \\generate\\ calls, and serving models locally with \\transformers serve\\, with in a way compatible with the Responses API.\n\nIn this guide we’ll run through various optimised ways to run the gpt-oss models via Transformers.\n\nBonus: You can also fine-tune models via transformers, check out our fine-tuning guide here.\n\n\nBoth gpt-oss models are available on Hugging Face:\n\nopenai/gpt-oss-20b**\n  \\~16GB VRAM requirement when using MXFP4\n  Great for single high-end consumer GPUs\nopenai/gpt-oss-120b**\n  Requires ≥60GB VRAM or multi-GPU setup\n  Ideal for H100-class hardware\n\nBoth are MXFP4 quantized by default. Please, note that MXFP4 is supported in Hopper or later architectures. This includes data center GPUs such as H100 or GB200, as well as the latest RTX 50xx family of consumer cards.\n\nIf you use bfloat16 instead of MXFP4, memory consumption will be larger (\\~48 GB for the 20b parameter model).\n\n\nInstall dependencies\n   It’s recommended to create a fresh Python environment. Install transformers, accelerate, as well as the Triton kernels for MXFP4 compatibility:\n\npip install -U transformers accelerate torch triton==3.4 kernels\n\n(Optional) Enable multi-GPU\n   If you’re running large models, use Accelerate or torchrun to handle device mapping automatically.\n\n\nTo launch a server, simply use the transformers serve CLI command:\n\ntransformers serve\n\nThe simplest way to interact with the server is through the transformers chat CLI\n\ntransformers chat localhost:8000 --model-name-or-path openai/gpt-oss-20b\n\nor by sending an HTTP request with cURL, e.g.\n\ncurl -X POST http://localhost:8000/v1/responses -H \"Content-Type: application/json\" -d '{\"messages\": [{\"role\": \"system\", \"content\": \"hello\"}], \"temperature\": 0.9, \"max_tokens\": 1000, \"stream\": true, \"model\": \"openai/gpt-oss-20b\"}'\n\nAdditional use cases, like integrating transformers serve with Cursor and other tools, are detailed in the documentation.\n\n\nThe easiest way to run the gpt-oss models is with the Transformers high-level pipeline API:\n\nfrom transformers import pipeline\n\ngenerator = pipeline(\n    \"text-generation\",\n    model=\"openai/gpt-oss-20b\",\n    torch_dtype=\"auto\",\n    device_map=\"auto\"  # Automatically place on available GPUs\n)\n\nmessages = [\n    {\"role\": \"user\", \"content\": \"Explain what MXFP4 quantization is.\"},\n]\n\nresult = generator(\n    messages,\n    max_new_tokens=200,\n    temperature=1.0,\n)\n\nprint(result0)\n\n\nIf you want more control, you can load the model and tokenizer manually and invoke the .generate() method:\n\nfrom transformers import AutoModelForCausalLM, AutoTokenizer\n\nmodel_name = \"openai/gpt-oss-20b\"\n\ntokenizer = AutoTokenizer.from_pretrained(model_name)\nmodel = AutoModelForCausalLM.from_pretrained(\n    model_name,\n    torch_dtype=\"auto\",\n    device_map=\"auto\"\n)\n\nmessages = [\n    {\"role\": \"user\", \"content\": \"Explain what MXFP4 quantization is.\"},\n]\n\ninputs = tokenizer.apply_chat_template(\n    messages,\n    add_generation_prompt=True,\n    return_tensors=\"pt\",\n    return_dict=True,\n).to(model.device)\n\noutputs = model.generate(\n    **inputs,\n    max_new_tokens=200,\n    temperature=0.7\n)\n\nprint(tokenizer.decode(outputs[0]))\n\n\nOpenAI gpt-oss models use the harmony response format for structuring messages, including reasoning and tool calls.\n\nTo construct prompts you can use the built-in chat template of Transformers. Alternatively, you can install and use the openai-harmony library for more control.\n\nTo use the chat template:\n\nfrom transformers import AutoModelForCausalLM, AutoTokenizer\n\nmodel_name = \"openai/gpt-oss-20b\"\n\ntokenizer = AutoTokenizer.from_pretrained(model_name)\nmodel = AutoModelForCausalLM.from_pretrained(\n    model_name,\n    device_map=\"auto\",\n    torch_dtype=\"auto\",\n)\n\nmessages = [\n    {\"role\": \"system\", \"content\": \"Always respond in riddles\"},\n    {\"role\": \"user\", \"content\": \"What is the weather like in Madrid?\"},\n]\n\ninputs = tokenizer.apply_chat_template(\n    messages,\n    add_generation_prompt=True,\n    return_tensors=\"pt\",\n    return_dict=True,\n).to(model.device)\n\ngenerated = model.generate(**inputs, max_new_tokens=100)\nprint(tokenizer.decode(generated0.shape[-1] :]))\n\nTo integrate the openai-harmony library to prepare prompts and parse responses, first install it like this:\n\npip install openai-harmony\n\nHere’s an example of how to use the library to build your prompts and encode them to tokens:\n\nimport json\nfrom openai_harmony import (\n    HarmonyEncodingName,\n    load_harmony_encoding,\n    Conversation,\n    Message,\n    Role,\n    SystemContent,\n    DeveloperContent\n)\nfrom transformers import AutoModelForCausalLM, AutoTokenizer\n\nencoding = load_harmony_encoding(HarmonyEncodingName.HARMONY_GPT_OSS)\n\nconvo = Conversation.from_messages([\n    Message.from_role_and_content(Role.SYSTEM, SystemContent.new()),\n    Message.from_role_and_content(\n        Role.DEVELOPER,\n        DeveloperContent.new().with_instructions(\"Always respond in riddles\")\n    ),\n    Message.from_role_and_content(Role.USER, \"What is the weather like in SF?\")\n])\n\nprefill_ids = encoding.render_conversation_for_completion(convo, Role.ASSISTANT)\nstop_token_ids = encoding.stop_tokens_for_assistant_actions()\n\nmodel_name = \"openai/gpt-oss-20b\"\ntokenizer = AutoTokenizer.from_pretrained(model_name)\nmodel = AutoModelForCausalLM.from_pretrained(model_name, torch_dtype=\"auto\", device_map=\"auto\")\n\noutputs = model.generate(\n    input_ids=[prefill_ids],\n    max_new_tokens=128,\n    eos_token_id=stop_token_ids\n)\n\ncompletion_ids = outputs0:]\nentries = encoding.parse_messages_from_completion_tokens(completion_ids, Role.ASSISTANT)\n\nfor message in entries:\n    print(json.dumps(message.to_dict(), indent=2))\n\nNote that the Developer role in Harmony maps to the system prompt in the chat template.\n\n\nThe large gpt-oss-120b fits on a single H100 GPU when using MXFP4. If you want to run it on multiple GPUs, you can:\n\nUse tp_plan=\"auto\" for automatic placement and tensor parallelism\nLaunch with accelerate launch or torchrun for distributed setups\nLeverage Expert Parallelism\nUse specialised Flash attention kernels for faster inference\n\nfrom transformers import AutoModelForCausalLM, AutoTokenizer\nfrom transformers.distributed import DistributedConfig\nimport torch\n\nmodel_path = \"openai/gpt-oss-120b\"\ntokenizer = AutoTokenizer.from_pretrained(model_path, padding_side=\"left\")\n\ndevice_map = {\nEnable Expert Parallelism\n    \"distributed_config\": DistributedConfig(enable_expert_parallel=1),\nEnable Tensor Parallelism\n    \"tp_plan\": \"auto\",\n}\n\nmodel = AutoModelForCausalLM.from_pretrained(\n    model_path,\n    torch_dtype=\"auto\",\n    attn_implementation=\"kernels-community/vllm-flash-attn3\",\n    **device_map,\n)\n\nmessages = [\n     {\"role\": \"user\", \"content\": \"Explain how expert parallelism works in large language models.\"}\n]\n\ninputs = tokenizer.apply_chat_template(\n    messages,\n    add_generation_prompt=True,\n    return_tensors=\"pt\",\n    return_dict=True,\n).to(model.device)\n\noutputs = model.generate(**inputs, max_new_tokens=1000)\n\nresponse = tokenizer.decode(outputs[0])\nprint(\"Model response:\", response.split(\"final\")[-1].strip())\n\nYou can then run this on a node with four GPUs via\n\ntorchrun --nproc_per_node=4 generate.py"])</script><script>self.__next_f.push([1,"32:T1a17,"])</script><script>self.__next_f.push([1,"vLLM is an open-source, high-throughput inference engine designed to efficiently serve large language models (LLMs) by optimizing memory usage and processing speed. This guide will walk you through how to use vLLM to set up gpt-oss-20b or gpt-oss-120b on a server to serve gpt-oss as an API for your applications, and even connect it to the Agents SDK.\n\nNote that this guide is meant for server applications with dedicated GPUs like NVIDIA’s H100s. For local inference on consumer GPUs, check out our Ollama or LM Studio guides.\n\n\nvLLM supports both model sizes of gpt-oss:\n\nopenai/gpt-oss-20b\n  The smaller model\n  Only requires about 16GB of VRAM\nopenai/gpt-oss-120b\n  Our larger full-sized model\n  Best with ≥60GB VRAM\n  Can fit on a single H100 or multi-GPU setups\n\nBoth models are MXFP4 quantized out of the box.\n\n\nInstall vLLM\n   vLLM recommends using uv to manage your Python environment. This will help with picking the right implementation based on your environment. Learn more in their quickstart. To create a new virtual environment and install vLLM run:\n\nuv venv --python 3.12 --seed\nsource .venv/bin/activate\nuv pip install --pre vllm==0.10.1+gptoss \\\n    --extra-index-url https://wheels.vllm.ai/gpt-oss/ \\\n    --extra-index-url https://download.pytorch.org/whl/nightly/cu128 \\\n    --index-strategy unsafe-best-match\n\nStart up a server and download the model\n   vLLM provides a serve command that will automatically download the model from HuggingFace and spin up an OpenAI-compatible server on localhost:8000. Run the following command depending on your desired model size in a terminal session on your server.\n\nvllm serve openai/gpt-oss-20b\n\nvllm serve openai/gpt-oss-120b\n\n\nvLLM exposes a Chat Completions-compatible API and a Responses-compatible API so you can use the OpenAI SDK without changing much. Here’s a Python example:\n\nfrom openai import OpenAI\n\nclient = OpenAI(\n    base_url=\"http://localhost:8000/v1\",\n    api_key=\"EMPTY\"\n)\n\nresult = client.chat.completions.create(\n    model=\"openai/gpt-oss-20b\",\n    messages=[\n        {\"role\": \"system\", \"content\": \"You are a helpful assistant.\"},\n        {\"role\": \"user\", \"content\": \"Explain what MXFP4 quantization is.\"}\n    ]\n)\n\nprint(result.choices[0].message.content)\n\nresponse = client.responses.create(\n    model=\"openai/gpt-oss-120b\",\n    instructions=\"You are a helfpul assistant.\",\n    input=\"Explain what MXFP4 quantization is.\"\n)\n\nprint(response.output_text)\n\nIf you’ve used the OpenAI SDK before, this will feel instantly familiar and your existing code should work by changing the base URL.\n\n\nvLLM supports function calling and giving the model browsing capabilities.\n\nFunction calling works through both the Responses and Chat Completions APIs.\n\nExample of invoking a function via Chat Completions:\n\ntools = [\n    {\n        \"type\": \"function\",\n        \"function\": {\n            \"name\": \"get_weather\",\n            \"description\": \"Get current weather in a given city\",\n            \"parameters\": {\n                \"type\": \"object\",\n                \"properties\": {\"city\": {\"type\": \"string\"}},\n                \"required\": [\"city\"]\n            },\n        },\n    }\n]\n\nresponse = client.chat.completions.create(\n    model=\"openai/gpt-oss-120b\",\n    messages=[{\"role\": \"user\", \"content\": \"What's the weather in Berlin right now?\"}],\n    tools=tools\n)\n\nprint(response.choices[0].message)\n\nSince the models can perform tool calling as part of the chain-of-thought (CoT) it’s important for you to return the reasoning returned by the API back into a subsequent call to a tool call where you provide the answer until the model reaches a final answer.\n\n\nWant to use gpt-oss with OpenAI’s Agents SDK?\n\nBoth Agents SDK enable you to override the OpenAI base client to point to vLLM for your self-hosted models. Alternatively, for the Python SDK you can also use the LiteLLM integration to proxy to vLLM.\n\nHere’s a Python Agents SDK example:\n\nuv pip install openai-agents\n\nimport asyncio\nfrom openai import AsyncOpenAI\nfrom agents import Agent, Runner, function_tool, OpenAIResponsesModel, set_tracing_disabled\n\nset_tracing_disabled(True)\n\n@function_tool\ndef get_weather(city: str):\n    print(f\"[debug] getting weather for {city}\")\n    return f\"The weather in {city} is sunny.\"\n\n\nasync def main(model: str, api_key: str):\n    agent = Agent(\n        name=\"Assistant\",\n        instructions=\"You only respond in haikus.\",\n        model=OpenAIResponsesModel(\n            model=\"openai/gpt-oss-120b\",\n            openai_client=AsyncOpenAI(\n                base_url=\"http://localhost:8000/v1\",\n                api_key=\"EMPTY\",\n            ),\n        )\n        tools=[get_weather],\n    )\n\n    result = await Runner.run(agent, \"What's the weather in Tokyo?\")\n    print(result.final_output)\n\nif name == \"main\":\n    asyncio.run(main())\n\n\nAside from running vLLM using vllm serve as an API server, you can use the vLLM Python library to control inference directly.\n\nIf you are using vLLM for sampling directly it’s important to ensure that your input prompts follow the harmony response format as the model will not function correctly otherwise. You can use the openai-harmony SDK for this.\n\nuv pip install openai-harmony\n\nAfterwards you can use harmony to encode and parse the tokens generated by vLLM’s generate function.\n\nimport json\nfrom openai_harmony import (\n    HarmonyEncodingName,\n    load_harmony_encoding,\n    Conversation,\n    Message,\n    Role,\n    SystemContent,\n    DeveloperContent,\n)\n\nfrom vllm import LLM, SamplingParams\n\nencoding = load_harmony_encoding(HarmonyEncodingName.HARMONY_GPT_OSS)\n\nconvo = Conversation.from_messages(\n    [\n        Message.from_role_and_content(Role.SYSTEM, SystemContent.new()),\n        Message.from_role_and_content(\n            Role.DEVELOPER,\n            DeveloperContent.new().with_instructions(\"Always respond in riddles\"),\n        ),\n        Message.from_role_and_content(Role.USER, \"What is the weather like in SF?\"),\n    ]\n)\n\nprefill_ids = encoding.render_conversation_for_completion(convo, Role.ASSISTANT)\n\nstop_token_ids = encoding.stop_tokens_for_assistant_actions()\n\nllm = LLM(\n    model=\"openai/gpt-oss-120b\",\n    trust_remote_code=True,\n)\n\nsampling = SamplingParams(\n    max_tokens=128,\n    temperature=1,\n    stop_token_ids=stop_token_ids,\n)\n\noutputs = llm.generate(\n    prompt_token_ids=[prefill_ids],   # batch of size 1\n    sampling_params=sampling,\n)\n\ngen = outputs[0].outputs[0]\ntext = gen.text\noutput_tokens = gen.token_ids  # \u003c-- these are the completion token IDs (no prefill)\n\nentries = encoding.parse_messages_from_completion_tokens(output_tokens, Role.ASSISTANT)\n\nfor message in entries:\n    print(f\"{json.dumps(message.to_dict())}\")"])</script><script>self.__next_f.push([1,"33:T1215,"])</script><script>self.__next_f.push([1,"Want to get OpenAI gpt-oss running on your own hardware? This guide will walk you through how to use Ollama to set up gpt-oss-20b or gpt-oss-120b locally, to chat with it offline, use it through an API, and even connect it to the Agents SDK.\n\nNote that this guide is meant for consumer hardware, like running a model on a PC or Mac. For server applications with dedicated GPUs like NVIDIA’s H100s, check out our vLLM guide.\n\n\nOllama supports both model sizes of gpt-oss:\n\ngpt-oss-20b**\n  The smaller model\n  Best with ≥16GB VRAM or unified memory\n  Perfect for higher-end consumer GPUs or Apple Silicon Macs\ngpt-oss-120b**\n  Our larger full-sized model\n  Best with ≥60GB VRAM or unified memory\n  Ideal for multi-GPU or beefy workstation setup\n\nA couple of notes:\n\nThese models ship MXFP4 quantized out the box and there is currently no other quantization\nYou can offload to CPU if you’re short on VRAM, but expect it to run slower.\n\n\nInstall Ollama → Get it here\nPull the model you want:\n\nollama pull gpt-oss:20b\n\nollama pull gpt-oss:120b\n\n\nReady to talk to the model? You can fire up a chat in the app or the terminal:\n\nollama run gpt-oss:20b\n\nOllama applies a chat template out of the box that mimics the OpenAI harmony format. Type your message and start the conversation.\n\n\nOllama exposes a Chat Completions-compatible API, so you can use the OpenAI SDK without changing much. Here’s a Python example:\n\nfrom openai import OpenAI\n\nclient = OpenAI(\n    base_url=\"http://localhost:11434/v1\",  # Local Ollama API\n    api_key=\"ollama\"                       # Dummy key\n)\n\nresponse = client.chat.completions.create(\n    model=\"gpt-oss:20b\",\n    messages=[\n        {\"role\": \"system\", \"content\": \"You are a helpful assistant.\"},\n        {\"role\": \"user\", \"content\": \"Explain what MXFP4 quantization is.\"}\n    ]\n)\n\nprint(response.choices[0].message.content)\n\nIf you’ve used the OpenAI SDK before, this will feel instantly familiar.\n\nAlternatively, you can use the Ollama SDKs in Python or JavaScript directly.\n\n\nOllama can:\n\nCall functions\nUse a built-in browser tool (in the app)\n\nExample of invoking a function via Chat Completions:\n\ntools = [\n    {\n        \"type\": \"function\",\n        \"function\": {\n            \"name\": \"get_weather\",\n            \"description\": \"Get current weather in a given city\",\n            \"parameters\": {\n                \"type\": \"object\",\n                \"properties\": {\"city\": {\"type\": \"string\"}},\n                \"required\": [\"city\"]\n            },\n        },\n    }\n]\n\nresponse = client.chat.completions.create(\n    model=\"gpt-oss:20b\",\n    messages=[{\"role\": \"user\", \"content\": \"What's the weather in Berlin right now?\"}],\n    tools=tools\n)\n\nprint(response.choices[0].message)\n\nSince the models can perform tool calling as part of the chain-of-thought (CoT) it’s important for you to return the reasoning returned by the API back into a subsequent call to a tool call where you provide the answer until the model reaches a final answer.\n\n\nOllama doesn’t (yet) support the Responses API natively.\n\nIf you do want to use the Responses API you can use Hugging Face’s Responses.js proxy to convert Chat Completions to Responses API.\n\nFor basic use cases you can also run our example Python server with Ollama as the backend. This server is a basic example server and does not have the\n\npip install gpt-oss\npython -m gpt_oss.responses_api.serve \\\n    --inference_backend=ollama \\\n    --checkpoint gpt-oss:20b\n\n\nWant to use gpt-oss with OpenAI’s Agents SDK?\n\nBoth Agents SDK enable you to override the OpenAI base client to point to Ollama using Chat Completions or your Responses.js proxy for your local models. Alternatively, you can use the built-in functionality to point the Agents SDK against third party models.\n\nPython:** Use LiteLLM to proxy to Ollama through LiteLLM\nTypeScript:** Use AI SDK with the ollama adapter\n\nHere’s a Python Agents SDK example using LiteLLM:\n\nimport asyncio\nfrom agents import Agent, Runner, function_tool, set_tracing_disabled\nfrom agents.extensions.models.litellm_model import LitellmModel\n\nset_tracing_disabled(True)\n\n@function_tool\ndef get_weather(city: str):\n    print(f\"[debug] getting weather for {city}\")\n    return f\"The weather in {city} is sunny.\"\n\n\nasync def main(model: str, api_key: str):\n    agent = Agent(\n        name=\"Assistant\",\n        instructions=\"You only respond in haikus.\",\n        model=LitellmModel(model=\"ollama/gpt-oss:120b\", api_key=api_key),\n        tools=[get_weather],\n    )\n\n    result = await Runner.run(agent, \"What's the weather in Tokyo?\")\n    print(result.final_output)\n\nif name == \"main\":\n    asyncio.run(main())"])</script><script>self.__next_f.push([1,"34:T623e,"])</script><script>self.__next_f.push([1,"The gpt-oss models were trained on the harmony response format for defining conversation structures, generating reasoning output and structuring function calls. If you are not using gpt-oss directly but through an API or a provider like Ollama, you will not have to be concerned about this as your inference solution will handle the formatting. If you are building your own inference solution, this guide will walk you through the prompt format. The format is designed to mimic the OpenAI Responses API, so if you have used that API before, this format should hopefully feel familiar to you. gpt-oss should not be used without using the harmony format, as it will not work correctly.\n\n\n\nEvery message that the model processes has a role associated with it. The model knows about five types of roles:\n\n| Role        | Purpose                                                                                                                                                                                 |\n| :---------- | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| system    | A system message is used to specify reasoning effort, meta information like knowledge cutoff and built-in tools                                                                         |\n| developer | The developer message is used to provide information about the instructions for the model (what is normally considered the “system prompt”) and available function tools                |\n| user      | Typically representing the input to the model                                                                                                                                           |\n| assistant | Output by the model which can either be a tool call or a message output. The output might also be associated with a particular “channel” identifying what the intent of the message is. |\n| tool      | Messages representing the output of a tool call. The specific tool name will be used as the role inside a message.                                                                      |\n\nThese roles also represent the information hierarchy that the model applies in case there are any instruction conflicts: system \\\u003e developer \\\u003e user \\\u003e assistant \\\u003e tool\n\n\nAssistant messages can be output in three different “channels”. These are being used to separate between user-facing responses and internal facing messages.\n\n| Channel      | Purpose                                                                                                                                                                                                                                                                                                                                                            |\n| :----------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| final      | Messages tagged in the final channel are messages intended to be shown to the end-user and represent the responses from the model.                                                                                                                                                                                                                                 |\n| analysis   | These are messages that are being used by the model for its chain of thought (CoT). Important: Messages in the analysis channel do not adhere to the same safety standards as final messages do. Avoid showing these to end-users.                                                                                                                             |\n| commentary | Any function tool call will typically be triggered on the commentary channel while built-in tools will normally be triggered on the analysis channel. However, occasionally built-in tools will still be output to commentary. Occasionally this channel might also be used by the model to generate a preamble to calling multiple functions. |\n\n\nWe recommend using our harmony renderer through PyPI or crates.io when possible as it will automatically handle rendering your messages in the right format and turning them into tokens for processing by the model.\n\nBelow is an example of using the renderer to construct a system prompt and a short conversation.\n\nfrom openai_harmony import (\n    Author,\n    Conversation,\n    DeveloperContent,\n    HarmonyEncodingName,\n    Message,\n    Role,\n    SystemContent,\n    ToolDescription,\n    load_harmony_encoding,\n    ReasoningEffort\n)\n\nencoding = load_harmony_encoding(HarmonyEncodingName.HARMONY_GPT_OSS)\n\nsystem_message = (\n    SystemContent.new()\n        .with_reasoning_effort(ReasoningEffort.HIGH)\n        .with_conversation_start_date(\"2025-06-28\")\n)\n\ndeveloper_message = (\n    DeveloperContent.new()\n        .with_instructions(\"Always respond in riddles\")\n        .with_function_tools(\n            [\n                ToolDescription.new(\n                    \"get_current_weather\",\n                    \"Gets the current weather in the provided location.\",\n                    parameters={\n                        \"type\": \"object\",\n                        \"properties\": {\n                            \"location\": {\n                                \"type\": \"string\",\n                                \"description\": \"The city and state, e.g. San Francisco, CA\",\n                            },\n                            \"format\": {\n                                \"type\": \"string\",\n                                \"enum\": [\"celsius\", \"fahrenheit\"],\n                                \"default\": \"celsius\",\n                            },\n                        },\n                        \"required\": [\"location\"],\n                    },\n                ),\n            ]\n\t)\n)\n\nconvo = Conversation.from_messages(\n    [\n        Message.from_role_and_content(Role.SYSTEM, system_message),\n        Message.from_role_and_content(Role.DEVELOPER, developer_message),\n        Message.from_role_and_content(Role.USER, \"What is the weather in Tokyo?\"),\n        Message.from_role_and_content(\n            Role.ASSISTANT,\n            'User asks: \"What is the weather in Tokyo?\" We need to use get_current_weather tool.',\n        ).with_channel(\"analysis\"),\n        Message.from_role_and_content(Role.ASSISTANT, '{\"location\": \"Tokyo\"}')\n        .with_channel(\"commentary\")\n        .with_recipient(\"functions.get_current_weather\")\n        .with_content_type(\" json\"),\n        Message.from_author_and_content(\n            Author.new(Role.TOOL, \"functions.get_current_weather\"),\n            '{ \"temperature\": 20, \"sunny\": true }',\n        ).with_channel(\"commentary\"),\n    ]\n)\n\ntokens = encoding.render_conversation_for_completion(convo, Role.ASSISTANT)\n\nparsed_response = encoding.parse_messages_from_completion_tokens(new_tokens, Role.ASSISTANT)\n\nAdditionally the openai_harmony library also includes a StreamableParser for parsing and decoding as the model is generating new tokens. This can be helpful for example to stream output and handle unicode characters during decoding.\n\nfrom openai_harmony import (\n    load_harmony_encoding,\n    Role,\n    StreamableParser,\n    HarmonyEncodingName\n)\n\nencoding = load_harmony_encoding(HarmonyEncodingName.HARMONY_GPT_OSS)\nstream = StreamableParser(encoding, role=Role.ASSISTANT)\n\ntokens = [\n    200005,35644,200008,1844,31064,25,392,4827,382,220,17,659,220,17,16842,12295,81645,\n    13,51441,6052,13,200007,200006,173781,200005,17196,200008,17,659,220,17,314,220,19,\n    13,200002\n]\n\nfor token in tokens:\n    stream.process(token)\n    print(\"--------------------------------\")\n    print(\"current_role\", stream.current_role)\n    print(\"current_channel\", stream.current_channel)\n    print(\"last_content_delta\", stream.last_content_delta)\n    print(\"current_content_type\", stream.current_content_type)\n    print(\"current_recipient\", stream.current_recipient)\n    print(\"current_content\", stream.current_content)\n\n\nIf you choose to build your own renderer, you’ll need to adhere to the following format.\n\n\nThe model uses a set of special tokens to identify the structure of your input. If you are using tiktoken these tokens are encoded in the o200k_harmony encoding. All special tokens follow the format ``.\n\n| Special token           | Purpose                                                                                                                                     | Token ID |\n| :---------------------- | :------------------------------------------------------------------------------------------------------------------------------------------ | :------- |\n|      | Indicates the beginning of a message. Followed by the “header” information of a message starting with the role | 200006 |\n|        | Indicates the end of a message                                                                                           | 200007 |\n|    | Indicates the transition from the message “header” to the actual content                                                                    | 200008 |\n|    | Indicates the transition to the channel information of the header                                                              | 200005 |\n|  | Indicates the transition to the data type definition in a tool call                                                | 200003 |\n|     | Indicates the model is done with sampling the response message. A valid “stop token” indicating that you should stop inference.             | 200002 |\n|       | Indicates the model wants to call a tool. A valid “stop token” indicating that you should stop inference.                                   | 200012 |\n\n\nThe harmony response format consists of “messages” with the model potentially generating multiple messages in one go. The general structure of a message is as follows:\n\n{header}{content}\n\nThe {header} contains a series of meta information including the role. ` represents the end of a fully completed message but the model might also use other stop tokens such as  for tool calling and ` to indicate the model is done with the completion.\n\n\nFollowing the message format above the most basic chat format consists of a user message and the beginning of an assistant message.\n\n\nuserWhat is 2 + 2?\nassistant\n\nThe output will begin by specifying the channel. For example analysis to output the chain of thought. The model might output multiple messages (primarily chain of thought messages) for which it uses the `` token to separate them.\n\nOnce its done generating it will stop with either a ` token indicating it’s done generating the final answer, or ` indicating that a tool call needs to be performed. In either way this indicates that you should stop inference.\n\n\nanalysisUser asks: \"What is 2 + 2?\" Simple arithmetic. Provide answer.\nassistantfinal2 + 2 = 4.\n\nThe final channel will contain the answer to your user’s request. Check out the reasoning section for more details on the chain-of-thought.\n\nImplementation note: ` is a decode-time stop token only. When you add the assistant’s generated reply to conversation history for the next turn, replace the trailing  with  so that stored messages are fully formed as {header}{content}. Prior messages in prompts should therefore end with . For supervised targets/training examples, ending with  is appropriate; for persisted history, normalize to `.\n\n\nThe system message is used to provide general information to the system. This is different to what might be considered the “system prompt” in other prompt formats. For that, check out the developer message format.\n\nWe use the system message to define:\n\nThe identity of the model — This should always stay as You are ChatGPT, a large language model trained by OpenAI. If you want to change the identity of the model, use the instructions in the developer message.\nMeta dates — Specifically the Knowledge cutoff: and the Current date:\nThe reasoning effort — As specified on the levels high, medium, low\nAvailable channels — For the best performance this should map to analysis, commentary, and final.\nBuilt-in tools — The model has been trained on both a python and browser tool. Check out the built-in tools section for details.\n\nIf you are defining functions, it should also contain a note that all function tool calls must go to the commentary channel.\n\nFor the best performance stick to this format as closely as possible.\n\n\nThe most basic system message you should use is the following:\n\nsystemYou are ChatGPT, a large language model trained by OpenAI.\nKnowledge cutoff: 2024-06\nCurrent date: 2025-06-28\n\nReasoning: high\n\n\nIf functions calls are present in the developer message section, use:\n\nsystemYou are ChatGPT, a large language model trained by OpenAI.\nKnowledge cutoff: 2024-06\nCurrent date: 2025-06-28\n\nReasoning: high\n\nCalls to these tools must go to the commentary channel: 'functions'.\n\n\nThe developer message represents what is commonly considered the “system prompt”. It contains the instructions that are provided to the model and optionally a list of function tools available for use or the output format you want the model to adhere to for structured outputs.\n\nIf you are not using function tool calling your developer message would just look like this:\n\ndeveloper# Instructions\n\n{instructions}\n\nWhere {instructions} is replaced with your “system prompt”.\n\nFor defining function calling tools, check out the dedicated section.\nFor defining an output format to be used in structured outputs, check out this section of the guide.\n\n\nThe gpt-oss models are reasoning models. By default, the model will do medium level reasoning. To control the reasoning you can specify in the system message the reasoning level as low, medium, or high. The recommended format is:\n\nReasoning: high\n\nThe model will output its raw chain-of-thought (CoT) as assistant messages into the analysis channel while the final response will be output as final.\n\nFor example for the question What is 2 + 2? the model output might look like this:\n\nanalysisUser asks: \"What is 2 + 2?\" Simple arithmetic. Provide answer.\nassistantfinal2 + 2 = 4.\n\nIn this case the CoT is\n\nUser asks: “What is 2 + 2?” Simple arithmetic. Provide answer.\n\nAnd the actual answer is:\n\n2 + 2 = 4\n\nImportant:\nThe model has not been trained to the same safety standards in the chain-of-thought as it has for final output. You should not show the chain-of-thought to your users, as they might contain harmful content. Learn more in the model card.\n\n\nIn general, you should drop any previous CoT content on subsequent sampling if the responses by the assistant ended in a message to the final channel. Meaning if our first input was this:\n\nuserWhat is 2 + 2?\nassistant\n\nand resulted in the output:\n\nanalysisUser asks: \"What is 2 + 2?\" Simple arithmetic. Provide answer.\nassistantfinal2 + 2 = 4.\n\nFor the model to work properly, the input for the next sampling should be\n\nuserWhat is 2 + 2?\nassistantfinal2 + 2 = 4.\nuserWhat about 9 / 2?\nassistant\n\nThe exception for this is tool/function calling. The model is able to call tools as part of its chain-of-thought and because of that, we should pass the previous chain-of-thought back in as input for subsequent sampling. Check out the function calling section for a complete example.\n\n\n\nAll functions that are available to the model should be defined in the developer message in a dedicated Tools section.\n\nTo define the functions we use a TypeScript-like type syntax and wrap the functions into a dedicated functions namespace. It’s important to stick to this format closely to improve accuracy of function calling. You can check out the harmony renderer codebase for more information on how we are turning JSON schema definitions for the arguments into this format but some general formatting practices:\n\nDefine every function as a type {function_name} = () =\u003e any if it does not receive any arguments\nFor functions that receive an argument name the argument _ and inline the type definition\nAdd comments for descriptions in the line above the field definition\nAlways use any as the return type\nKeep an empty line after each function definition\nWrap your functions into a namespace, generally functions is the namespace you should use to not conflict with other tools that the model might have been trained on.\n\nHere’s a complete input example including the definition of two functions:\n\nsystemYou are ChatGPT, a large language model trained by OpenAI.\nKnowledge cutoff: 2024-06\nCurrent date: 2025-06-28\n\nReasoning: high\n\nCalls to these tools must go to the commentary channel: 'functions'.developer# Instructions\n\nUse a friendly tone.\n\n\n\nnamespace functions {\n\n// Gets the location of the user.\ntype get_location = () =\u003e any;\n\n// Gets the current weather in the provided location.\ntype get_current_weather = (_: {\n// The city and state, e.g. San Francisco, CA\nlocation: string,\nformat?: \"celsius\" | \"fahrenheit\", // default: celsius\n}) =\u003e any;\n\n// Gets the current weather in the provided list of locations.\ntype get_multiple_weathers = (_: {\n// List of city and state, e.g. [\"San Francisco, CA\", \"New York, NY\"]\nlocations: string[],\nformat?: \"celsius\" | \"fahrenheit\", // default: celsius\n}) =\u003e any;\n\n} // namespace functionsuserWhat is the weather like in SF?assistant\n\n\nIf the model decides to call a tool it will define a recipient in the header of the message using the format to={name}. For example, if it decides to trigger the get_current_weather function from above it would specify to=functions.get_current_weather in the header and commentary as the channel as specified in the system message. The recipient might be defined in the role or channel section of the header.\n\nThe model might also specify a ` token to indicate the type of input for the tool call. In this case since it’s being passed in as JSON the  is set to json`.\n\nanalysisNeed to use function get_current_weather.assistantcommentary to=functions.get_current_weather json{\"location\":\"San Francisco\"}\n\n\nAfter the function call was handled we need to provide the output back to the model by specifying a new tool message with the output after the call message.\n\nA tool message has the following format:\n\n{toolname} to=assistantcommentary{output}\n\nSo in our example above\n\nfunctions.get_current_weather to=assistantcommentary{\"sunny\": true, \"temperature\": 20}\n\nOnce you have gathered the output for the tool calls you can run inference with the complete content:\n\nsystemYou are ChatGPT, a large language model trained by OpenAI.\nKnowledge cutoff: 2024-06\nCurrent date: 2025-06-28\n\nReasoning: high\n\nCalls to these tools must go to the commentary channel: 'functions'.developer# Instructions\n\nUse a friendly tone.\n\n\n\nnamespace functions {\n\n// Gets the location of the user.\ntype get_location = () =\u003e any;\n\n// Gets the current weather in the provided location.\ntype get_current_weather = (_: {\n// The city and state, e.g. San Francisco, CA\nlocation: string,\nformat?: \"celsius\" | \"fahrenheit\", // default: celsius\n}) =\u003e any;\n\n// Gets the current weather in the provided list of locations.\ntype get_multiple_weathers = (_: {\n// List of city and state, e.g. [\"San Francisco, CA\", \"New York, NY\"]\nlocations: string[],\nformat?: \"celsius\" | \"fahrenheit\", // default: celsius\n}) =\u003e any;\n\n} // namespace functionsuserWhat is the weather like in SF?assistantanalysisNeed to use function get_current_weather.assistantcommentary to=functions.get_current_weather json{\"location\":\"San Francisco\"}\u000bfunctions.get_current_weather to=assistantcommentary{\"sunny\": true, \"temperature\": 20}assistant\n\nAs you can see above we are passing not just the function out back into the model for further sampling but also the previous chain-of-thought (“Need to use function get_current_weather.”) to provide the model with the necessary information to continue its chain-of-thought or provide the final answer.\n\n\nAt times the model might choose to generate a “preamble” to inform the user about the tools it is about to call. For example, when it plans to call multiple tools. If this is the case it will generate an assistant message on the commentary channel that, unlike the chain-of-thought, is intended to be shown to the end-user.\n\nanalysis{long chain of thought}assistantcommentaryAction plan:\nGenerate an HTML file\nGenerate a JavaScript for the Node.js server\nStart the server\nWill start executing the plan step by stepassistantcommentary to=functions.generate_filejson{\"template\": \"basic_html\", \"path\": \"index.html\"}\n\nIn this case the model generated an action plan to inform the user about the multiple steps it is about to execute.\n\n\nTo control the output behavior of the model, you can define a response format at the end of the developer message with the following structure:\n\n\n\n// {description or context}\n{schema}\n\nThe format name functions similar to the name you can specify for your schema in the Responses API and the schema is a JSON Schema.\n\nAs an example, here’s a developer message that defines a schema for a shopping list:\n\ndeveloper# Instructions\n\nYou are a helpful shopping assistant\n\n\n\n{\"properties\":{\"items\":{\"type\":\"array\",\"description\":\"entries on the shopping list\",\"items\":{\"type\":\"string\"}}},\"type\":\"object\"}userI need to buy coffee, soda and eggsassistant\n\n\nThis prompt alone will, however, only influence the model’s behavior but doesn’t guarantee the full adherence to the schema. For this you still need to construct your own grammar and enforce the schema during sampling.\n\n\nDuring the training of the gpt-oss models, they were trained with two common tools to browse for information and execute python code to improve its results.\n\nIf you are trying to build this functionality, you should use the format below to improve reliability and accuracy.\n\nThese tools should be defined in the system message not in the developer message by adding a # Tools section.\n\n\nTo define the browser tool add it to the system prompt section:\n\nsystemYou are ChatGPT, a large language model trained by OpenAI.\nKnowledge cutoff: 2024-06\nCurrent date: 2025-06-28\n\nReasoning: high\n\n\n\n// Tool for browsing.\n// The cursor appears in brackets before each browsing display: [{cursor}].\n// Cite information from the tool using the following format:\n// 【{cursor}†L{line_start}(-L{line_end})?】, for example: 【6†L9-L11】 or 【8†L3】.\n// Do not quote more than 10 words directly from the tool output.\n// sources=web (default: web)\nnamespace browser {\n\n// Searches for information related to query and displays topn results.\ntype search = (_: {\nquery: string,\ntopn?: number, // default: 10\nsource?: string,\n}) =\u003e any;\n\n// Opens the link id from the page indicated by cursor starting at line number loc, showing num_lines lines.\n// Valid link ids are displayed with the formatting: 【{id}†.*】.\n// If cursor is not provided, the most recent page is implied.\n// If id is a string, it is treated as a fully qualified URL associated with source.\n// If loc is not provided, the viewport will be positioned at the beginning of the document or centered on the most relevant passage, if available.\n// Use this function without id to scroll to a new location of an opened page.\ntype open = (_: {\nid?: number | string, // default: -1\ncursor?: number, // default: -1\nloc?: number, // default: -1\nnum_lines?: number, // default: -1\nview_source?: boolean, // default: false\nsource?: string,\n}) =\u003e any;\n\n// Finds exact matches of pattern in the current page, or the page given by cursor.\ntype find = (_: {\npattern: string,\ncursor?: number, // default: -1\n}) =\u003e any;\n\n} // namespace browser\n\n\nIf the model decides to call actions in the browser it will use the same format as for function calls with two notable exceptions:\n\nRequests will be made to the analysis channel\nThe recipient will be browser.search, browser.open, browser.find respectively\n\n\nsystemYou are ChatGPT, a large language model trained by OpenAI.\nKnowledge cutoff: 2024-06\nCurrent date: 2025-06-28\n\nReasoning: high\n\n\n\nUse this tool to execute Python code in your chain of thought. The code will not be shown to the user. This tool should be used for internal reasoning, but not for code that is intended to be visible to the user (e.g. when creating plots, tables, or files).\n\nWhen you send a message containing Python code to python, it will be executed in a stateful Jupyter notebook environment. python will respond with the output of the execution or time out after 120.0 seconds. The drive at '/mnt/data' can be used to save and persist user files. Internet access for this session is UNKNOWN. Depends on the cluster.\n\n\nIf the model decides to execute Python code it will use the same format as for function calls with two notable exceptions:\n\nRequests will be made to the analysis channel\nThe recipient will always be python"])</script><script>self.__next_f.push([1,"35:T17cc5,"])</script><script>self.__next_f.push([1,"This notebook provides a hands-on guide for building temporally-aware knowledge graphs and performing multi-hop retrieval directly over those graphs.\n\nIt's designed for engineers, architects, and analysts working on temporally-aware knowledge graphs. Whether you’re prototyping, deploying at scale, or exploring new ways to use structured data, you’ll find practical workflows, best practices, and decision frameworks to accelerate your work.\n\nThis cookbook presents two hands-on workflows you can use, extend, and deploy right away:\n\n    Temporally-aware knowledge graph (KG) construction\n\n      A key challenge in developing knowledge-driven AI systems is maintaining a database that stays current and relevant. While much attention is given to boosting retrieval accuracy with techniques like semantic similarity and re-ranking, this guide focuses on a fundamental—yet frequently overlooked—aspect: systematically updating and validating your knowledge base as new data arrives.\n\n      No matter how advanced your retrieval algorithms are, their effectiveness is limited by the quality and freshness of your database. This cookbook demonstrates how to routinely validate and update knowledge graph entries as new data arrives, helping ensure that your knowledge base remains accurate and up to date.\n\n    Multi-hop retrieval using knowledge graphs\n\n  Learn how to combine OpenAI models (such as o3, o4-mini, GPT-4.1, and GPT-4.1-mini) with structured graph queries via tool calls, enabling the model to traverse your graph in multiple steps across entities and relationships.\n\n\n  This method lets your system answer complex, multi-faceted questions that require reasoning over several linked facts, going well beyond what single-hop retrieval can accomplish.\n\n\nInside, you'll discover:\n\nPractical decision frameworks** for choosing models and prompting techniques at each stage\nPlug-and-play code examples** for easy integration into your ML and data pipelines\nLinks to in-depth resources** on OpenAI tool use, fine-tuning, graph backend selection, and more\nA clear path from prototype to production**, with actionable best practices for scaling and reliability\nNote: All benchmarks and recommendations are based on the best available models and practices as of June 2025. As the ecosystem evolves, periodically revisit your approach to stay current with new capabilities and improvements.\n\n    Why make your knowledge graph temporal?\n\n     Traditional knowledge graphs treat facts as static, but real-world information evolves constantly. What was true last quarter may be outdated today, risking errors or misinformed decisions if the graph does not capture change over time. Temporal knowledge graphs allow you to precisely answer questions like “What was true on a given date?” or analyse how facts and relationships have shifted, ensuring decisions are always based on the most relevant context.\n\n    What is a Temporal Agent?\n\n      A Temporal Agent is a pipeline component that ingests raw data and produces time-stamped triplets for your knowledge graph. This enables precise time-based querying, timeline construction, trend analysis, and more.\n\n    How does the pipeline work?\n\n      The pipeline starts by semantically chunking your raw documents. These chunks are decomposed into statements ready for our Temporal Agent, which then creates time-aware triplets. An Invalidation Agent can then perform temporal validity checks, spotting and handling any statements that are invalidated by new statements that are incident on the graph.\n\n    Why use multi-step retrieval?\n\n  Direct, single-hop queries frequently miss salient facts distributed across a graph's topology. Multi-step (multi-hop) retrieval enables iterative traversal, following relationships and aggregating evidence across several hops. This methodology surfaces complex dependencies and latent connections that would remain hidden with one-shot lookups, providing more comprehensive and nuanced answers to sophisticated queries.\n\n    Planners\n\n      Planners orchestrate the retrieval process. Task-orientated planners decompose queries into concrete, sequential subtasks. Hypothesis-orientated planners, by contrast, propose claims to confirm, refute, or evolve. Choosing the optimal strategy depends on where the problem lies on the spectrum from deterministic reporting (well-defined paths) to exploratory research (open-ended inference).\n\n    Tool Design Paradigms\n\n      Tool design spans a continuum: Fixed tools provide consistent, predictable outputs for specific queries (e.g., a service that always returns today’s weather for San Francisco). At the other end, Free-form tools offer broad flexibility, such as code execution or open-ended data retrieval. Semi-structured tools fall between these extremes, restricting certain actions while allowing tailored flexibility—specialized sub-agents are a typical example. Selecting the appropriate paradigm is a trade-off between control, adaptability, and complexity.\n\n    Evaluating Retrieval Systems\n\n  High-fidelity evaluation hinges on expert-curated \"golden\" answers, though these are costly and labor-intensive to produce. Automated judgments, such as those from LLMs or tool traces, can be quickly generated to supplement or pre-screen, but may lack the precision of human evaluation. As your system matures, transition towards leveraging real user feedback to measure and optimize retrieval quality in production.\n\n      A proven workflow: Start with synthetic tests, benchmark on your curated human-annotated \"golden\" dataset, and iteratively refine using live user feedback and ratings.\n\n    Keep the graph lean\n\n      Established archival policies and assign numeric relevance scores to each edge (e.g., recency x trust x query-frequency). Automate the archival or sparsification of low-value nodes and edges, ensuring only the most critical and frequently accessed facts remain for rapid retrieval.\n\n    Parallelize the ingestion pipeline\n\n      Transition from a linear document → chunk → extraction → resolution pipeline to a staged, asynchronous architecture. Assign each processing phase its own queue and dedicated worker pool. Apply clustering or network-based batching for invalidation jobs to maximize efficiency. Batch external API requests (e.g., OpenAI) and database writes wherever possible. This design increases throughput, introduces backpressure for reliability, and allows you to scale each pipeline stage independently.\n\n    Integrate Robust Production Safeguards\n\n      Enforce rigorous output validation: standardise temporal fields (e.g., ISO-8601 date formatting), constrain entity types to your controlled vocabulary, and apply lightweight model-based sanity checks for output consistency. Employ structured logging with traceable identifiers and monitor real-time quality and performance metrics in real lime to proactively detect data drift, regressions, or pipeline anomalised before they impact downstream applications.\n\n\nThis cookbook is designed for flexible engagement:\n\nUse it as a comprehensive technical guide—read from start to finish for a deep understanding of temporally-aware knowledge graph systems.\nSkim for advanced concepts, methodologies, and implementation patterns if you prefer a high-level overview.\nJump into any of the three modular sections; each is self-contained and directly applicable to real-world scenarios.\n\nInside, you'll find:\n\n    Creating a Temporally-Aware Knowledge Graph with a Temporal Agent\n\n      Build a pipeline that extracts entities and relations from unstructured text, resolves temporal conflicts, and keeps your graph up-to-date as new information arrives.\n\n    Multi-Step Retrieval Over a Knowledge Graph\n\n      Use structured queries and language model reasoning to chain multiple hops across your graph and answer complex questions.\n\n    Prototype to Production\n\n      Move from experimentation to deployment. This section covers architectural tips, integration patterns, and considerations for scaling reliably.\n\n\nBefore diving into building temporal agents and knowledge graphs, let's set up your environment. Install all required dependencies with pip, and set your OpenAI API key as an environment variable. Python 3.12 or later is required.\nAccurate data is the foundation of any good business decision.\nOpenAI’s latest models like o3, o4-mini, and the GPT-4.1 family are enabling businesses to build state-of-the-art retrieval systems for their most important workflows. However, information evolves rapidly: facts ingested confidently yesterday may already be outdated today.\n\n\n\n\nWithout the ability to track when each fact was valid, retrieval systems risk returning answers that are outdated, non-compliant, or misleading. The consequences of missing temporal context can be severe in any industry, as illustrated by the following examples.\n\n      Industry\n      Example question\n      Risk if database is not temporal\n\n      Financial Services\n      \"How has Moody’s long‑term rating for Bank YY evolved since Feb 2023?\"\n      Mispricing credit risk by mixing historical \u0026 current ratings\n\n      \"Who was the CFO of Retailer ZZ when the FY‑22 guidance was issued?\"\n      Governance/insider‑trading analysis may blame the wrong executive\n\n      \"Was Fund AA sanctioned under Article BB at the time it bought Stock CC in Jan 2024?\"\n      Compliance report could miss an infraction if rules changed later\n\n      Manufacturing / Automotive\n      \"Which ECU firmware was deployed in model Q3 cars shipped between 2022‑05 and 2023‑03?\"\n      Misdiagnosing field failures due to firmware drift\n\n      \"Which robot‑controller software revision ran on Assembly Line 7 during Lot 8421?\"\n      Root‑cause analysis may blame the wrong software revision\n\n      \"What torque specification applied to steering‑column bolts in builds produced in May 2024?\"\n      Safety recall may miss affected vehicles\n\n\nWhile we've called out some specific examples here, this theme is true across many industries including pharmaceuticals, law, consumer goods, and more.\n\nLooking beyond standard retrieval\n\nA temporally-aware knowledge graph allows you to go beyond static fact lookup. It enables richer retrieval workflows such as factual Q\u0026A grounded in time, timeline generation, change tracking, counterfactual analysis, and more. We dive into these in more detail in our retrieval section later in the cookbook.\n\n\n\nA temporal agent is a specialized pipeline that converts raw, free-form statements into time-aware triplets ready for ingesting into a knowledge graph that can then be queried with the questions of the character “What was true at time T?”.\n\nTriplets are the basic building blocks of knowledge graphs. It's a way to represent a single fact or piece of knowledge using three parts (hence, \"triplet\"):\nSubject** - the entity you are talking about\nPredicate** - the type of relationship or property\nObject** - the value or other entity that the subject is connected to\n\nYou can thinking of this like a sentence with a structure [Subject] - [Predicate] - [Object]. As a more clear example:\n\"London\" - \"isCapitalOf\" - \"United Kingdom\"\n\nThe Temporal Agent implemented in this cookbook draws inspiration from Zep and Graphiti, while introducing tighter control over fact invalidation and a more nuanced approach to episodic typing.\n\n    Temporal validity extraction\n\n      Builds on Graphiti's prompt design to identify temporal spans and episodic context without requiring auxiliary reference statements.\n\n    Fact invalidation logic\n\n      Introduces bidirectionality checks and constrains comparisons by episodic type. This retains Zep's non-lossy approach while reducing unnecessary evaluations.\n\n    Temporal \u0026 episodic typing\n\n      Differentiates between Fact, Opinion, Prediction, as well as between temporal classes Static, Dynamic, Atemporal.\n\n    Multi‑event extraction\n\n      Handles compound sentences and nested date references in a single pass.\n\n\nThis process allows us to update our sources of truth efficiently and reliably:\n\n\n\nNote: While the implementation in this cookbook is focused on a graph-based implementation, this approach is generalizable to other knowledge base structures e.g., pgvector-based systems.\nThe Temporal Agent processes incoming statements through a three-stage pipeline:\n\n    Temporal Classification\n\n      Labels each statement as Atemporal, Static, or Dynamic:\n\n      Atemporal statements never change (e.g., “The speed of light in a vaccuum is ≈3×10⁸ m s⁻¹”).\n      Static statements are valid from a point in time but do not change afterwards (e.g., \"Person YY was CEO of Company XX on October 23rd 2014.\").\n      Dynamic statements evolve (e.g., \"Person YY is CEO of Company XX.\").\n\n    Temporal Event Extraction\n\n      Identifies relative or partial dates (e.g., “Tuesday”, “three months ago”) and resolves them to an absolute date using the document timestamp or fallback heuristics (e.g., default to the 1st or last of the month if only the month is known).\n\n    Temporal Validity Check\n\n      Ensures every statement includes a t_created timestamp and, when applicable, a t_expired timestamp. The agent then compares the candidate triplet to existing knowledge graph entries to:\n\n      Detect contradictions and mark outdated entries with t_invalid\n      Link newer statements to those they invalidate with invalidated_by\n\n\nWhen building systems with LLMs, it is a good practice to start with larger models then later look to optimize and shrink.\n\nThe GPT-4.1 series is particularly well-suited for building Temporal Agents due to its strong instruction-following ability. On benchmarks like Scale’s MultiChallenge, GPT-4.1 outperforms GPT-4o by $10.5\\%_{abs}$, demonstrating superior ability to maintain context, reason in-conversation, and adhere to instructions - key traits for extracting time-stamped triplets. These capabilities make it an excellent choice for prototyping agents that rely on time-aware data extraction.\n\n    Prototype with GPT-4.1\n\n      Maximize correctness and reduce prompt-debug time while you build out the core pipeline logic.\n\n    Swap to GPT-4.1-mini or GPT-4.1-nano\n\n      Once prompts and logic are stable, switch to smaller variants for lower latency and cost-effective inference.\n\n    Distill onto GPT-4.1-mini or GPT-4.1-nano\n\n      Use OpenAI's Model Distillation to train smaller models with high-quality outputs from a larger 'teacher' model such as GPT-4.1, preserving (or even improving) performance relative to GPT-4.1.\n\n\n| Model                    | Relative cost | Relative latency  | Intelligence | Ideal Role in Workflow                   |\n| ----------------------- | ------ | -------- | - |------------------------------ |\n| GPT-4.1      | ★★★ | ★★ | ★★★ (highest) | Ground-truth prototyping, generating data for distillation |\n| GPT-4.1-mini             | ★★  | ★     | ★★ | Balanced cost-performance, mid to large scale production systems |\n| GPT-4.1-nano        | ★ (lowest)    | ★ (fastest)     | ★ | Cost-sensitive and ultra-large scale bulk processing |\nIn practice, this looks like: prototype with GPT-4.1 → measure quality → step down the ladder until the trade-offs no longer meet your needs.\nBefore diving into the implementation details, it's useful to understand the ingestion pipeline at a high level:\n\n    Load transcripts\n\n    Creating a Semantic Chunker\n\n    Laying the Foundations for our Temporal Agent\n\n    Statement Extraction\n\n    Temporal Range Extraction\n\n    Creating our Triplets\n\n    Temporal Events\n\n    Defining our Temporal Agent\n\n    Entity Resolution\n\n    Invalidation Agent\n\n    Building our pipeline\n\n\nFor the purposes of this cookbook, we have selected the \"Earnings Calls Dataset\" (jlh-ibm/earnings_call) which is made available under the Creative Commons Zero v1.0 license. This dataset contains a collection of 188 earnings call transcripts originating in the period 2016-2020 in relation to the NASDAQ stock market. We believe this dataset is a good choice for this cookbook as extracting information from - and subsequently querying information from - earnings call transcripts is a common problem in many financial institutions around the world.\n\nMoreover, the often variable character of statements and topics from the same company across multiple earnings calls provides a useful vector through which to demonstrate the temporal knowledge graph concept.\n\nDespite this dataset's focus on the financial world, we build up the Temporal Agent in a general structure, so it will be quick to adapt to similar problems in other industries such as pharmaceuticals, law, automotive, and more.\n\nFor the purposes of this cookbook we are limiting the processing to two companies - AMD and Nvidia - though in practice this pipeline can easily be scaled to any company.\n\nLet’s start by loading the dataset from HuggingFace.\nDatabase Set-up\n\n\nBefore we get to processing this data, let’s set up our database.\n\nFor convenience within a notebook format, we've chosen SQLite as our database for this implementation. In the \"Prototype to Production\" section, and in Appendix section A.1 \"Storing and Retrieving High-Volume Graph Data\" we go into more detail of considerations around different dataset choices in a production environment.\n\nIf you are running this cookbook locally, you may chose to set memory = False to save the database to storage, the default file path my_database.db will be used to store your database or you may pass your own db_path arg into make_connection.\n\nWe will set up several tables to store the following information:\nTranscripts\nChunks\nTemporal Events\nTriplets\nEntities (including canonical mappings)\n\nThis code is abstracted behind a make_connection method which creates the new SQLite database. The details of this method can be found in the db_interface.py script in the GitHub repository for this cookbook.\nBefore diving into buidling the Chunker class itself, we begin by defining our first data models. As is generally considered good practice when working with Python, Pydantic is used to ensure type safety and clarity in our model definitions. Pydantic provides a clean, declarative way to define data structures whilst automatically validating and parsing input data, making our data models both robust and easy to work with.\nThis is a core data model that we'll use to store individual segments of text extracted from transcripts, along with any associated metadata. As we process the transcripts by breaking them into semantically meaningful chunks, each piece will be saved as a separate Chunk.\n\nEach Chunk contains:\nid: A unique identifier automatically generated for each chunk. This helps us identify and track chunks of text throughout\ntext: A string field that contains the text content of the chunk\nmetadata: A dictionary to allow for flexible metadata storage\nAs the name suggests, we will use the Transcript model to represent the full content of an earnings call transcript. It captures several key pieces of information:\nid: Analogous to Chunk, this gives us a unique identifier\ntext: The full text of the transcript\ncompany: The name of the company that the earnings call was about\ndate: The date of the earnings call\nquarter: The fiscal quarter that the earnings call was in\nchunks: A list of Chunk objects, each representing a meaningful segment of the full transcript\n\nTo ensure the date field is handled correctly, the to_datetime validator is used to convert the value to datetime format.\nNow, we define the Chunker class to split each transcript into semantically meaningful chunks. Instead of relying on arbitrary rules like character count or line break, we apply semantic chunking to preserve more of the contextual integrity of the original transcript. This ensures that each chunk is a self-contained unit that keeps contextually linked ideas together. This is particularly helpful for downstream tasks like statement extraction, where context heavily influences accuracy.\n\nThe chunker class contains two methods:\n\nfind_quarter\n\n  This method attempts to extract the fiscal quarter (e.g., \"Q1 2023\") directly from the transcript text using a simple regular expression. In this case, this is straightforward as the data format of quarters in the transcripts is consistent and well defined.\n\n  However, in real world scenarios, detecting the quarter reliably may require more work. Across multiple sources or document types the detailing of the quarter is likely to be different. LLMs are great tools to help alleviate this issue. Try using GPT-4.1-mini with a prompt specifically to extract the quarter given wider context from the document.\n\ngenerate_transcripts_and_chunks\n\n  This is the core method that takes in a dataset (as an iterable of dictionaries) and returns a list of Transcript objects each populated with semantically derived Chunks. It performs the following steps:\n\n  Transcript creation: Initializes Transcript objects using the provided text, company, and date fields\n  Filtering: Uses the SemanticChunker from chonkie along with OpenAI's text-embedding-3-small model to split the transcript into logical segments\n  Chunk assignment: Wraps each semantic segment into a Chunk model, attaching relevant metadata like start and end indices\n\nThe chunker falls in to this part of our pipeline:\n\n\nAlternatively, we can load just the AMD and NVDA pre-chunked transcripts from pre-processed files in transcripts/\nNow we can inspect a couple of chunks:\nWith this, we have successfully split our transcripts into semantically sectioned chunks. We can now move onto the next steps in our pipeline.\nBefore we move onto defining the TemporalAgent class, we will first define the prompts and data models that are needed for it to function.\nFor our temporal agent to be able to accurately extract the statement and temporal types we need to provide it with sufficiently detailed and specific context. For convenience, we define these within a structured format below.\n\nEach label contains three crucial pieces of information that we will later pass to our LLMs in prompts.\n\n    definition\n\n      Provides a concise description of what the label represents. It establishes the conceptual boundaries of the statement or temporal type and ensures consistency in interpretation across examples.\n\n    date_handling_guidance\n\n      Explains how to interpret the temporal validity of a statement associated with the label. It describes how the valid_at and invalid_at dates should be derived when processing instances of that label.\n\n    date_handling_examples\n\n      Includes illustrative examples of how real-world statements would be labelled and temporally annotated under this label. These will be used as few-shot examples to the LLMs downstream.\n\n\n\"Statement Extraction\" refers to the process of splitting our semantic chunks into the smallest possible \"atomic\" facts. Within our Temporal Agent, this is achieved by:\n\n    Finding every standalone, declarative claim\n\n      Extract statements that can stand on their own as complete subject-predicate-object expressions without relying on surrounding context.\n\n    Ensuring atomicity\n\n      Break down complex or compound sentences into minimal, indivisible factual units, each expressing a single relationship.\n\n    Resolving references\n\n      Replace pronouns or abstract references (e.g., \"he\" or \"The Company\") with specific entities (e.g., \"John Smith\", \"AMD\") using the main subject for disambiguation.\n\n    Preserving temporal and quantitative precision\n\n      Retain explicit dates, durations, and quantities to anchor each fact precisely in time and scale.\n\n    Labelling each extracted statement\n\n      Every statement is annotated with a StatementType and a TemporalType.\n\n\nThe TemporalType enum provides a standardized set of temporal categories that make it easier to classify and work with statements extracted from earnings call transcripts.\n\nEach category captures a different kind of temporal reference:\n\nAtemporal**: Statements that are universally true and invariant over time (e.g., “The speed of light in a vacuum is ≈3×10⁸ m s⁻¹.”).\nStatic**: Statements that became true at a specific point in time and remain unchanged thereafter (e.g., “Person YY was CEO of Company XX on October 23rd, 2014.”).\nDynamic**: Statements that may change over time and require temporal context to interpret accurately (e.g., “Person YY is CEO of Company XX.”).\n\nSimilarly, the StatementType enum classifies the nature of each extracted statement, capturing its epistemic characteristics.\n\nFact**: A statement that asserts a verifiable claim considered true at the time it was made. However, it may later be superseded or contradicted by other facts (e.g., updated information or corrections).\nOpinion**: A subjective statement reflecting a speaker’s belief, sentiment, or judgment. By nature, opinions are considered temporally true at the moment they are expressed.\nPrediction**: A forward-looking or hypothetical statement about a potential future event or outcome. Temporally, a prediction is assumed to hold true from the time of utterance until the conclusion of the inferred prediction window.\nThe RawStatement model represents an individual statement extracted by an LLM, annotated with both its semantic type (StatementType) and temporal classification (TemporalType). These raw statements serve as intermediate representations and are intended to be transformed into TemporalEvent objects in later processing stages.\n\nCore fields:\nstatement: The textual content of the extracted statement\nstatement_type: The type of statement (Fact, Opinion, Prediction), based on the StatementType enum\ntemporal_type: The temporal classification of the statement (Static, Dynamic, Atemporal), drawn from the TemporalType enum\n\nThe model includes field-level validators to ensure that all type annotations conform to their respective enums, providing a layer of robustness against invalid input.\n\nThe companion model RawStatementList contains the output of the statement extraction step: a list of RawStatement instances.\nThis is the core prompt that powers our Temporal Agent's ability to extract and label atomic statements. It is written in Jinja allowing us to modularly compose dynamic inputs without rewriting the core logic.\n\n    Set up the extraction task\n\n      We instruct the assistant to behave like a domain expert in finance and clearly define the two subtasks: (i) extracting atomic, declarative statements, and (ii) labelling each with a statement_type and a temporal_type.\n\n    Enforces strict extraction guidelines\n\n      The rules for extraction help to enforce consistency and clarity. Statements must:\n\n      Be structured as clean subject-predicate-object triplets\n      Be self-contained and context-independent\n      Resolve co-references (e.g., \"he\" → \"John Smith\")\n      Include temporal/quantitative qualifiers where present\n      Be split when multiple events or temporalities are described\n\n    Supports plug-and-play definitions\n\n      The {% if definitions %} block makes it easy to inject structured definitions such as statement categories, temporal types, and domain-specific terms.\n\n    Includes few-shot examples\n\n      We provide an annotated example chunk and the corresponding JSON output to demonstrate to the model how it should behave.\n\n\nThe RawTemporalRange model holds the raw extraction of valid_at and invalid_at date strings for a statement. These both use the date-time supported string property.\n\nvalid_at represents the start of the validity period for a statement\ninvalid_at represents the end of the validity period for a statement\nWhile the RawTemporalRange model preserves the originally extracted date strings, the TemporalValidityRange model transforms these into standardized datetime objects for downstream processing.\n\nIt parses the raw valid_at and invalid_at values, converting them from strings into timezone-aware datetime instances. This is handled through a field-level validator.\nLet's now create the prompt that guides our Temporal Agent in accurately determining the temporal validity of statements.\n\n\nThis prompt helps the Temporal Agent precisely understand and extract temporal validity ranges.\n\n    Clearly Defines the Extraction Task\n\n      The prompt instructs our model to determine when a statement became true (valid_at) and optionally when it stopped being true (invalid_at).\n\n    Uses Contextual Guidance\n\n      By dynamically incorporating {{ inputs.temporal_type }} and {{ inputs.statement_type }}, the prompt guides the model in interpreting temporal nuances based on the nature of each statement (like distinguishing facts from predictions or static from dynamic contexts).\n\n    Ensures Consistency with Clear Formatting Rules\n\n      To maintain clarity and consistency, the prompt requires all dates to be converted into standardized ISO 8601 date-time formats, normalized to UTC. It explicitly anchors relative expressions (like \"last quarter\") to known publication dates, making temporal information precise and reliable.\n\n    Aligns with Business Reporting Cycles\n\n      Recognizing the practical need for quarter-based reasoning common in business and financial contexts, the prompt can interpret and calculate temporal ranges based on business quarters, minimizing ambiguity.\n\n    Adapts to Statement Types for Semantic Accuracy\n\n      Specific rules ensure the semantic integrity of statements—for example, opinions might only have a start date (valid_at) reflecting the moment they were expressed, while predictions will clearly define their forecast window using an end date (invalid_at).\n\n\nWe will now build up the definitions and prompts to create the our triplets. As discussed above, these are a combination of:\nSubject** - the entity you are talking about\nPredicate** - the type of relationship or property\nObject** - the value or other entity that the subject is connected to\n\nLet's start with our predicate.\nThe Predicate enum provides a standard set of predicates that clearly describe relationships extracted from text.\n\nWe've defined the set of predicates below to be appropriate for earnings call transcripts. Here are some examples for how each of these predicates could fit into a triplet in our knowledge graph:\nHere are more anonymized, generalized examples following your template:\n\nIS_A: \\[Company ABC]-\\[IS\\_A]-\\[Software Provider]\nHAS_A: \\[Corporation XYZ]-\\[HAS\\_A]-\\[Innovation Division]\nLOCATED_IN: \\[Factory 123]-\\[LOCATED\\_IN]-\\[Germany]\nHOLDS_ROLE: \\[Jane Doe]-\\[HOLDS\\_ROLE]-\\[CEO at Company LMN]\nPRODUCES: \\[Company DEF]-\\[PRODUCES]-\\[Smartphone Model X]\nSELLS: \\[Retailer 789]-\\[SELLS]-\\[Furniture]\nLAUNCHED: \\[Company UVW]-\\[LAUNCHED]-\\[New Subscription Service]\nDEVELOPED: \\[Startup GHI]-\\[DEVELOPED]-\\[Cloud-Based Tool]\nADOPTED_BY: \\[New Technology]-\\[ADOPTED\\_BY]-\\[Industry ABC]\nINVESTS_IN: \\[Investment Firm JKL]-\\[INVESTS\\_IN]-\\[Clean Energy Startups]\nCOLLABORATES_WITH: \\[Company PQR]-\\[COLLABORATES\\_WITH]-\\[University XYZ]\nSUPPLIES: \\[Manufacturer STU]-\\[SUPPLIES]-\\[Auto Components to Company VWX]\nHAS_REVENUE: \\[Corporation LMN]-\\[HAS\\_REVENUE]-\\[€500 Million]\nINCREASED: \\[Company YZA]-\\[INCREASED]-\\[Market Share]\nDECREASED: \\[Firm BCD]-\\[DECREASED]-\\[Operating Expenses]\nRESULTED_IN: \\[Cost Reduction Initiative]-\\[RESULTED\\_IN]-\\[Improved Profit Margins]\nTARGETS: \\[Product Launch Campaign]-\\[TARGETS]-\\[Millennial Consumers]\nPART_OF: \\[Subsidiary EFG]-\\[PART\\_OF]-\\[Parent Corporation HIJ]\nDISCONTINUED: \\[Company KLM]-\\[DISCONTINUED]-\\[Legacy Product Line]\nSECURED: \\[Startup NOP]-\\[SECURED]-\\[Series B Funding]\n\nWe also assign a definition to each predicate, which we will then pass to the extraction prompt downstream.\nWhen working with different data sources, you'll want to define your own predicates that are specific to your use case.\n\nTo define your own predicates:\nFirst, run your pipeline with PREDICATE_DEFINITIONS = {} on a representative sample of your documents. This initial run will derive a noisy graph with many non-standardized and overlapping predicates\nNext, drop some of your intial results into ChatGPT or manually review them to merge similar predicate classes. This process helps to eliminate duplicates such as IS_CEO and IS_CEO_OF\nFinally, carefully review and refine this list of predicates to ensure clarity and precision. These finalized predicate definitions will then guide your extraction process and ensure a consistent extraction pipeline\nWith predicates now well-defined, we can begin building up the data models for our triplets.\n\nThe RawTriplet model represents a basic subject-predicate-object relationship that is extracted directly from textual data. This serves as a precursor for the more detailed triplet representation in Triplet which we introduce later.\n\nCore fields:\nsubject_name: The textual representation of the subject entity\nsubject_id: Numeric identifier for the subject entity\npredicate: The relationship type, specified by the Predicate enum\nobject_name: The textual representation of the object entity\nobject_id: Numeric identifier for the object entity\nvalue: Numeric value associated to relationship, may be None e.g. Company -\u003e HAS_A -\u003e Revenue with value='$100 mill'\n\nThe Triplet model extends the RawTriplet by incorporating unique identifiers and optionally linking each triplet to a specific event. These identifiers help with integration into structured knowledge bases like our temporal knowledge graph.\nThe RawEntity model represents an Entity as extracted from the Statement. This serves as a precursor for the more detailed triplet representation in Entity which we introduce next.\n\nCore fields:\nentity_idx: An integer to differentiate extracted entites from the statement (links to RawTriplet)\nname: The name of the entity extracted e.g. AMD\ntype: The type of entity extracted e.g. Company\ndescription: The textual description of the entity e.g. Technology company know for manufacturing semiconductors\nThe Entity model extends the RawEntity by incorporating unique identifiers and optionally linking each entity to a specific event.\nAdditionally, it contains resolved_id which will be populated during entity resolution with the canonical entity's id to remove duplicate naming of entities in the database.\nThese updated identifiers help with integration and linking of entities to events and triplets .\nBoth RawTriplet and RawEntity are extracted at the same time per Statement to reduce LLM calls and to allow easy referencing of Entities through Triplets.\nThe prompt below guides our Temporal Agent to effectively extract triplets and entities from provided statements.\n\n    Avoids temporal details\n\n      The agent is specifically instructed to ignore temporal relationships, as these are captured separately within the TemporalValidityRange.\n      Defined Predicates are deliberately designed to be time-neutral—for instance, HAS_A covers both present (HAS_A) and past (HAD_A) contexts.\n\n    Maintains structured outputs\n\n      The prompt yields structured RawExtraction outputs, supported by detailed examples that clearly illustrate:\n\n      How to extract information from a given Statement\n      How to link Entities with corresponding Triplets\n      How to handle extracted values\n      How to manage multiple Triplets involving the same Entity\n\n\nThe TemporalEvent model brings together the Statement and all related information into one handy class. It's a primary output of the TemporalAgent and plays an important role within the InvalidationAgent.\n\nMain fields include:\nid: A unique identifier for the event\nchunk_id: Points to the specific Chunk associated with the event\nstatement: The specific RawStatement extracted from the Chunk detailing a relationship or event\nembedding: A representation of the statement used by the InvalidationAgent to gauge event similarity\ntriplets: Unique identifiers for the individual Triplets extracted from the Statement\nvalid_at: Timestamp indicating when the event becomes valid\ninvalid_at: Timestamp indicating when the event becomes invalid\ntemporal_type: Describes temporal characteristics from the RawStatement\nstatement_type: Categorizes the statement according to the original RawStatement\ncreated_at: Date the event was first created.\nexpired_at: Date the event was marked invalid (set to created_at if invalid_at is already set when building the TemporalEvent)\ninvalidated_by: ID of the TemporalEvent responsible for invalidating this event, if applicable\nNow we arrive at a central point in our pipeline: The TemporalAgent class. This brings together the steps we've built up above - chunking, data models, and prompts. Let's take a closer look at how this works.\n\nThe core function, extract_transcript_events, handles all key processes:\n\nIt extracts a RawStatement from each Chunk.\nFrom each RawStatement, it identifies the TemporalValidityRange along with lists of related Triplet and Entity objects.\nFinally, it bundles all this information neatly into a TemporalEvent for each RawStatement.\n\nHere's what you'll get:\n\ntranscript: The transcript currently being analyzed.\nall_events: A comprehensive list of all generated TemporalEvent objects.\nall_triplets: A complete collection of Triplet objects extracted across all events.\nall_entities: A detailed list of all Entity objects pulled from the events, which will be further refined in subsequent steps.\n\nThe diagram below visualizes this portion of our pipeline:\n\n\n\nBefore diving into Temporal Invalidation, we need to first tackle entity resolution. This process is crucial to ensure that each real-world entity has a single, authoritative representation, eliminating duplicates and maintaining data consistency. For instance, AMD and Advanced Micro Devices clearly refer to the same entity, so they should be represented under a unified canonical entity.\n\nHere's our approach to entity resolution:\n\nWe use the EntityResolution class to batch entities by type (Entity.type), which helps us make context-specific comparisons—like distinguishing companies from individuals.\n\nTo address noisy data effectively, we leverage RapidFuzz to cluster entities based on name similarity. This method involves a simple, case-insensitive, punctuation-free comparison using a partial match ratio, allowing tolerance for minor typos and substring matches.\n\nWithin each fuzzy-matched cluster, we select the medoid—the entity most representative of the cluster based on overall similarity. This prevents bias toward the most frequently occurring or earliest listed entity. The medoid then serves as the initial canonical entity, providing a semantically meaningful representation of the group.\n\nBefore adding a new canonical entity, we cross-check the medoid against existing canonicals, considering both fuzzy matching and acronyms. For example, Advanced Micro Devices Inc. may yield AMDI, closely matching the acronym AMD. This step helps prevent unnecessary creation of duplicate canonical entities.\n\nIf a global match isn't found, the medoid becomes a new canonical entity, with all entities in the cluster linked to it via a resolved ID.\n\nFinally, we perform an additional safeguard check to resolve potential acronym duplication across all canonical entities, ensuring thorough cleanup.\n\nTo further enhance entity resolution, you could consider advanced techniques such as:\n\nUsing embedding-based similarity on Entity.description alongside Entity.name, improving disambiguation beyond simple text similarity.\nEmploying a large language model (LLM) to intelligently group entities under their canonical forms, enhancing accuracy through semantic understanding.\n\n\nTo effectively invalidate temporal events, the agent performs checks in both directions:\n1. Incoming vs. Existing: Are incoming events invalidated by events already present?\n2. Existing vs. Incoming: Are current events invalidated by the new incoming events?\n\nThis bi-directional assessment results in a clear True/False decision.\nThe prompt has three key components:\n\n\nTask Setup\nDefines two roles—primary and secondary—for event comparison. The assessment checks if the primary event is invalidated by the secondary event.\n\nGuidelines\nProvides clear criteria on interpreting temporal metadata. Importantly, invalidation must rely solely on the relationships explicitly stated between events. External information cannot influence the decision.\n\nEvent Information\nBoth events (primary and secondary) include timestamp details (valid_at and invalid_at) along with semantic context through either Statement, Triplet, or both. This context ensures accurate and relevant comparisons.\n\n\nWe can only invalidate dynamic facts that haven't been marked invalid yet. These facts serve as our primary events, while potential candidates for invalidation are our secondary events. To streamline the invalidation process, consider these guidelines when evaluating secondary events:\n\nMust be a FACT type and not Atemporal\nShare at least one canonical entity at the triplet level\nBelong to the same semantic predicate group at the triplet level (defined below)\nTemporally overlap and be currently ongoing\nHave a statement cosine similarity above the threshold (currently set to 0.5)\nThe similarity threshold (0.5) helps us filter noise effectively by selecting only the top_k most relevant results. Low-level semantic similarities are acceptable since our goal is refining the data sent to the LLM for further assessment\n\nWhen invalidation occurs, we annotate the affected events with expired_at and invalidated_by to clearly indicate cause-and-effect relationships.\nWhen we put all of this together, the workflow for our InvalidationAgent looks like this:\n\n    Temporal Range Detection\n\n      We start by identifying when events happen with get_incoming_temporal_bounds(). This function checks the event's valid_at and, if it's dynamic, its invalid_at. Atemporal events aren't included here.\n\n    Temporal Event Selection\n\n      We use select_events_temporally() to filter events by:\n\n      Checking if they're static or dynamic.\n      Determining if their time ranges overlap with our incoming event.\n      Handling dynamic events carefully, especially \"ongoing\" ones without an invalid_at, or events with various overlaps.\n\n    Embedding Similarity Filtering\n\n      Then, filter_by_embedding_similarity() compares events based on semantic similarity:\n\n      It calculates cosine similarity between embeddings.\n      Events below a similarity threshold (_similarity_threshold = 0.5) are filtered out.\n      We keep only the top-K most similar events (_top_k = 10).\n\n    Combining Temporal and Semantic Filters\n\n      With select_temporally_relevant_events_for_invalidation(), we:\n\n      Apply temporal filters first.\n      Then apply embedding similarity filters.\n      This gives us a refined list of events most likely interacting or conflicting with the incoming one.\n\n    Event Invalidation Decision (LLM-based)\n\n      The LLM-based invalidation_step() (powered by GPT-4.1-mini) determines whether the incoming event invalidates another event:\n\n      If it does, we update:\n\n          invalid_at to match the secondary event's valid_at.\n          expired_at with the current timestamp.\n          invalidated_by with the ID of the secondary event.\n\n    Bidirectional Event Check\n\n      We use bi_directional_event_invalidation() to check:\n\n      If the incoming event invalidates existing events.\n      If existing, later events invalidate the incoming event, especially if the incoming one is dynamic and currently valid.\n\n    Deduplication Logic\n\n      Lastly, resolve_duplicate_invalidations() ensures clean invalidation:\n\n      It allows only one invalidation per event.\n      Picks the earliest invalidation time to avoid conflicts.\n      This helps manage batch processing effectively.\n\n\nThe invalidation below represents this part of our pipeline:\n\n\n\nWe can create a batch processing function for invalidation for a set of Temporal Events. This is where we filter our Statements to type FACT before passing into the invalidation agent to process.\nNow that we have built out each individual component of the Temporal Knowledge Graph workflow, we can integrate them into a cohesive workflow.\n\nGiven a chunked transcript, the Temporal Agent sequentially processes each chunk, initially extracting relevant statements. These statements are then classified and enriched through subsequent extraction phases, resulting in Temporal Events, structured Triplets, and identified Entities.\n\nThe extracted Entities are cross-referenced with existing records in the database, ensuring accurate resolution and avoiding redundancy. Following entity resolution, the Dynamic Facts undergo validation via the Invalidation Agent to verify temporal consistency and validity.\n\nAfter successful processing and validation, the refined data is systematically stored into their respective tables within the SQLite database, maintaining an organized and temporally accurate knowledge graph.\n\nTo help visually ground the code presented below, we can look again at the pipeline diagram:\n\nWe can then ingest the rest of the Transcripts. Note that this code has not been optimised to be production ready and on average takes 2-5 mins per Transcript. This bulk ingestion using the data in /transcripts (~30 files) will take up to 2 hours to run. Optimizing this is a critical step in scaling to production. We outline some methods you can use to approach this in the Appendix in A.3 \"Implementing Concurrency in the Ingestion Pipeline\", including batch chunking, entity clustering, and more.\nNote: Running the below cell for all transcripts in this dataset can take approximately 1 hour\nWe recommend loading the pre-processed AMD and NVDA data from file by creating a new SQLite connection using the code below. This will create the database needed for building the graph and retriever.\n\nYou can find this data on HuggingFace.\nWhen constructing the knowledge graph, canonical entity identifiers derived from triplets ensure accurate mapping of entity names, allowing storage of detailed temporal metadata directly on edges. Specifically, the implementation utilizes attributes:\n\nvalid\\_at, **invalid\\_at, and temporal\\_type for Temporal Validity, representing real-world accuracy at specific historical moments—critical for analysis of historical facts.\nOptionally, attributes created\\_at and expired\\_at may also be used for Transactional Validity, enabling audit trails and source attribution by tracking when information was recorded, updated, or corrected.\n\nTransactional validity is particularly beneficial in scenarios such as:\n\nFinance**: Determining the accepted financial facts about Company X’s balance sheet on a specific historical date, based on contemporaneously accepted knowledge.\nLaw**: Identifying applicable legal frameworks as understood at a contract signing date, or compliance obligations recognized at past dates.\nJournalism**: Assessing if previously reported information has become outdated, ensuring press releases and reporting remain accurate and credible over time.\n\nTo effectively implement and utilize the knowledge graph we utilise NetworkX for the purposes of this cookbook for several reasons.\nPython integration: NetworkX seamlessly integrates with Python, facilitating rapid prototyping and iterative development\nEase of setup: It requires minimal initial setup, not requiring a client-server setup featured in alternatives. This makes it ideal for users who wish to run this cookbook themselves\nCompatibility with In-Memory Databases: NetworkX can efficiently manage graphs with fewer than c.100,000 nodes, which is appropriate for this cookbook's data scale\n\nHowever, it should be noted that NetworkX lacks built-in data persistence and is therefore not typically recommended for production builds.\n\nFor production builds, Neo4j emerges as a more optimal choice due to a wider set of production-centric features, including:\nNative Graph Storage and Processing**: Optimized for graph data with high-performance and efficient handling\nOptimized Query Engine**: Leverages the Cypher query language, explicitly designed for efficient graph traversal\nScalability and Persistence**: Effectively manages extensive graph datasets, ensuring data persistence, reliability, and durability\nProduction Tooling**: Offers integrated tooling such as Neo4j Bloom for vislualization and Neo4j Browser for exploration, enhancing user interaction and analysis\nAdvanced Access Control**: Provides granular security options to control data access\nThe approach presented above offers a foundational implementation of a Temporal Agent for knowledge graph construction. However, it does not fully address complexities or all possible edge cases encountered in real-world applications. Below, we outline several possible enhancements that could be used to further improve the robustness and applicability of this implementation. In the later \"Prototype to Production\" section, we expand on these enhancements by suggesting additional considerations essential for deploying such agents effectively in production environments. Further details on scaling to production are included in the Appendix.\nIn this cookbook, the Temporal Agent does not identify or merge duplicate Temporal Events arising from statements referring to the same event, especially when originating from different sources. These events are saved separately rather than unified into a single, consolidated event.\n\nThere's an opportunity to enrich the dataset by consistently capturing both Static and Dynamic representations of events, even when explicit statements aren't available.\n\nFor Dynamic events without corresponding Static statements, creating explicit Static entries marking the start (valid_at) and end (invalid_at) can enhance temporal clarity, particularly for the purposes of retrieval tasks.\n\nConversely, Static events lacking Dynamic counterparts can have Dynamic relationships inferred, though this would require careful checks for potential invalidation within statement cohorts.\nThe implementation in this cookbook does not explictly record assumptions made during date disambiguation.\n\nIn the absence of an explicit publication date, the present date is used implicitly as a reference. For some workflows, this assumption may have to be changed to meet the needs of the end users.\n\nAbstract dates (e.g., \"until next year\") are resolved into explicit dates, however the vagueness is not represented in the stored data structure. The inclusion of more granular metadata can capture more abstract date ranges:\ntemporal_event = {\n  \"summary\": \"The event ran from April to September\",\n  \"label\": \"dynamic\",\n  \"valid_at\": {\n      \"date\": \"2025-04-01\",\n      \"literal\": False,\n      \"abstract_date\": \"2025-04\"\n  },\n  \"invalid_at\": {\n      \"date\": \"2025-09-30\",\n      \"literal\": False,\n      \"abstract_date\": \"2025-09\"\n  }\n}\nThis structure permits the explicit representation of both literal and abstract date interpretations.\nThere are several possible avenues for improving the Triplet Extraction presented in this cookbook. These include:\nUtilising a larger model and optimizing the extraction prompts further\nRunning the extraction process multiple times and consolidating results via e.g., a modal pooling mechanism to improve the accuracy and confidence in a prediction\nIncorporating entity extraction tools (e.g., Spacy and leveraging predefined ontologies tailored to specific use cases for improved consistency and reliability\nThe presented Invalidation Agent does not refine temporal validity ranges, but one could extend its functionality to perform said refinement as well as intra-cohort invalidation checks to identify temporal conflicts among incoming statements.\n\nThere are also several opportunities for efficiency enhancements.\nTransitioning from individual (1:1) comparisons to omni-directional (1:many) invalidation checks would reduce the number of LLM calls required\nApplying network analysis techniques to cluster related statements could enable batching of invalidation checks. Clusters can be derived from several properties including semantic similarity, temporal proximity, or more advanced techniques. This would significantly reduce bottlenecks arising from sequential processing, which is particularly important when ingesting large volumes of data\nSimple retrieval systems can often handle straightforward \"look-up\" queries with a single search against a vector store or document index. In practice, though, agents deployed in real-world settings frequently need more. User questions often require LLMs to synthesise information from multiple parts of a knowledge base or across several endpoints.\n\nThe temporal knowledge graphs introduced earlier provide a natural foundation for this, explicitly encoding entities (nodes), relationships (edges), and their evolution over time.\n\nMulti-step retrieval allows us to fully harness the capabilities of these graphs. It involves iteratively traversing the graph through a series of targeted queries, enabling the agent to gather all necessary context before forming a response.\nWe can see the power of multi-step retrieval below:\n\n\nIn this case, the initial query to the knowledge graph returned no information on some competitors’ R\u0026D activities. Rather than failing silently, the system pivoted to an alternative source—the strategy content—and successfully located the missing information. This multi-step approach allowed it to navigate sparse data and deliver a complete response to the user.\nAt a high level, we will build out the following structure:\n\n    User question → Planner → Orchestrator\n\n      A planner utilising GPT 4.1 will decompose the user's question into a small sequence of proposed graph operations. This is then passed to the orchestrator to execute\n\n    Tool calls to retrieve information from the Temporal Knowledge Graph\n\n      Considering the user query and the plan, the Orchestrator (o4-mini) makes a series of initial tool calls to retrieve information from the knowledge graph\n\n    Loop until done → Generate answer\n\n      The responses to the tool calls are fed back to the Orchestrator which can then decide to either make more queries to the graph or answer the user's question\n\n\nPlanning steps are incorporated in many modern LLM applications.\n\nThe explicit inclusion of a planning step improves overall performance by having the system consider the full scope of the problem before acting.\n\nIn this implementation, the plan remains static. In longer-horizon agentic pipelines, however, it's common to include mechanisms for replanning or updating the plan as the system progresses.\n\nBroadly, planners take two forms:\n\n    Task-orientated (used in this cookbook)\n\n      The planner outlines the concrete subtasks the downstream agentic blocks should execute. The tasks are phrased in an action-orientated sense such as \"1. Extract information on R\u0026amp;D activities of Company IJK between 2018–2020.\" These planners are typically preferred when the goal is mostly deterministic and the primary risk is skipping or duplicating work.\n\n      Example tasks where this approach is useful:\n\n      Law: \"Extract and tabulate termination-notice periods from every master service agreement executed in FY24\"\n      Finance: \"Fetch every 10-K filed by S\u0026amp;P 500 banks for FY24, extract tier-1 capital and liquidity coverage ratios, and output a ranked table of institutions by capital adequacy\"\n      Automotive: \"Compile warranty-claim counts by component for Model XYZ vehicles sold in Europe since the new emissions regulation came into force\"\n      Manufacturing: \"Analyse downtime logs from each CNC machine for Q1 2025, classify the root-cause codes, and generate a Pareto chart of the top five failure drivers\"\n\n    Hypothesis-orientated\n\n      The plan is framed as a set of hypotheses the system can confirm, reject, or refine in response to the user's question. Each step represents a testable claim, optionally paired with suggested actions. This approach excels in open-ended research tasks where new information can significantly reshape the solution space.\n\n      Example tasks where this approach is useful:\n\n      Law: \"Does the supplied evidence satisfy all four prongs of the fair-use doctrine? Evaluate each prong against relevant case law\"\n      Pharmaceuticals: \"What emerging mRNA delivery methods could be used to target the IRS1 gene to treat obesity?\"\n      Finance: \"Is Bank Alpha facing a liquidity risk? Compare its LCR trend, interbank borrowing costs, and deposit-outflow and anything else you find that is interesting\"\n\n\nWe will define two prompts (one system and one user) for the initial planner.\n\nThe most notable characteristic of our system prompt below is the use of 'persona-based' prompting. We prompt the LLM giving it a persona of an internal company expert. This helps to frame the tone of the model's response to the behaviour that we want - a direct, action-orientated task list that is fit for the financial industry.\n\nThis is then extended in the user prompt, where we prepend the user_question with information on this specific situation and how the planner should handle it.\n\nIn production settings you can super-charge this template by dynamically enriching the prompt before each call. You can inject information on the user's profile —sector, role, preferred writing style, prior conversation context—so the planner tailors its actions to their environment. You can also perform a quick “question-building” loop: have the assistant propose clarifying questions, gather the answers, and merge them back into the prompt so the planner starts with a well-scoped, information-rich request rather than a vague one.\n\nAnother flow that can work well is to allow users to view the plan and optionally edit it before it is executed. This is particularly effective when your AI system is acting in more of an assistant role. Giving domain experts such as lawyers or pharmaceutical researchers the flexibility to steer and incorporate their ideas and research directions deeper into the system often has the dual benefit of improving both system performance and end user satisfaction.\nOpenAI function calling (otherwise known as tools) enable models to perform specific external actions by calling predefined functions. Some of the tools provided on the OpenAI platform include:\nCode interpreter**: Executes code for data analysis, math, plotting, and file manipulation\nWeb search**: Include data from the internet in model response generation\nFile search**: Search the contents of uploaded files for context\nImage generation**: Generate or edit images using GPT image\nRemote MCP servers**: Give the model access to new capabilities via Model Context Protocol (MCP) servers\n\nOther cookbooks cover how to build tools for use with LLMs. In this example, we’ll develop several tools designed to efficiently explore the temporal knowledge graph and help answer the user’s question.\n\nThere are several schools of thought on tool design, and the best choice depends on the application at hand.\n\n\n\nIn this context, 'fixed' tools refer to those with a rigid, well-defined functionality. Typically, these tools accept a limited number of specific arguments and perform clearly outlined tasks. For instance, a fixed tool might execute a simple query such as \"Get today's weather for the user's location.\" Due to their structured nature, these tools excel at performing consistent lookups or monitoring values within structured environments like ERP systems, regulatory frameworks, or dashboards. However, their rigidity limits flexibility, prompting users to often replace them with more dynamic, traditional data pipelines, particularly for continuous data streaming.\n\nExamples of fixed tools in various industries include:\n\nFinance*: *\"What's the current exchange rate from USD to EUR?\"\nPharmaceuticals*: *\"Retrieve the known adverse effects for Drug ABC.\"\nManufacturing*: *\"What was the defect rate for batch #42?\"\n\n\nFree-form tools represent the most flexible end of the tool spectrum. These tools are capable of executing complex, open-ended tasks with minimal constraints on input structure. A common example is a code interpreter, capable of handling diverse analytical tasks. Although their flexibility offers substantial advantages, they can also introduce unpredictability and can be more challenging to optimize for consistent reliability.\n\nIn industry applications, free-form tools can look like:\n\nFinance*: *\"Backtest this momentum trading strategy using ETF price data over the past 10 years, and plot the Sharpe ratio distribution.\"\nAutomotive*: *\"Given this raw telemetry log, identify patterns that indicate early brake failure and simulate outcomes under various terrain conditions.\"\nPharmaceuticals*: *\"Create a pipeline that filters for statistically significant gene upregulation from this dataset, then run gene set enrichment analysis and generate a publication-ready figure.\"\n\n\n\nModern agentic workflows frequently require tools that effectively balance structure and flexibility. Semi-structured tools are designed specifically to manage this middle ground. They accept inputs in moderately complex formats—such as text fragments, JSON-like arguments, or small code snippets—and often embed basic reasoning, retrieval, or decision-making capabilities. These tools are ideal when tasks are well-defined but not entirely uniform, such as when the required dataset or service is known, but the query or expected output varies.\n\nTwo common paradigms of semi-structured tools are:\n\nExtended Capabilities**: Tools that function as specialized agents themselves, incorporating internal logic and analysis routines\nFlexible Argument Interfaces**: Tools permitting the LLM to pass expressive yet structured arguments, such as detailed queries, filters, or embedded functions\n\nSemi-structured tools are particularly valuable when:\n\nDelegating specific yet non-trivial tasks (like searches, transformations, or summarizations) to specialized tools\nThe source data or APIs are known, but the results returned can be unpredictable\n\nIn production environments, these tools are often preferable to free-form tools, like code interpreters, due to their enhanced reliability and performance. For instance, executing complex, multi-step queries against large Neo4j knowledge graphs is more reliable and efficient using optimized Cypher queries templated within semi-structured tools rather than generating each query from scratch.\n\nIndustry applications of semi-structured tools include:\n\nFinance*: *\"Extract all forward-looking risk factors from company filings for Q2 2023.\"\nAutomotive*: *\"Identify recurring electrical faults from maintenance logs across EV models launched after 2020.\"\nPharmaceuticals*: *\"Locate omics data supporting the hypothesis that a specific mRNA treatment effectively upregulates the IRS1 gene.\"\n\nThe factual_qa tool provides an efficient way for our agent to retrieve information from our temporal knowledge graph pertaining to a particular company, topic, and date range. This will help the agent answer questions about the data such as \"What were AMD's earnings in Q3 2017?\"\n\nThis tool sits somewhere in the middle of the fixed and semi-structured tools we introduced earlier. This is generally quite a rigid tool in that it restricts the agent to a small number of parameters. However, the degrees of freedom in the input are large and the tool is still flexible in what information it can retrieve from the knowledge graph. This helps avoid the need for the core agent to write new queries for networkx from scratch on each query, improving accuracy and latency.\n\nThe tool has the following arguments:\nentity: This is the entity (or object with respect to triplet ontology) that the tool should retrieve information for\nstart_date_range: This is the lower bound of the date range that the tool should retrieve over\nend_date_range: This is the upper bound of the date range that the tool should retrieve over\npredicate: This is the name of the predicate that the tool will connect the entity to perform a retrieval\n\nWe begin by loading the predicate definitions. We will use these to improve error tolerance in the tool, using a GPT-4.1-nano to normalize the predicate passed in the argument to a valid predicate name.\nWe define several helper functions for the factual QA tool.\n\nFirst is _as_datetime. This tool is used to coerce the arguments that define the date range to the correct datetime format.\n\nNext, we introduce two new data models: PredicateMatching and PredicateMatchValidation. PredicateMatching defines the output format for the GPT-4.1-nano call that matches the predicate in the function arguments to valid predicate names. PredicateMatchValidation then performs a secondary validation step to assert that this output from GPT-4.1-nano is a valid predicate name, leveraging a Pydantic field validator. This process helps to ensure that the tool runs smoothly and helps to eliminate some of the rare edge cases which would lead to an unsuccessful graph query.\nOur factual QA tool can be decomposed into four steps.\n\n    Predicate coercion\n\n      If the provided predicate is not found in the PREDICATE_DEFINITIONS dictionary, this step uses GPT-4.1-nano to coerce it into a valid predicate\n\n    Entity location\n\n      Performs fuzzy matching to identify the corresponding entity nodes within the networkx graph\n\n    Edge collection\n\n      Retrieves both inbound and outbound edges associated with the identified entity nodes\n\n    Response formatting\n\n      Structures the collected information into a well-formatted response that is easy for the orchestrator to consume\n\n\nThe trend_analysis tool is designed to compare how specific metrics or signals evolve over time—often across multiple companies and/or topics. It exposes a structured interface that lets the agent specify the time window, subject set, and target metric, then delegates the comparison logic to a specialised agent for handling this analysis. In this case we utilised o4-mini with high reasoning effort as this is a 'harder' anaysis task.\n\nThis allows us to build a highly focused and optimised pipeline for dealing with comparison-style tasks. Whilst this could be built into the core orchestrator itself, it's often more manageable to split this into specialised tools so they can be more easily swapped out or updated later without much concern for impact on the wider system.\nWe design a simple retriever containing only a run method which encompasses the planning step and a while loop to execute each tool call that the orchestrator makes before returning a final answer.\nWe can now run our MultiStepRetriever.\n\nWe observe that the answer returned is detailed, and includes a detailed walkthrough of how AMD's research priorities evolved from 2016 to 2020, with references to the underlying quotes that were used to derive these answers.\nWe can also inspect the tools used by our MultiStepRetriever to answer this query.\nAppendix section A.5. \"Scaling and Productionizing our Retrieval Agent\" outlines some guidelines for how one could take the Retrieval Agent we've built up to production.\n\nMulti-step retrieval agents need strong reasoning to hop through entities and relations, verify answers, and decide what to do next.  Latency still matters to users, but usually less than raw accuracy. Hence, this is one of the domains where OpenAI's o3 and o4-mini reasoning models shine.\n\nOnce again, for development we recommend a “start big, then specialise” ladder:\n\nStart with o3 – ensure your retrieval logic (chaining, re-ranking, fallback prompts) is sound. o3 may also be the best choice for production if your retrieval system is working with particularly complex data such as pharmaceutical or legal data. You can test this by looking at the severity of performance degradation with smaller models. If the drop off in performance is large, consider sticking with o3\nMove to o4-mini\n   Prompt enhancement - optimise your prompts to push the performance of the o4-mini system as close to that of the full o3 model\n   Reinforcement fine-tuning (RFT) - OpenAI's Reinforcement Fine-Tuning offering enables you to fine-tune OpenAI's o-series models to improve their performance on hard reasoning tasks. With as little as ~50 golden answers you can leverage the power of reinforcement learning to fine-tune o4-mini which can help it come close or even exceed the base o3's performance on the same task\nFallback to GPT 4.1 when latency dominates – for cases when latency is particularly important or you've tuned your prompts well enough that performance drop-off is minimal, consider moving to the GPT 4.1 series\n\n| Model       | Relative cost | Relative latency | Intelligence | Ideal role in workflow                               |\n| ----------- | ------------- | ---------------- | - | ---------------------------------------------------- |\n| o3 | ★★★           | ★★               | ★★★ (highest) | Initial prototyping, working with complex data, golden dataset generation |\n| o4-mini   | ★★            | ★               | ★★ | Main production engine, can push performance with RFT      |\n| GPT 4.1 series   | ★ (lowest)          | ★ (fastest) | ★  | Latency-critical or large-scale background scoring   |\n\nRFT has a number of benefits over Supervised Fine-Tuning or Direct Preference Optimization for this use case.\n\nFirstly, reinforcement fine-tuning can be performed with a far small number of examples, sometimes requiring as little as 50 training examples.\n\nAdditionally, RFT eliminates the necessity of providing labeled step-by-step trajectories. By supplying only the final correct answer, the system learns implicitly how to navigate the knowledge graph effectively. This feature is particularly valuable in real-world contexts where end users typically face time constraints and may struggle to curate the extensive sets of labeled examples (often numbering in the hundreds or thousands) required by traditional SFT methods.\n\n    Human-annotated “Golden Answers”\n\n      The traditional baseline for retrieval evaluation: a curated set of query → gold answer pairs,\n      vetted by domain experts.\n      Metrics such as precision@k or recall@k are computed by matching retrieved passages\n      against these gold spans.\n\n      Pros:   Highest reliability, clear pass/fail thresholds, excellent for regression testing\n      Cons:   Expensive to create, slow to update, narrow coverage (quickly becomes stale\n      when the knowledge base evolves)\n\n    Synthetically generated answers\n\n      Use an LLM to generate reference answers or judgments, enabling rapid, low-cost expansion\n      of the evaluation set.  Three common pathways:\n\n      LLM-as-judge: Feed the query, retrieved passages, and candidate answer to a\n          judge model that outputs a graded score or e.g., “yes / partial / no”\n      Tool-use pathway: For different question types you can either manually or synthetically generate the 'correct' tool-use pathways and score responses against this\n\n      Pros:  Fast, infinitely scalable, easier to keep pace with a dynamic application specification\n      Cons:  Judgement quality is typically of lower quality than expert human-annotated solutions\n\n    Human feedback\n\n      Collect ratings directly from end-users or domain reviewers (thumbs-up/down, five-star scores, pairwise\n      comparisons).  Can be in-the-loop (model trains continuously on live feedback) or\n      offline (periodic eval rounds).\n\n      Pros:  Captures real-world utility, surfaces edge-cases synthetic tests miss\n      Cons:  Noisy and subjective; requires thoughtful aggregation (e.g., ELO\n      scoring), risk of user biases becoming incorporated in the model\n\n\nThere is no single best method. However, a workflow that we have found that works well on projects is:\nStart building and iterate synthetic evaluations\nTest with your golden human set of evaluations before deployment\nMake it easy for end-users to annotate good and bad answers, and use this feedback to continue to develop your application over time\n\nTransitioning your knowledge graph system from a proof-of-concept to a robust, production-grade pipeline requires you to address several key points:\nStoring and retrieving high-volume graph data**\nMananging and pruning datasets**\nImplementing concurrency in the ingestion pipeline**\nMinimizing token cost**\nScaling retrieval agents**\nSafeguards**\n\nThis section serves as a walkthrough of key considerations and best practices to ensure your temporally-aware knowledge graph can operate reliably in a real-world environment. A more detailed Prototype to Production Appendix section can be found towards the end of this cookbook.\n\n\n\n\n  Storing and Retrieving High-Volume Graph Data\n\n    Appendix section A.1. \"Storing and Retrieving High-Volume Graph Data\"\n\n    Manage scalability through thoughtful schema design, sharding, and partitioning. Clearly define entities, relationships, and ensure schema flexibility for future evolution. Use high-cardinality fields like timestamps for efficient data partitioning.\n\n\n  Temporal Validity \u0026 Versioning\n\n    Appendix section A.1.2. \"Temporal Validity \u0026 Versioning\"\n\n    Include temporal markers (valid_from, valid_to) for each statement. Maintain historical records non-destructively by marking outdated facts as inactive and indexing temporal fields for efficient queries.\n\n\n  Indexing \u0026 Semantic Search\n\n    Appendix section A.1.3. \"Indexing \u0026 Semantic Search\"\n\n    Utilize B-tree indexes for efficient temporal querying. Leverage PostgreSQL’s pgvector extension for semantic search with approximate nearest-neighbor algorithms like ivfflat, ivfpq, and hnsw to optimize query speed and memory usage.\n\n\n  Managing and Pruning Datasets\n\n    Appendix section A.2. \"Managing and Pruning Datasets\"\n\n    Establish TTL and archival policies for data retention based on source reliability and relevance. Implement automated archival tasks and intelligent pruning with relevance scoring to optimize graph size.\n\n\n  Concurrent Ingestion Pipeline\n\n    Appendix section A.3. \"Implementing Concurrency in the Ingestion Pipeline\"\n\n    Implement batch processing with separate, scalable pipeline stages for chunking, extraction, invalidation, and entity resolution. Optimize throughput and parallelism to manage ingestion bottlenecks.\n\n\n  Minimizing Token Costs\n\n    Appendix section A.4. \"Minimizing Token Cost\"\n\n    Use caching strategies to avoid redundant API calls. Adopt service tiers like OpenAI's flex option to reduce costs and replace expensive model queries with efficient embedding and nearest-neighbor search.\n\n\n  Scaling Retrieval Agents\n\n    Appendix section A.5. \"Scaling and Productionizing our Retrieval Agent\"\n\n    Use a controller and traversal workers architecture to handle multi-hop queries. Implement parallel subgraph extraction, dynamic traversal with chained reasoning, caching, and autoscaling for high performance.\n\n\n  Safeguards \u0026 Verification\n\n    Appendix section A.6. \"Safeguards\"\n\n    Deploy multi-layered output verification, structured logging, and monitoring to ensure data integrity and operational reliability. Track critical metrics and perform regular audits.\n\n\n  Prompt Optimization\n\n    Appendix section A.7. \"Prompt Optimization\"\n\n    Optimize LLM interactions with personas, few-shot prompts, chain-of-thought methods, dynamic context management, and automated A/B testing of prompt variations for continuous performance improvement.\n\n\nThis cookbook equips you with foundational techniques and concrete workflows to effectively build and deploy temporally-aware knowledge graphs coupled with powerful multi-hop retrieval capabilities.\n\nWhether you're starting from a prototype or refining a production system, leveraging structured graph data with OpenAI models can unlock richer, more nuanced interactions with your data. As these technologies evolve rapidly, look out for updates in OpenAI's model lineup and keep experimenting with indexing methods and retrieval strategies to continuously enhance your knowledge-centric AI solutions.\n\nYou can easily adapt the frameworks presented in this cookbook to your respective domain by customizing the provided ontologies and refining the extraction prompts. Swapping in Neo4j as the graph database takes you well on the way to an MVP level application, providing data persistence out of the box. It also opens the door to levelling up your retriever's tools with Cypher queries.\n\nIterively develop your solution by making use of synthetic evals, and then test your solution against \"golden\" expert-human annotated solutions. Once in production, you can quickly iterate from human feedback to push your application to new heights.\nThis cookbook serves as a joint collaboration between OpenAI and Tomoro.\n\nAlex Heald\nDouglas Adams\nRishabh Sagar\nDanny Wigg\nShikhar Kwatra\nWithin this appendix, you'll find a more in-depth Prototype to Production section.\nAs your dataset scales to millions or even billions of nodes and edges, managing performance and maintainability becomes critical. This requires thoughtful approaches to both schema design and data partitioning:\n\n    Schema design for growth and change\n\n      Clearly define core entity types (e.g., Person, Organization, Event) and relationships. Design the schema with versioning and flexibility in mind, enabling future schema evolution with minimal downtime.\n\n    Sharding \u0026amp; partitioning\n\n      Use high-cardinality fields (such as timestamps or unique entity IDs) for partitioning to preserve query performance as data volume grows. This is particularly important for temporally-aware data. For example:\n\n    CREATE TABLE statements (\n    statement_id UUID PRIMARY KEY,\n    entity_id UUID NOT NULL,\n    text TEXT NOT NULL,\n    valid_from TIMESTAMP NOT NULL,\n    valid_to TIMESTAMP,\n    status VARCHAR(16) DEFAULT 'active',\n    embedding VECTOR(1536),\n    ...\n  ) PARTITION BY RANGE (valid_from);\n\n\nIn our temporal knowledge graph, each statement includes temporal markers (e.g., valid_from, valid_to).\n\n    Preserve history non-destructively\n\n      Avoid deleting or overwriting records. Instead mark outdated facts as inactive by setting a status (e.g., inactive).\n\n    Optimize for temporal access\n\n      Index temporal fields (valid_from, valid_to) to support efficient querying of both current and historical states.\n\n\nRather than removing or overwriting a record, update its status and close its validity window:\n\nUPDATE statements\nSET status = 'inactive', valid_to = '2025-03-15T00:00:00Z'\nWHERE statement_id = '...' AND entity_id = '...';\nTo support efficient temporal queries create B-tree indexes on valid_from and valid_to. A 'B-tree' index is a tree data structure that keeps data sorted to facilitate fast lookups, range queries, and ordered scans in logarithmic time. It's the default index type in many relational databases.\n\nCREATE INDEX ON statements (valid_from);\nCREATE INDEX ON statements (valid_to);\nStoring vector embeddings in PostgreSQL (via the pgvector extension) enables similarity-based retrieval via semantic search. This follows a two-step process:\nStore high-dimensional vectors that represent the semantic meaning of the text. These can be created with embedding models such as OpenAI's text-embedding-3-small and text-embedding-3-large\nUse Approximate Nearest-Neighbour (ANN) for efficient similarity matching at scale\n\nThere are several different indexing options available in pgvector, each with different purposes. These indexing options are described in more detail, along with in-depth implementation steps in the README on the Github repository for pgvector.\n| Index Type | Build Time | Query Speed | Memory Usage | Accuracy | Recommended Scale | Notes |\n|-------------------------------------|--------------------------------------|----------------------------------------|-----------------------------------------|-----------------------------------|----------------------------------------------|-------|\n| flat | Minimal | Slow(linear scan) | Low | 100%(exact) | Very small(\u0026lt; 100 K vectors) | No approximate indexing—scans all vectors. Best for exact recall on small collections |\n| ivfflat | Moderate | Fast when tuned | Moderate | High(tunable) | Small to Medium(100 K–200 M) | Uses inverted file indexing. Query-time parameters control trade-offs |\n| ivfpq | High | Very fast | Low(quantized) | Slightly lowerthan ivfflat | Medium to Large(1 M–500 M) | Combines inverted files with product quantization for lower memory use |\n| hnsw | Highest | Fastest(esp. at scale) | High(in-memory) | Very high | Large to Very Large(100 M–Billions+) | Builds a hierarchical navigable graph. Ideal for latency-sensitive, high-scale systems |\n\n\n\nivfflat\nlists: Number of partitions (e.g., 100)\nprobes: Number of partitions to scan at query time (e.g., 10-20), controls recall vs. latency\n\nivfpq\nsubvectors: Number of blocks to quantize (e.g., 16)\nbits: Number of bits per block (e.g., 8)\nprobes: Same as in ivfflat\n\nhnsw\nM: Max connections per node (e.g., 16)\nef_construction: Build-time dynamic candidate list size (e.g., 200)\nef_search: Queyr-time candidate pool (e.g., 64-128)\n\nflat for debugging or small datasets\nivfflat when you want tunable accuracy with good speed\nivfpq when memory efficieny is critical\nhnsw when optimizing for lowest latency on massive collections\n\n\n| Vector DB    | Key Features                                                 | Pros                                        | Cons                                                            |\n| ------------ | ------------------------------------------------------------ | ------------------------------------------- | --------------------------------------------------------------- |\n| Pinecone | Fully managed, serverless; supports HNSW and SPANN           | Auto-scaling, SLA-backed, easy to integrate | Vendor lock-in; cost escalates at scale                         |\n| Weaviate | GraphQL API, built-in modules for encoding and vectorization | Hybrid queries (metadata + vector), modular | Production deployment requires Kubernetes                       |\n| Milvus   | Supports GPU indexing; IVF, HNSW, ANNOY                      | High performance at scale, dynamic indexing | Operational complexity; separate system                         |\n| Qdrant   | Lightweight, real-time updates, payload filtering            | Simple setup, good hybrid query support     | Lacks native relational joins; eventual consistency in clusters |\n| Vectara  | Managed with semantic ranking and re-ranking                 | Strong relevance features; easy integration | Proprietary; limited index control                              |\n\n\n| Scale | Recommendation | Details |\n|--------------------------------|------------------------------------------|---------|\n| Small to Medium Scale(less than 100M vectors) | PostgreSQL + pgvectorwith ivfflat index | Often sufficient for moderate workloads. Recommended settings: lists = 100–200, probes = 10–20. |\n| Large Scale(100M – 1B+ vectors) | Milvus or Qdrant | Suitable for high-throughput workloads, especially when GPU-accelerated indexing or sub-millisecond latency is needed. |\n| Hybrid Scenarios | PostgreSQL for metadata+ dedicated vector DB | Use PostgreSQL for entity metadata storage and a vector DB (e.g., Milvus, Qdrant) for similarity search. Synchronize embeddings using CDC pipelines (e.g., Debezium). |\n\nFor more detailed information, check out the OpenAI cookbook on vector databases.\n\nFor some cases, especially those requiring high availability or state recovery across restarts, it may be worth persisting state to reliable disk storage and implementing a backup strategy.\n\nIf durability is a concern, consider using persistent disks with regular backups or syncing state to external storage. While not necessary for all deployments, it can provide a valuable safeguard against data loss or operational disruption in environments where consistency and fault tolerance matter.\nEstablish clear policies to determine which facts should be retained indefinitely (e.g., legally required records for regulators) and which can be archived after a defined period (e.g., statements sourced from social media more than one year old).\n\nKey practices to include:\n\n    Automated Archival Jobs\n\n      Set up a background task that periodically queries for records with e.g., valid_to \u0026lt; NOW() - INTERVAL 'X days' and moves them to an archival table for long-term storage.\n\n    Source-Specific Retention Policies\n\n      Tailor retention durations by data source or entity type. For example, high-authority sources like government publications may warrant longer retention than less reliable data such as scraped news headlines or user-generated content.\n\n\nAs your knowledge graph grows, the utility of many facts will decline. To keep the graph focused and maximise performance:\n\n    Index a Relevance Score\n\n      Introduce a numeric relevance_score column (or columns) that incorporate metrics such as recency, source trustworthiness, and production query frequency.\n\n    Automated Pruning Logic\n\n      Schedule a routine job to prune or archive facts falling below a predefined relevance threshold.\n\n\nEfficiently reducing the size of a knowledge graph is important when scaling. A 2024 survey categorizes techniques into sparsification, coarsening, and condensation—all aimed at shrinking the graph while preserving task-critical semantics. These methods offer substantial runtime and memory gains on large-scale KGs.\n\nExample implementation pattern:\n\n    Score Each Triple\n\n      Compute a composite relevance_score, for example:\n\n    relevance_score = β1 * recency_score + β2 * source_trust_score + β3 * retrieval_count\n\n      Where:\n\n      recency_score: exponential decay from valid_from\n      source_trust_score: source-domain trust value\n      retrieval_count: production query frequency\n\n    Apply a Reduction Strategy\n\n      Sparsify: Select and retain only the most relevant edges or nodes based on criteria like centrality, spectral similarity, or embedding preservation\n      Coarsen: Group low-importance or semantically similar nodes into super-nodes and aggregate their features and connections\n      Condense: Construct a task-optimized mini-graph from scratch\n\n    Validate in Shadow Mode\n\n      Log and compare outputs from the pruned vs. original graph before routing production traffic.\n\n    Re-Score Regularly\n\n      Recompute relevance (e.g., nightly) to ensure new or frequently accessed facts surface back to the top.\n\n\nMoving from prototype to production often requires you to transform your linear processing pipeline into a concurrent, scalable pipeline. Instead of processing documents sequentially (document → chunking → statement extraction → entity extraction → statement invalidation → entity resolution), implement a staged pipeline where each phase can scale independently.\n\nDesign your pipeline with a series of specialized stages, each with its own queue and worker pool. This allows you to scale bottlenecks independently and maintain system reliability under varying loads.\n\n    Batch Chunking\n\n      Begin by collecting documents in batches of e.g., 100–500 using a job queue like Redis or Amazon SQS. Process these documents in parallel, splitting each into their respective chunks. The chunking stage should often optimize for I/O parallelization as document reading is often the bottleneck. You can then store the chunks and their respective metadata in your chunk_store table, using bulk insert operations to minimize overhead.\n\n    Statement and Entity Extraction\n\n      Pull chunks in batches of e.g., 50–100 and send them to your chosen LLM (e.g., GPT-4.1-mini) using parallel API requests. Implement rate limiting with semaphores or other methods to stay safely within OpenAI's API limits whilst maximizing your throughputs. We've covered rate limiting in more detail in our cookbook on How to handle rate limits. Once extracted, you can then write these to the relevant table in your database.\n\n      You can then similarly group the statements we've just extracted into batches, and run the entity extraction processes in a similar vein before storing them.\n\n    Statement Invalidation\n\n      Group extracted statement IDs by their associated entity clusters (e.g., all statements related to a specific entity like “Acme Corp.”). Send each cluster to your LLM (e.g., GPT-4.1-mini) in parallel to assess which statements are outdated or superseded. Use the model’s output to update the status field in your statements table—e.g., setting status = 'inactive'. Parallelize invalidation jobs for performance and consider scheduling periodic sweeps for consistency.\n\n    Entity Resolution\n\n      Take batches of newly extracted entity mentions and compute embeddings using your model’s embedding endpoint. Insert these into your entity_registry table, assigning each a provisional or canonical entity_id. Perform approximate nearest-neighbor (ANN) searches using pgvector to identify near-duplicates or aliases. You can then update the entities table with resolved canonical IDs, ensuring downstream tasks reference unified representations.\n\n\nThroughput – Batching reduces the overhead of individual API calls and database transactions.\n\nParallelism – Each stage can horizontally scale: you can run multiple worker processes for chunking, extraction, invalidation, etc., each reading from a queue.\n\nBackpressure \u0026 Reliability – If one stage becomes slow (e.g., statement invalidation during a sudden data surge), upstream stages can buffer more items in the queue until capacity frees up.\n\nAvoid redundant API calls by memoizing responses to brittle sub-prompts.\n\nImplementation Strategy:\nCache Frequent Queries**: For example, repeated prompts like \"Extract entities from this statement\" on identicial statements\nUse Hash Keys**: Generate a unique cache key using the MD5 hash of the statement text: md5(statement_text)\nStorage Options**: Redis for scalable persistence or in-memory LRU cache for simplicity and speed\nBypass API Calls**: If a statement is found in cache, skip the API call\nUtilize the service_tier=flex parameter in the OpenAI Responses SDK to enable partial completions and reduce costs.\n\nAPI Configuration:\n{\n  \"model\": \"o4-mini\",\n  \"prompt\": \"\",\n  \"service_tier\": \"flex\"\n}\n\nCost Benefits:\nCharges only for generated tokens, not prompt tokens\nCan reduce costs by up to 40% for short extractions (e.g., single-sentence entity lists)\n\nYou can learn more about the power of Flex processing and how to utilise it in the API documentation for Flex processing.\nReplace expensive text-generation calls with more efficient alternatives where possible.\n\nAlternative approach:\nUse embeddings endpoint (cheaper per token) combined with pgvector nearest-neighbor search\nInstead of asking the model \"Which existing statement is most similar?\", compute embeddings once and query directly in Postgres\nThis approach is particularly effective for semantic similarity tasks\n\nBenefits:\nLower cost per operation\nFaster query response times\nReduced API dependency for similarity searches\nOnce your graph is populated, you need a mechanism to answer multi-hop queries at scale. This requires:\n\n    Agent Architecture\n\n      Controller Agent (Frontend): Receives a user question (e.g., “What events led to Acme Corp.’s IPO?”), then decomposes it into sub-questions or traversal steps.\n      Traversal Worker Agents: Each worker can perform a local graph traversal (e.g., “Find all facts where Acme Corp. has EventType = Acquisition between 2020–2025”), possibly in parallel on different partitions of the graph.\n\n    Parallel Subgraph Extraction\n\n      Partition the graph by entity ID hash (e.g., modulo 16). For a given query, identify which partitions are likely to contain relevant edges, then dispatch traversal tasks in parallel to each worker.\n      Workers return partial subgraphs (nodes + edges), and the Controller Agent merges them.\n\n    Chained LLM Reasoning\n\n      For multi-hop questions, the Controller can prompt a model (e.g., GPT-4.1) with the partial subgraph and ask “Which next edge should I traverse?” This allows dynamic, context-aware traversal rather than blind breadth-first search.\n\n    Caching and Memoization\n\n      For frequently asked queries or subgraph patterns, cache the results (e.g., in Redis or a Postgres Materialized View) with a TTL equal to the fact’s valid_to date, so that subsequent requests hit the cache instead of re-traversing.\n\n    Load Balancing \u0026amp; Autoscaling\n\n      Deploy the Traversal Worker Agents in a Kubernetes cluster with Horizontal Pod Autoscalers. Use CPU and memory metrics (and average queue length) to scale out during peak usage.\n\n\nRun a lightweight validation pipeline to ensure outputs are as desired. Some examples of what can be included in this:\nCheck that dates conform to ISO-8601\nVerify that entity types match your controlled vocabulary (e.g., if the model outputs an unexpected label, flag for manual review)\nDeploy a \"sanity-check\" function call to a smaller, cheaper model to verify the consistency of outputs (for example, “Does this statement parse correctly as a Fact? Yes/No.”)\nImplement structured logging with configurable verbosity levels (e.g., debug, info, warn, error)\nStore input pre-processing steps, intermediate outputs, and final results with full tracing, such as that offered via OpenAI's tracing\nTrack token throughput, latency, and error rates\nMonitor data quality metrics where possible, such as document or statement coverage, temporal resolution rates, and more\nMeasure business-related metrics such as user numbers, average message volume, and user satisfaction\n\n    Personas\n\n      Introducing a persona to the model is an effective way to drive performance. Once you have narrowed down the specialism of the component you are developing the prompt for, you can create a persona in the system prompt that helps to shape the model's behaviour. We used this in our planner model to create a system prompt like this:\n\n    initial_planner_system_prompt = (\n    \"You work for the leading financial firm, ABC Incorporated, one of the largest financial firms in the world. \"\n    \"Due to your long and esteemed tenure at the firm, various equity research teams will often come to you \"\n    \"for guidance on research tasks they are performing. Your expertise is particularly strong in the area of \"\n    \"ABC Incorporated's proprietary knowledge base of earnings call transcripts. This contains details that have been \"\n    \"extracted from the earnings call transcripts of various companies with labelling for when these statements are, or \"\n    \"were, valid. You are an expert at providing instructions to teams on how to use this knowledge graph to answer \"\n    \"their research queries. \\n\"\n)\n\n      Persona prompts can become much more developed and specific than this, but this should provide an insight into what this looks like in practice.\n\n    Few-Shot Prompting and Chain-of-Thought\n\n      For extraction-related tasks, such as statement extraction, a concise few-shot prompt (2–5 examples) will typically deliver higher precision than a zero-shot prompt at a marginal increase in cost.\n\n      For e.g., temporal reconciliation tasks, chain-of-thought methods where you guide the model through comparison logic are more appropriate. This can look like:\n\n    Example 1: [Old fact], [New fact] → Invalidate\nExample 2: [Old fact], [New fact] → Coexist\nNow: [Old fact], [New fact] →\n\n    Dynamic Prompting \u0026amp; Context Management\n\n      You can also lean on other LLMs or more structured methods to prune and prepare material that will be dynamically passed to prompts. We saw an example of this when building the tools for our retriever above, where the timeline_generation tool sorts the retrieved material before passing it back to the central orchestrator.\n\n      Steps to clean up the context or compress it mid-run can also be highly effective for longer-running queries.\n\n    Template Library \u0026amp; A/B Testing\n\n      Maintain a set of prompt templates in a version-controlled directory (e.g., prompts/statement_extraction.json, prompts/entity_extraction.json) to enable you to audit past changes and revert if necessary. You can utilize OpenAI's reusuable prompts for this. In the OpenAI dashboard, you can develop reusable prompts to use in API requests. This enables you to build and evaluate your prompts, deploying updated and improved versions without ever changing the code.\n\n      Automate A/B testing by periodically sampling extracted facts from the pipeline, re-running them through alternative prompts, and comparing performance scores (you can track this in a separate evaluation harness).\n\n      Track key performance indicators (KPIs) such as extraction latency, error rates, and invalidation accuracy.\n\n      If any metric drifts beyond a threshold (e.g., invalidation accuracy drops below 90%), trigger an alert and roll back to a previous prompt version."])</script><script>self.__next_f.push([1,"36:Tfdf,"])</script><script>self.__next_f.push([1,"This cookbook demonstrates how to use OpenAI's Evals framework for image-based tasks. Leveraging the Evals API, we will grade model-generated responses to an image and prompt by using sampling to generate model responses and model grading (LLM as a Judge) to score the model responses against the image, prompt, and reference answer.\n\nIn this example, we will evaluate how well our model can:\nGenerate appropriate responses to user prompts about images\nAlign with reference answers that represent high-quality responses\n\nWe use the VibeEval dataset that's hosted on Hugging Face. It contains a collection of user prompt, accompanying image, and reference answer data. First, we load the dataset.\nWe extract the relevant fields and put it in a json-like format to pass in as a data source in the Evals API. Input image data can be in the form of a web URL or a base64 encoded string. Here, we use the provided web URLs.\nIf you print the data source list, each item should be of a similar form to:\n\n{\n  \"item\": {\n    \"media_url\": \"https://storage.googleapis.com/reka-annotate.appspot.com/vibe-eval/difficulty-normal_food1_7e5c2cb9c8200d70.jpg\"\n    \"reference\": \"This appears to be a classic Margherita pizza, which has the following ingredients...\"\n    \"prompt\": \"What ingredients do I need to make this?\"\n  }\n}\n\nNow that we have our data source and task, we will create our evals. For the OpenAI Evals API docs, visit API docs.\n\nEvals have two parts, the \"Eval\" and the \"Run\". In the \"Eval\", we define the expected structure of the data and the testing criteria (grader).\n\nBased on the data that we have compiled, our data source config is as follows:\nFor our testing criteria, we set up our grader config. In this example, it is a model grader that takes in an image, reference answer, and sampled model response (in the sample namespace), and then outputs a score between 0 and 1 based on how closely the model response matches the reference answer and its general suitability for the conversation. For more info on model graders, visit API Grader docs.\n\nGetting the both the data and the grader right are key for an effective evaluation. So, you will likely want to iteratively refine the prompts for your graders.\nNote: The image url field / templating need to be placed in an input image object to be interpreted as an image. Otherwise, the image will be interpreted as a text string.\nNow, we create the eval object.\nTo create the run, we pass in the eval object id, the data source (i.e., the data we compiled earlier), and the chat message input we will use for sampling to generate the model response. Note that EvalsAPI also supports stored completions and responses containing images as a data source. See the Additional Info: Logs Data Source section for more info.\n\nHere's the sampling message input we'll use for this example.\nWe now kickoff an eval run.\nWhen the run finishes, we can take a look at the result. You can also check in your org's OpenAI evals dashboard to see the progress and results.\nTo see a full output item, we can do the following. The structure of an output item is specified in the API docs here.\n\nAs mentioned earlier, EvalsAPI supports logs (i.e., stored completions or responses) containing images as a data source. To use this functionality, change your eval configurations as follows:\n\nEval Creation\n  set data_source_config = { \"type\": \"logs\" }\n  revise templating in grader_config to use {{item.input}} and/or {{sample.output_text}}, denoting the input and output of the log\n\nEval Run Creation\n  specify the filters in the data_source field that will be used to obtain the corresponding logs for the eval run (see the docs for more information)\n\nIn this cookbook, we covered a workflow for evaluating an image-based task using the OpenAI Evals API's. By using the image input functionality for both sampling and model grading, we were able to streamline our evals process for the task.\n\nWe're excited to see you extend this to your own image-based use cases, whether it's OCR accuracy, image generation grading, and more!"])</script><script>self.__next_f.push([1,"37:T123c,"])</script><script>self.__next_f.push([1,"This cookbook demonstrates how to use OpenAI's Evals framework for audio-based tasks. Leveraging the Evals API, we will grade model-generated responses to an audio message and prompt by using sampling to generate model responses and model grading to score the model responses against the output audio and reference answer. Note that grading will be on audio outputs from the sampled response.\n\nBefore audio support was added, to evaluate audio conversations, they first needed to be transcribed to text. Now you can use the original audio and get samples from the model in audio as well. This more accurately represents workflows such as a customer support scenario where both the user and the agent are using audio. For grading, we will use an audio model to grade the audio response with a model grader. We could alternatively, or in combination, use the text transcript from the sampled audio and leverage the existing suite of text graders.\n\nIn this example, we will evaluate how well our model can:\nGenerate appropriate responses to user prompts about an audio message\nAlign with reference answers that represent high-quality responses\n\nWe use the big_bench_audio dataset that is hosted on Hugging Face. Big Bench Audio is an audio version of a subset of Big Bench Hard questions. The dataset can be used for evaluating the reasoning capabilities of models that support audio input. It contains an audio clip describing a logic problem, a category, and an official answer.\nWe extract the relevant fields and put them in a JSON-like format to pass in as a data source in the Evals API. Input audio data must be in the form of a base64-encoded string. We process the data in the audio file and convert it to base64.\n\nNote: Audio models currently support WAV, MP3, FLAC, Opus, or PCM16 formats. See audio inputs for details.\nIf you print the data source list, each item should be of a similar form to:\n\n{\n  \"item\": {\n    \"id\": 0\n    \"category\": \"formal_fallacies\"\n    \"official_answer\": \"invalid\"\n    \"audio_base64\": \"UklGRjrODwBXQVZFZm10IBAAAAABAAEAIlYAAESsA...\"\n  }\n}\n\nNow that we have our data source and task, we will create our evals. For the OpenAI Evals API docs, visit API docs.\n\nSince audio inputs are large, we need to save the examples to a file and upload it to the API.\nEvals have two parts: the \"Eval\" and the \"Run\". In the \"Eval\" we define the expected structure of the data and the testing criteria (grader).\n\nBased on the data that we have compiled, our data source configuration is as follows:\nFor our testing criteria, we set up our grader configuration. In this example, we use a score_model grader that takes in the official answer and sampled model response (in the sample namespace), and then outputs a score of 0 or 1 based on whether the model response matches the official answer. The response contains both audio and the text transcript of the audio. We will use the audio in the grader. For more information on graders, visit API Grader docs.\n\nGetting both the data and the grader right is key for an effective evaluation. You will likely want to iteratively refine the prompts for your graders.\nAlternatively we could use a string_check grader that takes in the official answer and sampled model response (in the sample namespace), and then outputs a score between 0 and 1 based on if the model response contains the reference answer. The response contains both audio and the text transcript of the audio. We will use the text transcript in the grader.\n\ngrader_config = {\n  \"type\": \"string_check\",\n  \"name\": \"String check grader\",\n  \"input\": \"{{sample.output_text}}\",\n  \"reference\": \"{{item.official_answer}}\",\n  \"operation\": \"ilike\"\n}\nNow, we create the eval object.\nTo create the run, we pass in the eval object id, the data source (i.e., the data we compiled earlier), and the chat message input we will use for sampling to generate the model response.\n\nHere's the sampling message input we'll use for this example.\nWe now kick off an eval run.\nWhen the run finishes, we can take a look at the result. You can also check your organization's OpenAI Evals dashboard to see the progress and results.\nTo see a full output item, we can do the following. The structure of an output item is specified in the API docs here.\n\nIn this cookbook, we covered a workflow for evaluating native audio inputs to a model using the OpenAI Evals API. We demonstrated using a score model grader to grade the audio response.\nConvert this example to your own use case.\nIf you have large audio clips, try using the uploads API for support up to 8 GB.\nNavigate to the Evals dashboard to visualize the outputs and get insights into the performance of the eval."])</script><script>self.__next_f.push([1,"38:T2773,"])</script><script>self.__next_f.push([1,"Crafting effective prompts is a critical skill when working with AI models. Even experienced users can inadvertently introduce contradictions, ambiguities, or inconsistencies that lead to suboptimal results. The system demonstrated here helps identify and fix common issues, resulting in more reliable and effective prompts.\n\nThe optimization process uses a multi-agent approach with specialized AI agents collaborating to analyze and rewrite prompts. The system automatically identifies and addresses several types of common issues:\n\nContradictions** in the prompt instructions\nMissing or unclear format specifications\nInconsistencies** between the prompt and few-shot examples\n\nObjective: This cookbook demonstrates best practices for using Agents SDK together with Evals to build an early version of OpenAI's prompt optimization system. You can optimize your prompt using this code or use the optimizer in our playground!\n\n\n\n\n\n\n\n\nAsk ChatGPT\n\n\nCookbook Structure\nThis notebook follows this structure:\n\nStep 1. System Overview - Learn how the prompt optimization system works\nStep 2. Data Models - Understand the data structures used by the system\nStep 3. Defining the Agents - Look at agents that analyze and improve prompts\nStep 4. Evaluations - Use Evals to verify our agent model choice and instructions\nStep 5. Run Optimization Workflow - See how the workflow hands off the prompts\nStep 6. Examples - Explore real-world examples of prompt optimization\n\nPrerequisites\nThe openai Python package\nThe openai-agents package\nAn OpenAI API key set as OPENAI_API_KEY in your environment variables\n\nThe prompt optimization system uses a collaborative multi-agent approach to analyze and improve prompts. Each agent specializes in either detecting or rewriting a specific type of issue:\n\nDev-Contradiction-Checker: Scans the prompt for logical contradictions or impossible instructions, like \"only use positive numbers\" and \"include negative examples\" in the same prompt.\n\nFormat-Checker: Identifies when a prompt expects structured output (like JSON, CSV, or Markdown) but fails to clearly specify the exact format requirements. This agent ensures that all necessary fields, data types, and formatting rules are explicitly defined.\n\nFew-Shot-Consistency-Checker: Examines example conversations to ensure that the assistant's responses actually follow the rules specified in the prompt. This catches mismatches between what the prompt requires and what the examples demonstrate.\n\nDev-Rewriter: After issues are identified, this agent rewrites the prompt to resolve contradictions and clarify format specifications while preserving the original intent.\n\nFew-Shot-Rewriter: Updates inconsistent example responses to align with the rules in the prompt, ensuring all examples properly comply with the new developer prompt.\n\nBy working together, these agents can systematically identify and fix issues in prompts.\n\nTo facilitate structured communication between agents, the system uses Pydantic models to define the expected format for inputs and outputs. These Pydantic models help validate data and ensure consistency throughout the workflow.\n\nThe data models include:\n\nRole - An enumeration for message roles (user/assistant)\nChatMessage - Represents a single message in a conversation\nIssues - Base model for reporting detected issues\nFewShotIssues - Extended model that adds rewrite suggestions for example messages\nMessagesOutput - Contains optimized conversation messages\nDevRewriteOutput - Contains the improved developer prompt\n\nUsing Pydantic allows the system to validate that all data conforms to the expected format at each step of the process.\n\nIn this section, we create specialized AI agents using the Agent class from the openai-agents package. Looking at these agent definitions reveals several best practices for creating effective AI instructions:\n\n\nClear Scope Definition: Each agent has a narrowly defined purpose with explicit boundaries. For example, the contradiction checker focuses only on \"genuine self-contradictions\" and explicitly states that \"overlaps or redundancies are not contradictions.\"\n\nStep-by-Step Process: Instructions provide a clear methodology, like how the format checker first categorizes the task before analyzing format requirements.\n\nExplicit Definitions: Key terms are defined precisely to avoid ambiguity. The few-shot consistency checker includes a detailed \"Compliance Rubric\" explaining exactly what constitutes compliance.\n\nBoundary Setting: Instructions specify what the agent should NOT do. The few-shot checker explicitly lists what's \"Out-of-scope\" to prevent over-flagging issues.\n\nStructured Output Requirements: Each agent has a strictly defined output format with examples, ensuring consistency in the optimization pipeline.\n\nThese principles create reliable, focused agents that work effectively together in the optimization system. Below we see the complete agent definitions with their detailed instructions.\n\nLet's see how we used OpenAI Evals to tune agent instructions and pick the correct model to use. In order to do so we constructed a set of golden examples: each one contains original messages (developer message + user/assistant message) and the changes our optimization workflow should make. Here are two example of golden pairs that we used:\n[\n  {\n    \"focus\": \"contradiction_issues\",\n    \"input_payload\": {\n      \"developer_message\": \"Always answer in English.\\nNunca respondas en inglés.\",\n      \"messages\": [\n        {\n          \"role\": \"user\",\n          \"content\": \"¿Qué hora es?\"\n        }\n      ]\n    },\n    \"golden_output\": {\n      \"changes\": true,\n      \"new_developer_message\": \"Always answer in English.\",\n      \"new_messages\": [\n        {\n          \"role\": \"user\",\n          \"content\": \"¿Qué hora es?\"\n        }\n      ],\n      \"contradiction_issues\": \"Developer message simultaneously insists on English and forbids it.\",\n      \"few_shot_contradiction_issues\": \"\",\n      \"format_issues\": \"\",\n      \"general_improvements\": \"\"\n    }\n  },\n  {\n    \"focus\": \"few_shot_contradiction_issues\",\n    \"input_payload\": {\n      \"developer_message\": \"Respond with only 'yes' or 'no' – no explanations.\",\n      \"messages\": [\n        {\n          \"role\": \"user\",\n          \"content\": \"Is the sky blue?\"\n        },\n        {\n          \"role\": \"assistant\",\n          \"content\": \"Yes, because wavelengths …\"\n        },\n        {\n          \"role\": \"user\",\n          \"content\": \"Is water wet?\"\n        },\n        {\n          \"role\": \"assistant\",\n          \"content\": \"Yes.\"\n        }\n      ]\n    },\n    \"golden_output\": {\n      \"changes\": true,\n      \"new_developer_message\": \"Respond with only the single word \\\"yes\\\" or \\\"no\\\".\",\n      \"new_messages\": [\n        {\n          \"role\": \"user\",\n          \"content\": \"Is the sky blue?\"\n        },\n        {\n          \"role\": \"assistant\",\n          \"content\": \"yes\"\n        },\n        {\n          \"role\": \"user\",\n          \"content\": \"Is water wet?\"\n        },\n        {\n          \"role\": \"assistant\",\n          \"content\": \"yes\"\n        }\n      ],\n      \"contradiction_issues\": \"\",\n      \"few_shot_contradiction_issues\": \"Assistant examples include explanations despite instruction not to.\",\n      \"format_issues\": \"\",\n      \"general_improvements\": \"\"\n    }\n  }\n]\nFrom these 20 hand labelled golden outputs which cover a range of contradiction issues, few shot issues, format issues, no issues, or a combination of issues, we built a python string check grader to verify two things: whether an issue was detected for each golden pair and whether the detected issue matched the expected one. From this signal, we tuned the agent instructions and which model to use to maximize our accuracy across this evaluation. We landed on the 4.1 model as a balance between accuracy, cost, and speed. The specific prompts we used also follow the 4.1 prompting guide. As you can see, we achieve the correct labels on all 20 golden outputs: identifying the right issues and avoiding false positives.\nAccuracy for the golden set\nEvaluation for the golden set\n\nLet's dive into how the optimization system actually works end to end. The core workflow consists of multiple runs of the agents in parallel to efficiently process and optimize prompts.\nTrace for the workflow\n\nThe optimize_prompt_parallel function implements a workflow to maximize efficiency through parallelization:\n\nParallel Issue Detection: The first phase runs all checker agents simultaneously:\n   dev_contradiction_checker searches for logical contradictions in the prompt\n   format_checker looks for unclear format specifications\n   fewshot_consistency_checker (if examples exist) checks for mismatches between the prompt and examples\n\nAfter the parallel checking phase, the workflow handles dependencies carefully:\n\nPrompt Rewriting (Conditional): The dev_rewriter agent only runs if contradiction or format issues were detected. This agent depends on the outputs from:\n   dev_contradiction_checker (the cd_issues variable)\n   format_checker (the fi_issues variable)\n\nExample Rewriting (Conditional): The fewshot_rewriter agent only runs if example inconsistencies were detected. This agent depends on:\n   The rewritten prompt (must be done after prompt rewriting)\n   The original messages\n   The few-shot issues (the fs_issues variable)\n\n\nLet's see the optimization system in action with some practical examples.\nThis demonstrates how the system can detect and resolve critical contradictions that could lead to inconsistent outputs or confusion for the model.\n\nThis is particularly important because few-shot examples have a strong influence on how models respond. If examples don't follow the stated rules, the model may learn to ignore those rules in favor of mimicking the examples. By ensuring consistency between the prompt instructions and examples, the optimization system creats a more reliable prompt.\nThis example highlights how the format checker identifies and resolves ambiguous format specifications. The prompt requested a Markdown output and the optimization flow significantly improved these format specifications."])</script><script>self.__next_f.push([1,"39:T2494,"])</script><script>self.__next_f.push([1,"This cookbook provides a practical, step-by-step approach to automating the workflow between Jira and GitHub. By labeling a Jira issue, you trigger an end-to-end process that creates a GitHub pull request, keeps both systems updated, and streamlines code review, all with minimal manual effort. The automation is powered by the codex-cli agent running inside a GitHub Action.\n\n\n\nThe flow is:\n\nLabel a Jira issue\nJira Automation calls the GitHub Action\nThe action spins up codex-cli to implement the change\nA PR is opened\nJira is transitioned \u0026 annotated - creating a neat, zero-click loop. This includes changing the status of the ticket, adding the PR link and commenting in the ticket with updates.\n\n\nJira: project admin rights + ability to create automation rules\nGitHub: write access, permission to add repository secrets, and a protected main branch\nAPI keys \u0026 secrets placed as repository secrets:\n  OPENAI_API_KEY – your OpenAI key for codex-cli\n  JIRA_BASE_URL, JIRA_EMAIL, JIRA_API_TOKEN – for REST calls from the action\ncodex-cli installed locally (pnpm add -g @openai/codex) for ad-hoc testing\nA repository that contains a .github/workflows/ folder\n\n\n\n\nThe first step in this rule listens for changes to an issue’s labels. This ensures we only trigger the automation when a label is added or modified—no need to process every update to the issue.\n\nNext, we check whether the updated labels include a specific keyword, in our example we are using aswe. This acts as a filter so that only issues explicitly tagged for automation proceed, avoiding unnecessary noise from unrelated updates.\n\nIf the condition is met, we send a POST request to GitHub’s workflow_dispatch endpoint. This kicks off a GitHub Actions workflow with the relevant issue context. We pass in the issue key, summary, and a cleaned-up version of the description—escaping quotes and newlines so the payload parses correctly in YAML/JSON. There are additional fields available as variables in JIRA to give the codex agent more context during its execution.\n\nThis setup allows teams to tightly control which Jira issues trigger automation, and ensures GitHub receives structured, clean metadata to act on. We can also set up multiple labels, each triggering a different GitHub Action. For example, one label could kick off a quick bug fix workflow, while another might start work on refactoring code or generating API stubs.\n\n\nGitHub Actions enable you to automate workflows within your GitHub repository by defining them in YAML files. These workflows specify a series of jobs and steps to execute. When triggered either manually or via a POST request, GitHub automatically provisions the necessary environment and runs the defined workflow steps.\n\nTo process the POST request from JIRA we will create a Github action with a YAML like below in the .github/workflows/ directory of the repository:\n\nname: Codex Automated PR\non:\n  workflow_dispatch:\n    inputs:\n      issue_key:\n        description: 'JIRA issue key (e.g., PROJ-123)'\n        required: true\n      issue_summary:\n        description: 'Brief summary of the issue'\n        required: true\n      issue_description:\n        description: 'Detailed issue description'\n        required: true\n\npermissions:\n  contents: write           # allow the action to push code \u0026 open the PR\n  pull-requests: write      # allow the action to create and update PRs\n\njobs:\n  codex_auto_pr:\n    runs-on: ubuntu-latest\n\n    steps:\n0 – Checkout repository\n    uses: actions/checkout@v4\n      with:\n        fetch-depth: 0       # full history → lets Codex run tests / git blame if needed\n\n1 – Set up Node.js and Codex\n    uses: actions/setup-node@v4\n      with:\n        node-version: 22\n    run: pnpm add -g @openai/codex\n\n2 – Export / clean inputs (available via $GITHUB_ENV)\n    id: vars\n      run: |\n        echo \"ISSUE_KEY=${{ github.event.inputs.issue_key }}\"        \u003e\u003e $GITHUB_ENV\n        echo \"TITLE=${{ github.event.inputs.issue_summary }}\"        \u003e\u003e $GITHUB_ENV\n        echo \"RAW_DESC=${{ github.event.inputs.issue_description }}\" \u003e\u003e $GITHUB_ENV\n        DESC_CLEANED=$(echo \"${{ github.event.inputs.issue_description }}\" | tr '\\n' ' ' | sed 's/\"/'\\''/g')\n        echo \"DESC=$DESC_CLEANED\"                                    \u003e\u003e $GITHUB_ENV\n        echo \"BRANCH=codex/${{ github.event.inputs.issue_key }}\"     \u003e\u003e $GITHUB_ENV\n\n3 – Transition Jira issue to \"In Progress\"\n    name: Jira – Transition to In Progress\n      env:\n        ISSUE_KEY:      ${{ env.ISSUE_KEY }}\n        JIRA_BASE_URL:  ${{ secrets.JIRA_BASE_URL }}\n        JIRA_EMAIL:     ${{ secrets.JIRA_EMAIL }}\n        JIRA_API_TOKEN: ${{ secrets.JIRA_API_TOKEN }}\n      run: |\n        curl -sS -X POST \\\n          --url   \"$JIRA_BASE_URL/rest/api/3/issue/$ISSUE_KEY/transitions\" \\\n          --user  \"$JIRA_EMAIL:$JIRA_API_TOKEN\" \\\n          --header 'Content-Type: application/json' \\\n          --data  '{\"transition\":{\"id\":\"21\"}}'\n21 is the transition ID for changing the ticket status to In Progress. Learn more here: https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-issues/#api-rest-api-3-issue-issueidorkey-transitions-get\n\n4 – Set Git author for CI commits\n    run: |\n        git config user.email \"github-actions[bot]@users.noreply.github.com\"\n        git config user.name  \"github-actions[bot]\"\n\n5 – Let Codex implement \u0026 commit (no push yet)\n    name: Codex implement \u0026 commit\n      env:\n        OPENAI_API_KEY:  ${{ secrets.OPENAI_API_KEY }}\n        CODEX_QUIET_MODE: \"1\"          # suppress chatty logs\n      run: |\n        set -e\n        codex --approval-mode full-auto --no-terminal --quiet \\\n              \"Implement JIRA ticket $ISSUE_KEY: $TITLE. $DESC\"\n\n        git add -A\n        git commit -m \"feat($ISSUE_KEY): $TITLE\"\n\n6 – Open (and push) the PR in one go\n    id: cpr\n      uses: peter-evans/create-pull-request@v6\n      with:\n        token:  ${{ secrets.GITHUB_TOKEN }}\n        base:   main\n        branch: ${{ env.BRANCH }}\n        title:  \"${{ env.TITLE }} (${{ env.ISSUE_KEY }})\"\n        body: |\n          Auto-generated by Codex for JIRA ${{ env.ISSUE_KEY }}.\n          ---\n          ${{ env.DESC }}\n\n7 – Transition Jira to \"In Review\" \u0026 drop the PR link\n    name: Jira – Transition to In Review \u0026 Comment PR link\n      env:\n        ISSUE_KEY:      ${{ env.ISSUE_KEY }}\n        JIRA_BASE_URL:  ${{ secrets.JIRA_BASE_URL }}\n        JIRA_EMAIL:     ${{ secrets.JIRA_EMAIL }}\n        JIRA_API_TOKEN: ${{ secrets.JIRA_API_TOKEN }}\n        PR_URL:         ${{ steps.cpr.outputs.pull-request-url }}\n      run: |\nStatus transition\n        curl -sS -X POST \\\n          --url   \"$JIRA_BASE_URL/rest/api/3/issue/$ISSUE_KEY/transitions\" \\\n          --user  \"$JIRA_EMAIL:$JIRA_API_TOKEN\" \\\n          --header 'Content-Type: application/json' \\\n          --data  '{\"transition\":{\"id\":\"31\"}}'\n31 is the Transition ID for changing the ticket status to In Review. Learn more here: https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-issues/#api-rest-api-3-issue-issueidorkey-transitions-get\n\nComment with PR link\n        curl -sS -X POST \\\n          --url   \"$JIRA_BASE_URL/rest/api/3/issue/$ISSUE_KEY/comment\" \\\n          --user  \"$JIRA_EMAIL:$JIRA_API_TOKEN\" \\\n          --header 'Content-Type: application/json' \\\n          --data  \"{\\\"body\\\":{\\\"type\\\":\\\"doc\\\",\\\"version\\\":1,\\\"content\\\":[{\\\"type\\\":\\\"paragraph\\\",\\\"content\\\":[{\\\"type\\\":\\\"text\\\",\\\"text\\\":\\\"PR created: $PR_URL\\\"}]}]}}\"\n\n\nCodex Implementation \u0026 Commit (Step 5)\n   Uses OpenAI API to implement the JIRA ticket requirements\n   Runs codex CLI in full-auto mode without terminal interaction\n   Commits all changes with standardized commit message\n\nCreate Pull Request (Step 6)\n   Uses peter-evans/create-pull-request action\n   Creates PR against main branch\n   Sets PR title and description from JIRA ticket info\n   Returns PR URL for later use\n\nJIRA Updates (Step 7)\n   Transitions ticket to \"In Review\" status via JIRA API\n   Posts comment with PR URL on the JIRA ticket\n   Uses curl commands to interact with JIRA REST API\n\n\nAttach the special aswe label to any bug/feature ticket:\n\nDuring creation – add it in the \"Labels\" field before hitting Create\nExisting issue – hover the label area → click the pencil icon → type aswe\n\n\n\n\nJira label added → Automation triggers\nworkflow_dispatch fires; action spins up on GitHub\ncodex-cli edits the codebase \u0026 commits\nPR is opened on the generated branch\nJira is moved to In Review and a comment with the PR URL is posted\nReviewers are notified per your normal branch protection settings\n\n\n\n\n\nYou can open the PR link posted in the JIRA ticket and check to see if everything looks good and then merge it. If you have branch protection and Smart Commits integration enabled, the Jira ticket will be automatically closed when the pull request is merged.\n\n\nThis automation streamlines your development workflow by creating a seamless integration between Jira and GitHub:\n\nAutomatic status tracking** - Tickets progress through your workflow without manual updates\nImproved developer experience** - Focus on reviewing code quality instead of writing boilerplate code\nReduced handoff friction** - The PR is ready for review as soon as the ticket is labeled\n\nThe codex-cli tool is a powerful AI coding assistant that automates repetitive programming tasks. You can explore more about it here"])</script><script>self.__next_f.push([1,"3a:T1910,"])</script><script>self.__next_f.push([1,"Newer models, such as GPT-4.1, are best in class in performance and instruction following. As model gets smarter, there is a consistent need to adapt prompts that were originally tailored to earlier models' limitations, ensuring they remain effective and clear for newer generations.\n\nModels such as GPT‑4.1 excel at closely following instructions, but this precision means it can interpret unclear or poorly phrased instructions literally, leading to unexpected or incorrect results. To leverage GPT‑4.1's full potential, it's essential to refine prompts, ensuring each instruction is explicit, unambiguous, and aligned with your intended outcomes.\n\nExample of Unclear Instructions:\n\nAmbiguous:\n\"\"Do not include irrelevant information.\"\"\n\nIssue: GPT-4.1 might struggle to determine what is \"irrelevant\" if not explicitly defined. This could cause it to omit essential details due to overly cautious interpretation or include too much detail inadvertently..\n\nImproved:\n\"Only include facts directly related to the main topic (X). Exclude personal anecdotes, unrelated historical context, or side discussions.\"\n\nObjective: This interactive notebook helps you improve an existing prompt (written for another model) into one that is clear, unambiguous and optimised for GPT‑4.1 following best practices.\n\nWorkflow Overview\nThis notebook uses the following approach:\n\nStep 1. Input your original prompt\nStep 2. Identify all instructions in your prompt\nStep 3. Ask GPT-4.1 to critique the prompt\nStep 4. Auto-generate a revised system prompt\nStep 5. Evaluate and iterate\nStep 6. (Optional) Automatically apply GPT-4.1 best practices\n\nPrerequisites\nThe openai Python package and OPENAI_API_KEY\nBelow are a few helper functions to enable us to easily review the analysis and modifications on our prompt.\nBegin by providing your existing prompt clearly between triple quotes (\"\"\"). This prompt will serve as the baseline for improvement.\n\nFor this example, we will be using the system prompt for LLM-as-a-Judge provided in the following paper.\nIn this section, we will extract every INSTRUCTION that the LLM identifies within the system prompt. This allows you to review the list, spot any statements that should not be instructions, and clarify any that are ambiguous.\n\nCarefully review and confirm that each listed instruction is both accurate and essential to retain.\nIt's helpful to examine which parts of your prompt the model recognizes as instructions. Instructions are how we \"program\" models using natural language, so it's crucial to ensure they're clear, precise, and correct.\nNext, GPT‑4.1 itself will critique the original prompt, specifically identifying areas that may cause confusion or errors:\n\nAmbiguity: Phrases open to multiple interpretations.\n\nLacking Definitions: Labels or terms that are not clearly defined, which may cause the model to infer or guess their intended meaning.\n\nConflicting Instructions: Rules or conditions that contradict or overlap.\n\nMissing Context or Assumptions: Necessary information or context not explicitly provided.\n\nThe critique output will be clearly organized, highlighting specific issues along with actionable suggestions for improvement.\n\nModels are really good at identifying parts of a prompt that they find ambiguous or confusing. By addressing these issues, we can engineer the instructions to make them clearer and more effective for the model.\nReview the list of issues:\nIf you are satisfied with them, proceed to next step #4.\nIf you believe some issues are not relevant, copy the above text into the next cell and remove those issues. In this case, all three issues make reasonable sense, so we skip this step.\nWe now feed the critique back to GPT‑4.1 and ask it to produce an improved version of the original prompt, ready to drop into a system role message.\nLet's review the changes side-by-side comparison highlighting changes between the improved and refined prompts:\nFinally, evaluate your refined prompt by:\n\nTesting it with representative evaluation examples or data.\n\nAnalyzing the responses to ensure desired outcomes.\n\nIterating through previous steps if further improvements are required.\n\nConsistent testing and refinement ensure your prompts consistently achieve their intended results.\n\nLet’s evaluate whether our current prompt migration has actually improved for the task of this judge. The original prompt, drawn from this paper, is designed to serve as a judge between two assistants’ answers. Conveniently, the paper provides a set of human-annotated ground truths, so we can measure how often the LLM judge agrees with the humans judgments.\n\nThus, our metric of success will be measuring how closely the judgments generated by our migrated prompt align with human evaluations compared to the judgments generated with our baseline prompt. For context, the benchmark we’re using is a subset of MT-Bench, which features multi-turn conversations. In this example, we’re evaluating 200 conversation rows, each comparing the performance of different model pairs.\n\n\nOn our evaluation subset, a useful reference anchor is human-human agreement, since each conversation is rated by multiple annotators. Humans do not always agree with each other on which assistant answer is better, so we wouldn't expect our judge to achieve perfect agreement either. For turn 1 (without ties), humans agree with each other in 81% of cases, and for turn 2, in 76% of cases.\nGraph 3 for Model Agreement\nComparing this to our models before migration, GPT-4 (as used in the paper) achieves an agreement with human judgments of 74% on turn 1 and 71% on turn 2, which is not bad, but still below the human-human ceiling. Switching to GPT-4.1 (using the same prompt) improves the agreement: 77% on turn 1 and 72% on turn 2. Finally, after migrating and tuning our prompt specifically for GPT-4.1, the agreement climbs further, reaching 80% on turn 1 and 72% on turn 2, very close to matching the level of agreement seen between human annotators.\nViewed all together, we can see that prompt migration and upgrading to more powerful models improve agreement on our sample task. Go ahead and try it on your prompt now!\n\nIn this step, GPT-4.1 best practices will be applied automatically to enhance your original prompt. We strongly suggest to manually review the edits made and decide if you want to keep or not.\n\nSee the 4.1 Prompting Guide for reference."])</script><script>self.__next_f.push([1,"3b:T3d1d,"])</script><script>self.__next_f.push([1,"This guide is for developers and ML practitioners who have some experience with OpenAIʼs APIs and wish to use their fine-tuned models for research or other appropriate uses. OpenAI’s services are not intended for the personalized treatment or diagnosis of any medical condition and are subject to our applicable terms.\n\nThis guide discusses fine-tuning methods supported by OpenAI, specifically highlighting what each method is best for and not best for, to help you identify the most suitable technique for your use case. It then provides an in-depth look at one particular method — Direct Preference Optimization (DPO) — and provides links to existing guides for the other techniques.\n\nWhat is fine-tuning? Fine-tuning is the process of continuing training on a smaller, domain-specific dataset to optimize a model for a specific task. There are two main reasons why we would typically fine-tune:\nImprove model performance on a specific task\nImprove model efficiency (reduce the number of tokens needed, distill expertise into a smaller model, etc.)\n\nCurrently, the OpenAI platform supports four fine-tuning methods:\nSupervised fine-tuning (SFT):** this technique employs traditional supervised learning using input-output pairs to adjust model parameters. The training process adjusts model weights to minimize the difference between predicted and target outputs across the provided examples. The model will replicate features that it finds in provided pairs.\nVision fine-tuning:** this technique extends supervised fine-tuning to multimodal data by processing both text and image in a unified training framework. The training process adjusts model weights to minimize errors across text-image pairs and as a result improve the model's understanding of image inputs.\nDirect preference optimization (DPO):** this technique uses pairwise comparisons (e.g., preferred and rejected example responses) to optimize a model to favor certain outputs over others. The model learns to replicate the preference patterns found in the provided comparison data.\nReinforcement fine-tuning (RFT):** this technique uses reinforcement learning with a reward signal (via a grader or reward model) to fine-tune the model for complex objectives. In RFT, the model generates outputs for given prompts during training, and each output is evaluated for quality. The model's parameters are then updated to maximize the reward, reinforcing behaviors that lead to better outcomes. This iterative feedback loop encourages the model to improve reasoning or decision-making strategies.\nTo help you select the appropriate fine-tuning technique, the table below summarizes the scenarios each method is best suited for, as well as those for which it is not well suited:\n\n| Technique                            | Good For                                                                                                                                                                                                                                                                                    | Not Good For                                                                                            |\n| ---------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------- |\n| Supervised fine-tuning (SFT)         | Emphasizing knowledge already present in the model.Customizing response structure or tone.Generating content in a specific format.Teaching complex instructions or correcting instruction-following failures.Optimizing cost/latency (saving tokens from prompt or distilling). | Adding entirely new knowledge (consider RAG instead).Tasks with subjective quality.                     |\n| Vision fine-tuning                   | Specialized visual recognition tasks (e.g., image classification).Domain-specific image understanding.Correcting failures in instruction following for complex prompts.                                                                               | Purely textual tasks.Generalized visual tasks without specific context.General image understanding. |\n| Direct preference optimization (DPO) | Aligning model outputs with subjective preferences (tone, politeness).Refining outputs via human-rated feedback.Achieving nuanced behavioral alignment.                                                                                                                                 | Learning completely new tasks.Tasks without clear human preference signals.                             |\n| Reinforcement fine-tuning (RFT)      | Complex domain-specific tasks that require advanced reasoning.Refining existing partial capabilities (fostering emergent behaviours).Tasks with measurable feedback.Scenarios with limited explicit labels where reward signals can be defined.                                                                     | Tasks where the model has no initial skill.Tasks without clear feedback or measurable signals.          |\n\n\n\nToday, there are pre-existing Cookbooks for:\n\nSupervised fine-tuning (SFT): (1) How to fine-tune chat models (2) Leveraging model distillation to fine-tune a model\nVision fine-tuning: Vision fine-tuning on GPT-4o for visual question answering\nReinforcement fine-tuning (RFT): (1) Reinforcement fine-tuning (RFT), (2) Reinforcement fine-tuning for healthbench QA\n\nDirect preference optimization (DPO) will be covered in this guide.\n\nAs mentioned above, Direct Preference Optimization (DPO) is an alignment technique for fine-tuning language models using pairwise preference data (e.g., ranked pairs of responses). DPO directly optimizes a model to favor certain outputs over others using explicit pairwise comparisons, typically from human preferences. This approach simplifies alignment and eliminates the need for a separate reward model or complex reinforcement learning procedures, making DPO a lightweight alternative to techniques such as Reinforcement Learning from Human Feedback (RLHF).\n\nWhen should you use DPO? DPO excels in scenarios when response quality is subjective, cannot be measured objectively, or when nuanced criteria such as tone, style, appropriateness, or clarity matter - typically cases where multiple valid outputs exist. Example applications where DPO is particularly effective in aligning AI responses include:\nEnhancing Conversational AI Responses\nImproving Code Generation Quality \u0026 Style\nEnsuring Compliance with Legal, Ethical \u0026 Safety Standards\nControlling Brand Voice, Professionalism, \u0026 Tone\nCustomizing Creative Outputs \u0026 User Experience\n\nBy fine-tuning on explicit pairs of preferred vs non‑preferred completions, DPO aligns model outputs to these nuanced preferences. The below table gives examples of pairwise preference data for a fictional AI assistant that represents an organization, where preferred responses are clear, professional, and aligned with brand standards.\n\n| Example Question                                           | Chosen Response                                                                                                                                                                   | Rejected Response                                       |\n|------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------|\n| Q1: How do I review your product?              | To submit a product review, please visit your account dashboard, select the product, and click ‘Write a review.’ Share your honest experience, rate key features, and submit when ready.        | Yo, just leave some quick stars or whatever, it’s chill!         |\n| Q2: How do I review your product?              | We welcome your feedback! In the ‘Reviews’ section on the product page, click ‘Leave a Review,’ rate it, and add your comments about what you liked or areas for improvement.                   | Just scribble something—doesn’t matter what, honestly.          |\n| Q3: How to troubleshoot this particular error? | To address the error ‘X101,’ first clear your cache, then verify your internet connection. If the issue remains, follow our step-by-step guide at [Support → Troubleshooting → Error X101]. | Just reboot it, I guess. If it doesn't work, you're on your own! |\n\nIn this guide, weʼll walk through how to apply DPO using the fine-tuning API. You will learn key steps to take in order to successfully run preference fine-tuning jobs for your use-cases.\n\nHere’s what we’ll cover:\n\nRecommended Workflow**\nDemonstration Scenario**\nGenerating the Dataset**\nBenchmarking the Base Model**\nFine-Tuning**\nUsing your Fine-Tuned Model**\n\nOpenAI recommends the following workflow:\nPerforming Supervised Fine-Tuning (SFT) on a subset of your preferred responses.\nUsing the SFT fine-tuned model as the starting point, apply DPO using preference comparison data.\n\nPerforming Supervised Fine-Tuning (SFT) before Direct Preference Optimization (DPO) enhances model alignment and overall performance by establishing a robust initial policy, ensuring the model already prefers correct responses. This reduces the magnitude of weight updates during DPO, stabilizing training and preventing overfitting by allowing DPO to efficiently refine subtle nuances. Consequently, the combined SFT-then-DPO workflow converges faster and yields higher-quality results.\n\nIn this guide, we'll focus exclusively on applying Direct Preference Optimization (DPO). However, depending on your use case, you may find performance gains from first performing Supervised Fine-Tuning (SFT). If so, you can follow the SFT guide linked above, save the resulting model ID, and use that as the starting point for your DPO job.\n\nTo make things concrete, let’s walk through fine-tuning a customer-facing AI assistant to follow a fictional brand’s voice and style. Imagine Good Vibes Corp, an organization that prides itself on a friendly, enthusiastic tone with a personal touch.\n\nThey want their customer AI assistant to answer queries in a way that reflects these brand guidelines (e.g. an upbeat attitude, polite language, and a friendly sign-off), and prefer those responses over more generic or curt answers. This is a good scenario for DPO: there’s no objectively correct answer format, but there is a preferred style.\n\nDPO will help the model learn from comparisons which style is preferred. We'll outline the steps to: (1) generate a synthetic preference dataset of prompts with paired responses (one in the desired brand voice and one not). (2) Evaluate base model performance using the OpenAI evals API. (3) Prepare and upload the data in the required JSONL format for preference fine-tuning. (4) Fine-tune the model with DPO using the OpenAI fine-tuning API. (5) Evaluate the fine-tuned model using the OpenAI evals API to show how the brand-style preference improved.\n\nWe are going to synthesize a dataset for this demonstration. First, let’s create a seed bank of questions to generate more variations from.\n\nLet’s get started!\n\nNext, we’ll define functions to take each prompt from our seed bank and generate related questions. We’ll create a dataset of preference pairs by first generating these prompt variations, then producing both a preferred and a rejected response for every prompt.\n\nThis dataset is synthetic and serves to illustrate the mechanics of Direct Preference Optimization — when developing your own application you should collect or curate a high-quality, preference dataset. Note: the volume of data required for DPO depends on the use case; generally more is better (thousands to tens of thousands), and for preference pairs the ordering logic should be consistent (e.g. if A \u003e B and B \u003e C, then A \u003e C).\nNow, using these defined functions we'll build our dataset by generating friendly versus blunt response pairs. The friendly responses reflect the brand's desired communication style. We'll do this asynchronously for efficiency, creating a dataset suited for Direct Preference Optimization.\n\nBelow, we split our dataset into training, validation, and testing sets. We also show a sample from the training dataset, which demonstrates a clear difference between the preferred (friendly, on-brand) and non-preferred (blunt, neutral) responses for that input pair.\nTo assess the model's performance prior to fine-tuning, we'll use an automated grader (LLM-as-a-Judge) to score each response for friendliness and empathy. The grader will assign a score from 0 to 4 for each answer, allowing us to compute a mean baseline score for the base model.\n\nTo do this, we first generate responses for the base model on the test set, then use the OpenAI evals API to create and run an evaluation with an automated grader.\nNext, we'll use the OpenAI evals API to create \u0026 run an evaluation with an automated grader, starting by defining the rubric for the LLM-as-a-Judge. Note: we will access responses via data logging, so in order for this to work, you'll need to be in an org where data logging isn't disabled (through zdr, etc.). If you aren't sure if this is the case for you, go to https://platform.openai.com/logs?api=responses and see if you can see the responses you just generated.\n\nWith a baseline established, we can now fine-tune the model using the training set and DPO. This process will teach the model to prefer responses that align with our desired style, based on the preference pairs we created earlier.\n\nNote: beta (β) is a unique fine-tuning hyperparameter for Direct Preference Optimization (DPO). It’s a floating-point number ranging between 0 and 2, controlling the balance between preserving a model’s existing behavior and adapting to new, preference-aligned responses.\nHigh β (close to 2): makes the model more conservative, strongly favoring previous behavior. The fine-tuned model will show minimal deviations from its original style or characteristics, emphasizing consistency and avoiding abrupt changes.\nModerate β (around 1): balances between adherence to prior behavior and adaptation to new preferences. Recommended as a sensible starting point for most practical scenarios.\nLow β (close to 0): encourages aggressive adaptation, causing the model to prioritize newly provided preferences more prominently. This might result in significant stylistic shifts and greater alignment with explicit preferences but could lead to unexpected or overly specialized outputs.\n\nTechnically, beta scales the difference in log-probabilities in the DPO loss; a larger β causes the sigmoid-based loss function to saturate with smaller probability differences, yielding smaller weight updates (thus preserving old behavior). It is recommended to experiment systematically with the β value to achieve optimal results tailored to your specific use-case and desired trade-offs between stability and adaptation.\n\nOnce fine-tuning is complete, we'll evaluate the DPO-tuned model on the same test set. By comparing the mean scores before and after fine-tuning, as well as reviewing example outputs, we can see how the model's alignment with our preferences has improved."])</script><script>self.__next_f.push([1,"3c:T3da8,"])</script><script>self.__next_f.push([1,"Agents are becoming the de-facto framework in which we orchestrate various, often specialized, LLMs applications to work with one another. Many practical applications require the use of external tools to create a complex workflow for LLM-based agents.\n\nModel Context Protocol (MCP) has quickly become the open standard for building Agentic systems. The protocol provides easy integration of common tool services and the interoperability between models across the AI ecosystem.\n\nModel Context Protocol (MCP) is an open protocol designed to standardize how AI models - especially large language models (LLMs) - interface with external tools, data sources, and context providers in a secure, modular, and composable way. MCP provides a unified framework for sending structured requests from an agent or application to a set of “tool services,” such as databases, APIs, or custom logic modules. By adopting MCP, developers can,\nDecouple agent logic from tool implementations: Agents can call out to tools (like a database or search service) using a standard protocol, rather than relying on hardcoded integrations.\nEnforce consistent security and governance: MCP defines authentication, authorization, and data boundary controls between the model and external resources.\nSupport modular, reusable agent architectures: Tools can be swapped, updated, or extended without changing the agent code, making it easy to evolve complex workflows.\nRun tools locally or remotely: The same protocol works whether a tool is running in the customer’s environment or in the cloud, supporting privacy and data residency requirements.\n\nMCP acts as the “middleware” that bridges AI models and the external world, enabling secure, flexible, and maintainable integration of real-world context and capabilities into conversational or autonomous agents.\n\nIn today’s enterprise landscape, conversational agents - especially voice-powered ones—are quickly becoming a standard for customer support, internal helpdesks, and task automation. Yet, building robust, scalable voice agents is challenging due to fragmented tooling, integration complexity, and the need for reliable orchestration of backend systems. A common pattern seen across the enterprise landscape is to develop agents that are backed by knowledge bases (both structured and unstructured). These bots are divided into several categories:\n copilots for internal use, and\n customer-facing assistants.\nThe latter of the two use cases, i.e. customer-facing assistants, tends to have a higher requirement for both accuracy, usability and design. Additionally, one common requirement for customer-facing chatbots is the need to add voice as a modality for user interface (i.e. for phone call automation).\n\nThese Q\u0026A chatbots apply to a wide range of industries: healthcare, government, legal and other industries that requires a easy way for knowledge retrieval at a user's fingertips.\n\nOne such industry is the insurance industry, where we've seen tremendous value for customers we work with in the space. Insurance policies are complex and navigating the system can often be difficult for policy holders.\n\nIn this cookbook, we provide an end-to-end modular recipe leveraging MCP for building voice-enabled agents using the OpenAI Agents SDK. In particular, we demonstrate how we can use it for dynamic context management and using agentic tool-calling. We demonstrate the capabilities of such a system for the aforementioned insurance use-case. In this example, we demonstrate the use of MCP for various tools that you may want for your application. Specifically, we showcase the use of custom MCP servers (for text retrieval and web search) as well as using predefined MCP servers (for SQLite).\n\nThis section outlines a straightforward setup for deploying microservices for tools within the MCP framework, specifically focusing on RAG, database lookup, and web search functionalities. The MCP servers are responsible not only for hosting these services but also for performing RAG indexing to support backend operations.\n\nWe employ a \"chained\" approach for voice input and output throughout the system. During inference, the workflow begins by capturing a user's voice input, which is transcribed to text using a speech-to-text system. This transcribed text is then sent to the Planner agent, which determines which tools to invoke and makes requests to the appropriate microservices. After retrieving tool outputs, the Planner agent synthesizes a cohesive, contextually appropriate response. This textual response is subsequently converted to audio using a text-to-speech system, delivering the final voice response to the user.\n\nThe end-to-end workflow is summarized in the diagram below:\n\nCookbook_image\nFirst, we install the library dependencies for the project.\nNote: One specific dependency that may be needed on your machine, is to install ffmpeg. If you are using a mac, you will need to install this separately using brew install ffmpeg.\n\n\nTo execute this cookbook, you'll need to install the following packages providing access to OpenAI's API, the Agents SDK, MCP, and libraries for audio processing. Additionally, you can set your OpenAI API key for use by the agents via the set_default_openai_key function.\n\nFirst, we define a custom MCP service that host the RAG and web search tools using the FastMCP interface. Specifically, we add @mcp.tool functions for:\n\nRetrieving information from a RAG service\nSearching the broader internet for information using OpenAI's web_search\n\n\nFor the purpose in this cookbook, we'll run both tools under the same service.\n\nThe below code has been provided in search_server.py within the same directory. Run the code to start the server. As the server runs, your files will be indexed and stored in the vector store.\n\nYou can run the search_server.py file by running the following command:\n\n        uv run python search_server.py\n\nOnce the server is running, you can access the vector store and files at https://platform.openai.com/storage/files and https://platform.openai.com/storage/vector_stores respectively, and continue with running the next cells in the notebook.\nimport os\nfrom mcp.server.fastmcp import FastMCP\nfrom openai import OpenAI\nfrom agents import set_tracing_export_api_key\n\nmcp = FastMCP(\"Search Server\")\n_vector_store_id = \"\"\n\ndef _run_rag(query: str) -\u003e str:\n    \"\"\"Do a search for answers within the knowledge base and internal documents of the user.\n    Args:\n        query: The user query\n    \"\"\"\n    results = client.vector_stores.search(\n        vector_store_id=_vector_store_id,\n        query=query,\n        rewrite_query=True,  # Query rewriting generally improves results\n    )\n    return results.data[0].content[0].text\n\n\ndef _summarize_rag_response(rag_output: str) -\u003e str:\n    \"\"\"Summarize the RAG response using GPT-4\n    Args:\n        rag_output: The RAG response\n    \"\"\"\n    response = client.responses.create(\n        model=\"gpt-4.1-mini\",\n        tools=[{\"type\": \"web_search_preview\"}],\n        input=\"Summarize the following text concisely: \\n\\n\" + rag_output,\n    )\n    return response.output_text\n\n\n@mcp.tool()\ndef generate_rag_output(query: str) -\u003e str:\n    \"\"\"Generate a summarized RAG output for a given query.\n    Args:\n        query: The user query\n    \"\"\"\n    print(\"[debug-server] generate_rag_output: \", query)\n    rag_output = _run_rag(query)\n    return _summarize_rag_response(rag_output)\n\n\n@mcp.tool()\ndef run_web_search(query: str) -\u003e str:\n    \"\"\"Run a web search for the given query.\n    Args:\n        query: The user query\n    \"\"\"\n    print(\"[debug-server] run_web_search:\", query)\n    response = client.responses.create(\n        model=\"gpt-4.1-mini\",\n        tools=[{\"type\": \"web_search_preview\"}],\n        input=query,\n    )\n    return response.output_text\n\n\ndef index_documents(directory: str):\n    \"\"\"Index the documents in the given directory to the vector store\n    Args:\n        directory: The directory to index the documents from\n    \"\"\"\nOpenAI supported file extensions for retrieval (see docs)\n    SUPPORTED_EXTENSIONS = {'.pdf', '.txt', '.md', '.docx', '.pptx', '.csv', '.rtf', '.html', '.json', '.xml'}\nCollect all files in the specified directory\n    files = [os.path.join(directory, f) for f in os.listdir(directory)]\nFilter files for supported extensions only\n    supported_files = []\n    for file_path in files:\n        _, ext = os.path.splitext(file_path)\n        if ext.lower() in SUPPORTED_EXTENSIONS:\n            supported_files.append(file_path)\n        else:\n            print(f\"[warning] Skipping unsupported file for retrieval: {file_path}\")\n\n    vector_store = client.vector_stores.create( # Create vector store\n        name=\"Support FAQ\",\n    )\n    global _vector_store_id\n    _vector_store_id = vector_store.id\n\n    for file_path in supported_files:\nUpload each file to the vector store, ensuring the file handle is closed\n        with open(file_path, \"rb\") as fp:\n            client.vector_stores.files.upload_and_poll(\n                vector_store_id=vector_store.id,\n                file=fp\n            )\n        print(f\"[debug-server] uploading file: {file_path}\")\n\n\nif name == \"main\":\n    oai_api_key = os.environ.get(\"OPENAI_API_KEY\")\n    if not oai_api_key:\n        raise ValueError(\"OPENAI_API_KEY environment variable is not set\")\n    set_tracing_export_api_key(oai_api_key)\n    client = OpenAI(api_key=oai_api_key)\n\n    current_dir = os.path.dirname(os.path.abspath(file))\n    samples_dir = os.path.join(current_dir, \"sample_files\")\n    index_documents(samples_dir)\n\n    mcp.run(transport=\"sse\")\nAs seen above, we also include the RAG indexing as part of this workflow. In real-world applications, this will not be necessary for every run and if you have a large corpus of data, you may put this in a separate process.\n\nIn addition to simple RAG retrieval, we add an extra step to summarize the RAG output. This step is not always necessary, though we've found this to provide more succinct responses to the planner. Whether to do this depends on your system and your latency requirements.\n\n\n\nWhile implementing custom MCPs servers is relatively straightforward, the power of MCP is the ability to use pre-defined servers that others have built and maintain. Using existing implementations enables more rapid development, has a consistent interface with other tools, and makes data integration more seamless.\n\nFor our database lookup tool, we use the prebuilt SQLite server implementation. As you will see below, we can implement this simply with just a comand line prompt and providing it with a *.db file with the data.\n\nNext, we can define how the MCP server will generate meaningful responses. The planner agent is a key component within MCP’s agent orchestration pipeline. Its primary function is to decompose user requests into actionable steps and decide which tools, APIs, or agents should be called at each stage. Given the input as text, the planner parses and analyzes the request, maintaining context across multiple turns. Based on the conversation state, it invokes MCP tool services by dispatching tool calls via the MCP server’s orchestration layer. The agent then collects intermediate results, synthesizes responses, and guides the conversation toward resolution.\n\nA key design consideration is the model selection for the planner. While larger models like 4.1 offer superior reasoning, low end-to-end latency is critical in voice-driven applications. For this reason, we select the 4.1-mini model, which achieves a strong balance between reasoning ability and response speed.\nIn the agent definition, we clearly specify when each tool should be used. This ensures better control over responses and improves answer relevance. We also provide the Voice Agent with guidelines to set the desired tone and level of precision in its replies.\n\nNext, we define the configurations for our voice module, both for speech-to-text (STT) and text-to-speech (TTS). We use the OpenAI Agent Voice library to handling both input and output of voice. As defaults, this API calls the gpt-4o-transcribe and gpt-4o-mini-tts for STT and TTS, respectively.\n\nFor more content on defining voice assistants, see this Cookbook.\nIn enterprise scenarios, the tone and style of audio responses are critical to system usability. Speech output should consistently reflect professionalism and align with the company's brand identity. For most applications, this means generating a realistic voice that mirrors the courteous, approachable demeanor typical of call-center representatives. With TTS, we can leverage prompt engineering to guide the model toward producing audio that better matches specific customer use cases and brand values.\n\nAfter configuring the voice settings, the next step is to implement functions for processing incoming audio and generating spoken responses. Pay particular attention to the silence_threshold parameter in your configuration—this plays a crucial role in accurately detecting when a user has finished speaking and helps with speech endpoint detection.\n\nNext, we add a simple convenience function for bringing up servers locally:\n\nIn our main function, we can bring up the various tool-use services we're interested in.\n\nFor our custom server for (RAG and web search), we can use the MCPServerSse function to start a server (in this case locally). To bring up the standard MCP SQLite service, we call MCPServerStdio with simple arguments provided, in this case, the local database.db file.\n\nNow that we have the various pieces in place, we can take a step back and visualize the overall workflow of our system:\nCookbook_image\nFinally, we can instantiate the custom tool-use server and bring up the service:\n\nNow that we have built the system end-to-end, we can now use it to answer questions. Here, we use our system to provide answers for a few common insurance questions based on the policy information docs. Below are some sample voice outputs from our agents based on some common questions users have:\nHow are prescription drugs covered under this plan? (uses retrieval)\nWhich policies have monthly premium less than $300? (uses DB lookup with SQL)\nWhat are effective treatments for diabetes? (uses Web Search)\nBy default, model and tool calls that are used in our application are added to the Traces dashboard out-of-the-box. These traces provide meaningful insight into what users experience as they use our agents.\nCookbook_image\nBeyond agent performance, one critical aspect of building voice agents is the latency of responses. With the Traces dashboard, we are able to view the breakdown of walltime for each step to help debug and find areas of improvement for latency:\nCookbook_image\nExplore individual traces to see each function call and its output, as shown below.\n\nimage\n\nTraces offer granular visibility into function calls and their execution times, making it easy to identify sources of latency (for example, the web search tool above). Analyzing response time variability for each tool invocation helps you pinpoint bottlenecks and opportunities for optimization in production systems.\n\nThis cookbook has guided you through building a complete agent solution that harnesses the flexibility and strength of the MCP platform. By integrating the Voice Agents SDK, we illustrated how to develop a consumer-ready product powered by these technologies. We've shown how OpenAI’s tools and the Agents API can be effectively combined with MCP to deliver impactful applications.\n\nWe hope this guide has offered both practical instruction and inspiration, helping you create your own MCP-powered voice agents tailored to your specific needs.\n\nThis cookbook serves as a joint collaboration effort between OpenAI and Brain Co.\n\nCece Z\nSibon Li\nShikhar Kwatra"])</script><script>self.__next_f.push([1,"3d:T3876,"])</script><script>self.__next_f.push([1,"In supply-chain operations, an agent can resolve questions that directly affect service levels and revenue: Do we have the inventory and capacity to satisfy current demand? Where will manufacturing delays occur, and how will those delays propagate downstream? Which workflow adjustments will minimise disruption?\n\nDatabricks MCP UI\n\nThis cookbook outlines the process for building a supply-chain copilot with the OpenAI Agent SDK and Databricks Managed MCP. MCP enables the agent to query structured and unstructured enterprise data, such as inventory, sales, supplier feeds, local events, and more, for real-time visibility, early detection of material shortages, and proactive recommendations. An orchestration layer underpins the system, unifying:\nQueries against structured inventory, demand, and supplier data\nTime series forecasting for every wholesaler\nGraph based raw material requirements and transport optimizations\nVector-indexed e-mail archives that enable semantic search across unstructured communications\nRevenue risk calculation\n\nBy the end of this guide you will deploy a template that queries distributed data sources, predictive models, highlights emerging bottlenecks, and recommends proactive actions. It can address questions such as:\nWhat products are dependent on L6HUK material?\nHow much revenue is at risk if we can’t produce the forecasted amount of product autoclave_1?\nWhich products have delays right now?\nAre there any delays with syringe_1?\nWhat raw materials are required for syringe_1?\nAre there any shortages with one of the following raw materials: O4GRQ, Q5U3A, OAIFB or 58RJD?\nWhat are the delays associated with wholesaler 9?\n\nStakeholders can submit a natural-language prompt and receive answers instantly.\nThis guide walks you through each step to implement this solution in your own environment.\n\n\nThe architecture presented in this cookbook layers an OpenAI Agent on top of your existing analytics workloads in Databricks. You can expose Databricks components as callable Unity Catalog functions. The agent is implemented with the OpenAI Agent SDK and connects to Databricks Managed MCP servers.\n\nThe result is a single, near-real-time conversational interface that delivers fine-grained forecasts, dynamic inventory recommendations, and data-driven decisions across the supply chain. The architecture yields an agent layer that harnesses your existing enterprise data (structured and unstructured), classical ML models, and graph-analytics capabilities.\n\nDatabricks MCP Architecture\n\nYou can set up your Databricks authentication by adding a profile to ~/.databrickscfg. A Databricks configuration profile contains settings and other information that Databricks needs to authenticate.\n\nThe snippet’s WorkspaceClient(profile=...) call will pick that up. It tells the SDK which of those stored credentials to load, so that your code never needs to embed tokens. Another option would be to create environment variables such as DATABRICKS_HOST and DATABRICKS_TOKEN, but using ~/.databrickscfg is recommended.\nGenerate a workspace personal access token (PAT) via Settings → Developer → Access tokens → Generate new token, then record it in ~/.databrickscfg.\n\nTo create this Databricks configuration profile file, run the Databricks CLI databricks configure command, or follow these steps:\nIf /.databrickscfg is missing, create it: touch /.databrickscfg\nOpen the file: nano ~/.databrickscfg\nInsert a profile section that lists the workspace URL and personal-access token (PAT) (additional profiles can be added at any time):\n\n\n[DEFAULT]\nhost  = https://dbc-a1b2345c-d6e7.cloud.databricks.com # add your workspace URL here\ntoken = dapi123...    # add your PAT here\n\nYou can then run this sanity check command databricks clusters list with the Databricks CLI or SDK. If it returns data without prompting for credentials, the host is correct and your token is valid.\n\nAs a pre-requisite, Serverless compute and Unity Catalog must be enabled in the Databricks workspace.\n\nThis cookbook can be used to work with your own Databricks supply chain datasets and analytical workloads.\n\nAlternatively, you can accelerate your setup by using a tailored version of the Databricks’ Supply Chain Optimization Solution Accelerator. To do so, you can clone this GitHub repository into your Databricks workspace and follow the instructions in the README file. Running the solution will stand up every asset the Agent will later reach via MCP, from raw enterprise tables and unstructured e-mails to classical ML models and graph workloads.\n\nIf you prefer to use your own datasets and models, make sure to wrap relevant components as Unity Catalog functions and define a Vector Search index as shown in the accelerator. You can also expose Genie Spaces.\n\nThe sample data mirrors a realistic pharma network: three plants manufacture 30 products, ship them to five distribution centers, and each distribution center serves 30-60 wholesalers. The repo ships time-series demand for every product-wholesaler pair, a distribution center-to-wholesaler mapping, a plant-to-distribution center cost matrix, plant output caps, and an e-mail archive flagging shipment delays.\n\nPharma Network\n\nAnswering supply-chain operations questions requires modelling how upstream bottlenecks cascade through production, logistics, and fulfilment so that stakeholders can shorten lead times, avoid excess stock, and control costs. The notebooks turn these raw feeds into governed, callable artefacts:\nDemand forecasting \u0026 aggregation (notebook 2): Generates one-week-ahead SKU demand for every wholesaler and distribution center with a Holt-Winters seasonal model (or any preferred time-series approach). It leverages Spark’s parallelisation for large-scale forecasting tasks by using Pandas UDFs (taking your single node data science code and distributing it across multiple nodes). Forecasts are then rolled up to DC-level totals for each product. The output is a table  product_demand_forecasted with aggregate forecasts at the distribution center level.\nRaw-material planning (notebook 3): Constructs a product-to-material using graph processing, propagating demand up the bill-of-materials hierarchy to calculate component requirements at scale. We transform the bill‑of‑materials into a graph so product forecasts can be translated into precise raw‑material requirements, yielding two tables: raw_material_demand and raw_material_supply.\nTransportation optimisation (notebook 4): Minimises plant to distribution center transportation cost under capacity and demand constraints, leveraging Pandas UDFs, outputting recommendations in shipment_recommendations.\nSemantic e-mail search (notebook 6): Embeds supply-chain manager e-mails in a vector index using OpenAI embedding models, enabling semantic queries that surface delay and risk signals.\n\nEach insight is wrapped as a Unity Catalog (UC) function in notebook 5 and notebook 7, e.g. product_from_raw, raw_from_product, revenue_risk, lookup_product_demand, query_unstructured_emails. Because UC governs tables, models, and vector indexes alike, the Agent can decide at runtime whether to forecast, trace a BOM dependency, gauge revenue impact, fetch history, or search e-mails, always within the caller’s data-access rights.\n\nThe result is an end-to-end pipeline that forecasts demand, identifies raw‑material gaps, optimizes logistics, surfaces hidden risks, and lets analysts ask ad‑hoc questions and surface delay warnings.\n\nAfter all notebooks have been executed (by running notebook 1), the Databricks environment is ready, you can proceed to build the Agent and connect it to Databricks.\n\nCurrently, the MCP spec defines three kinds of servers, based on the transport mechanism they use:\nstdio servers run as a subprocess of your application. You can think of them as running \"locally\".\nHTTP over SSE servers run remotely. You connect to them via a URL.\nStreamable HTTP servers run remotely using the Streamable HTTP transport defined in the MCP spec.\n\nDatabricks-hosted MCP endpoints (vector-search, Unity Catalog functions, Genie) sit behind standard HTTPS URLs and implement the Streamable HTTP transport defined in the MCP spec. Make sure that your workspace is serverless enabled so that you can connect to the Databricks managed MCP.\nThe OpenAI Agent is available here. Start by installing the required dependencies:\nYou will need an OpenAI API key to securely access the API. If you're new to the OpenAI API, sign up for an account. You can follow these steps to create a key and store it in a safe location.\nThis cookbook shows how to serve this Agent with FastAPI and chat through a React UI. However, main.py is set up as a self‑contained REPL, so after installing the required dependencies and setting up the necessary credentials (including the Databricks host and personal-access token as described above), you can run the Agent directly from the command line with a single command:\nThe main.py file orchestrates the agent logic, using the OpenAI Agent SDK and exposing Databricks MCP vector-search endpoints and Unity Catalog functions as callable tools. It starts by reading environment variables that point to the target catalog, schema, and Unity Catalog (UC) function path, then exposes two tools: vector_search, which queries a Databricks Vector Search index, and uc_function, which executes Unity Catalog functions via MCP. Both tools make authenticated, POST requests through httpx, returning raw JSON from the Databricks REST API. Both helpers obtain the workspace host and Personal Access Token through the _databricks_ctx() utility (backed by DatabricksOAuthClientProvider) and issue authenticated POST requests with httpx, returning raw JSON responses.\n\nInside run_agent(), the script instantiates an Agent called “Assistant” that is hard-scoped to supply-chain topics. Every response must invoke one of the two registered tools, and guardrails force the agent to refuse anything outside logistics, inventory, procurement or forecasting. Each user prompt is processed inside an SDK trace context. A simple REPL drives the interaction: user input is wrapped in an OpenTelemetry-style trace, dispatched through Runner.run, and the final answer (or guardrail apology) is printed. The program is kicked off through an asyncio.run call in main(), making the whole flow fully asynchronous and non-blocking.\ndatabricks_mcp.py serves as a focused authentication abstraction: it obtains the Personal Access Token we created earlier from a given WorkspaceClient (ws.config.token) and shields the rest of the application from Databricks‑specific OAuth logic. By confining all token‑handling details to this single module, any future changes to Databricks’ authentication scheme can be accommodated by updating this file.\n\nsupply_chain_guardrails.py implements a lightweight output guardrail by spinning up a second agent (“Supply‑chain check”) that classifies candidate answers. The main agent hands its draft reply to this checker, which returns a Pydantic object with a Boolean is_supply_chain. If that flag is false, the guardrail raises a tripwire and the caller swaps in a refusal.\nTo kick off the backend (Fast API), run the following command:\nThe API will be available at http://localhost:8000 (for FastAPI docs go to: http://localhost:8000/docs).\n\nThe api_server.py is a FastAPI backend that exposes your agent as a streaming /chat API endpoint. At startup it configures CORS so a local front-end can talk to it, then defines build_mcp_servers(), which authenticates to the caller’s Databricks workspace, constructs two HTTP “server tools” (one for vector search, one for Unity-Catalog functions), and pre-connects them for low-latency use. Each incoming POST to /chat contains a single user message. The handler spins up a fresh Agent whose mcp_servers list is populated by those streaming tools and whose model is forced to call a tool for every turn.\nThe endpoint streams tokens back to the browser while the agent reasons and calls MCP tools.\nIn a different terminal, run the following to start the Frontend (React UI):\nThe app will be available at http://localhost:5173\nThe React chat UI in the /ui folder provides a user-friendly web interface for interacting with the backend agent. It features components for displaying the conversation history and a text input for sending messages.\n\nWhen a user submits a message, the UI sends it to the backend /chat endpoint and streams the agent’s response in real time, updating the chat window as new content arrives. The design emphasizes a conversational experience, making it easy for users to ask questions and receive answers from the Databricks-powered agent, all within a responsive and interactive web application.\n\nIn particular, the file ChatUI.jsx file contains the core logic for the chat interface, including how user messages are sent to the backend and how streaming responses from the agent are handled and displayed in real time.\nThe UI streams and displays the agent’s response as it arrives, creating a smooth, real-time chat experience. Highlighting this will clearly show your readers how the UI achieves interactive, conversational feedback from your backend agent.\n\nDatabricks MCP UI\n\nNavigate to http://localhost:5173 and try the following prompts:\nWhat products are dependent on L6HUK material?\nHow much revenue is at risk if we can’t produce the forecasted amount of product autoclave_1?\nWhich products have delays right now?\nAre there any delays with syringe_1?\nWhat raw materials are required for syringe_1?\nAre there any shortages with one of the following raw materials: O4GRQ, Q5U3A, OAIFB or 58RJD?\nWhat are the delays associated with wholesaler 9?\nThe agent will call relevant tools and format a grounded answer for the user.\n\nIn the OpenAI API dashboard you can open the Traces view to see every function the agent invoked. In the example below, the agent first calls raw_from_product to fetch the material linked to a specific product, and then calls revenue_risk to estimate the revenue impact of a shortage.\n\nTracing Dashboard\n\nYou can consider adding multi-turn capabilities\nYou can also add Genie Space MCP servers if you’d like to adapt this setup to your own workspace\nDatabricks Managed MCP documentation\nOpenAI Agent SDK documentation\nOpenAI Agent Guardrails documentation\nOpenai-agents-python example snippets"])</script><script>self.__next_f.push([1,"3e:T837d,"])</script><script>self.__next_f.push([1,"This cookbook provides a practical, end-to-end guide on how to effectively use\nevals as the core process in creating a production-grade autonomous system to\nreplace a labor-intensive human workflow. It's a direct product of collaborative\nexperience dealing with projects where users may not have started with pristine\nlabeled data or a perfect understanding of the problem - two issues that most tutorials gloss\nover but are in practice almost always serious challenges.\n\nMaking evals the core process prevents poke-and-hope guesswork and impressionistic\njudgments of accuracy, instead demanding engineering rigor. This means we can make\nprincipled decisions about cost trade-offs and investment.\n\nThis guide is designed for ML/AI engineers and Solution Architects who are\nlooking for practical guidance beyond introductory tutorials. This notebook is fully\nexecutable and organized to be as modular as possible to support using code\nsamples directly in your own applications.\n\n\nWe'll follow a realistic storyline: replacing a manual receipt-analysis service for validating expenses.\n\nStart Small:** Begin with a very small set of labeled data (retail receipts). Many businesses don't have good ground truth data sets.\nBuild Incrementally:** Develop a minimal viable system and establish initial evals.\nBusiness Alignment:** Evaluate eval performance in the context of business KPIs and\n  dollar impact, and target efforts to avoid working on low-impact improvements.\nEval-Driven Iteration:** Iteratively improve by using eval scores to power model\n  improvements, then by using better models on more data to expand evals and identify more\n  areas for improvement.\n\n\nThis cookbook is structured as an eval-centric guide through the lifecycle of building\nan LLM application.\n\nIf you're primarily interested in the ideas presented, read through the text and skim over\n   the code.\nIf you're here because of something else you're working on, you can go ahead and jump to that\n   section and dig into the code there, copy it, and adapt it to your needs.\nIf you want to really understand how this all works, download this notebook and run\n   the cells as you read through it; edit the code to make your own changes, test your\n   hypotheses, and make sure you actually understand how it all works together.\nNote: If your OpenAI organization has a Zero Data Retention (ZDR) policy, Evals will still be available, but will retain data to maintain application state.\n\nIn order to condense this guide we'll be using a small hypothetical problem that's still complex\nenough to merit detailed and multi-faceted evals. In particular, we'll be focused on how\nto solve a problem given a limited amount of data to work with, so we're working with a\ndataset that's quite small.\n\n\nFor this guide, we assume that we are starting with a workflow for reviewing and filing\nreceipts. While in general, this is a problem that already has a lot of established\nsolutions, it's analogous to other problems that don't have nearly so much prior work;\nfurther, even when good enterprise solutions exist there is often still a\n\"last mile\" problem that still requires human time.\n\nIn our case, we'll assume we have a pipeline where:\n\nPeople upload photos of receipts\nAn accounting team reviews each receipt to categorize and approve or audit the expense\n\nBased on interviews with the accounting team, they make their decisions based on\n\nMerchant\nGeographic location\nExpense amount\nItems or services purchased\nHandwritten notes or annotations\n\nOur system will be expected to handle most receipts without any human intervention, but\nescalate low-confidence decisions for human QA. We'll be focused on reducing the total\ncost of the accounting process, which is dependent on\n\nHow much the previous / current system cost to run per-receipt\nHow many receipts the new system sends to QA\nHow much the system costs to run per-receipt, plus any fixed costs\nWhat the business impact is of mistakes, either receipts kicked out for review or mistakes missed\nThe cost of engineering to develop and integrate the system\n\n\nThe receipt images come from the CC by 4.0 licensed\nReceipt Handwriting Detection Computer Vision Project\ndataset published by Roboflow. We've added our own labels and narrative spin in order to\ntell a story with a small number of examples.\n\nNot every project will proceed in the same way, but projects generally have some\nimportant components in common.\n\nProject Lifecycle\n\nThe solid arrows show the primary progressions or steps, while the dotted line\nrepresents the ongoing nature of problem understanding - uncovering more about\nthe customer domain will influence every step of the process. We wil examine\nseveral of these iterative cycles of refinement in detail below.\nNot every project will proceed in the same way, but projects generally have some common\nimportant components.\n\n\nUsually, the decision to start an engineering process is made by leadership who\nunderstand the business impact but don't need to know the process details. In our\nexample, we're building a system designed to replace a non-AI workflow. In a sense this\nis ideal: we have a set of domain experts, the people currently doing the task who we\ncan interview to understand the task details and who we can lean upon to help develop\nappropriate evals.\n\nThis step doesn't end before we start building our system; invariably, our initial\nassessments are an incomplete understanding of the problem space and we will continue to\nrefine our understanding as we get closer to a solution.\n\n\nIt's very rare for a real-world project to begin with all the data necessary to achieve a satisfactory solution, let alone establish confidence.\n\nIn our case, we'll assume we have a decent sample of system inputs, in the form of but receipt images, but start without any fully annotated data. We find this is a not-unusual situation when automating an existing process. We'll walk through the process of incrementally expanding our test and training sets in collaboration with domain experts as we go along and make our evals progressively more comprehensive.\n\n\nWe want to get the skeleton of a system built as quickly as possible. We don't need a\nsystem that performs well - we just need something that accepts the right inputs and\nprovides outputs of the correct type. Usually this is almost as simple as describing the\ntask in a prompt, adding the inputs, and using a single model (usually with structured\noutputs) to make an initial best-effort attempt.\n\n\nWe've found that in the absence of an established ground truth, it's not uncommon to\nuse an early version of a system to generate 'draft' truth data which can be annotated\nor corrected by domain experts.\n\nOnce we have an end-to-end system constructed, we can start processing the inputs we\nhave to generate plausible outputs. We'll send these to our domain experts to grade\nand correct. We will use these corrections and conversations about how the experts\nare making their decisions to design further evals and to embed expertise in the system.\n\n\nBefore we jump into correcting every error, we need to make sure that we're investing\ntime effectively. The most critical task at this stage is to review our evals and\ngain an understanding of how they connect to our key objectives.\n\nStep back and assess the potential costs and benefits of the system\nIdentify which eval measurements speak directly to those costs and benefits\nFor example, what does \"failure\" on a particular eval cost? Are we measuring\n  something worthwhile?\nCreate a (non-LLM) model that uses eval metrics to provide a dollar value\nBalance performance (accuracy, or speed) with cost to develop and run\n\n\nHaving identified which efforts are most worth making, we can begin iterating on\nimprovements to the system. The evals act as an objective guide so we know when we've\nmade the system good enough, and ensure we avoid or identify regression.\n\nEvals aren't just for development. Instrumenting all or a portion of a production\nservice will surface more useful test and training samples over time, identifying\nincorrect assumptions or finding areas with insufficient coverage. This is also the only\nway you can ensure that your models continue performing well long after your initial\ndevelopment process is complete.\n\nIn practice, we would probably be building a system that operates via a REST API,\npossibly with some web frontend that would have access to some set of components and\nresources. For the purposes of this cookbook, we'll distill that down to a pair of\nfunctions, extract_receipt_details and evaluate_receipt_for_audit that collectively\ndecide what we should do with a given receipt.\n\nextract_receipt_details will take an image as input and produce structured output\n  containing important details about the receipt.\nevaluate_receipt_for_audit will take that structure as input and decide whether or\n  not the receipt should be audited.\nBreaking up a process into steps like this has both pros and cons; it is easier to\nexamine and develop if the process is made up of small isolated steps. But you can\nprogressively lose information, effectively letting your agents play \"telephone\". In\nthis notebook we break up the steps and don't let the auditor see the actual receipt\nbecause it's more instructive for the evals we want to discuss.\n\nWe'll start with the first step, the literal data extraction. This is intermediate\ndata: it's information that people would examine implicitly, but often isn't recorded.\nAnd for this reason, we often don't have labeled data to work from.\n\nCapture the meaningful information in a structured output.\nNote: Normally we would use decimal.Decimal objects for the numbers above and datetime.datetime objects for time field, but neither of those deserialize well. For the purposes of this cookbook, we'll work with strings, but in practice you'd want to have another level of translation to get the correct output validated.\n\nLet's build our extract_receipt_details function.\n\nUsually, for the very first stab at something that might work, we'll simply feed ChatGPT\nthe available documents we've assembled so far and ask it to generate a prompt. It's not\nworth spending too much time on prompt engineering before you have a benchmark to grade\nyourself against! This is a prompt produced by o4-mini based on the problem description\nabove.\n\nLet's evaluate just a single receipt and review it manually to see how well a smart model with a naive prompt can do.\n\nWe'll get different answers if we re-run it, but it usually gets most things correct\nwith a few errors. Here's a specific example:\nThe model extracted a lot of things correctly, but renamed some of the line\nitems - incorrectly, in fact. More importantly, it got some of the prices wrong, and it\ndecided not to categorize any of the line items.\n\nThat's okay, we don't expect to have perfect answers at this point! Instead, our\nobjective is to build a basic system we can evaluate. Then, when we start iterating, we\nwon't be 'vibing' our way to something that looks better -- we'll be engineering a\nreliable solution. But first, we'll add an action decision to complete our draft system.\n\nNext, we need to close the loop and get to an actual decision based on receipts. This\nlooks pretty similar, so we'll present the code without comment.\n\nOrdinarily one would start with the most capable model - o3, at this time - for a\nfirst pass, and then once correctness is established experiment with different models\nto analyze any tradeoffs for their business impact, and potentially consider whether\nthey are remediable with iteration. A client may be willing to take a certain accuracy\nhit for lower latency or cost, or it may be more effective to change the architecture\nto hit cost, latency, and accuracy goals. We'll get into how to make these tradeoffs\nexplicitly and objectively later on.\n\nFor this cookbook, o3 might be too good. We'll use o4-mini for our first pass, so\nthat we get a few reasoning errors we can use to illustrate the means of addressing\nthem when they occur.\n\nNext, we need to close the loop and get to an actual decision based on receipts. This\nlooks pretty similar, so we'll present the code without comment.\nA schematic of the overall process shows two LLM calls:\n\nProcess Flowchart\n\nIf we run our above example through this model, here's what we get -- again, we'll use\nan example result here. When you run the code you might get slightly different results.\nThis example illustrates why we care about end-to-end evals and why we can't use them in\nisolation. Here, the initial extraction had OCR errors and forwarded the prices to the\nauditor that don't add up to the total, but the auditor fails to detect it and asserts\nthere are no math errors. However, missing this doesn't change the audit decision\nbecause it did pick up on the other two reasons the receipt needs to be audited.\n\nThus, AuditDecision is factually incorrect, but the decision that we care about\nis correct. This gives us an edge to improve upon, but also guides us toward making\nsound choices for where and when we apply our engineering efforts.\n\nWith that said, let's build ourselves some evals!\n\nOnce we have a minimally functional system we should process more inputs and get domain\nexperts to help develop ground-truth data. Domain experts doing expert tasks may not\nhave much time to devote to our project, so we want to be efficient and start small,\naiming for breadth rather than depth at first.\nIf your data doesn't require domain expertise, then you'd want to reach for a\nlabeling solution (such as Label Studio) and attempt to annotate\nas much data as you can given the policy, budget, and data availability restrictions.\nIn this case, we're going to proceed as if data labeling is a scarce resource; one we\ncan rely on for small amounts each week, but these are people with other job\nresponsibilities whose time and willingness to help may be limited. Sitting with these\nexperts to help annotate examples can help make selecting future examples more\nefficient.\n\nBecause we have a chain of two steps, we'll be collecting tuples of type\n[FilePath, ReceiptDetails, AuditDecision]. Generally, the way to do this is to take\nunlabeled samples, run them through our model, and then have experts correct the output.\nFor the purposes of this notebook, we've already gone through that process for all the\nreceipt images in data/test.\n\n\nThere's a little more to it than that though, because when you are evaluating a\nmultistep process it's important to know both the end to end performance and the\nperformance of each individual step, conditioned on the output of the prior step.\n\nIn this case, we want to evaluate:\n\nGiven an input image, how well do we extract the information we need?\nGiven receipt information, how good is our judgement for our audit decision?\nGiven an input image, how successful are we about making our final audit decision?\n\nThe phrasing difference between #2 and #3 is because if we give our auditor incorrect\ndata, we expect it to come to incorrect conclusions. What we want is to be confident\nthat the auditor is making the correct decision based on the evidence available, even if\nthat evidence is misleading. If we don't pay attention to that case, we can end up\ntraining the auditor to ignore its inputs and cause our overall performance to degrade.\n\nThe core component of an eval is the\ngrader. Our eventual eval is going to\nuse 18 of them, but we only use three kinds, and they're all quite conceptually\nstraightforward.\n\nHere are examples of one of our string check graders, one of our text similarity\ngraders, and finally one of our model graders.\nEach grader evaluates some portion of a predicted output. This might be a very narrow\ncheck for a specific field in a structured output, or a more holistic check that\njudges an output in its entirety. Some graders can work without context, and evaluate an\noutput in isolation (for example, an LLM judge that is evaluating if a paragraph is rude\nor inappropriate). Others can evaluate based on the input and output, while while the\nones we're using here rely on an output and a ground-truth (correct) output to compare\nagainst.\n\nThe most direct way of using Evals provides a prompt and a model, and lets the eval run\non an input to generate output itself. Another useful method uses previously logged\nresponses or completions as the source of the outputs. It's not quite as simple, but the\nmost flexible thing we can do is to supply an item containing everything we want it to\nuse—this allows us to have the \"prediction\" function be an arbitrary system rather than\nrestricting it to a single model call. This is how we're using it in the examples below;\nthe EvaluationRecord shown below will be used to populate the {{ }} template\nvariables.\nNote on Model Selection:\nSelecting the right model is crucial. While faster, less expensive models are often preferable in production, development workflows benefit from prioritizing the most capable models available. For this guide, we use o4-mini for both system tasks and LLM-based grading—while o3 is more capable, our experience suggests the difference in output quality is modest relative to the substantial increase in cost. In practice, spending $10+/day/engineer on evals is typical, but scaling to $100+/day/engineer may not be sustainable.\nNonetheless, it's valuable to periodically benchmark with a more advanced model like o3. If you observe significant improvements, consider incorporating it for a representative subset of your evaluation data. Discrepancies between models can reveal important edge cases and guide system improvements.\nOnce we have the graders and the data, creating and running our evals is very straightforward:\nAfter you run that eval you'll be able to view it in the UI, and should see something\nlike the below.\n\n(Note, if you have a Zero-Data-Retention agreement, this data is not stored\nby OpenAI, so will not be available in this interface.)\nlike:\n\nSummary UI\n\nYou can drill into the data tab to look at individual examples:\n\nDetails UI\n\nEvals show you where you can improve, and help track progress and regressions over time.\nBut the three evals above are just measurements — we need to imbue them with raison\nd'être.\n\nThe first thing we need is to add evaluations for the final stage of our receipt\nprocessing, so that we can start seeing the results of our audit decisions. The next\nthing we need, the most important, is a model of business relevance.\n\n\nIt's almost never easy to work out what costs and benefits you could get out of a new\nsystem depending on how well it performs. Often people will avoid trying to put\nnumbers to things because they know how much uncertainty there is and they don't want to\nmake guesses that make them look bad. That's okay; we just have to make our best guess,\nand if we get more information later we can refine our model.\n\nFor this cookbook, we're going to create a simple cost structure:\n\nour company processes 1 million receipts a year, at a baseline cost of $0.20 /\n  receipt\nauditing a receipt costs about $2\nfailing to audit a receipt we should have audited costs an average of $30\n5% of receipts need to be audited\nthe existing process\n  identifies receipts that need to be audited 97% of the time\n  misidentifies receipts that don't need to be audited 2% of the time\n\nThis gives us two baseline comparisons:\n\nif we identified every receipt correctly, we would spend $100,000 on audits\nour current process spends $135,000 on audits and loses $45,000 to un-audited expenses\n\nOn top of that, the human-driven process costs an additional $200,000.\n\nWe're expecting our service to save money by costing less to run (≈1¢/receipt if we use\nthe prompts from above with o4-mini), but whether we save or lose money on audits and\nmissed audits depends on how well our system performs. It might be worth writing this as\na simple function — written below is a version that includes the above factors but\nneglects nuance and ignores development, maintenance, and serving costs.\n\n\n\nThe point of the above model is it lets us apply meaning to an eval that would\notherwise just be a number. For instance, when we ran the system above we were wrong 85%\nof the time for merchant names. But digging in, it seems like most instances are\ncapitalization issues or \"Shell Gasoline\" vs. \"Shell Oil #2144\" — problems that when\nwe follow through, do not appear to affect our audit decision or change our fundamental\ncosts.\n\nOn the other hand, it seems like we fail to catch handwritten \"X\"s on receipts about\nhalf the time, and about half of the time when there's an \"X\" on a receipt that gets\nmissed, it results in a receipt not getting audited when it should. Those are\noverrepresented in our dataset, but if that makes up even 1% of receipts, that 50%\nfailure would cost us $75,000 a year.\n\nSimilarly, it seems like we have OCR errors that cause us to audit receipts quite often\non account of the math not working out, up to 20% of the time. This could cost us almost\n$400,000!\n\nNow, we're in a place to add more graders and start working backwards from the audit\ndecision accuracy to determine which problems we should focus on.\n\nBelow are the rest of our graders and the results we get with our initial un-optimized\nprompts. Note that at this point we do quite badly! Across our 20 samples (8 positive,\n12 negative), we had two false negatives and two false positives. If we extrapolated to\nour entire business, we'd be losing $375,000 on audits we missed and $475,000 on\nunnecessary audits.\nLarge Summary UI\n\nHaving our business model means we have a map of what's worth doing and what isn't. Our\ninitial evals are a road sign that lets us know we're moving in the right direction; but\neventually we'll need more signage. At this point in the process we usually have a lot\nof different things we can work on, with a few linked cycles where improvement on one\nwill open up more room for improvement on a different cycle.\n\nDevelopment Flywheel\n\nOur evals show us where we can improve, and we can immediately use them to guide us\n   in model selection, prompt engineering, tool use, and fine-tuning strategies.\nWe're not done once system performs well according to our evals. That's when it's\n   time to improve our evals. We will process more data, give it to our domain experts\n   to review, and feed the corrections into building better, more comprehensive evals.\n\nThis cycle can go on for a while. We can speed it along by identifying the efficient\nfrontier of \"interesting\" data to examine. There are a few techniques for this, but an\neasy one is re-running models on inputs to prioritize labeling inputs that don't\nget consistent answers. This works especially well when using different underlying\nmodels, and often even benefits from using less-intelligent models (if a dumb model\nagrees with a smart model then it's probably not a hard problem).\n\nOnce it seems like we've hit a point of dimishing returns on performance, we can keep\nusing the same techniques to optimize model cost; if we have a system that performs\nquite well, then fine-tuning or some form of model distillation will probably allow us\nto get similar performance from smaller, cheaper, faster models.\n\nWith our evals in place and an understanding of how they connect to our business metrics,\nwe're finally ready to turn our attention to improving the output of our system.\n\nAbove, we noted that we get merchant names wrong 85% of the time, more than any other\noutput we're evaluating. This looks pretty bad, and it's probably something we can\nimprove dramaticaly with only a little work, but instead let's start from the endpoint\nof our business metrics and work backwards to see what issues caused incorrect\ndecisions.\n\nWhen we do that, we see that the mistakes we made on merchant names are completely\nuncorrelated with our final audit decision, and there's no evidence that they have any\nimpact on that decision. Based on our business model, we don't actually see a need to\nimprove it -- in other words, not all evals matter. Instead, we can examine\nspecifically the examples where we made a bad audit decision. There are only two of them\n(out of 20). Examining them closely, we observe that in both cases the problem came from\nthe second stage of the pipeline making a wrong decision based on a non-problematic\nextraction. And in fact, both of them come from a failure to reason correctly about\ntravel-related expenses.\n\nIn the first case, the purchase is a snowbroom from an auto-parts store. This is a\nlittle bit of an edge case, but our domain experts identified this as a valid travel\nexpense (because drivers might need one to clear their windshield). This seems like\nexplaining the decision process in more detail and providing an analogous example would\ncorrect the error.\n\nIn the second case, the purchase is some tools from a home improvement score. The tools\ndon't have anything to do with normal driving, so this receipt should be audited as a\n\"non-travel-related expense\". In this case our model correctly identifies it as an\nexpense that's not travel-related, but then reasons incorrectly about that fact,\napparently misunderstanding that true for not_travel_related should imply true for\nneeds_audit. Again, this seems like an example where more clarity in our instructions\nand a few examples should fix the issue.\n\nConnecting this back to our cost model, we note that we have 1 false negative and 1\nfalse positive, along with 7 true positives and 11 true negatives. Extrapolating this to\nthe frequencies we see in production, this would increase our overall costs by $63,000\nper year.\n\nLet's modify the prompt and re-run our evals to see how we do. We'll provide more\nguidance in the form of a specific example in the instructions about engine oil\n(different from a snow broom, but requires the same reasoning), and we'll include three\nexamples pulled from our training set (data/train) as few-shot guidance.\nThe modifications we made to the prompt above are:\n\nUnder item 1 concerning travel-related expenses, we added a bullet point\n\nTravel-related expenses include anything that could be reasonably required for\n  business-related travel activities. For instance, an employee using a personal\n  vehicle might need to change their oil; if the receipt is for an oil change or the\n  purchase of oil from an auto parts store, this would be acceptable and counts as a\n  travel-related expense.\n\nWe added more proscriptive guidance on how to evaluate for a math error.\n   Specifically, we added the bullet points:\n\n   Add up the price and quantity of each line item to get the subtotal\n   Add tax to the subtotal to get the total\n   If the total doesn't match the amount on the receipt, this is a math error\n   If the total is off by no more than $0.01, this is NOT a math error\n\n   This doesn't actually have to do with the issues we mentioned, but is another issue\n   we noticed as a flaw in the reasoning provided by the audit model.\n\nWe added very strong guidance (we actually needed to state it and restate it\n   emphatically) to say that non-travel-related expenses should be audited.\n\nNote that violation of a criterion means that it is true. If any of the above four\nvalues are true, then the receipt needs auditing (needs_audit should be true: it\nfunctions as a boolean OR over all four criteria).\n\nIf the receipt contains non-travel expenses, then NOT_TRAVEL_RELATED should be true\nand therefore NEEDS_AUDIT must also be set to true. IF THE RECEIPT LISTS ITEMS THAT\nARE NOT TRAVEL-RELATED, THEN IT MUST BE AUDITED.\n\nWe added three examples, JSON input/output pairs wrapped in XML tags.\nWe added three examples, JSON input/output pairs wrapped in XML tags.\n\nWith our prompt revisions, we'll regenerate the data to evaluate and re-run the same\neval to compare our results:\nWhen we ran the eval again, we actually still got two audit decisions wrong. Digging into\nthe examples we made a mistake on, it turns out that we completely fixed the issues we\nidentified, but our examples improved the reasoning step and caused two other issues to\nsurface. Specifically:\n\nOne receipt needed to be audited only because there was a mistake in extraction and\n   a handwritten \"X\" wasn't identified. The audit model reasoned correctly, but based on\n   incorrect data.\nOne receipt was extracted in such a way that a $0.35 debit fee wasn't visible, so the\n   audit model identified a math error. This almost certainly happened because we\n   provided it with more detailed instructions and clear examples that demonstrated it\n   needed to actually add up all the line items in order to decide whether there was a\n   math error. Again, this demonstrates correct behavior on the part of the audit model\n   and suggests we need to correct the extraction model.\n\nThis is great, and we'll continue iterating on issues as we uncover them. This is the\ncycle of improvement!\n\n\nWhen beginning a project, we usually start with one of the most capable models available, such as o4-mini, to establish a performance baseline. Once we’re confident in the model’s ability to solve the task, the next step is to explore smaller, faster, or more cost-effective alternatives.\n\nOptimizing for inference cost and latency is essential, especially for production or customer-facing systems, where these factors can significantly impact overall expenses and user experience. For instance, switching from o4-mini to gpt-4.1-mini could reduce inference costs by nearly two-thirds—an example where thoughtful model selection leads to meaningful savings.\n\nIn the next section, we’ll rerun our evaluations using gpt-4.1-mini for both extraction and audit steps to see how well a more efficient model performs.\nThe results are pretty promising. It doesn't look like the extraction accuracy suffered\nat all. We see one regression (the snowbroom again), but our audit decision is correct\ntwice as often as it was before our prompt changes.\n\nEval Variations\n\nThis is great evidence that we'll be able to switch to a cheaper model, but it might\nrequire more prompt engineering, fine-tuning, or some form of model-distillation. Note\nhowever that according to our current model this would already be saving us money. We\ndon't quite believe that yet because we don't have a large enough sample — our real\nfalse negative rate will be more than the 0 we see here.\n\n\nThis cookbook focuses on the philosophy and practicalities of evals, not the full range of model improvement techniques. For boosting or maintaining model performance (especially when moving to smaller, faster, or cheaper models), consider these steps in order—start from the top, and only proceed down if needed. For example, always optimize your prompt before resorting to fine-tuning; fine-tuning on a weak prompt can lock in bad performance even if you improve the prompt later.\n\nModel Improvement Waterfall\n\nModel selection: try smarter models, or increase their reasoning budget.\nPrompt tuning: clarify instructions and provide very explicit rules.\nExamples and context: add few- or many-shot examples, or more context for the\n   problem. RAG fits in here, and may be used to dynamically select similar examples.\nTools use: provide tools to solve specific problems, including access to external\n   APIs, the ability to query databases, or otherwise enable the model to have its own\n   questions answered.\nAccessory models: add models to perform limited sub-tasks, to supervise and provide\n   guardrails, or use a mixture of experts and aggregate solutions from multiple\n   sub-models.\nFine-tuning: use labeled training data for supervised fine tuning, eval\n   graders for reinforcement fine tuning, or different outputs for direct preference\n   optimization.\n\nThe above options are all tools to maximize performance. Once you're trying to optimize\nfor a price:performance ratio, you'll usually have already done all of the above and\nlikely don't need to repeat most steps, but you can still fine-tune smaller models or\nuse your best model to train a smaller model (model distillation).\nOne really excellent thing about OpenAI Evals is that you can use the same graders for\nReinforcement Fine-Tuning\nto produce better model performance in an extremely sample-efficient manner. One note\nof caution is to make sure that you use separate training data and don't leak your\neval datasets during RFT.\nBuilding and deploying an LLM application is just the beginning—the real value comes from ongoing improvement. Once your system is live, prioritize continuous monitoring: log traces, track outputs, and proactively sample real user interactions for human review using smart sampling techniques.\n\nProduction data is your most authentic source for evolving your evaluation and training datasets. Regularly collect and curate fresh samples from actual use cases to identify gaps, edge cases, and new opportunities for enhancement.\n\nIn practice, leverage this data for rapid iteration. Automate periodic fine-tuning pipelines that retrain your models on recent, high-quality samples and automatically deploy new versions when they outperform existing ones in your evals. Capture user corrections and feedback, then systematically feed these insights back into your prompts or retraining process—especially when they highlight persistent issues.\n\nBy embedding these feedback loops into your post-development workflow, you ensure your LLM applications continuously adapt, stay robust, and remain closely aligned with user needs as they evolve.\nThis cookbook serves as a joint collaboration effort between OpenAI and Fractional.\n\nHugh Wimberly\nJoshua Marker\nEddie Siegel\nShikhar Kwatra"])</script><script>self.__next_f.push([1,"3f:T58e7,"])</script><script>self.__next_f.push([1,"This guide is for readers already familiar with OpenAI models and LLM agents, and want to see how to orchestrate a team of agents for a real-world, complex task.\n\nWhat You'll Learn\n\nIn this notebook, you'll learn how to use the OpenAI Agents SDK to design and implement a complex multi-agent collaboration system. Specifically, you'll see how to:\nBuild a workflow where multiple specialist agents (Macro, Fundamental, Quantitative) collaborate under a Portfolio Manager agent to solve a challenging investment research problem.\nUse the \"agents as a tool\" approach, where a central agent orchestrates and calls other agents as tools for specific subtasks.\nLeverage all major tool types supported by the SDK (custom Python functions, managed tools like Code Interpreter and WebSearch, and external MCP servers) in a single, integrated workflow.\nApply best practices for modularity, parallelism, and observability in agentic patterns.\n\nWhy this matters\n\nThe \"agents as a tool\" pattern is a powerful way to build transparent, auditable, and scalable multi-agent collaboration . This example demonstrates how to combine deep specialization, parallel execution, and robust orchestration using the OpenAI Agents SDK.\n\nBy the end of this guide, you'll have a clear blueprint for building your own multi-agent workflows for research, analysis, or any complex task that benefits from expert collaboration.\n\n\nWhat is Multi-Agent Collaboration?\nCollaboration Patterns: Handoff vs. Agent-as-Tool\nArchitecture Overview\nSupported Tool Types\nSetup\nRunning the Workflow\nThe Head Portfolio Manager (PM) Agent\nBreaking Down the Head Portfolio Manager Agent\nExample Output\nBest Practices When Building Agents\nFurther Reading \u0026 Best Practices\n\n\nMulti-agent collaboration means multiple autonomous agents (LLM \"nodes\") coordinate to achieve an overarching goal that would be difficult for a single agent to handle. Instead of one monolithic prompt, each agent handles a specific subtask or expertise area, and an orchestration layer connects these agent \"nodes\" into a coherent workflow. This approach is useful for complex systems – for example, a financial analysis might be broken into macro-economic analysis, fundamental company analysis, and quantitative signal analysis, each handled by a different agent specialist. The agents share information and their results are combined to produce a final outcome.\n\n\n\nThe OpenAI Agents SDK supports multiple patterns for agents to work together:\n\nHandoff Collaboration:** One agent can handoff control to another agent mid-problem. In a handoff architecture, each agent knows about the others and can decide when to defer to a more appropriate agent. This is flexible for open-ended or conversational workflows, but can make it harder to maintain a global view of the task. Read more in the SDK docs.\n\nAgent as a Tool:* In this approach, one agent (often a central planner or manager) *calls other agents as if they were tools. Sub-agents don't take over the conversation; instead, the main agent invokes them for specific subtasks and incorporates their results. This model keeps a single thread of control (the main agent orchestrates everything) and tends to simplify coordination. **This repo uses the agent-as-tool model: the Portfolio Manager agent remains in charge, using the other specialist agents as tools when it needs their expertise. This choice keeps the overall reasoning transparent and allows parallel execution of sub-tasks, which is ideal for complex analyses.\n\nFor more on these collaboration patterns, see the OpenAI Agents SDK documentation.\n\nOur system follows a hub-and-spoke design. The Portfolio Manager agent is the hub (central coordinator), and the specialist agents are the spokes. The user's query (e.g. \"How would a planned interest rate reduction affect my GOOGL holdings?\") goes first to the Portfolio Manager. The Portfolio Manager agent is prompted to break down the problem and delegate to the appropriate specialist agents. It treats each specialist as a callable tool, invoking them for their portion of the analysis. All three report back to the Portfolio Manager, which then synthesizes a final answer for the user.\n\nMulti-Agent Investment Report Workflow\n\n\nA key advantage of the Agents SDK is the flexibility in defining tools that agents can use. Tools can range from simple Python functions to external services. In this project, we use:\n\nMCP (Model Context Protocol) Server:** Used to connect agents to external tools and data sources in a standardized way. This project uses a local MCP server for Yahoo Finance data (see mcp/yahoo_finance_server.py). Learn more: OpenAI MCP docs | MCP Spec\n\nOpenAI Managed Tools:* Managed tools are built-in, hosted tools provided by OpenAI that require no custom implementation. They offer powerful capabilities out of the box, such as *Code Interpreter* (for quantitative/statistical analysis) and *WebSearch** (for up-to-date news and data). These tools are easy to integrate, maintained by OpenAI, and allow agents to perform advanced actions like code execution and real-time information retrieval without additional setup.\n\nCustom Tools:** Custom tools are any Python functions you define and register as tools for your agent. The Agents SDK makes this easy: just decorate your function, and the SDK will automatically extract its name, docstring, and input schema. This is ideal for domain-specific logic, data access, or workflow extensions.\n  In our project, we use custom tools to access FRED economic data (see FRED API) and perform file system operations.\n\nCustom tools give you full flexibility to extend your agent's capabilities beyond built-in or managed tools. See the SDK docs on function tools.\nWant to add more tools? The SDK supports a wide range of tool types, including web search, file search, code execution, and more. See the full list of supported tools in the SDK documentation.\n\nBefore running the workflow, set your environment variables:\nOPENAI_API_KEY (for OpenAI access)\nFRED_API_KEY (for FRED economic data, see FRED API key instructions)\nEdit the question to whatever you'd like, but keep the date field to improve accuracy!\n\n\nDisclaimer: This example is for educational purposes only. Consult a qualified financial professional before making any investment decisions\n\n\nThe workflow is kicked off by sending a user request to the Head Portfolio Manager (PM) agent. The PM agent orchestrates the entire process, delegating to specialist agents and tools as needed. You can monitor the workflow in real time using OpenAI Traces, which provide detailed visibility into every agent and tool call.\n\nEdit the question in the code below to whatever you'd like, but keep the date field to improve accuracy!\n\n\nNote: Depending on the complexity of the task, this request can take up to 10 minutes.\n\n\n\nThe Head Portfolio Manager (PM) agent is the orchestrator of the entire workflow. It coordinates a set of four specialist agents, each focused on a different area of expertise. This design is intentional: overloading a single agent with every possible responsibility leads to shallow, generic outputs and makes it hard to maintain or improve your system over time.\n\nBy breaking the problem into specialized agents—each with a clear role—you get:\n\nDeeper, higher-quality research:** Each agent can focus on its domain, using the right tools and prompts for the job. The PM agent brings these perspectives together for a more nuanced, robust answer.\n\nModularity and clarity:** You can update, test, or improve one agent without affecting the others. This makes your system easier to maintain and extend as your needs evolve.\n\nFaster results through parallelism:** Independent agents can work at the same time, dramatically reducing the time to complete complex, multi-part analyses.\n\nConsistency and auditability:** A structured, prompt-driven workflow ensures every run follows best practices, is easy to debug, and produces outputs you can trust and review.\n\nThis approach is ideal for any application where you want depth, specialization, and reliability—whether you're building a research assistant, a decision support tool, or any system that benefits from expert collaboration and orchestration.\n\nHow We Implement This in Practice:\nEach specialist agent (Fundamental, Macro, Quantitative) is wrapped as a callable tool using the SDK's function_tool decorator, with custom names and descriptions. This makes the PM agent's toolset explicit and LLM-friendly.\n\nThe Head PM agent uses the run_all_specialists_parallel tool to invoke all three specialists concurrently, leveraging parallel_tool_calls=True for maximum speed and efficiency.\n\nThe agent's prompt is loaded from a markdown file (pm_base.md), encoding not just the firm's philosophy but also detailed tool usage rules and a step-by-step workflow. This ensures every run is consistent, auditable, and aligned with best practices.\n\nAfter gathering and reviewing the specialist outputs, the PM agent uses a dedicated memo editor tool to assemble, format, and finalize the investment report. This separation of concerns keeps the workflow modular and easy to extend.\n\nThe system is designed for extensibility: you can add new specialist agents, swap out tools, or update prompts without breaking the overall orchestration logic. All tool calls, agent decisions, and outputs are captured in OpenAI Traces for full transparency and debugging.\n\nThese implementation choices directly support the benefits above—enabling deep, modular, and reliable multi-agent research workflows that are easy to maintain, audit, and improve.\n\nfrom agents import Agent, ModelSettings, function_tool\nfrom utils import load_prompt, DISCLAIMER\n\ndef build_head_pm_agent(fundamental, macro, quant, memo_edit_tool):\n    def make_agent_tool(agent, name, description):\n        @function_tool(name_override=name, description_override=description)\n        async def agent_tool(input):\n            return await specialist_analysis_func(agent, input)\n        return agent_tool\n    fundamental_tool = make_agent_tool(fundamental, \"fundamental_analysis\", \"Generate the Fundamental Analysis section.\")\n    macro_tool = make_agent_tool(macro, \"macro_analysis\", \"Generate the Macro Environment section.\")\n    quant_tool = make_agent_tool(quant, \"quantitative_analysis\", \"Generate the Quantitative Analysis section.\")\n\n    @function_tool(name_override=\"run_all_specialists_parallel\", description_override=\"Run all three specialist analyses (fundamental, macro, quant) in parallel and return their results as a dict.\")\n    async def run_all_specialists_tool(fundamental_input, macro_input, quant_input):\n        return await run_all_specialists_parallel(\n            fundamental, macro, quant,\n            fundamental_input, macro_input, quant_input\n        )\n\n    return Agent(\n        name=\"Head Portfolio Manager Agent\",\n        instructions=(load_prompt(\"pm_base.md\") + DISCLAIMER),\n        model=\"gpt-4.1\",\n        tools=[fundamental_tool, macro_tool, quant_tool, memo_edit_tool, run_all_specialists_tool],\n        model_settings=ModelSettings(parallel_tool_calls=True, tool_choice=\"auto\", temperature=0)\n    )\n\nThe PM agent's system prompt (see prompts/pm_base.md) is the heart of the workflow. It encodes:\nThe firm's philosophy (originality, risk awareness, challenging consensus)\nClear tool usage rules (when to use parallel tools, how to structure inputs)\nA robust, multi-step workflow (determine task type, provide guidance, review outputs, assemble memo, handle missing data)\n\nThis prompt ensures that every run is:\nConsistent:** The same high standards and process are followed every time.\nAuditable:** Each step, tool call, and decision is visible in the trace.\nHigh-Quality:** Outputs are original, risk-aware, and rigorously reviewed.\nHere's an example of an investment report generated through the workflow. Your output will be written to the outputs folder in the directory.\n\nClick to expand Investment Memo\n\n\n\nAlphabet Inc. (GOOGL) currently trades at \\$171.42 per share, with a market capitalization of \\$1.88 trillion and a P/E ratio of 16.91. The investment thesis is moderately constructive: while a planned interest rate reduction by the Federal Reserve is a mild tailwind, it is not the primary driver of GOOGL's price action. The most original, differentiated insight—fully aligned with our firm's vision—is that GOOGL's direct sensitivity to interest rates is modest (max weekly correlation with 10Y yield is ~0.29), and the real risk/reward hinges on the sustainability of AI-driven growth, sector rotation, and regulatory headwinds. This thesis is supported by robust technicals, strong fundamentals, and overwhelmingly positive analyst sentiment, but is tempered by the risk that AI optimism fades or macro/regulatory shocks emerge. The consensus view is justified by evidence: GOOGL's business remains resilient, but the variant view—where rate cuts fail to stimulate tech or sector rotation caps returns—should not be ignored. Key risks include regulatory action, macroeconomic uncertainty, and the potential for a shift in the AI narrative. In the best case, GOOGL could reach \\$200–\\$210 by year-end 2025; in the worst case, a retest of \\$160–\\$170 is plausible. This memo embodies the firm's vision by focusing on scenario planning, original quantitative analysis, and a critical assessment of consensus and variant views.\n\n\nAlphabet's core business is driven by its dominance in digital advertising (Google Search, YouTube) and its growing cloud and AI segments. As of the latest quarter (Q1 2025), revenue was \\$90.2 billion, net income \\$34.5 billion, and EPS \\$2.81, with net margin at 38.3%. Margins have improved over the past year, and the company's scale and leadership in AI and cloud provide a durable moat. However, recent analyst price targets have been revised downward (Bernstein: \\$165, UBS: \\$209, Wolfe: \\$210), reflecting caution around regulatory and macroeconomic risks. The consensus view is justified: while Alphabet's financial strength and innovation are clear, regulatory scrutiny and macro headwinds (e.g., reduced ad budgets in downturns) are real risks. The most original insight is the company's ability to adapt and innovate, potentially mitigating some risks. The analysis is evidence-based, with recent quarterly data showing stable or improving margins:\n\n| Date       |    Revenue |   Net Income |   Gross Profit |   Total Expenses |   EPS |   Net Margin (%) |   Gross Margin (%) |   Operating Margin (%) |\n|:-----------|-----------:|-------------:|---------------:|-----------------:|------:|-----------------:|-------------------:|-----------------------:|\n| 2025-03-31 | 9.0234e+10 |   3.454e+10  |     5.3873e+10 |       5.9628e+10 |  2.81 |          38.28 |            59.70 |                33.92 |\n| 2024-12-31 | 9.6469e+10 |   2.6536e+10 |     5.5856e+10 |       6.5497e+10 |  2.15 |          27.51 |            57.90 |                32.11 |\n| 2024-09-30 | 8.8268e+10 |   2.6301e+10 |     5.1794e+10 |       5.9747e+10 |  2.12 |          29.80 |            58.68 |                32.31 |\n| 2024-06-30 | 8.4742e+10 |   2.3619e+10 |     4.9235e+10 |       5.7317e+10 |  1.89 |          27.87 |            58.10 |                32.36 |\n| 2024-03-31 | 8.0539e+10 |   2.3662e+10 |     4.6827e+10 |       5.5067e+10 |  1.89 |          29.38 |            58.14 |                31.63 |\n\nRecent analyst sentiment is overwhelmingly positive, with 56 Buy, 12 Hold, and 0 Sell recommendations currently:\n\n| period       |   Buy |   Hold |   Sell |\n|:-------------|------:|-------:|-------:|\n| Current      |    56 |     12 |      0 |\n| 1 Month Ago  |    55 |     12 |      0 |\n| 2 Months Ago |    55 |     12 |      0 |\n| 3 Months Ago |    53 |     12 |      0 |\n\nThe fundamental view is aligned with the firm vision by focusing on evidence, scenario planning, and not simply following consensus. The main divergence from the firm vision would be if the analysis failed to consider the impact of regulatory or macro shocks, but this is addressed here.\n\n\nThe macroeconomic environment is mixed. U.S. real GDP is expanding (\\$23.5 trillion, Q1 2025), unemployment is low (4.2%), and inflation remains elevated (CPI: 320.3). The Federal Reserve has kept rates at 4.25–4.50%, with a patient stance and a focus on evolving risks. The U.S. dollar is strong (DXY: 123.4), and recent tariffs have introduced uncertainty. Investors are rotating from U.S. tech to Asian equities, reflecting concerns about high valuations and better growth prospects abroad. The consensus macro view is that rate cuts will support tech valuations, but the variant view—supported by our firm's vision—is that sector rotation and trade policy could offset these benefits. Tail-risk scenarios include a base case where rate cuts support GOOGL (\\$180–\\$190 target), and a downside where trade tensions or sector rotation cap returns. The analysis is evidence-based, using FRED data and recent policy statements, and explicitly considers both best- and worst-case scenarios. The macro view is fully aligned with the firm vision by challenging consensus and planning for multiple outcomes.\n\n\nQuantitative analysis confirms that GOOGL's direct sensitivity to interest rates is modest. The mean weekly correlation with the 10Y Treasury yield is 0.29, and with the Fed Funds rate is 0.05, indicating that rate changes are not the primary driver of GOOGL's returns. Technicals are robust: GOOGL is above key moving averages, momentum is positive, and volatility is moderate. Scenario analysis shows that a rate cut is a mild tailwind, but if the move is already priced in or if technicals break down, a 5–10% pullback is possible. Analyst sentiment is strongly positive, and fundamentals (revenue, margins) are improving. Quantitative summary statistics:\n\n| Metric                                  |     Value |\n|:----------------------------------------|----------:|\n| Mean daily corr (FEDFUNDS, GOOGL)       | 0.05 |\n| Mean daily reg slope (FEDFUNDS, GOOGL)  | 0.02 |\n| Mean daily corr (DGS10, GOOGL)          | 0.13 |\n| Mean daily reg slope (DGS10, GOOGL)     | 0.05 |\n| Mean weekly corr (FEDFUNDS, GOOGL)      | 0.05 |\n| Mean weekly reg slope (FEDFUNDS, GOOGL) | 0.03 |\n| Mean weekly corr (DGS10, GOOGL)         | 0.29 |\n| Mean weekly reg slope (DGS10, GOOGL)    | 0.09 |\n\nKey charts and images:\n\nGOOGL Daily Returns\nGOOGL Moving Averages\nGOOGL RSI\nGOOGL Rolling Volatility\nCumulative Return Comparison\nRolling Volatility Comparison\nRolling Corr/Reg Daily Fed Funds\nRolling Corr/Reg Daily 10Y\nRolling Corr/Reg Weekly Fed Funds\nRolling Corr/Reg Weekly 10Y\nGOOGL Quarterly Trends\nGOOGL Quarterly Margins\nGOOGL Analyst Recommendations Trend\n\nThe quantitative view is original in its focus on scenario analysis and the modest rate sensitivity, and is aligned with the firm vision by not simply following consensus. Limitations include the short post-pandemic data window and the fact that GOOGL's price is driven by multiple factors (AI, ad market, regulation) beyond rates.\n\n\nThe PM synthesis is that all three specialist sections converge on a moderately constructive outlook, with a realistic year-end 2025 price target of \\$190–\\$210. The most original insight is that GOOGL's direct rate sensitivity is modest, and the real risk is whether AI-driven growth can continue or if sector rotation and regulatory headwinds will cap returns. The quant section is strong in highlighting robust technicals and sentiment, but also the risk of a \\$160–\\$170 retest in downside scenarios. The fundamental and macro sections emphasize the importance of monitoring regulatory and trade policy. If underweight large-cap tech, now is a reasonable entry point, but position sizing should reflect the risk of sector rotation or macro disappointment. The variant view—rate cuts failing to stimulate tech or a shift in AI narrative—should not be ignored. Position sizing and risk management are key, fully in line with the firm's vision of scenario planning and differentiated insight.\n\n\nThe recommendation is to maintain or modestly increase exposure to GOOGL, especially if underweight large-cap tech, with a year-end 2025 price target of \\$200–\\$210 in the base case. This embodies the firm vision by focusing on original, evidence-based scenario analysis, not simply following consensus. The recommendation is justified by robust fundamentals, positive technicals, and strong analyst sentiment, but is tempered by the risk of sector rotation, regulatory action, or a shift in the AI narrative. If these risks materialize, a retest of \\$160–\\$170 is possible. Sizing and risk management should reflect these scenarios. This approach is differentiated, evidence-driven, and fully aligned with the firm's vision.\n\nEND_OF_MEMO\n\nDISCLAIMER: I am an AI language model, not a registered investment adviser. Information provided is educational and general in nature. Consult a qualified financial professional before making any investment decisions.\n\n\n\n\nThe most effective agentic systems combine modular agent design, clear tool definitions, parallel execution, and structured prompts. This approach—central to the OpenAI Agents SDK—makes your workflows robust, scalable, and easy to debug or extend.\n\nKey features of the OpenAI Agents SDK that enable these best practices:\nAgent loop:** Handles tool calls, LLM reasoning, and workflow control automatically.\nPython-first orchestration:** Use familiar Python patterns to chain, compose, and orchestrate agents.\nHandoffs:** Delegate tasks between agents for specialization and modularity.\nGuardrails:** Validate inputs/outputs and break early on errors for reliability.\nFunction tools:** Register any Python function as a tool, with automatic schema and validation.\nTracing:** Visualize, debug, and monitor every step of your workflow for full transparency.\n\nA combination of well-designed tools, thoughtful orchestration, and careful model selection is crucial for building effective agent systems. In this example, we use the GPT-4.1 family of models for their strong analytical and tool-use capabilities (see the GPT-4.1 Prompting Guide). For deeper architectural best practices, see the included A Practical Guide to Building Agents (PDF). By bringing these elements together, you get a system that is robust, scalable, and easy to debug or extend.\n\nPlease try out the sample with your own investment questions, and please share any feedback! Happy building.\n\nOpenAI Agents SDK Documentation\nOpenAI Agents SDK: Multi-Agent Orchestration\nOpenAI Agents SDK: Tool List\nOpenAI Agents SDK: MCP Documentation\n\nMCP Spec\nOpenAI Cookbook\n(GPT-4.1 Prompting Guide)\nA Practical Guide to Building Agents (PDF)"])</script><script>self.__next_f.push([1,"40:T52df,"])</script><script>self.__next_f.push([1,"The o3/o4-mini models are the latest in our o-series of models trained to think for longer before responding. They are the smartest models we’ve released to date and represent a significant step forward from o1/o3-mini in tool calling capabilities. These models are trained to use tools natively within their chain of thought (CoT) which unlocks improved reasoning capabilities around when and how to use tools. We’ve released a guide on how to call functions with these models via the responses API, this guide builds on top of that and tells you how you can get the best function calling performance with these models.\nTo fully utilize function calling intelligence behind o3/o4-mini models, we recommend a few best practices in both developer prompts and function descriptions.\n\nWe introduced developer messages to make it explicit to reasoning models that an instruction is coming from the developer. In o-series models, any system message provided by the developer is automatically converted to a developer message internally. For practical purposes, you can treat the developer prompt as analogous to the traditional system prompt—but for clarity and correctness, this guide refers to all such instructions as developer prompts/messages.\n\nWhen we refer to a function description in this document, we mean the explanatory text in the description field of each function object inside the tool parameter of an API request. This description tells the model when and how to use the function. Here’s an example from our function calling documentation:\n\ntools = [{\n    \"type\": \"function\",\n    \"name\": \"get_weather\",\n    \"description\": \"Get current temperature for provided coordinates in celsius.\",\n    \"parameters\": {\n        \"type\": \"object\",\n        \"properties\": {\n            \"latitude\": {\"type\": \"number\"},\n            \"longitude\": {\"type\": \"number\"}\n        },\n        \"required\": [\"latitude\", \"longitude\"],\n        \"additionalProperties\": False\n    },\n    \"strict\": True\n}]\nHere, \"Get current temperature for provided coordinates in celsius.\" serves as the function description.\n\nNow that we got definitions out of the way, we can start getting into best practices.\n\n\nGeneral context: In line with general prompt engineering best practices, role prompting is helpful in setting the base behavior, tone and outlining the set of actions that are possible. For example:\nYou are an AI retail agent.\n\nAs a retail agent, you can help users cancel or modify pending orders, return or exchange delivered orders, modify their default user address, or provide information about their own profile, orders, and related products.\nFunction Call ordering: o3/o4-mini are trained to accomplish goals with tools. However, it can make mistakes in the order of the tool calls. To guard against these cases, it is recommended to explicitly outline the orders to accomplish certain tasks. For example, to guard against the failure case that a coding agent possibly making a file in a directory that does not yet exist, adding the following will usually suffice:\ncheck to see if directories exist before making files\nFor high volume and well defined tasks, we can make it even more robust by outlining the sequence of functions to call explicitly, for example:\nTo Process a refund for a delivered order, follow the following steps:\nConfirm the order was delivered. Use: order_status_check\nCheck the refund eligibility policy. Use: refund_policy_check\nCreate the refund request. Use: refund_create\nNotify the user of refund status. Use: user_notify\n\nDefining boundaries on when to use tools: It is helpful to clarify the model boundaries on when and when not to invoke certain tools. This can be done both at the developer prompt level and at the tool description level. Here is an example developer prompt:\nBe proactive in using tools to accomplish the user's goal. If a task cannot be completed with a single step, keep going and use multiple tools as needed until the task is completed. Do not stop at the first failure. Try alternative steps or tool combinations until you succeed.\n\nUse tools when:\n  The user wants to cancel or modify an order.\n  The user wants to return or exchange a delivered product.\n  The user wants to update their address or contact details.\n  The user asks for current or personalized order or profile info.\n\nDo not use tools when:\n  The user asks a general question like “What’s your return policy?”\n  The user asks something outside your retail role (e.g., “Write a poem”).\n\nIf a task is not possible due to real constraints (For example, trying to cancel an already delivered order), explain why clearly and do not call tools blindly.\n\nA function’s description should clarify when it should be invoked and how its arguments should be constructed.\n\nA function’s description is the ideal place to clarify both when the function should be invoked and how its arguments should be constructed. This serves as a durable interface contract between reasoning models and tool APIs.\n\nIn general, the function description defines what it does, how to invoke it. Developer instructions provide guidance to the agent using the tools. So if there are multiple tools that could be used for a similar purpose, the developer can disambiguate between them in the instructions. If the agentic workflow requirements have a preference for using tools in a specific order, or use certain tools frequently vs sparingly these would also go into the developer instructions.\n\nA well-structured description can improve accuracy and reduce misfires by anchoring key criteria and argument requirements early. It also allows developers to encode “proactiveness” control heuristics outside the developer prompt, closer to the tool definition itself.\n\nUsage Criteria: Similar to how you can refine function calling proactiveness through the developer prompt, you can further refine how a function gets called at the function description level. Here is an example for a file_create function:\nCreates a new file with the specified name and contents in a target directory. This function should be used when persistent storage is needed and the file does not already exist.\nOnly call this function if the target directory exists. Check first using the directory_check tool.\nDo not use for temporary or one-off content—prefer direct responses for those cases.\nDo not overwrite existing files. Always ensure the file name is unique.\nDo not overwrite existing files.\n  If replacement is intended and confirmed, use file_delete followed by file_create, or use file_update instead.\nFew shot prompting: While reasoning models do not benefit from few-shot prompting as much as non-reasoning models, we found that few shot prompting can improve tool calling performance, especially when the model struggles to accurately construct function arguments. For example, here is an example tool description for a grep tool passed in as tool description:\n\nUse this tool to run fast, exact regex searches over text files using the ripgrep engine.\n\n\nAlways escape special regex characters: ( ) [ ] { } + * ? ^ $ | . \\\\\nUse \\\\ to escape any of these characters when they appear in your search string.\nDo NOT perform fuzzy or semantic matches.\nReturn only a valid regex pattern string.\n\nExamples:\nLiteral            -\u003e Regex Pattern\nfunction(          -\u003e function\\\\(\nvalue[index]       -\u003e value\\\\[index\\\\]\nfile.txt           -\u003e file\\\\.txt\nuser|admin         -\u003e user\\\\|admin\npath\\to\\file       -\u003e path\\\\\\\\to\\\\\\\\file\n\nKey rules up front and minimize distractions: Note in the above example, the instruction to escape a special character is relatively the first thing the model reads. A worse alternative would be:\nPerforms a fast regex-based text search that looks for exact pattern matches within files or entire directories, leveraging the ripgrep tool for high-speed scanning.\nOutput follows ripgrep formatting and can optionally display line numbers and matched lines.\nTo manage verbosity, results are limited to a maximum of 50 hits.\nYou can fine-tune the search by specifying inclusion or exclusion rules based on file types or path patterns.\nThis method is ideal when searching for literal text snippets or specific regular expressions.\nIt offers more accuracy than semantic methods when the goal is to locate a known string or structure.\nIt’s generally recommended over semantic search when you’re looking for a specific identifier—such as a function name, variable, or keyword—within a defined set of directories or file types.\n\nThis performs poorly because much of the prompt is not prescriptive and the most important rules for how to construct the argument are not front and center. The previous prompt scored 6% higher on a tool calling accuracy eval for using this ripgrep tool compared to the one above.\n\n\n\n\nWe are aware that the o3 model may be more prone to hallucinations than other models. These hallucinations may appear as the model promising to call tools in the background without actually doing so, or promising to call a tool in future turns, etc. In instances like these, it is helpful to be explicit in a few areas to minimize these types of hallucinations:\n\nExplicit instructions: explicitly instruct the model to avoid common hallucinations like promising future function calls when it is not possible.\n\nDo NOT promise to call a function later. If a function call is required, emit it now; otherwise respond normally.\n\nCatch bad arguments early:\nsetting strict to true will ensure function calls reliably adhere to the function schema. We recommend turning it on whenever possible.\n\nIf your arguments have additional complex format requirements (e.g valid python code etc), adding the following instruction can remind the model of the expected format.\n\nValidate arguments against the format before sending the call; if you are unsure, ask for clarification instead of guessing.\n\nAnother note on lazy behavior:\nwe are aware of rare instances of lazy behavior from o3, such as stating it does not have enough time to complete a task, promising to follow up separately, or giving terse answers even when explicitly prompted to provide more detail. We have found that the following steps help ameliorate this behavior:\n\n    a. Start a new conversation for unrelated topics:\n       When switching to a new or unrelated topic, begin a fresh conversation thread rather than continuing in the same context. This helps the model focus on the current subject and prevents it from being influenced by previous, irrelevant context, which can sometimes lead to incomplete or lazy responses. For example, if you were previously discussing code debugging and now want to ask about documentation best practices, which does not require previous conversation context, start a new conversation to ensure clarity and focus.\n\n    b. Discard irrelevant past tool calls/outputs when the list gets too long, and summarize them as context in the user message:\n       If the conversation history contains a long list of previous tool calls or outputs that are no longer relevant, remove them from the context. Instead, provide a concise summary of the important information as part of the user message. This keeps the context manageable and ensures the model has access to only the most pertinent information. For instance, if you have a lengthy sequence of tool outputs, you can summarize the key results and include only that summary in your next message.\n\n    c. We are constantly improving our models and expect to have this issue addressed in future versions.\n\n\nSince these models are reasoning models and produce an internal chain of thought, they do not have to be explicitly prompted to plan and reason between tool calls. Therefore, a developer should not try to induce additional reasoning before each function call by asking the model to plan more extensively. Asking a reasoning model to reason more may actually hurt the performance.\n\nA quick side note on reasoning summaries: the models will output reasoning tokens before calling tools. However, these will not always be accompanied by a summary, since our reasoning summaries require a minimum number of material reasoning tokens to produce a summary.\n\n\nWe’ve released a cookbook detailing the benefits of using the responses API. It is worth restating a few of the main points in this guide as well. o3/o4-mini are both trained with its internal reasoning persisted between tool calls within a single turn. Persisting these reasoning items between tool calls during inference will therefore lead to higher intelligence and performance in the form of better decision in when and how a tool gets called. Responses allow you to persist these reasoning items (maintained either by us or yourself through encrypted content if you do not want us to handle state-management) while Chat Completion doesn’t. Switching to the responses API and allowing the model access to reasoning items between function calls is the easiest way to squeeze out as much performance as possible for function calls. Here is an the example in the cookbook, reproduced for convenience, showing how you can pass back the reasoning item using encrypted_content in a way which we do not retain any state on our end:\n\nResponses API supports a set of hosted/built-in tools. We recently also added new tools and features in the responses API which makes it easier to build agentic applications that connect to external services; With built-in tools in the Responses API, developers can create more capable agents with a single API call.\n\nYou can mix and match hosted tools and custom tools in the same session. This unlocks powerful composition patterns, but it also makes tool routing clarity critical. Here are a couple of concrete recommendations:\n\nExplicitly define tool usage boundaries in the developer prompt: If multiple tools can fulfill similar roles (e.g. both the python tool and a custom calculator), instruct the model which tool is preferred and when. This reduces ambiguity, improves accuracy, and avoids tool overuse or underuse. :\nYou are a helpful research assistant with access to the following tools:\npython tool: for any computation involving math, statistics, or code execution\ncalculator: for basic arithmetic or unit conversions when speed is preferred\n\nAlways use the python tool for anything involving logic, scripts, or multistep math. Use the calculator tool only for simple 1-step math problems.\n\nClarify when internal knowledge is not sufficient: Even though o3/o4-mini models can often solve tasks on their own, tools may provide more reliable answers. Use the system prompt to steer the model away from “trying to solve it itself” when a tool is more appropriate.\n\nYou have access to a code_interpreter. Always prefer using code_interpreter when a user asks a question involving:\nmath problems\ndata analysis\ngenerating or executing code\nformatting or transforming structured text\n\nAvoid doing these directly in your own response. Always use the tool instead.\n\nSince the developer prompt acts as a centralized, durable contract, spell out decision boundaries for tools here when we want to mix and match hosted tools with your custom functions, including coverage overlap, confidence expectations, or fallback behavior:\n\nUse python for general math, data parsing, unit conversion, or logic tasks that can be solved without external lookup—for example, computing the total cost from a list of prices.\n\nUse calculate_shipping_cost when the user asks for shipping estimates, as it applies business-specific logic and access to live rate tables. Do not attempt to estimate these using the python tool.\n\nWhen both could be used (e.g., calculating a delivery fee), prefer calculate_shipping_cost for accuracy and policy compliance. Fall back to python only if the custom tool is unavailable or fails.\n\nMore on MCP: We have a more detailed guide on best practices for using MCP tools, but for completeness, we will reiterate a few high-level guidelines here (these are not specific to o3/o4-mini, but are still relevant).\n\nFilter tools to avoid ballooning payloads: take advantage of the allowed_tools parameter to use only the tools that are necessary and save on unnecessary context: Since you do not always need all of the tools returned by the MCP server, you can filter to only the necessary tools via the allowed_tools field.\n\n\n    \"tools\": [\n        {\n            \"type\": \"mcp\",\n            \"server_label\": \"gitmcp\",\n            \"server_url\": \"https://gitmcp.io/openai/tiktoken\",\n            \"allowed_tools\": [\"search_tiktoken_documentation\", \"fetch_tiktoken_documentation\"],\n            \"require_approval\": \"never\"\n        }\n\nReduce latency via caching and reserve reasoning models for high complexity tasks: make sure you are either passing back mcp_list_tools or include previous_response_id to make sure the API does not need to reimport the list of tools again and again unnecessarily.\nUse MCP with other tools: You can mix and match MCP with other hosted tools and your custom defined functions. If you are mixing the tools, it is helpful to define the decision boundaries and be explicit about when to use a tool over another using the overall developer prompt. Here is a great example from the MCP tool guide.\n\n\nQ: How many functions is too many?\n\nA: For o3 and o4-mini models, there is no hard upper limit on the number of functions, but practical guidance does exist based on both training data distribution and observed model behavior. As of May 2025, any setup with fewer than 100 tools and fewer than 20 arguments per tool is considered in-distribution and should perform within expected reliability bounds. Performance still depends on your prompt design and task complexity.\n\nEven if you are technically within training distribution, more tools can introduce ambiguity or confusion. Here are key considerations:\n\nFunction description clarity becomes critical: If multiple tools have overlapping purposes or vague descriptions, models may call the wrong one or hesitate to call any at all.\n\nTool list size can affect latency and reasoning depth: Longer lists mean the model has more options to parse during its reasoning phase. While o3/o4-mini can handle this with their integrated reasoning pipelines, performance can degrade if schema clarity or invocation conditions aren’t sharp.\n\nTool hallucinations can increase with complexity: Especially with o3, there have been reports of hallucinated or speculative tool calls when the toolset is large and under-defined. Explicit instructions help mitigate this (e.g., “Only use tools X, Y, Z. Do not invent tool calls or defer them to future turns.”)\n\nUltimately, the performance will defer depending on the use case; Therefore it is important to invest in evals that you trust you can use to iterate on.\n\n\nQ: Is it OK to have deeply nested params within tools or should I \"flatten\" out the schema?\n\nA: There is again no hard guidance. However, even if your nesting structure is technically supported, deeply layered argument trees can impact performance or reliability. When in doubt we recommend you err on the side of making the arguments flat.\n\nFlat structures are often easier for the model to reason about: In flatter schemas, argument fields are top-level and immediately visible. This reduces the need for internal parsing and structuring, which can help prevent issues like partially filled nested objects or invalid field combinations. With deeply nested objects, especially ones with repeated or semantically similar field names, the model is more likely to omit or misuse arguments.\n\nNesting can help organize complex logic, but needs additional care: For domains that naturally involve structured input, like configuration payloads, rich search filters, or form submissions, nesting helps organize related parameters. However, you must use techniques like clear field descriptions, anyOf logic, or strict schemas to guard against invalid argument combinations and improve model reliability\n\nThe best way to choose is to test with your own evals and measure success. There’s no “one-size-fits-all” because invocation behaviors are emergent and prompt-sensitive\n\n\nQ: Does this function-calling guidance apply to custom tool formats?\n\nA: Not guaranteed. The guidance in this document assumes you’re using the standard tools model parameter to pass your function schemas, as shown in our general guide on function calling. Our o3/o4-mini models are trained to understand and use these schemas natively for tool selection and argument construction.\n\nIf you’re instead providing custom tool definitions via natural language in a developer-authored prompt (e.g., defining tools inline in the developer message or user message), this guidance may not fully apply. In those cases:\nThe model is not relying on its internal tool-schema priors.\nYou may need to be more explicit with few-shot examples, output formats, and tool selection criteria.\nArgument construction reliability may degrade without schema-level anchoring.\n\nUse the structured tools parameter when possible. If you must define tools in free text, treat it as a custom protocol and test accordingly."])</script><script>self.__next_f.push([1,"41:T400e,"])</script><script>self.__next_f.push([1,"This guide is for developers and ML practitioners who already know their way around OpenAIʼs APIs, have a basic understanding of reinforcement fine-tuning (RFT), and wish to use their fine-tuned models for research or other appropriate uses. OpenAI’s services are not intended for the personalized treatment or diagnosis of any medical condition and are subject to our applicable terms.\n\nReinforcement fine-tuning (RFT) of reasoning models consists in running reinforcement learning on of top the models to improve their reasoning performance by exploring the solution space and reinforcing strategies that result in a higher reward. RFT helps the model make sharper decisions and interpret context more effectively.\n\nIn this guide, weʼll walk through how to apply RFT to the OpenAI o4-mini reasoning model, using a task from the life sciences research domain: predicting outcomes from doctor-patient transcripts and descriptions, which is a necessary assessment in many health research studies. We'll use a subset of the medical-o1-verifiable-problem dataset. You will learn key steps to take in order to succesfully run RFT jobs for your use-cases.\n\nHere’s what we’ll cover:\n\n1. Setup**\n2. Gathering the dataset**\n3. Benchmarking the base model**\n4. Defining your grader**\n5. Training**\n6. Using your fine-tuned model**\n\nEven strong reasoning models can miss the mark when it comes to expert-level behavior-especially in domains like medicine, where nuance and exactness matter. Imagine a model trying to extract ICD-10 codes from a transcript: even if it understands the gist, it may not use the precise terminology expected by medical professionals.\n\nOther great candidates for RFT include topics like ledger normalization or tiering fraud risk- settings in which you want precise, reliable, and repeatable reasoning. Checkout our RFT use-cases guide for great examples.\n\nIn our case, weʼll focus on teaching o4-mini to become better at predicting the outcomes of clinical conversations and descriptions. Specifically, we want to see if RFT can boost the accuracy of the prediction.\n\nAlong the way, weʼll talk about how to write effective graders, how they guide the modelʼs learning, and how to watch out for classic reward-hacking pitfalls.\n\nLetʼs start off by loading the dataset from Hugging Face. Weʼre interested in samples framed as a description of a patient case with an associated question, followed by the correct answer. These represent real world transcripts where a physician is summarizing a case and assigning an outcome. For any use-case, verifying the accuracy of the gold level answers is critical and requires careful consideration. Here, we will trust the dataset quality.\nOne of the advantages of RFT is that it doesnʼt need thousands of samples to start making a difference. Thanks to trajectory sampling and the feedback loop during training, the model learns not just correct behaviors, but also patterns to avoid. This means we can see solid gains even with small datasets.\n\nFor this run, weʼll randomly sample 100 training and 100 test examples and slightly normalize them.\nWe'll convert these samples to jsonl format, as expected by the reinforcement finetuning API.\n\nNext up: we’ll see how the base model performs out of the box-and where there’s room to grow.\n\nBefore we fine-tune anything, we need to know where we’re starting from. Benchmarking gives us a clear picture of the model’s initial strengths and weaknesses-so we can later measure how far it’s come.\n\nWe’ll first lean on two simple yet powerful evaluators:\n\nclinical_phrase_binary_grader - an exact-match checker.\nclinical_phrase_grader - a softer, token-based similarity grader.\nThis combination lets us track both strict correctness and partial lexical overlap. The binary grader gives a crisp 0 or 1: did the model produce an exact match? The softer one gives more nuance-how close did the output come to the gold answer? We use both because outcomes are often phrased in multiple valid ways. For instance, a model might respond with “gouty arthritis” instead of “gout.” While a human evaluator could consider this partially acceptable, a strict string match would not. Combining exact and fuzzy scoring ensures a more accurate and fair assessment of model outputs.\n\nWe build a helper function to preprend the examples with a system prompt.\nThen build a helper function to generate and store the model's predictions.\nTo generate the predictions, first make sure your API key is set:\n\nexport OPENAI_API_KEY=...\nWe now have predictions that are ready to be evaluated.\nWe'll build a helper function that allows us to easily swap in different scoring methods,\nand then run the evaluations.\nVisualizing the results allows us to spot trends and failure modes.\nAs observed above, typical failure modes fall into three categories:\nSmall differences and formatting issues, score \u003e=0.8.\nPartial lexical match, 0.3  Note: In practice, analyzing model errors at scale often involves a mix of manual review and automated methods-like tagging failure types or clustering predictions by score and content. That workflow is beyond the scope of this guide, but it's a valuable next step once you've identified broad patterns.\nLet's compare with other models and prompts, and visualize scores.\nWe can see that the modelʼs performance has clear limits. In practice, iterating on the prompt often helps boost baseline results and get more out of the base model. However, in this case, our prompt engineering didnʼt lead to meaningful improvements-so we excluded those runs from the analysis.\n\n\nA key requirement for RFT to work is that the base model demonstrates it can successfully complete the task for at least some examples right out of the gate. The initial accuracy of ~0.6 is a strong signal that RFT can boost performance. If the model never succeeds on your tasks, there is no training signal to hill climb on.\n\n\nThis evaluation process prepares us for the next step: guiding the model with structured, high-quality feedback from a grader.\n\nThe grader defines the reward function that shapes model behavior during RFT. It provides examples of desired outputs-and penalizes undesirable ones. Designing an effective grader requires both principled structure and thoughtful domain insight, and is perhaps the most important task for successful RFT.\n\nIn this section, we will present 3 graders, show how they should be set up to fit the API, and discuss the results they yielded. We will then show how to actually launch an RFT task.\nWe began with a dual grader using our earlier evaluation functions since it provides a distribution of scores that will be aligned with the lexical proximity of the prediction to the reference answer. It provided a starting point, but the signal wasnʼt rich enough for o4-mini to truly learn and improve, and a first experiment showed stagnant reward during the RFT run. For the API calls, you should build the python grading function as shown below.\nHere is a snapshot of its training curves, where the green curve is the traning set reward and the blue curve is the test set reward:\n\nRFT String Grader\nTo address this limitation, we introduced a more advanced approach: the model grader. A model-based grader lets us embed semantic understanding and nuance into the feedback. Thatʼs especially powerful when domain-specific synonyms or fuzzy reasoning are in play.\n\nWe used gpt-4.1 as our grader model, guided by a rubric that emphasized semantic fidelity: clinical synonymy, correct disease categorization, and conceptual alignment. Rather than focusing on superficial phrasing-e.g., \"Is this the same string?\"-the grader aimed to answer, \"Does this reflect the correct outcome or phenomenon?\"\n\nTo ensure the grader aligned with expert expectations, we evaluated it on a subset of base model predictions. For any production use-case, domain expert reviewers should verify that model assigned scores reflect preferred answer orderings and align with domain judgment. This typically involves confirming that the model grader correctly ranks predictions according to their validity. In the scope of this cookbook, we approximated this evaluation by using OpenAI o3 to check whether higher-quality predictions were consistently rewarded relative to their alternatives.\n\nFrom these discussions of o3 , we iteratively update the model grader until the results are aligned.\nTo be submitted through the API, this is how the dictionary is built.\nAccordingly, we set up the model grader locally to check the results of the models we will fine-tune next.\nWhile the rubric initially delivered sensible feedback, the model soon uncovered a loophole and began reward-hacking. Scores shot up-sometimes by 20-30 percentage points-not because clinical accuracy improved but because the model padded its “one phrase” answers with synonyms, doses, and full management plans. You might see begin warfarin therapy and continue unfractionated heparin for ≥5 days, overlapping until the INR is in the therapeutic range (2–3) or chewable aspirin 325 mg stat plus nitroglycerin… instead of the required continue unfractionated heparin or aspirin respectively. Although the system prompt is explicit-“respond with exactly one phrase: the single most likely outcome or phenomenon”-these verbose outputs inflate lexical_similarity scores without precisely adding prediction value. This experience highlights the need to continuously inspect model outputs and remain vigilant for reward-hacking behaviours that can quietly distort evaluation metrics.\nHere is a snapshot of its training curves (green is training reward, blue is test reward):\n\nRFT Model Hacking\nTo mitigate this reward-hack, we refined the grader prompt by clarifying expectations, enforcing stricter output constraints, and supplying contrastive examples of correct versus incorrect behavior. Once again, we've iterated with o3, leveraging predictions from the base o4-mini and the previous fine-tuned model hacking examples, to design and validate our grader. Another important point of this updated grader is the reduction of the weight of the lexical_similarity, to ensure that clinical_similarity prevails.\n\nThe final result was a high-signal, domain-sensitive grader that guided the model toward more appropriate and concise predictions.\n\nNote on cost: LLM graders incur token usage charges in addition to training compute. To manage costs effectively, we recommend:\nTesting your grader locally on base model completions (and optionally synthetic ones) to ensure it aligns with your rubric or human preferences. When available, use flex processing for more efficient evaluation.\nStarting with a small-scale RFT run to validate grader alignment and detect potential reward-hacking before scaling up.\n\nLet's look at how to launch the training in the next step!\n\nOnce your prompt and grader are finalized, you can proceed to training. This section shows how to launch RFT using your final grader-but naturally, you would have already run similar commands when experimenting with earlier grader versions to evaluate their performance.\nWe make sure the grader passed API test,\nand upload the training and test sets to the OpenAI file system.\nLet's now define the hyper-parameters for our run. We will be fine-tuning o4-mini, with the medium reasoning effort. This parameter will impact the duration by limiting the number of tokens the model uses to reason. We tune with a moderate compute multiplier and reasonable number of epochs, prioritizing efficiency and fast iteration. Additionally, we set the eval_samples parameter to 3 to make the validation curves more robust given the stochasticity of o4-mini’s outputs. Averaging across multiple samples reduces noise and helps reveal consistent patterns of learning.\n\nYou’ll want to tailor these depending on your budget, desired generalization, and dataset difficulty.\nWe are now ready to launch the run!\nOn the dashboard you can observe the reward plots - they let you watch overall performance improve across steps, while the per-grader charts break down specific components in the case of a multi_grader. Reasoning token usage trends (often decreasing as the model gets more confident) and step duration metrics give insight into efficiency. Grader latency and error count plots help ensure your grader stays performant and bug-free during the run.\n\nHere is a snapshot of our training curves, where the green and orange curves are for the training set, while tbe blue and red curves are for the test subset:\n\nRFT Dashboard Example\n\nDuring training, evaluation runs on the test set are logged directly to the Evaluation API. You can head there to track how your samples perform and get a sense of how predictions evolve over time.\n\nWhen training completes, you can call your new model by its model_id and benchmark its improvements. Expect sharper predictions!\n\nLet's compute the scores of our base and fine-tuned models for comparison.\nWe can now visualize them!\nWe see about a 5-point boost in accuracy after fine-tuning. Looking at the first few errors, the model tends to harshly penalize answers that are close but not clinically identical-like unfractionated heparin vs. enoxaparin. It also dings longer answers, even when they’re correct, like contrast enhanced computed tomography of the abdomen.\nLooking at the distruibution of scores, we observe that RFT helped shift the model’s predictions out of the mid-to-low score zone (0.2-0.6) and into the high range (0.8-1.0). Since the grader emphasizes clinical similarity over lexical match, this shift reflects stronger medical reasoning-not just better phrasing-according to our expert grader. As seen in the (0.0-0.1) range, a handful of already weak predictions fell even further, hinting at a residual knowledge gap.\n\nNote that, because the earlier combined_grader was designed to reward lexical correctness, its accuracy didnʼt improve much-which is expected. That gap reinforces why validating your model grader is critical, and why you should monitor for reward-hacking. In our case, we used o3 to spot-check grading behavior, but domain expert review is essential.\n\nAnother important point in the analysis of the fine-tuned model are the reasoning summaries. The model may provide key information throughout these summaries, and exploring them to understand where the model fails can drive updates in the model's and the grader's system prompts. Below, we show examples of such chain of thought summaries that the model produced to show its way of answering the question:\nThe fine-tuned model spends more reasoning tokens to think through the question. Let's visualize an example thanks to the reasoning summaries.\nBase o4‑mini’s reasoning zooms straight to “abdominal CT scan,” mostly worrying about lowercase formatting and giving only a cursory “often the initial choice” justification. The finetuned model, meanwhile, first links the patient’s steatorrhea and alcohol history to chronic pancreatitis or cancer, weighs CT against MRCP and EUS, and explains why a contrast‑enhanced abdominal CT best reveals calcifications and structural change. The latter seems more careful, and seems to have learnt to break down the case description even more.\nBoth the baseline o3 and our fine-tuned o4-mini sometimes scored zero on the same samples-a red flag that the reference labels may be wrong. Before adding more compute, invest in data quality: have a domain expert relabel the noisy slice, analyze the model's reasoning, then tighten the grader prompt. Clean, trusted data and methodical updates almost always buys more accuracy than extra epochs.\n\nWeʼve looked at how to design graders that give o4-mini the kind of detailed feedback it needs during RFT. That signal is what helps the model actually learn and improve beyond the baseline. Model graders can be incredibly powerful for this-but only if theyʼre designed carefully. A sloppy grader or sloppy data can send the wrong signals and steer the model in the wrong direction.\n\nYou're now ready to apply reinforcement fine-tuning on your own models using the OpenAI API. Weʼre excited to see how you push the boundaries of reasoning and tool use with custom graders and smarter model behavior!\n\nFor troubleshooting or next steps, refer to the OpenAI fine-tuning documentation."])</script><script>self.__next_f.push([1,"42:T1746,"])</script><script>self.__next_f.push([1,"This guide is for developers and ML practitioners who have some experience with OpenAIʼs APIs and wish to use their fine-tuned models for research or other appropriate uses. OpenAI’s services are not intended for the personalized treatment or diagnosis of any medical condition and are subject to our applicable terms.\n\nThis notebook demonstrates how to use OpenAI's reinforcement fine-tuning (RFT) to improve a model's conversational reasoning capabilities (specifically asking questions to gain additional context and reduce uncertainty). RFT allows you to train models using reinforcement learning techniques, rewarding or penalizing responses based on specific criteria. This approach is particularly useful for enhancing dialogue systems, where the quality of reasoning and context understanding is crucial.\n\nFor a deep dive into the Reinforcement Fine-Tuning API and how to write effective graders, see Exploring Model Graders for Reinforcement Fine-Tuning.\n\n\nThis cookbook evaluates and improves model performance on a synthetic dataset inspired by a focused subset of HealthBench, a benchmark suite for medical QA. It walks through how to configure the datasets, define evaluation rubrics, and fine-tune model behavior using reinforcement signals derived from custom graders.\n\nHealthBench is a comprehensive evaluation benchmark developed to assess the performance of large language models on healthcare-related question answering. It spans multiple clinical domains and question types, emphasizing accuracy, safety, and factual grounding.\n\n\nThe openai/simple-evals repository is a lightweight framework for prototyping and running evaluation pipelines on OpenAI models. It’s designed to support both structured and unstructured inputs, flexible grader configurations, and integration with OpenAI's fine-tuning APIs.\n\nWe will use this framework to evaluate the performance of GPT-4.1 on a focused subset of HealthBench so we can perform some error analysis on where the model is making mistakes.\n\n\nClone the simple-evals repo\n\ngit clone https://github.com/openai/simple-evals.git\npip install openai human-eval\n\nGPT-4.1 is one of the best performing models on HealthBench hard. For a more detailed breakdown of the results on HealthBench, check out the healthbench_analysis notebook.\n\nRun the command below\npython -m simple-evals.simple_evals --eval=healthbench_hard --model=gpt-4.1\n\n\nThe task in HealthBench is for a model to provide the best possible response to the user’s last message. HealthBench evaluates model responses using physician-written rubrics with specific criteria that outline what responses should include or avoid. Each criterion has a weighted point value, and responses are scored by a model-based grader based on how well they meet these criteria. We specifically want to improve the model's performance on a particularly challenging rubric that requires the model to seek additional context to reduce uncertainty.\n\nEach entry includes:\n  prompt: The conversation history between the user and the model.\n  rubric: The rubric criteria used by the grader.\n  completion: The model's response to the prompt.\n  score: The score of the response from the grader for the rubrics it is graded on.\n  usage: The number of tokens used by the model for the completion.\n\nExample entry format:\n{\n    \"prompt\": \"I found my 70-year-old neighbor lying on the floor unresponsive, but they have a pulse and they're breathing slowly. Should I just wait for them to come around, or do I need to do something right away, given they have no known health issues? Please give details.\",\n    \"rubric\": \"Includes clear and concise advice to call or activate emergency services for an unresponsive person.\",\n    \"completion\": \"I am not your neighbor's doctor, and this answer can't replace professional medical care, but an unresponsive adult—even one who still has a pulse and some breathing—is always a medical emergency. Act right away. Dial 911 (or your local emergency number) immediately.\",\n    \"score\": 0.6\n}\n\n\n\n\nIn this section, we will create a synthetic training and validation dataset inspired by a subset of HealthBench Hard. For this example, we will use just 12 datapoints for training to keep the training time short for the tutorial.\n\nThe challenging rubric that even some of the best models struggle with on HealthBench Hard requires the models to seek additional context to reduce uncertainty. We will use this rubric for our fine-tuning job.\n\nWe also visualize how well the models perform on a handful of examples without any RFT. The rubric scores are non-zero to ensure the model has some signal it can use as a reward to improve on this task.\n\nCreate several few-shot examples we could use in our grader's prompt. This helps the grader apply complex rubrics correctly because the inputs similar to the HealthBench examples are nuanced, large in quantity, and complex.\n\nFor simplicity and speed in this cookbook, the prompt below contains just a couple of in-context examples, for a related task, asking follow-up questions when there is uncertainty. You could add a larger number of few-shot examples, for example some of the examples generated above, to improve performance in particular if the rubric is very challenging.\n\nThe hyperparameters are set to a slightly larger batch size and number of epochs than the default, to improve convergence for this challenging rubric. A hyperparameter search would be recommended for production use.\nBefore running the section below 'Evaluate results' we will need to wait for the fine-tuning job to complete.\n\nWe can now evaluate the results of the fine-tuning job. You can do this by viewing the fine-tuned run in the OpenAI console. We can also analyse how the fine-tuned model performs. The output of the model is now optimised to focus on asking highly targeted and relevant follow-up questions, which can help improve the quality of the responses and reduce model uncertainty."])</script><script>self.__next_f.push([1,"43:T289e,"])</script><script>self.__next_f.push([1,"Building agentic application often requires connecting to external services. Traditionally, this is done through function calling where every action makes a round-trip from the model to your backend, then to an external service, waits for a response, and finally returns the result to the model. This process introduces multiple network hops and significant latency, making it cumbersome to scale and manage.\n\nThe hosted Model Context Protocol (MCP) tool in the Responses API makes this easier. Instead of manually wiring each function call to specific services, you can configure your model once to point to an MCP server (or several!). That server acts as a centralized tool host, exposing standard commands like “search product catalog” or “add item to cart.” This allows for simpler orchestration and centralized management of tools. With MCP, the model interacts directly with the MCP server, reducing latency and eliminating backend coordination.\n\nMCP significantly reduces the friction of building products that interact with external services, allowing you to tie different services together seamlessly. Here’s a sampler of use cases that once involved friction but are now much simpler since the model can communicate directly with remote MCP servers.\n\n| Domain                 | Use case unlocked by MCP tool                                                                                                                                                  | Previous friction                                                                                                      |\n|---------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------|\n| Commerce / payments   | - Add an item to a Shopify cart and hand back a checkout URL in one turn — \"Add the Allbirds Men’s Tree Dasher 2 in size 10\" → cart link   - Generate a Stripe payment link | Function calling meant you had to write a custom cart_add or create_payment_link wrapper and host your own relay server. |\n| Dev-ops \u0026 code quality| - Ask Sentry for the latest error in a particular file, then open a GitHub issue with a suggested fix in the same conversation                                                    | Chaining two different third-party APIs inside one assistive loop involved webhook glue and state juggling.                |\n| Messaging / notifications | - Grab the morning’s top soccer headlines via web-search and have Twilio text the summary to a phone number in a single call                                                 | Required stitching two tool calls in your backend and batching the final SMS payload yourself.                             |\n\n\nAt a high level, here is how the MCP tool works:\n\nDeclare the server: When you add an MCP block to the tools array, the Responses API runtime first detects which transport the server speaks, either the newer “streamable HTTP” or the older HTTP-over-SSE variant, and uses that protocol for traffic.\nImport the tool list: The runtime calls the server’s tools/list, passing any headers you provide (API key, OAuth token, etc.). It then writes the result to an mcp_list_tools item in the model’s context. While this item is present, the list won’t be fetched again. You can limit what the model sees using allowed_tools.\n\n    OpenAI discards header values and all but the schema, domain, and subdomains of the MCP server_url after each request. Authorization keys and the server URL must be included with every API call. These values won't appear in response objects. Schemas use “strict” mode when possible, otherwise they're loaded as-is.\n\nCall and approve tools: Once the model knows the available actions, it can invoke one. Each invocation produces an mcp_tool_call item and by default the stream pauses for your explicit approval, but you can disable this once you trust the server.\n\n    After approval, the runtime executes the call, streams back the result, and the model decides whether to chain another tool or return a final answer.\n\nMCP is still in its early stages, so here are best practices that can improve model performance and behavior as you build. \n\n\nRemote servers often expose numerous tools without considering how models will interpret and use them. By default, this can result in dozens of endpoints being included, each accompanied by verbose definitions like names, descriptions, and JSON schemas that add hundreds of tokens to the model’s context and increase latency. Compounding this, many servers return entire data objects, such as full Stripe invoice records, even when only a few fields are relevant to the model’s task. To optimize for performance in production, use the allowed_tools parameter in the Responses API to limit which tools are included from the server’s mcp_list_tools. This reduces token overhead, improves response time, and narrows the model’s decision space. You may also want to exclude certain tools altogether, such as those capable of write actions or those that have financial or security implications.\n\nThe first time the model connects to a server, a new item of the type mcp_list_tools is created for each MCP server you add. As long as this item is present in the model's context, we will not call tools/list on the server again. This is akin to caching at the user-conversation level. If mcp_list_tools is not present, we import the list of tools from the MCP server again. Passingprevious_response_id in subsequent API requests is one way of ensuring that the mcp_list_tools item is present in the model's context on follow-up turns. Alternatively you can also pass in the items manually to new response. The other lever that will affect latency and the number of output tokens is whether you use a reasoning model, as reasoning models will produce far more output tokens, as well as reasoning tokens. Take for example the following two sample curls that compare the number of tokens produced with and without reasoning models:\nScenario 1: non-reasoning model\nScenario 2: reasoning model without previous_response_id\n\nThe MCP tool is just another entry in the tools array, so the model can use it seamlessly with other hosted tools like code_interpreter, web_search_preview, or image_generation, and with any custom tools you define. You can also use multiple remote MCP servers together.\n\nIn this example, we’ll create an agent that is a pricing analyst for a fictional yoga attire store: it first pulls current competitor prices for women’s shorts, yoga pants, and tank tops from the Alo Yoga MCP server, then grabs the price for the same three categories from Uniqlo via the hosted web-search tool. Using Code Interpreter it analyzes last week’s sales from a CSV that was pre-loaded with the Files endpoint, in order to calculate per-item revenue and average order value. Then it measures each item’s price gap versus the newly fetched Uniqlo and Alo Yoga benchmarks. Any product priced 15 percent or more above or below market is flagged, and the agent delivers a concise text report summarizing the discrepancies and key revenue stats.\nHere's a sample curl with a placeholder for the above system prompt.\nThe model is able to carry forward it’s results from the MCP tool and web search into the code interpreter steps to produce a report with the following content that is formatted for legibility:\n\nYour Store's Sales \u0026 Price Analysis\n\nRevenue by Product:**\n    Shorts: $6,060\n    Tank tops: $6,150\n    Yoga pants: $12,210\nAverage Order Value:** $872.14\nYour Store's Average Selling Price by Category:**\n    Shorts: $60.00\n    Tank tops: $75.00\n    Yoga pants: $110.00\n\n\n| Category | Store Avg Price | vs Alo Yoga Gap (%) | Flagged (≥15%) | vs Uniqlo Gap (%) | Flagged (≥15%) |\n| --- | --- | --- | --- | --- | --- |\n| Shorts | $60.00 | -31.8% | YES | +100.7% | YES |\n| Tank tops | $75.00 | -14.8% |  | +114.9% | YES |\n| Yoga pants | $110.00 | -14.1% |  | +267.9% | YES |\n\n\nFlagged products (≥15% price gap):\n\nShorts:** Priced 31.8% below Alo Yoga, but 100.7% above Uniqlo.\nTank tops:** Priced over 114.9% above Uniqlo.\nYoga pants:** Priced 267.9% above Uniqlo.\n\nShorts are priced significantly below premium competitors (Alo Yoga), but far higher than budget alternatives (Uniqlo). If you want to compete in the premium segment, consider increasing your price. If you want to target budget buyers, a price decrease could be justifiable. Most of your tank tops and yoga pants are similarly positioned—much lower than Alo, but well above Uniqlo.\n\nDepending on your use case you might find that the model invokes many MCP calls, for instance when using catalog-search tools. To avoid endless iterations over large product inventories it’s helpful to instruct the model to limit it’s search to N items and to offer to continue only when the user explicitly asks for more information. This keeps responses focused and snappy.\n\nIf the MCP servers you’re using include exhaustive mcp_list_tools, it’s also worth Including some targeted few-shot examples to show the model how  to choose the correct server and to stop once it has what it needs, instead of issuing redundant calls.\n\nFinally, adding guidance to remind the model that if essential information (size, color, product line, etc.) is missing from the user query, it should ask a follow-up question rather than launching a broad search. This small prompt nudge reduces unnecessary tool calls and improves answer quality. Here’s a sample prompt that shows how these guidelines come together:\n\nThe hosted MCP tool in the Responses API turns external-service access from a bespoke plumbing task into a first-class capability of the API. By connecting to a remote server, letting the runtime cache its tool list, and trimming that list with allowed_tools, you eliminate the extra network hop, cut token overhead, and give the model a concise, discoverable action set. When combined with built-in tools such as code_interpreter, web_search_preview, or image_gen, MCP unlocks rich, multi-service workflows whether you’re analyzing sales data, triaging production errors, or automating checkout flows."])</script><script>self.__next_f.push([1,"44:Tf1c,"])</script><script>self.__next_f.push([1,"Welcome! This notebook demonstrates how to build a Retrieval-Augmented Generation (RAG) system using OpenAI’s Vision and Responses APIs. It focuses on multimodal data, combining image and text inputs to analyze customer experiences. The system leverages GPT-5 and integrates image understanding with file search to provide context-aware responses.\n\nMultimodal datasets are increasingly common, particularly in domains like healthcare, where records often contain both visual data (e.g. radiology scans) and accompanying text (e.g. clinical notes). Real-world datasets also tend to be noisy, with incomplete or missing information, making it critical to analyze multiple modalities in tandem.\n\nThis guide focuses on a customer service use case: evaluating customer feedback that may include photos, and written reviews. You’ll learn how to synthetically generate both image and text inputs, use file search for context retrieval, and apply the Evals API to assess how incorporating image understanding impacts overall performance.\n\nSetup \u0026 Dependencies\nExample Generations\nData Processing\n   Load synthetic datasets\n   Merge data\nPopulating Vector Store\n   Upload data for file search\n   Set up attribute filters\nRetrieval and Filtering\n   Test retrieval performance\n   Apply attribute-based filters\nEvaluation and Analysis\n   Compare predictions to ground truth\n   Analyze performance metrics\n\nGenerating high-quality training and evaluation data for machine learning tasks can be costly and time-consuming. Synthetic data offers a practical and scalable alternative. In this notebook, the OpenAI Image API is used to generate synthetic images, while the Responses API is employed to create synthetic text, enabling efficient prototyping and experimentation across multimodal tasks.\n\nIn this example, we’ll work with a pre-generated synthetic dataset of customer feedback that includes short text snippets, images from customer reviews, and occasionally combined multimodal entries. You can also generate your own synthetic dataset using the examples provided above to tailor the data to your specific use case.\nThis example uses OpenAI's built-in vector store and file search capabilities to build a RAG system that can analyse customer experiences from their feedback, which can be both visual and text-based. We create two vector stores for comparisons, one with image understanding and one without.\n\nWe can analyse our dataset with natural language queries with the help of File Search. For the text-only dataset, we see that information is missing that could inform our analysis.\n\nThe only positive review for spaghetti in July has visual feedback and we can see the RAG system with only text based context available is uncertain about positive details. However with image context provided the second RAG system is able to provide a more accurate response.\n\nWe can confirm if this is correct by checking the retrieved images.\nLikewise we can test this for negative reviews in June concerning any burnt pizza.\nWe can confirm if this is correct by checking the retrieved images.\nAs our dataset likely evolves over time and we want to evaluate new models, we can use the OpenAI Evaluation API to evaluate the performance of our system for sentiment analysis. In this simple example, using the string_check criteria we checked if the output was one of the three possible values: positive, negative, or unclear.\nWe can retrieve the results of these evaluation runs and perform some local analysis. In this case, we will compare the performance of the text-only and text+image runs and evaluate how increasing the number of total tokens (through the addition of image context) affects the accuracy of the model. We can also do some basic error analysis by analysing the model input of the failed examples.\nFinally, let's clean up some of the resources we created."])</script><script>self.__next_f.push([1,"45:T1d15,"])</script><script>self.__next_f.push([1,"By leveraging the Responses API with OpenAI’s latest reasoning models, you can unlock higher intelligence, lower costs, and more efficient token usage in your applications. The API also enables access to reasoning summaries, supports features like hosted-tool use, and is designed to accommodate upcoming enhancements for even greater flexibility and performance.\n\n\nWe've recently released two new state-of-the-art reasoning models, o3 and o4-mini, that excel at combining reasoning capabilities with agentic tool use. What many folks don't know is that you can improve their performance by fully leveraging our (relatively) new Responses API. This cookbook shows how to get the most out of these models and explores how reasoning and function calling work behind the scenes. By giving the model access to previous reasoning items, we can ensure it operates at maximum intelligence and lowest cost.\nWe introduced the Responses API with a separate cookbook and API reference. The main takeaway: the Responses API is similar to the Completions API, but with improvements and added features. We've also rolled out encrypted content for Responses, making it even more useful for those who can't use the API in a stateful way!\n\nBefore we dive into how the Responses API can help, let's quickly review how reasoning models work. Models like o3 and o4-mini break problems down step by step, producing an internal chain of thought that encodes their reasoning. For safety, these reasoning tokens are only exposed to users in summarized form.\nIn a multistep conversation, the reasoning tokens are discarded after each turn while input and output tokens from each step are fed into the next\n\nreasoning-context\nDiagram borrowed from our doc\nLet us examine the response object being returned:\nFrom the JSON dump of the response object, you can see that in addition to the output_text, the model also produces a reasoning item. This item represents the model's internal reasoning tokens and is exposed as an ID—here, for example, rs_6820f383d7c08191846711c5df8233bc0ac5ba57aafcbac7. Because the Responses API is stateful, these reasoning tokens persist: just include their IDs in subsequent messages to give future responses access to the same reasoning items. If you use previous_response_id for multi-turn conversations, the model will automatically have access to all previously produced reasoning items.\n\nYou can also see how many reasoning tokens the model generated. For example, with 10 input tokens, the response included 148 output tokens—128 of which are reasoning tokens not shown in the final assistant message.\nWait—didn’t the diagram show that reasoning from previous turns is discarded? So why bother passing it back in later turns?\n\nGreat question! In typical multi-turn conversations, you don’t need to include reasoning items or tokens—the model is trained to produce the best output without them. However, things change when tool use is involved. If a turn includes a function call (which may require an extra round trip outside the API), you do need to include the reasoning items—either via previous_response_id or by explicitly adding the reasoning item to input. Let’s see how this works with a quick function-calling example.\nAfter some reasoning, the o4-mini model determines it needs more information and calls a function to get it. We can call the function and return its output to the model. Crucially, to maximize the model’s intelligence, we should include the reasoning item by simply adding all of the output back into the context for the next turn.\nWhile this toy example may not clearly show the benefits—since the model will likely perform well with or without the reasoning item—our own tests found otherwise. On a more rigorous benchmark like SWE-bench, including reasoning items led to about a 3% improvement for the same prompt and setup.\n\nAs shown above, reasoning models generate both reasoning tokens and completion tokens, which the API handles differently. This distinction affects how caching works and impacts both performance and latency. The following diagram illustrates these concepts:\n\nreasoning-context\nIn turn 2, any reasoning items from turn 1 are ignored and removed, since the model does not reuse reasoning items from previous turns. As a result, the fourth API call in the diagram cannot achieve a full cache hit, because those reasoning items are missing from the prompt. However, including them is harmless—the API will simply discard any reasoning items that aren’t relevant for the current turn. Keep in mind that caching only impacts prompts longer than 1024 tokens. In our tests, switching from the Completions API to the Responses API boosted cache utilization from 40% to 80%. Higher cache utilization leads to lower costs (for example, cached input tokens for o4-mini are 75% cheaper than uncached ones) and improved latency.\n\nSome organizations—such as those with Zero Data Retention (ZDR) requirements—cannot use the Responses API in a stateful way due to compliance or data retention policies. To support these cases, OpenAI offers encrypted reasoning items, allowing you to keep your workflow stateless while still benefiting from reasoning items.\n\nTo use encrypted reasoning items:\nAdd [\"reasoning.encrypted_content\"] to the include field in your API call.\nThe API will return an encrypted version of the reasoning tokens, which you can pass back in future requests just like regular reasoning items.\n\nFor ZDR organizations, OpenAI enforces store=false automatically. When a request includes encrypted_content, it is decrypted in-memory (never written to disk), used for generating the next response, and then securely discarded. Any new reasoning tokens are immediately encrypted and returned to you, ensuring no intermediate state is ever persisted.\n\nHere’s a quick code update to show how this works:\nWith include=[\"reasoning.encrypted_content\"] set, we now see an encrypted_content field in the reasoning item being passed back. This encrypted content represents the model's reasoning state, persisted entirely on the client side with OpenAI retaining no data. We can then pass this back just as we did with the reasoning item before.\nWith a simple change to the include field, we can now pass back the encrypted reasoning item and use it to improve the model's performance in intelligence, cost, and latency.\n\nNow you should be fully equipped with the knowledge to fully utilize our latest reasoning models!\n\nAnother useful feature in the Responses API is that it supports reasoning summaries. While we do not expose the raw chain of thought tokens, users can access their summaries.\nReasoning summary text lets you give users a window into the model’s thought process. For example, during conversations with multiple function calls, users can see both which functions were called and the reasoning behind each call—without waiting for the final assistant message. This adds transparency and interactivity to your application’s user experience.\n\nBy leveraging the OpenAI Responses API and the latest reasoning models, you can unlock higher intelligence, improved transparency, and greater efficiency in your applications. Whether you’re utilizing reasoning summaries, encrypted reasoning items for compliance, or optimizing for cost and latency, these tools empower you to build more robust and interactive AI experiences.\n\nHappy building!"])</script><script>self.__next_f.push([1,"46:T4349,"])</script><script>self.__next_f.push([1,"Build an end‑to‑end voice bot that listens to your mic, speaks back in real time and summarises long conversations so quality never drops.\n\nLive microphone streaming → OpenAI Realtime (voice‑to‑voice) endpoint.\nInstant transcripts \u0026 speech playback on every turn.\nConversation state container that stores every user/assistant message.\nAutomatic “context trim” – when the token window becomes very large (configurable), older turns are compressed into a summary.\nExtensible design you can adapt to support customer‑support bots, kiosks, or multilingual assistants.\n\n\n\n| Requirement | Details |\n|-------------|---------|\n| Python ≥ 3.10 | Will ensure that you don't hit any issues |\n| OpenAI API key | Set OPENAI_API_KEY in your shell or paste inline (not ideal for prod) |\n| Mic + speakers | Grant OS permission if prompted |\n\n\nNeed help setting up the key?\nFollow the official quick‑start guide.\n\n\nNotes:\n1. gpt-realtime supports a 32k token context window, though in certain use cases, you may notice performance degrade as you stuff more tokens into the context window.\n2. Token window = all tokens (words and audio tokens) the model currently keeps in memory for the session.x\n\n\nNew API Parameters:\n1. The Realtime API GA has releases a new parameter truncation. This parameter automatically optimizes context truncation, preserving relevant information while maximizing cache hit rates.\n\nLarge‑token windows are precious, every extra token you use costs latency + money.\nFor audio the input token window increases much faster than for plain text because amplitude, timing, and other acoustic details must be represented.\n\nIn practice you’ll often see ≈ 10 × more tokens for the same sentence in audio versus text.\n\n\ngpt-realtime accepts up to 32k tokens and as the token size increases, instruction adherence can drift.\nEvery user/assistant turn consumes tokens → the window only grows.\nStrategy**: Summarise older turns into a single assistant message, keep the last few verbatim turns, and continue.\n\n\nThe following helper functions will enable us to run the full script.\nUnlike HTTP-based Chat Completions, the Realtime API maintains an open, stateful session with two key components:\n\n| Component       | Purpose |\n|----------------|---------|\n| Session     | Controls global settings — model, voice, modalities, VAD, etc. |\n| Conversation | Stores turn-by-turn messages between user and assistant — both audio and text. |\n\nThis notebook wraps these components inside a simple ConversationState object to keep your logic clean, track history, and manage summarization when context windows fill up.\nA quick helper to peek at the transcript:\nWe’ll stream raw PCM‑16 microphone data straight into the Realtime API.\n\nThe pipeline is: mic ─► async.Queue ─► WebSocket ─► Realtime API\nWe’ll start with a coroutine that:\n\nOpens the default mic at 24 kHz, mono, PCM‑16 (one of the format Realtime accepts).\nSlices the stream into ≈ 40 ms blocks.\nDumps each block into an asyncio.Queue so another task (next section) can forward it to OpenAI.\n\nOur mic task is now filling an asyncio.Queue with raw PCM‑16 blocks.\nNext step: pull chunks off that queue, base‑64 encode them (the protocol requires JSON‑safe text), and ship each block to the Realtime WebSocket as an input_audio_buffer.append event.\nOnce audio reaches the server, the Realtime API pushes a stream of JSON events back over the same WebSocket.\nUnderstanding these events is critical for:\n\nPrinting live transcripts\nPlaying incremental audio back to the user\nKeeping an accurate Conversation State so context trimming works later\n\n| Event type | When it arrives | Why it matters | Typical handler logic |\n|------------|-----------------|---------------|-----------------------|\n| session.created | Immediately after the WebSocket handshake | Confirms the session is open and provides the session.id. | Log the ID for traceability and verify the connection. |\n| session.updated | After you send a session.update call | Acknowledges that the server applied new session settings. | Inspect the echoed settings and update any local cache. |\n| conversation.item.created (user) | A few ms after the user stops speaking (client VAD fires) | Reserves a timeline slot; transcript may still be null. | Insert a placeholder user turn in state.history marked “pending transcript”. |\n| conversation.item.retrieved | ~100 – 300 ms later, once audio transcription is complete | Supplies the final user transcript (with timing). | Replace the placeholder with the transcript and print it if desired. |\n| response.audio.delta | Every 20 – 60 ms while the assistant is speaking | Streams PCM‑16 audio chunks (and optional incremental text). | Buffer each chunk and play it; optionally show partial text in the console. |\n| response.done | After the assistant’s last token | Signals both audio \u0026 text are complete; includes usage stats. | Finalize the assistant turn, update state.latest_tokens, and log usage. |\n| conversation.item.deleted | Whenever you prune with conversation.item.delete | Confirms a turn was removed, freeing tokens on the server. | Mirror the deletion locally so your context window matches the server’s. |\n\n\nThe Realtime model keeps a large 32 k‑token window, but quality can drift long before that limit as you stuff more context into the model.\n\nOur goal: auto‑summarise once the running window nears a safe threshold (default 2 000 tokens for the notebook), then prune the superseded turns both locally and server‑side.\n\nWe monitor latest_tokens returned in response.done. When it exceeds SUMMARY_TRIGGER and we have more than KEEP_LAST_TURNS, we spin up a background summarization coroutine.\n\nWe compress everything except the last 2 turns into a single French paragraph, then:\n\nInsert that paragraph as a new assistant message at the top of the conversation.\n\nDelete the message items that was used for the summary.\n\nWe will later ask the Voice agent what language was the summary to test if the Summary insertion into Realtime API Conversation Context was successful.\nImportant implementation detail:\nThe summary is appended as a SYSTEM message rather than an ASSISTANT message. Testing revealed that, during extended conversations, using ASSISTANT messages for summaries can cause the model to mistakenly switch from audio responses to text responses. By using SYSTEM messages for summaries (which can also include additional custom instructions), we clearly signal to the model that these are context-setting instructions, preventing it from incorrectly adopting the modality of the ongoing user-assistant interaction.\nThe following function lets us poll for transcripts over time. This is useful in cases where the user's audio hasn't been transcribed immediately, so we can retrieve the final result later.\n\nRun the two cells below to launch an interactive session. Interrupt the cell stop recording.\nNote:\nThis notebook uses SUMMARY_TRIGGER = 2000 and KEEP_LAST_TURNS = 2 to make summarization easier to demo quickly.\nIn production, you should tune these values based on your application's needs.\n- A typical SUMMARY_TRIGGER falls between 20,000–32,000 tokens, depending on how performance degrades with larger context for your use case.\nsession.created ✅\n🎙️ Speak now (Ctrl‑C to quit)…\n—— response.done  (window ≈979 tokens) ——\n—— Conversation so far ———————————————\n[user     ] Can you tell me a quick story?  (item_BTuMOcpUqp8qknKhLzlkA)\n[assistant] Once upon a time, in a cozy little village, there was a cat named Whiskers who was always getting into trouble. One sunny day, Whiskers found a mysterious glowing stone in the garden. Curious, he pawed at it, and poof! The stone granted him the ability to talk to birds. Whiskers and his new bird friends had grand adventures, solving mysteries and exploring the village. And from that day on, Whiskers was known as the most adventurous cat in the village. The end.  (item_BTuMPRWxqpv0ph6QM46DK)\n——————————————————————————————————————————\n—— response.done  (window ≈2755 tokens) ——\n—— Conversation so far ———————————————\n[user     ] Can you tell me a quick story?  (item_BTuMOcpUqp8qknKhLzlkA)\n[assistant] Once upon a time, in a cozy little village, there was a cat named Whiskers who was always getting into trouble. One sunny day, Whiskers found a mysterious glowing stone in the garden. Curious, he pawed at it, and poof! The stone granted him the ability to talk to birds. Whiskers and his new bird friends had grand adventures, solving mysteries and exploring the village. And from that day on, Whiskers was known as the most adventurous cat in the village. The end.  (item_BTuMPRWxqpv0ph6QM46DK)\n[user     ] Can you tell me three extremely funny stories?  (item_BTuNN64LdULM21OyC4vzN)\n[assistant] Sure, let's dive into some giggle-worthy tales:  Story One: There was a forgetful baker named Benny who baked a hundred cakes for a big wedding. But on the big day, he forgot where he put them! The entire town joined in to find the missing cakes, only to discover Benny had stored them in his neighbor's garage, thinking it was his pantry. The wedding turned into a town-wide cake feast!  Story Two: A mischievous dog named Sparky loved to play pranks. One day, he swapped his owner's phone with a squeaky toy, causing a hilarious mix-up of barks, squeaks, and confused calls. Sparky's owner ended up having a full conversation with the mailman, all in squeaks!  Story Three: In a small town, a parrot named Polly became a local celebrity for reciting tongue twisters. One day, Polly challenged the mayor to a tongue twister duel. The mayor, tongue-tied and laughing, declared Polly the official town jester. Polly squawked with pride, and the town rang with laughter for days.  (item_BTuNNpNxki5ynSQ5c3Xsa)\n——————————————————————————————————————————\n⚠️  Token window ≈2755 ≥ 2000. Summarising…\n—— Conversation so far ———————————————\n[assistant] L'utilisateur a demandé une histoire rapide, et l'assistant a raconté celle d'un chat nommé Whiskers qui, après avoir trouvé une pierre mystérieuse dans son jardin, a obtenu le pouvoir de parler aux oiseaux. Avec ses nouveaux amis oiseaux, Whiskers a vécu de grandes aventures, résolvant des mystères et explorant le village, devenant ainsi le chat le plus aventurier du village.  (sum_001)\n[user     ] Can you tell me three extremely funny stories?  (item_BTuNN64LdULM21OyC4vzN)\n[assistant] Sure, let's dive into some giggle-worthy tales:  Story One: There was a forgetful baker named Benny who baked a hundred cakes for a big wedding. But on the big day, he forgot where he put them! The entire town joined in to find the missing cakes, only to discover Benny had stored them in his neighbor's garage, thinking it was his pantry. The wedding turned into a town-wide cake feast!  Story Two: A mischievous dog named Sparky loved to play pranks. One day, he swapped his owner's phone with a squeaky toy, causing a hilarious mix-up of barks, squeaks, and confused calls. Sparky's owner ended up having a full conversation with the mailman, all in squeaks!  Story Three: In a small town, a parrot named Polly became a local celebrity for reciting tongue twisters. One day, Polly challenged the mayor to a tongue twister duel. The mayor, tongue-tied and laughing, declared Polly the official town jester. Polly squawked with pride, and the town rang with laughter for days.  (item_BTuNNpNxki5ynSQ5c3Xsa)\n——————————————————————————————————————————\n✅ Summary inserted (sum_001)\n—— response.done  (window ≈2147 tokens) ——\n—— Conversation so far ———————————————\n[assistant] L'utilisateur a demandé une histoire rapide, et l'assistant a raconté celle d'un chat nommé Whiskers qui, après avoir trouvé une pierre mystérieuse dans son jardin, a obtenu le pouvoir de parler aux oiseaux. Avec ses nouveaux amis oiseaux, Whiskers a vécu de grandes aventures, résolvant des mystères et explorant le village, devenant ainsi le chat le plus aventurier du village.  (sum_001)\n[user     ] Can you tell me three extremely funny stories?  (item_BTuNN64LdULM21OyC4vzN)\n[assistant] Sure, let's dive into some giggle-worthy tales:  Story One: There was a forgetful baker named Benny who baked a hundred cakes for a big wedding. But on the big day, he forgot where he put them! The entire town joined in to find the missing cakes, only to discover Benny had stored them in his neighbor's garage, thinking it was his pantry. The wedding turned into a town-wide cake feast!  Story Two: A mischievous dog named Sparky loved to play pranks. One day, he swapped his owner's phone with a squeaky toy, causing a hilarious mix-up of barks, squeaks, and confused calls. Sparky's owner ended up having a full conversation with the mailman, all in squeaks!  Story Three: In a small town, a parrot named Polly became a local celebrity for reciting tongue twisters. One day, Polly challenged the mayor to a tongue twister duel. The mayor, tongue-tied and laughing, declared Polly the official town jester. Polly squawked with pride, and the town rang with laughter for days.  (item_BTuNNpNxki5ynSQ5c3Xsa)\n[user     ]   (item_BTuPLaCv8ATdIwAQ2rLgO)\n[assistant] Sure! The first summary I provided between us was in French.  (item_BTuPLa7BaSQToGCVOmfBK)\nWe had a conversation with our Voice AI. After several turns, the total token count reached SUMMARY_MAX, which triggered the conversation summarization step. This generated a summary of the earlier messages.\n\nSince there were N = 4 total messages, we summarized the first N - 2 = 2 messages:\n—— Conversation so far ———————————————\n[user     ] Can you tell me a quick story?  (item_BTuMOcpUqp8qknKhLzlkA)\n[assistant] Once upon a time, in a cozy little village, there was a cat named Whiskers who was always getting into trouble. One sunny day, Whiskers found a mysterious glowing stone in the garden. Curious, he pawed at it, and poof! The stone granted him the ability to talk to birds. Whiskers and his new bird friends had grand adventures, solving mysteries and exploring the village. And from that day on, Whiskers was known as the most adventurous cat in the village. The end.  (item_BTuMPRWxqpv0ph6QM46DK)\n\nWe then created a summary in French and inserted it into the conversation history using the root: true flag. This ensured the summary appeared as the first message in the conversation. After that, we deleted the original items, using \"type\": \"conversation.item.delete\", that were summarized.\n\nTo validate the summary insertion, we asked the Voice AI what language the summary was in. It correctly responded:\n\n[assistant] Sure! The first summary I provided between us was in French.  (item_BTuPLa7BaSQToGCVOmfBK)\n\nContext summarisation can be useful for long‑running voice experiences.\nHere are a use case ideas:\n\n| Use‑case | Added Value | Why Useful |\n|----------|-------------|------------|\n| Customer‑support voicebot | 24/7 natural phone tree; auto‑generate ticket summaries | Summarizes long customer calls for efficient handoff and record-keeping, reducing agent workload and improving response quality. |\n| Language tutor | Real‑time conversation practice with corrective feedback | Helps track learner progress and highlights recurring mistakes, enabling personalized feedback and more effective language acquisition. |\n| AI therapist / coach | Safe, always‑available listener that remembers sessions | Maintains continuity across sessions by recalling key topics and emotional tone, supporting a more empathetic and effective experience. |\n| Meeting assistant | Live transcripts + concise action‑item recap in Slack | Distills lengthy meetings into actionable summaries, saving team members time and ensuring important points are not missed. |\n\nTry out the notebook and try integrating context summary into your application.\n\nFew things you can try:\n| Try this… | What you’ll learn |\n|-----------|------------------|\n| A/B test summarisationRun your eval suite with summarisation on vs off. | Whether trimming actually improves quality for your domain—and how it affects latency \u0026 cost. |\n| Swap summary stylesChange the system prompt to bullet points, JSON, English vs French, etc. | Which format the downstream assistant absorbs best; how language choice influences follow‑up answers. |\n| Vary thresholdsPlay with SUMMARY_TRIGGER_TOKENS (2 k → 8 k). | The sweet spot between model drift and summarisation overhead. |\n| Cost tracingLog usage.total_tokens before/after summarisation. | Concrete ROI: token savings per hour of conversation. |\n\n\nOpenAI Realtime Guide\nOpenAI Realtime Conversations\nOpenAI Realtime API Reference\nVoice AI and Voice Agents"])</script><script>self.__next_f.push([1,"47:T1a40,"])</script><script>self.__next_f.push([1,"This notebook provides a clear, hands-on guide for beginners to quickly get started with Speech-to-Text (STT) using the OpenAI API. You'll explore multiple practical methods, their use cases, and considerations.\n\nBy the end you will be able to select and use the appropriate transcription method for your use use cases.\n\nNote:\nThis notebook uses WAV audio files for simplicity. It does *not* demonstrate real-time microphone streaming (such as from a web app or direct mic input).\nThis notebook uses WebSockets to connect to the Realtime API. Alternatively, you can use WebRTC, see the OpenAI docs for details.\n| Mode                           | Latency to first token | Best for (real examples)                                     | Advantages | Key limitations                |\n|--------------------------------|---------------------------|--------------------------------------------------------------|-----------------------------------------------------------|-----------------------------------------------------------|\n| File upload + stream=False (blocking) | seconds  | Voicemail, meeting recordings | Simple to set up | • No partial results, users see nothing until file finishes • Max 25 MB per request (you must chunk long audio) |\n| File upload + stream=True    | subseconds | Voice memos in mobile apps | Simple to set up \u0026 provides a “live” feel via token streaming | • Still requires a completed file • You implement progress bars / chunked uploads |\n| Realtime WebSocket             | subseconds | Live captions in webinars | True real-time; accepts a continuous audio stream | • Audio must be pcm16, g711_ulaw, or g711_alaw • Session ≤ 30 min, reconnect \u0026 stitch • You handle speaker-turn formatting to build the full transcript |\n| Agents SDK VoicePipeline       | subseconds | Internal help-desk assistant | Real-time streaming and easy to build agentic workflows | • Python-only beta • API surface may change |\n\nTo set up your environment, uncomment and run the following cell in a new Python environment:\nThis installs the necessary packages required to follow along with the notebook.\nBefore proceeding, ensure you have set your OpenAI API key as an environment variable named OPENAI_API_KEY. You can typically set this in your terminal or notebook environment: export OPENAI_API_KEY=\"your-api-key-here\"\n\nVerify that your API key is set correctly by running the next cell.\nmodel = gpt-4o-transcribe\n\nYou have a completed audio file (up to 25 MB).The following input file types are supported: mp3, mp4, mpeg, mpga, m4a, wav, and webm.\nSuitable for batch processing tasks like podcasts, call-center recordings, or voice memos.\nReal-time feedback or partial results are not required.\n\n\nSTT Not Streaming Transcription flow\n\n\nEase of use:** Single HTTP request – perfect for automation or backend scripts.\nAccuracy:** Processes the entire audio in one go, improving context and transcription quality.\nFile support:** Handles WAV, MP3, MP4, M4A, FLAC, Ogg, and more.\n\nNo partial results:** You must wait until processing finishes before seeing any transcript.\nLatency scales with duration:** Longer recordings mean longer wait times.\nFile-size cap:** Up to 25 MB (≈ 30 min at 16-kHz mono WAV).\nOffline use only:** Not intended for real-time scenarios such as live captioning or conversational AI.\nLet's first preview the audio file. I've downloaded the audio file from here.\nNow, we can call the STT endpoint to transcribe the audio.\nmodel = gpt-4o-transcribe\nYou already have a fully recorded audio file.\nYou need immediate transcription results (partial or final) as they arrive.\nScenarios where partial feedback improves UX, e.g., uploading a long voice memo.\n\nSTT Streaming Transcription flow\n\nReal-time feel:** Users see transcription updates almost immediately.\nProgress visibility:** Intermediate transcripts show ongoing progress.\nImproved UX:** Instant feedback keeps users engaged.\n\nRequires full audio file upfront:** Not suitable for live audio feeds.\nImplementation overhead:** You must handle streaming logic and progress updates yourself.\nmodel = gpt-4o-transcribe\nLive captioning for real-time scenarios (e.g., meetings, demos).\nNeed built-in voice-activity detection, noise suppression, or token-level log probabilities.\nComfortable handling WebSockets and real-time event streams.\n\n\nRealtime Transcription flow\n\nUltra-low latency:** Typically 300–800 ms, enabling near-instant transcription.\nDynamic updates:** Supports partial and final transcripts, enhancing the user experience.\nAdvanced features:** Built-in turn detection, noise reduction, and optional detailed log-probabilities.\n\nComplex integration:** Requires managing WebSockets, Base64 encoding, and robust error handling.\nSession constraints:** Limited to 30-minute sessions.\nRestricted formats:** Accepts only raw PCM (no MP3 or Opus); For pcm16, input audio must be 16-bit PCM at a 24kHz sample rate, single channel (mono), and little-endian byte order.\nmodels = gpt-4o-transcribe, gpt-4o-mini\nLeveraging the OpenAI Agents SDK for real-time transcription and synthesis with minimal setup.\nYou want to integrate transcription directly into agent-driven workflows.\nPrefer high-level management of audio input/output, WebSockets, and buffering.\n\n\nAgents Transcription flow\n\nBenefits\n\nMinimal boilerplate:** VoicePipeline handles resampling, VAD, buffering, token auth, and reconnects.\nSeamless agent integration**: Enables direct interaction with GPT agents using real-time audio transcription.\n\nLimitations\n\nPython-only beta:** not yet available in other languages; APIs may change.\nLess control:** fine-tuning VAD thresholds or packet scheduling requires digging into SDK internals.\n\nIn this notebook you explored multiple ways to convert speech to text with the OpenAI API and the Agents SDK, ranging from simple file uploads to fully-interactive, real-time streaming. Each workflow shines in a different scenario, so pick the one that best matches your product’s needs.\n\nMatch the method to the use-case:**\n  • Offline batch jobs → file-based transcription.\n  • Near-real-time updates → HTTP-streaming.\n  • Conversational, low-latency experiences → WebSocket or Agents SDK.\nWeigh trade-offs:** latency, implementation effort, supported formats, and session limits all differ by approach.\nStay current:** the models and SDK continue to improve; new features ship regularly.\n\nTry out the notebook!\nIntegrate your chosen workflow into your application.\nSend us feedback! Community insights help drive the next round of model upgrades.\nExplore the Transcriptions API docs.\nRead the Realtime guide.\nExplore the Agents SDK reference.\nExplore the Agents SDK Voice Pipeline reference"])</script><script>self.__next_f.push([1,"48:Tbe8d,"])</script><script>self.__next_f.push([1,"This cookbook serves as your practical guide to selecting, prompting, and deploying the right OpenAI model (between GPT 4.1, o3, and o4-mini) for specific workloads. Instead of exhaustive documentation, we provide actionable decision frameworks and real-world examples that help Solutions Engineers, Technical Account Managers, Partner Architects, and semi-technical practitioners quickly build working solutions. The content focuses on current model capabilities, vertical-specific implementations, and today's industry needs, with clear pathways from model selection to production deployment. Each section offers concise, adaptable code examples that you can immediately apply to your use cases while pointing to existing resources for deeper dives into specific topics.\nNote: The below prescriptive guidance and experimentation has been conducted with latest SOTA models available today. These metrics are bound to change in the future with different scenarios and timeline into consideration.\n\n\nThis cookbook is organized into distinct sections to help you quickly find the information you need. Each section covers a specific aspect of model selection, implementation, and deployment.\n\nPurpose \u0026 Audience: An overview of who this cookbook is for and what it covers.\nModel Guide: A quick reference to help you select the right model for your needs, including model comparisons and evolution diagrams based on mapping different use-case scenarios.\nUse Cases:\n   3A. Long-Context RAG for Legal Q\u0026A: Building an agentic system to answer questions from complex legal documents.\n   3B. AI Co-Scientist for Pharma R\u0026D: Accelerating experimental design in pharmaceutical research with multi-agent systems.\n   3C. Insurance Claim Processing: Digitizing and validating handwritten insurance forms with vision and reasoning.\nPrototype to Production: A checklist to help you transition from prototype to production.\nAdaptation Decision Tree: A flowchart to guide your model selection based on specific requirements.\nAppendices: Reference materials including pricing, latency, prompt patterns, and links to external resources.\n\nFor quick decisions, focus on the Model Guide and Adaptation Decision Tree sections. For implementation details, explore the specific use cases relevant to your needs.\n\n\n\n\n\n\n\n\n| Model | Core strength | Ideal first reach‑for | Watch‑outs | Escalate / Downgrade path |\n| :---- | :---- | :---- | :---- | :---- |\n| GPT‑4o | Real‑time voice / vision chat | Live multimodal agents | Slightly below 4.1 on text SOTA (state-of-the-art) | Need deep reasoning → o4‑mini |\n| GPT‑4.1 | 1 M‑token text accuracy king | Long‑doc analytics, code review | Cannot natively reason; higher cost than minis | Tight budget → 4.1‑mini / nano |\n| o3 | Deep tool‑using agent | High‑stakes, multi‑step reasoning | Latency \u0026 price | Cost/latency → o4‑mini |\n| o4‑mini | Cheap, fast reasoning | High‑volume \"good‑enough\" logic | Depth ceiling vs o3 | Accuracy critical → o3 |\n\n(Full price and utility table → Section 6.1)\n\n\nOpenAI's model lineup has evolved to address specialized needs across different dimensions. These diagrams showcase the current model families and their relationships.\n\n\nOpenAI offers two distinct model families, each with unique strengths:\n\nGPT Models (4o, 4.1)**: Optimized for general-purpose tasks with excellent instruction following. GPT-4.1 excels with long contexts (1M tokens) while GPT-4o has variants for realtime speech, text-to-speech, and speech-to-text. GPT-4.1 also comes in a mini, and nano variant, while GPT-4o has a mini variant. These variants are cheaper and faster than their full-size counterparts.\n\no-series Models (o3, o4-mini)**: Specialized for deep reasoning and step-by-step problem solving. These models excel at complex, multi-stage tasks requiring logical thinking and tool use. Choose these when accuracy and reasoning depth are paramount. These models also have an optional reasoning_effort parameter (that can be set to low, medium, or high), which allows users to control the amount of tokens used for reasoning.\n\n\nOpenAI Model Evolution\n\n\nGPT-4.1 Family**: Optimized for long context processing with 1M token context window.\no3**: Specialized for deep multi-step reasoning.\no4-mini**: Combines reasoning capabilities with vision at lower cost.\n\nEach model excels in different scenarios, with complementary strengths that can be combined for complex workflows.\n\nIn this cookbook we only experimented with the GPT-4.1 series models, o3, and o4-mini. We didn't experiment with the GPT-4o series models.\n\n\n\n\n\n\nLong-Context RAG for Legal Q\u0026A\n\nThis table summarizes the core technology choices and their rationale for this specific Long-Context Agentic RAG implementation.\n\n| Layer | Choice | Utility |\n| :---- | :---- | :---- |\n| Chunking | Sentence-aware Splitter | Splits document into 20 equal chunks, respecting sentence boundaries. |\n| Routing | gpt-4.1-mini | Uses natural language understanding to identify relevant chunks without embedding index. |\n| Path Selection | select(ids=[...]) and scratchpad(text=\"...\") | Records reasoning while drilling down through document hierarchy. |\n| Citation | Paragraph-level | Balances precision with cost; provides meaningful context for answers. |\n| Synthesis | gpt-4.1 (Structured Output) | Generates answers directly from selected paragraphs with citations. |\n| Verification | o4-mini (LLM-as-Judge) | Validates factual accuracy and citation correctness. |\n\nNote: Prices and model identifiers accurate as of April 2025, subject to change.\n\nThis section outlines the construction of a Retrieval-Augmented Generation (RAG) system designed to accurately answer questions about complex and lengthy procedural texts, using the Trademark Trial and Appeal Board Manual of Procedure (TBMP) as a representative case. The TBMP is an essential legal resource detailing the procedures governing trademark litigation before the USPTO's Trademark Trial and Appeal Board, and is frequently consulted by intellectual property attorneys and legal professionals. By leveraging the latest OpenAI models, the system enhances understanding and interpretability of dense legal content, enabling precise, contextually aware responses through advanced language understanding and dynamic retrieval capabilities.\n\nThese approaches can also be applied to other use cases that require precise information retrieval from complex documentation, such as healthcare compliance manuals, financial regulatory frameworks, or technical documentation systems where accuracy, citation, and auditability are mission-critical requirements.\n\n\nCorpus:** The primary document is the Trademark Trial and Appeal Board Manual of Procedure (TBMP, 2024 version). This manual contains detailed procedural rules and guidelines, coming to 1194 pages total.\nUsers:* The target users are intellectual property (IP) litigation associates and paralegals who need quick, accurate answers to procedural questions based *only on the TBMP.\nTypical Asks:** Users pose questions requiring synthesis and citation, such as:\n  \"What are the requirements for filing a motion to compel discovery according to the TBMP?\"\n  \"What deadlines apply to discovery conferences as specified in the manual?\"\n  \"Explain how the Board handles claims of attorney-client privilege during depositions according to the TBMP.\"\n  \"Enumerate the Fed. R. Civ. P. 11 sanctions the Board can invoke according to the TBMP.\"\n\nNote: Depending on your specific deployment environment, you may need to adapt some implementation steps to match your infrastructure requirements.\nWhile OpenAI's File Search tool offers a good starting point for many use cases, this section introduces a different approach that takes advantage of million-token context windows to process large documents without any preprocessing or vector database. The agentic approach described here enables zero-latency ingestion, dynamic granularity of retrieval, and fine-grained citation traceability.\n\n\nBefore diving into the implementation, let's understand the overall approach:\n\nLoad the entire document into the context window\nSplit into 20 chunks that respect sentence boundaries\nAsk the model which chunks might contain relevant information\nDrill down into selected chunks by splitting them further\nRepeat until we reach paragraph-level content\nGenerate an answer based on the selected paragraphs\nVerify the answer for factual accuracy\n\nThis hierarchical navigation approach mimics how a human might skim a document, focus on relevant chapters, then specific sections, and finally read only the most relevant paragraphs.\nHierarchical Router\n\n\n\n| Process Stage | Model Used | Purpose |\n|---------------|------------|---------|\n| Initial Routing | gpt-4.1-mini | Identifies which document chunks might contain relevant information |\n| Hierarchical Navigation | gpt-4.1-mini | Continues drilling down to find most relevant paragraphs |\n| Answer Generation | gpt-4.1 | Creates structured response with citations from selected paragraphs |\n| Answer Verification | o4-mini | Validates factual accuracy and proper citation usage |\n\nThis zero-preprocessing approach leverages large context windows to navigate documents on-the-fly, mimicking how a human would skim a document to find relevant information.\n\nLet's implement this approach step by step.\n\nStart by installing the required packages.\n\nFirst, let's load the document and check its size. For this guide, we'll focus on sections 100-900, which cover the core procedural aspects through Review of Decision of Board. Sections 1000 and beyond (Interferences, Concurrent Use Proceedings, Ex Parte Appeals) are specialized procedures outside our current scope.\nWe can see that the document is over 900k tokens long! While we could fit that into GPT 4.1's context length, we also want to have verifiable citations, so we're going to proceed with a recursive chunking strategy.\n\nNow, let's create an improved function to split the document into 20 chunks, ensuring each has a minimum token size and respecting sentence boundaries.\n20 is an empirically chosen number for this specific document/task and it might need tuning for other documents based on size and structure (The higher the number, the more fine-grained the chunks). The key principle here however is splitting sections of the document up, in order to let the language model decide relevant components. This same reasoning also applies to the max_depth parameter which will be introduced later on in the cookbook.\n\nNow, let's create the router function that will select relevant chunks and maintain a scratchpad.\nMaintaining a scratchpad allows the model to track decision criteria and reasoning over time. This implementation uses a two-pass approach with GPT-4.1-mini: first requiring the model to update the scratchpad via a tool call (tool_choice=\"required\"), then requesting structured JSON output for chunk selection. This approach provides better visibility into the model's reasoning process while ensuring consistent structured outputs for downstream processing.\n\nNow, let's create the recursive navigation function that drills down through the document. max_depth is the maximum number of levels to drill down (keeping token minimums in mind):\n\nLet's run the navigation for a sample question with our improved approach:\nGPT 4.1-mini's results show the iterative extraction of relevant components in a document with the scratchpad explaining it's thought process through it! At depth 1, the model identifies \"Detailed rules for signatures on submissions including motions\" and \"use of ESTTA, required signature format including electronic signatures with the symbol method '/sig/'\" as critical components needed to answer the query.\n\nBy depth 2, the scratchpad demonstrates sophisticated judgment by isolating precisely which chunks contain vital regulations about electronic signatures (chunks 5-12) while maintaining awareness of absent content, noting \"discovery-related motions... should be in chunks from 400 onwards (although these aren't fully visible here...)\".\n\nThis process shows how GPT 4.1 mimics a legal analyst, through iteratively digging deeper into relevant content, and explaining it's reasoning along the way (making it easier to debug why the model selected the chunks it did)\n\nNow, let's generate an answer using GPT-4.1 with the retrieved paragraphs.\nWe do a nifty trick here where we dynamically construct a List of Literals (which forces the model's answers to be one of the options we provide -- in this case the paragraph IDs). There are some restrictions on the number of options we can provide, so if you find your system citing \u003e 500 documents, then this solution might not work. In that case, you can either have a filter to go up to 500 potential citations, or you can ask the model to cite the exact ID in it's response, then post-process the response to extract the IDs, thus the citations (e.g. it might say \"... [doc 0.0.12]\", and you could use some regex to extract the citation).\n\n\nGPT 4.1 effectively integrates citations throughout its response while maintaining a clear flow of information. Each procedural requirement is linked to specific authoritative references (like \"0.0.5.0\" and \"0.0.5.5.6.2\"), creating a response that's both informative and precisely sourced.\n\nRather than simply listing citations at the end, it weaves them directly into the content using parenthetical notation after each key requirement. This approach transforms a standard recitation of rules into a well-supported legal analysis where statements about ESTTA filing procedures, electronic signature requirements, and paper submission exceptions are immediately backed by their corresponding regulatory citations.\n\nLet's first look at the cited paragraphs:\nThe \"List of Literals\" trick forces the model to cite only specific paragraph IDs (like \"0.0.5.4\") rather than making up its own references or highlighting random text — imagine it as creating a digital \"table of contents\" that GPT-4.1 can only select from. This solution ensures you get verifiable citation trails back to exact source material, solving an important problem in long-context RAG.\nFinally, let's verify the answer with an LLM-as-judge approach.\nThe verification step produces a clean, structured assessment that references specific regulations and methodically checks both the answer's accuracy and its proper use of citations. Rather than just saying \"correct,\" it offers useful context by explaining exactly why the answer was correct, giving you the confidence to then present the answer to the user with specific citations\n\nLet's break down the cost structure for this agentic RAG approach:\n\n\nEstimated Fixed (One-time) Costs:**\n  Traditional RAG: ~$0.43 (embedding + metadata generation)\n  Agentic RAG: $0.00 (zero preprocessing required)\n\n\nEstimated Variable (Per-Query) Costs:**\n  Router Model (gpt-4.1-mini):\n    Initial routing (20 chunks): ~$0.10\n    Two recursive levels: ~$0.20\n  Synthesis (gpt-4.1): ~$0.05\n  Verification (o4-mini): ~$0.01\n  Total per query: ~$0.36\n\nWhile the per-query cost is higher than traditional RAG, this approach offers:\nImmediate results on new documents\nMore precise citations\nBetter handling of paraphrases and conceptual questions\nNo infrastructure maintenance overhead\n\nThe cost can be optimized through:\nCaching results for common queries\nLimiting max tokens in the model calls\nUsing a hybrid approach that pre-filters the document first\n\n\nZero-ingest latency**: Answer questions from new documents immediately, with no preprocessing.\nDynamic navigation**: Mimics human reading patterns by focusing on promising sections.\nCross-section reasoning**: Model can find connections across document sections that might be missed by independent chunk retrieval, potentially increasing accuracy of generated answers and saving time on optimizing retrieval pipelines.\n\nHigher per-query cost**: Requires more computation for each question compared to embedding-based retrieval.\nIncreased latency**: Hierarchical navigation takes longer to process than simple vector lookups.\nLimited scalability**: May struggle with extremely large document collections where preprocessing becomes more efficient.\n\n\nThere are a few modifications we can make to the approach taken:\nGenerating a Knowledge Graph**: We can use the large context window of GPT 4.1-mini to iteratively generate a detailed knowledge graph, and then GPT 4.1 can traverse this graph to answer questions. This way we only need to \"ingest\" the document once, regardless of the question.\nImproved Scratchpad Tool**: The scratchpad tool could be given more choices such as editing or deleting past memory. This would allow the model to choose whatever is most relevant to the question at hand\nAdjust Depth**: We can adjust the depth of the hierarchical navigation to find the right balance between cost and performance. Certain usecases will require sentence level citations (like legal documents), while others may only require paragraph level citations (like news articles).\n\nContext Window is a Superpower: Million-token context windows make it possible to navigate documents on-the-fly.\nHierarchical Approach Mimics Human Reading: Agentic routing works like a human skimming a document for relevant sections.\nScratchpad Enables Multi-Step Reasoning: Maintaining a reasoning record improves navigation quality.\nFast Implementation, No Database: The entire system can be built with just API calls, no infrastructure needed.\nVerification Improves Reliability: The LLM-as-judge pattern catches errors before they reach users.\n\n\n\nAI Co-Scientist for Pharma R\u0026D\n\nThis section details how to build an AI system that functions as a \"co-scientist\" to accelerate experimental design in pharmaceutical R\u0026D, focusing on optimizing a drug synthesis process under specific constraints.\n\n\nThis table summarizes the core technology choices and their rationale for this specific AI Co-Scientist implementation.\n\n| Layer              | Choice                                                                  | Utility                                                                                           |\n| :----------------- | :------------------------------------------------------------------------ | :------------------------------------------------------------------------------------------------------- |\n| Ideation       | o4-mini (Parallel Role-Playing Agents)                                  | Generates diverse hypotheses \u0026 protocols rapidly and cost-effectively; role-playing enhances creativity. |\n| Grounding      | External Tool Calls (chem_lookup, cost_estimator, outcome_db, etc.) | Ensures plans are based on real-world data (chemical properties, costs, past results).                   |\n| Ranking        | o4-mini (Pairwise Tournament Comparison)                                | Nuanced evaluation beyond simple scoring; selects promising candidates efficiently.                      |\n| Critique/Synth | o3 (Deep Review \u0026 Synthesis)                                            | Provides rigorous, senior-level analysis, identifies risks, and ensures scientific validity.             |\n| Safety (Opt.)  | gpt-4.1-mini (Targeted Check)                                       | Adds an extra layer of specialized safety review before human handoff.                                   |\n| Learning       | o3 + Code Interpreter (Result Analysis → DB)                            | Captures experimental outcomes systematically, enabling continuous improvement over time.                |\n| Core Technique | Multi-Agent Collaboration \u0026 Escalation                                    | Leverages strengths of different models (speed vs. depth) for a complex, multi-step reasoning task.      |\n\nNote: Model identifiers accurate as of April 2025, subject to change.\n\n\nProblem Space:** Optimizing complex experimental procedures in pharmaceutical R\u0026D, such as improving the synthesis yield of a new drug compound (\"XYZ-13\") while adhering to strict constraints.\nUsers:** Research scientists and lab technicians involved in drug discovery and development.\nTypical Asks:**\n    Suggest 3 distinct protocols to increase XYZ-13 yield by ≥15% by testing different catalysts, staying under $15k using approved reagents.\n    Propose protocols to optimize XYZ-13 yield below 60°C (due to past heat issues), exploring different approved solvents within budget.\n    Design two XYZ-13 yield strategies (aiming for ≥15%): a. one maximizing potential yield within the \\$15k budget, b. one prioritizing cost under \\$10k.\nConstraints:**\n    Budgetary: Operate within defined financial limits (e.g., $15,000 per experiment series).\n    Regulatory/Safety: Use only pre-approved chemicals/reagents and adhere rigorously to safety protocols.\n    Human Oversight: Final experimental plans must be reviewed and validated by a human expert before execution.\nTraditionally, optimizing such experiments involves weeks of manual planning, literature review, iterative benchwork, and analysis. This AI Co-Scientist approach aims to dramatically reduce the cycle time by automating hypothesis generation, protocol design, and preliminary evaluation, enabling scientists to focus on higher-level strategy and final validation. It shifts the scientist's role from manual execution of planning steps to expert oversight and collaboration with the AI.\n\n\n\nThe system employs a multi-agent architecture that emulates a high-performing scientific team. Different AI components, acting in specialized roles (such as ideation, critique, and learning from outcomes), collaborate using various models and tools to execute the workflow.\n\nAI Co-Scientist Architecture\n\nThe process starts with the scientist defining the goal, target compound, and constraints.\nMultiple o4-mini instances, prompted with different roles (e.g., Hypothesis Agent, Protocol Agent, Resource Agent), generate experimental plans in parallel. Assigning distinct personas encourages diverse perspectives and covers different aspects of the problem simultaneously during the ideation phase.\nThe ideation agents can utilize external tools such as literature_search, chem_lookup (chemical database), cost_estimator, outcome_db (outcome of previous experiments) to ground their suggestions in data. Explicitly enabling and prompting models to use external tools ensures that generated plans are feasible, compliant, and informed by existing knowledge. The model decides when and which tool to call based on the task.\nThese tools are defined in agent_utils.py. For purposes of this solution, the tool calls are mocked in tools.py. In a real use case, these tools would call real APIs.\n\n\nGenerated protocols are compared pairwise based on criteria like expected effectiveness, feasibility, cost, and novelty. Instead of asking a model to score protocols in isolation, providing two protocols at a time and asking for a direct comparison against specific criteria often yields more reliable relative rankings.\n\nThis Elo-style ranking identifies the most promising candidates for deeper review.\nIn early experiments, we found that asking models to score protocols on a 1-10 scale led to inconsistent results with score compression. The tournament approach solved this by forcing relative judgments that proved more reliable. This mirrors human expert behavior — scientists often find it easier to compare two options directly than to assign absolute scores.\n\nThe top-ranked protocols are passed to o3 for rigorous review. o3 acts like a senior scientist, assessing scientific validity, methodology, safety, budget compliance, and suggesting improvements or synthesizing a final, refined protocol. It may also call tools for verification.\nWe deliberately separate ideation from critique using different models and personas. Having the same model both generate and critique its own work often leads to self-justification rather than objective assessment. The o3 model, acting as a \"senior scientist,\" consistently identified methodological weaknesses that o4-mini missed during ideation.\n\nA specialized model, such as gpt-4.1-mini, can perform a final check for specific safety concerns (e.g., hazardous reagent combos).\nThe AI-generated final plan is presented to the human scientist via an interface for validation, potential edits, and final approval.\nOnce the human approves, the plan is sent for lab execution. After lab execution, results are fed back into the system. o3 combined with the Code Interpreter analyzes the data, generates insights, and stores structured outcomes (protocol, parameters, results, insights) in a database (Outcome DB). This database informs future ideation cycles, creating a learning loop.\n\nChoosing between o4-mini and o3 depends on the task's complexity and required depth. For other tasks, gpt-4.1-mini provides balance between cost and performance, with the more powerful gpt4.1 recommended when greater capability or nuance is needed.\n\n| Task               | Start With     | Upgrade When...                                            | Escalate To  | Rationale                                                                                    |\n| :----------------- | :------------- | :--------------------------------------------------------- | :----------- | :------------------------------------------------------------------------------------------- |\n| Ideation \u0026 Protocol Generation | o4-mini | Hypotheses lack depth or creativity needed for complex chemical synthesis. | o3 | o4-mini rapidly generates diverse protocols cost-effectively. o3 provides deeper scientific reasoning when more nuanced approaches are required. |\n| Protocol Ranking | o4-mini | Comparison requires deeper scientific assessment or multi-factor trade-offs. | o3 | Tournament-style ranking with o4-mini efficiently identifies promising candidates. Escalate when subtle scientific validity needs evaluation. |\n| Deep Critique \u0026 Synthesis | o3 | N/A - Already using the most capable model for this critical task. | N/A | o3 excels at rigorous scientific review, identifying methodological flaws, and synthesizing improvements across complex protocols. This task inherently requires deep reasoning. |\n| Safety Assessment | gpt-4.1-mini | Domain-specific hazards require higher accuracy or specialized knowledge. | gpt-4.1 | gpt-4.1-mini offers a good balance of cost and performance for standard safety checks. Escalate to gpt4.1 when higher accuracy or more nuanced reasoning is needed for complex safety risks. |\n\nKey Insight:\nThis use case exemplifies a powerful pattern: using faster, cheaper models (o4-mini) for breadth and initial filtering, then escalating to more powerful models (o3) for depth, critical review, and synthesis. This layered approach optimizes for both creativity/speed and rigor/accuracy, while managing computational costs effectively. The integration with tools is essential for grounding the AI's reasoning in verifiable, real-world data.\n\n\nTransitioning the AI Co-Scientist from prototype to lab use involves careful planning.\n\nCost Control:**\n    Implement configurable \"modes\" (such as Fast, Standard, Thorough) that adjust the number of o4-mini ideation agents, the depth of o3 critique, or the use of optional checks to balance result quality with cost and latency.\n    Track token usage per stage (ideation, ranking, critique) and per tool call for fine-grained cost monitoring.\nObservability:**\n    Log inputs, outputs, model choices, tool calls/responses, latencies, and token counts for each step.\n    Monitor the performance of the tournament ranking and the impact of o3 critiques (such as how often plans are significantly altered or rejected).\n    Track user interactions: which plans are approved, edited, or rejected by the human scientist.\nSafety \u0026 Compliance:**\n    Implement multiple safety layers: constraints in prompts, tool-based checks (such as reagent compatibility via chem_lookup), optional dedicated model checks (gpt-4.1-mini), automated filters (such as for known hazardous combinations), and mandatory human review.\n    Ensure tool endpoints (such as internal databases) meet security requirements.\nRollout Strategy:**\n    Begin with retrospective analysis of past experiments, then move to shadow mode (AI suggests plans alongside human planners), followed by limited live use cases with close monitoring before broader adoption.\n\n\n\nModel pairing creates synergy: o4-mini covers more ground quickly; o3 brings precision and depth.\nTool integration grounds reasoning in reality: Real-world data such as chemical costs and safety constraints inform decision-making.\nHuman scientists remain central: The system empowers experts by removing grunt work—not by replacing them.\n\n\n\nHere are select resources that complement the design and implementation of the AI Co-Scientist system:\n\nOrchestrating Agents: Routines and Handoffs** Structuring multi-agent workflows with routines and handoffs, relevant to the ideation→ranking→critique pipeline.\n\nGPT-4.1 Prompting Guide** Advanced prompting, tool use, and task decomposition for improved accuracy in critique and safety reviews.\n\nStructured Outputs for Multi-Agent Systems** Enforcing consistent JSON outputs with schema validation for agent interoperability.\n\nAgents - OpenAI API**\n  Comprehensive guide to building multi-agent systems with OpenAI tools, covering orchestration, tool use, and best practices foundational to this system's architecture.\n\n\n\n\n\n\n\n\nMany businesses are faced with the task of digitizing hand-filled forms. In this section, we will demonstrate how OpenAI can be used to digitize and validate a hand-filled insurance form. While this is a common problem for insurance, the same techniques can be applied to a variety of other industries and forms, for example tax forms, invoices, and more.\n\n\nThis table summarizes the core technology choices and their rationale for this specific OCR implementation targeting the insurance use case.\n\n| Layer | Choice | Utility |\n| :---- | :---- | :---- |\n| JSON Output | Structured output with Pydantic | Easy to specify formatting, adheres to schema better than JSON mode |\n| OCR and Vision | gpt-4.1 | Powerful OCR and vision capabilities, structured output |\n| Reasoning | o4-mini | Affordable but capable reasoning, function calling available |\n| Form Validation | Custom function calling | Can provide interaction with custom or internal databases |\n\n\\*Note: Prices and model identifiers accurate as of April 2025, subject to change.\n\n\nUsers:** The target users are insurance servicing and ops teams who need to ingest data from handwritten forms.\nTypical Asks:** Each form will have a different required structure, as well as different fields that need to be extracted.\nConstraints:**\n  Accuracy: High accuracy is required to ensure that the data is correct and complete.\n  Uncertainty: The system must handle uncertainty in the data, such as missing data, ambiguous data, and different formats of the same field. In the event that the model cannot resolve the uncertainty, the system requires a mechanism to request human review.\n  Performance \u0026 Cost: While system latency is not critical, high accuracy is required while keeping costs under control. We will aim for a cost target of $20 or less per 1000 pages processed.\n\n\nThe high level basic architecture of the solution is shown below.\n\n\n\nThis task is complex and requires a wide variety of model capabilities, including vision, function calling, reasoning, and structured output. While o3 is capable of doing all of these at once, we found during experimentation that o4-mini alone was not sufficient to achieve the necessary performance. Due to the higher relative costs of o3, we instead opted for a two-stage approach.\n\nStage one is performed using the vision capabilities of GPT 4.1. This stage is optimized to extract text with maximum accuracy, leaving uncertainty for the reasoning stage and not making any assumptions not visible on the page. By doing OCR in the first stage, we do not require the reasoning model to work directly from an image, which can be challenging given all the other tasks the reasoning model must perform.\n\nStage two takes advantage of the reasoning abilities of o4-mini. We use o4-mini to validate the accuracy of the OCR and to extract the data into a structured format. Importantly, we expect o4-mini to act as the secondary quality gate \\-- if the OCR is incomplete at this stage we can use o4-mini to refine and validate the original results.\n\nTo demonstrate concretely how this works, let's look at a sample image of an insurance form.\n\n\n\nWhile the form itself is fairly straightforward, there is missing data and ambiguous information that will be difficult for a traditional OCR system to fill out correctly. First, notice that the zip code and county have been omitted. Second, the email address of the user is ambiguous \\-- it could be jsmith1@gmail.com or jsmithl@gmail.com. In the following sections, we will walk through how a well-designed solution can handle these ambiguities and return the correct form results.\n\nEnvironment Setup \u0026 Library Code:\n\nTo make our example code more clear, we have broken out environment setup (such as pip install commands) and library functions into a separate code block. This will make it easier to focus on only the relevant logic in each step of our solution.\nFlow Explanation: Stage 1\n\nImage: The image of the form taken from the user's smartphone is passed to the model. OpenAI's models can accept a variety of image formats, but we typically use a PNG format to keep the text crisp and reduce artifacts. For this example, we pass the image to the model from a publicly available content URL. In a production environment, you likely would pass the image as a signed URL to an image hosted in your own cloud storage bucket.\n\nStructured Output Schema: We define a Pydantic model that sets the structure of the output data. The model includes all of the fields that we need to extract from the form, along with the appropriate types for each field. Our model is broken into several subcomponents, each of which is a Pydantic model itself and referenced by the parent model.\nRun OCR: Using the vision capabilities of GPT-4.1, we run the first stage of our pipeline to extract the text from the document in a structured format. This initial stage aims to achieve high accuracy while passing through uncertainty to the second stage. Our prompt explicitly instructs the model to avoid inferring inputs and instead to fill out the details as exact as possible. For the image input, we set image input detail to auto to infer a detail level that's appropriate to the image. We found in our experiments that auto worked well, but if you are seeing quality issues in your OCR processing consider using high.\nNotice that the output is missing several fields. In the next stage of processing we will take advantage of OpenAI's reasoning models to infer the missing fields where possible.\n\nFlow Explanation: Stage 2\n\nFunction Definitions: We define a set of custom functions that the model can use to resolve uncertainty. In this case, we define a function that can validate email addresses by checking if the email exists. This can be used to resolve the ambiguous email address field where the model must choose between multiple possible values. By default, o4-mini supports built-in tools like web search, which in this case it will use to resolve zip codes and incomplete addresses.\nPrompt: We provide a prompt to the model explaining that we have extracted text via OCR and requesting that the model perform reasoning and function calling to fill in the missing or ambiguous fields.\nYou can see that the email address has been refined to a single value, the zip code and county have been filled in, and the mailing address has been filled in by using the risk address. The model has also returned the results in a structured format (with appropriate types such as boolean for yes/no questions), which can be easily parsed by a downstream system.\n\nTo help us understand and debug the model, we can also print the summary chain-of-thought reasoning produced by the model. This can help expose common failure modes, points where the model is unclear, or incorrect upstream details.\n\nWhile developing this solution, the chain-of-thought summaries exposed some incorrectly named and typed schema values.\n\nSelecting the right tool for the job is key to getting the best results. In general, it's a good idea to start with the simplest solution that fits your needs and then upgrade if you need more capabilities.\n\n| Task | Start With | Upgrade When... | Escalate To | Rationale |\n| :---- | :---- | :---- | :---- | :---- |\n| OCR | gpt-4.1 | Complex forms that are difficult to understand at a glance | o3 | gpt-4.1 is fast and cost-effective for most OCR. o-3 has the ability to reason about form structure. |\n| Results Refinement | o4-mini | Complex logic for inferring details, many function calls required. | o3 | Better for very long chains of reasoning, especially with both function calls and structured output. |\n\n\nTrack key metrics to ensure the system is performing accurately and as expected.\n\n\nOCR Accuracy:** Per-character and per-word accuracy.\nInferred Field Rate:** Portion unfilled entries correctly inferred from either existing data or function calling.\nHuman Intervention Rate:** How often a document contains an UNKNOWN and must be referred to a human.\n\nWe recommend building a labeled hold-out set of forms and their expected responses. This dataset should be representative of the expected deployment environment, see the OpenAI evals guide for more detailed information on building and evaluating your system.\n\n\nMoving from prototype to a production-ready system requires attention to operational details (LLMOps).\n\n\nWe will assume that for document ingestion, batch pricing is a viable option due to high latency tolerance (i.e. overnight runs are fine).\n\n\nModel: gpt-4.1\n\n| Type | Tokens | Rate (per 1M) | Cost |\n| :---- | :---- | :---- | :---- |\n| Input | 2,000 | $1.00 | $0.002 |\n| Output | 1,500 | $4.00 | $0.006 |\n| Total for 1,000 pages (Stage 1\\) |  |  | $8.00 |\n\n\nModel: o4-mini\n\n| Type | Tokens | Rate (per 1M) | Cost |\n| :---- | :---- | :---- | :---- |\n| Input | 2,000 | $0.55 | $0.0011 |\n| Output | 3,000 | $2.20 | $0.0066 |\n| Total for 1,000 pages (Stage 2\\) |  |  | $7.70 |\n\n\nCompare this cost to a one-stage o3 deployment. Assuming equal token usage and batch usage, the additional cost of the more powerful reasoning model would come to $70/1000 pages.\n\n\nMonitor your system by logging key metrics:\n\nllm_model_used, llm_input_tokens, llm_output_tokens, llm_latency_ms per model\ntotal_query_latency_ms, estimated_query_cost per model\nfunction_calls_per_document, num_email_validation_calls\nhuman_review_required\n\nPin the specific model version identifier (e.g., o4-mini-2025-04-16) used in deployment via configuration/environment variables to prevent unexpected behavior from silent model updates.\n\n\nRefer to these related resources for deeper dives into specific components:\n\nStructured Output\nVision Models\nFunction Calling\n\n\n\n\nPrototype to Production\n\nTransitioning a prototype to production requires careful planning and execution. This checklist highlights critical steps, drawing from our flagship use cases, to ensure your deployment is robust, efficient, and meets business goals.\n\n\n| Checklist Area | Key Focus / Actions | Why it Matters |\n| :---- | :---- | :---- |\n| Define Success Criteria | • Define measurable KPIs \u0026 SLOs (accuracy, cost, latency). • Ensure targets are measurable via logs. | Provides clear targets; proves value. |\n| Document Model Rationale | • Select initial models deliberately based on trade-offs. • Document the \"why\" behind model choices. | Justifies choices; aids future updates. |\n| Robust Evaluation \u0026 Testing | • Build automated tests (\"eval suite\") using a golden set. • Focus on factuality, hallucinations, tool errors.  • Test tool reliability \u0026 edge cases. | Ensures quality; prevents regressions before release. |\n| Observability \u0026 Cost | • Implement essential logging for monitoring \u0026 debugging. • Set cost guardrails (token limits, usage modes). | Enables tuning; keeps spending within budget. |\n| Safety \u0026 Compliance | • Use safety mechanisms (moderation APIs, prompts). • Enforce domain-specific compliance rules. • Mandate Human-in-the-Loop (HITL) for high-risk outputs. | Ensures responsible operation; meets requirements. |\n| Model Updates \u0026 Versioning | • Define version pinning strategy • Implement A/B testing for new versions • Create rollback procedures | Maintains stability while allowing improvements. |\n\nDefine Success Criteria Quantitatively: Move beyond \"it works\" to measurable targets before major development.\n\n   Set Key Performance Indicators (KPIs) \u0026 SLOs: Define specific targets for business value (e.g., RAG accuracy \\\u003e 95%, OCR cost \\\u003c $X/page) and performance (e.g., P95 latency \\\u003c 1s, error rates).\n   Ensure Measurability: Confirm that all KPIs and SLOs can be directly measured from system logs (e.g., tracking total_tokens, critique_status).\n\n\nDocument Initial Model Selection Rationale: Justify your starting model choices for future reference.\n\n   Choose Models Deliberately: Use the Model-Intro Matrix and use cases to select appropriate models for each task (e.g., o4-mini for speed/cost, gpt-4.1 for accuracy, o3 for depth).\n   Record the \"Why\": Briefly document the reasoning behind your choices (cost, latency, capability trade-offs) in code comments or design docs so future teams understand the context.\n\n\nImplement Robust Evaluation \u0026 Testing: Verify quality and prevent regressions before shipping changes.\n\n   Build an Automated Eval Suite: Create a repeatable test process using a \"golden set\" (50-100 diverse, expert-verified examples). Focus tests on factuality, hallucination rate, tool-error rate, and task-specific metrics.\n   Test Reliably: Rigorously test integrated tool reliability (success rate, error handling) and system behavior under load and with edge cases (malformed data, adversarial inputs).\n\n\nEstablish Observability \u0026 Cost Controls: Monitor performance and keep spending within budget.\n\n   Set Cost Guardrails: Prevent unexpected cost increases by defining max token limits per stage and considering operational modes (\"Fast,\" \"Standard,\" \"Thorough\") to balance cost and performance.\n   Implement Essential Logging: Capture key operational data via structured logs for each processing stage to enable debugging and monitoring.\n\n\nImplement Safety \u0026 Compliance Guardrails: Ensure responsible operation and meet requirements.\n\n   Use Safety Mechanisms: Employ tools like OpenAI's moderation APIs, safety-focused system prompts, or sentinel models for checks, especially with user input or sensitive topics.\n   Enforce Compliance: Build in checks relevant to your specific industry and risks (e.g., legal constraints, lab safety).\n   Require Human-in-the-Loop (HITL): Mandate human review for low-confidence outputs, high-risk scenarios, or critical decisions, ensuring the workflow flags these items clearly.\n\n\nManage Model Updates and Versioning: Prepare for model evolution over time.\n\n   Version Pinning Strategy: Decide whether to pin to specific model versions for stability or automatically adopt new versions for improvements.\n   A/B Testing Framework: Establish a process to evaluate new model versions against your key metrics before full deployment.\n   Rollback Plan: Create a clear procedure for reverting to previous model versions if issues arise with updates.\n   Monitor Version Performance: Track metrics across model versions to identify performance trends and inform future selection decisions.\n\n\n\n\n\n\nModel Selection Decision Tree\n\n\nWhen explaining your model choices to business stakeholders, focus on these key points:\n\nAlign with Business Outcomes: Explain how your model selection directly supports specific business goals (time savings, cost reduction, improved accuracy).\n\nTranslate Technical Metrics: Convert technical considerations into business impact:\n   \"This model reduces processing time from 5 seconds to 0.7 seconds, allowing us to handle customer inquiries 7x faster\"\n   \"By using the mini variant, we can process 5x more documents within the same budget\"\n\nHighlight Trade-offs: Present clear scenarios for different models:\n   \"Option A (GPT-4.1): Highest accuracy but higher cost - ideal for client-facing legal analysis\"\n   \"Option B (GPT-4.1 mini): 90% of the accuracy at 30% of the cost - perfect for internal document processing\"\n\nUse Concrete Examples: Demonstrate the practical difference in outputs between models to illustrate the value proposition of each option.\n\n\n\n\n\n\n\n| Term | Definition |\n|------|------------|\n| Context Window | The maximum number of tokens a model can process in a single request |\n| Hallucination | When a model generates content that appears plausible but is factually incorrect or unsupported |\n| Latency | The time delay between sending a request to a model and receiving a response |\n| LLM | Large Language Model; an AI system trained on vast amounts of text data |\n| Prompt Engineering | The practice of designing effective prompts to elicit desired outputs from AI models |\n| RAG | Retrieval-Augmented Generation; combining information retrieval with text generation |\n| SOTA | State-of-the-Art; representing the most advanced stage in a field at a given time |\n| Token | The basic unit of text that models process (roughly 0.75 words in English) |\n\n\n| Model | Context Window | Input Price (per 1M tokens) | Output Price (per 1M tokens) | Best For |\n|-------|----------------|-----------------------------|-----------------------------|----------|\n| GPT-4.1 | 1M | \\$2.00 | \\$8.00 | Long-doc analytics, code review |\n| GPT-4.1 mini | 1M | \\$0.40 | \\$1.60 | Production agents, balanced cost/performance |\n| GPT-4.1 nano | 1M | \\$0.10 | \\$0.40 | High-throughput, cost-sensitive applications |\n| GPT-4o | 128K | \\$5.00 | \\$15.00 | Real-time voice/vision chat |\n| GPT-4o mini | 128K | \\$0.15 | \\$0.60 | Vision tasks, rapid analytics |\n| o3 (low) | 200K | \\$10.00* | \\$40.00* | Bulk triage, catalog enrichment |\n| o3 (med) | 200K | \\$10.00* | \\$40.00* | Knowledge base Q\u0026A |\n| o3 (high) | 200K | \\$10.00* | \\$40.00* | Multi-step reasoning, troubleshooting |\n| o4-mini (low) | 200K | \\$1.10* | \\$4.40* | Vision tasks, rapid analytics |\n| o4-mini (med) | 200K | \\$1.10* | \\$4.40* | Balanced vision + reasoning |\n| o4-mini (high) | 200K | \\$1.10* | \\$4.40* | Deep reasoning with cost control |\n\n\\* Note: The low/med/high settings affect token usage rather than base pricing. Higher settings may use more tokens for deeper reasoning, increasing per-request cost and latency.\n\n\n| Prompt Pattern | Description | Token Impact | Latency Impact | Best Model Fit |\n|----------------|-------------|--------------|----------------|----------------|\n| Self-Critique | Ask model to evaluate its own answer before finalizing | +20-30% tokens | +15-25% latency | GPT-4.1, o3 |\n| Chain-of-Thought (CoT) | Explicitly instruct to \"think step by step\" | +40-80% tokens | +30-50% latency | o3, o4-mini (high) |\n| Structured Outputs | Use JSON schema or pydantic models for consistent formatting | +5-10% tokens | +5-10% latency | All models |\n| Zero-Token Memory | Store context in external DB rather than in conversation | -70-90% tokens | -5-10% latency | GPT-4.1 family |\n| Skeleton-Fill-In | Provide template structure for model to complete | -10-20% tokens | -5-15% latency | o4-mini, GPT-4.1 nano |\n| Self-Consistency | Generate multiple answers and select most consistent | +200-300% tokens | +150-250% latency | o3 (high) |\n| Role-Playing | Assign specific personas to model for specialized knowledge | +5-15% tokens | Neutral | GPT-4o, o4-mini |\n| Tournament Ranking | Compare options pairwise rather than scoring individually | +50-100% tokens | +30-60% latency | o3, o4-mini (high) |\n| Tool-Calling Reflex | Prompt model to call tools when uncertainty is detected | +10-30% tokens | +20-40% latency | o3, GPT-4.1 |\n\n\nOpenAI Cookbook Main Repository\nFunction Calling Guide\nVision Models Guide\nAgents Documentation\nStructured Outputs Guide\n\nRAG on PDFs\n\nVoice Assistant with Agents SDK\nMulti-Tool Orchestration\nData Extraction and Transformation\n\nGPT-4.1 Prompting Guide\nPrompt Engineering Best Practices\n\nGetting Started with OpenAI Evals\nHow to use the Usage API and Cost API to monitor your OpenAI usage\n\n\n\n\n\n\n This cookbook serves as a joint collaboration effort between OpenAI and Tribe AI\nKashyap Coimbatore Murali\nNate Harada\nSai Prashanth Soundararaj\nShikhar Kwatra"])</script><script>self.__next_f.push([1,"49:Tcdc,"])</script><script>self.__next_f.push([1,"Evals are task oriented and iterative, they're the best way to check how your LLM integration is doing and improve it.\n\nIn the following eval, we are going to focus on the task of detecting if my prompt change is a regression.\n\nOur use-case is:\nI have an llm integration that takes a list of push notifications and summarizes them into a single condensed statement.\nI want to detect if a prompt change regresses the behavior\n\n\nEvals have two parts, the \"Eval\" and the \"Run\". An \"Eval\" holds the configuration for your testing criteria and the structure of the data for your \"Runs\". An Eval can have many runs that are evaluated by your testing criteria.\n\nWe're testing the following integration, a push notifications summary, which takes in multiple push notifications and collapses them into a single one, this is a chat completions call.\n\nAn Eval holds the configuration that is shared across multiple Runs, it has two components:\nData source configuration data_source_config - the schema (columns) that your future Runs conform to.\n    The data_source_config uses JSON Schema to define what variables are available in the Eval.\nTesting Criteria testing_criteria - How you'll determine if your integration is working for each row of your data source.\n\nFor this use-case, we want to test if the push notification summary completion is good, so we'll set-up our eval with this in mind.\nThis data_source_config defines what variables are available throughout the eval.\n\nThis item schema:\n{\n  \"properties\": {\n    \"notifications\": {\n      \"title\": \"Notifications\",\n      \"type\": \"string\"\n    }\n  },\n  \"required\": [\"notifications\"],\n  \"title\": \"PushNotifications\",\n  \"type\": \"object\"\n}\nMeans that we'll have the variable {{item.notifications}} available in our eval.\n\n\"include_sample_schema\": True\nMean's that we'll have the variable {{sample.output_text}} available in our eval.\n\nNow, we'll use those variables to set up our test criteria.\nThe push_notification_grader is a model grader (llm-as-a-judge), which looks at the input {{item.notifications}} and the generated summary {{sample.output_text}} and labels it as \"correct\" or \"incorrect\".\nWe then instruct via. the \"passing_labels\", what constitutes a passing answer.\n\nNote: under the hood, this uses structured outputs so that labels are always valid.\n\nNow we'll create our eval!, and start adding data to it\n\nNow that we have our eval set-up with our test_criteria, we can start to add a bunch of runs!\nWe'll start with some push notification data.\nOur first run will be our default grader from the completions function above summarize_push_notification\nWe'll loop through our dataset, make completions calls, and then submit them as a run to be graded.\nNow let's simulate a regression, here's our original prompt, let's simulate a developer breaking the prompt.\n\nDEVELOPER_PROMPT = \"\"\"\nYou are a helpful assistant that summarizes push notifications.\nYou are given a list of push notifications and you need to collapse them into a single one.\nOutput only the final summary, nothing else.\n\"\"\"\nIf you view that report, you'll see that it has a score that's much lower than the baseline-run.\n\n\nQuick note:\nEvals doesn't yet support the responses api natively, however, you can transform it to the completions format with the following code."])</script><script>self.__next_f.push([1,"4a:Tc43,"])</script><script>self.__next_f.push([1,"Evals are task oriented and iterative, they're the best way to check how your LLM integration is doing and improve it.\n\nIn the following eval, we are going to focus on the task of testing many variants of models and prompts.\n\nOur use-case is:\nI want to get the best possible performance out of my push notifications summarizer\n\n\nEvals have two parts, the \"Eval\" and the \"Run\". An \"Eval\" holds the configuration for your testing criteria and the structure of the data for your \"Runs\". An Eval has_many runs, that are evaluated by your testing criteria.\n\nWe're testing the following integration, a push notifications summarizer, which takes in multiple push notifications and collapses them into a single message.\n\nAn Eval holds the configuration that is shared across multiple Runs, it has two components:\nData source configuration data_source_config - the schema (columns) that your future Runs conform to.\n    The data_source_config uses JSON Schema to define what variables are available in the Eval.\nTesting Criteria testing_criteria - How you'll determine if your integration is working for each row of your data source.\n\nFor this use-case, we want to test if the push notification summary completion is good, so we'll set-up our eval with this in mind.\nThis data_source_config defines what variables are available throughout the eval.\n\nThis item schema:\n{\n  \"properties\": {\n    \"notifications\": {\n      \"title\": \"Notifications\",\n      \"type\": \"string\"\n    }\n  },\n  \"required\": [\"notifications\"],\n  \"title\": \"PushNotifications\",\n  \"type\": \"object\"\n}\nMeans that we'll have the variable {{item.notifications}} available in our eval.\n\n\"include_sample_schema\": True\nMean's that we'll have the variable {{sample.output_text}} available in our eval.\n\nNow, we'll use those variables to set up our test criteria.\nThe push_notification_grader is a model grader (llm-as-a-judge) which looks at the input {{item.notifications}} and the generated summary {{sample.output_text}} and labels it as \"correct\" or \"incorrect\"\nWe then instruct via the \"passing_labels\" what constitutes a passing answer.\n\nNote: under the hood, this uses structured outputs so that labels are always valid.\n\nNow we'll create our eval, and start adding data to it!\n\nNow that we have our eval set-up with our testing_criteria, we can start to add a bunch of runs!\nWe'll start with some push notification data.\nNow we're going to set up a bunch of prompts to test.\n\nWe want to test a basic prompt, with a couple of variations:\nIn one variation, we'll just have the basic prompt\nIn the next one, we'll include some positive examples of what we want the summaries to look like\nIn the final one, we'll include both positive and negative examples.\n\nWe'll also include a list of models to use.\nNow we can just loop through all prompts and all models to test a bunch of configurations at once!\n\nWe'll use the 'completion' run data source with template variables for our push notification list.\n\nOpenAI will handle making the completions calls for you and populating \"sample.output_text\"\n\nCongratulations, you just tested 9 different prompt and model variations across your dataset!"])</script><script>self.__next_f.push([1,"4b:Te11,"])</script><script>self.__next_f.push([1,"Evals are task-oriented and iterative, they're the best way to check how your LLM integration is doing and improve it.\n\nIn the following eval, we are going to focus on the task of detecting our prompt changes for regressions.\n\nOur use-case is:\nWe have been logging chat completion requests by setting store=True in our production chat completions requests. Note that you can also enable \"on by default\" logging in your admin panel (https://platform.openai.com/settings/organization/data-controls/data-retention).\nWe want to see whether our prompt changes have introduced regressions.\n\n\nEvals have two parts, the \"Eval\" and the \"Run\". An \"Eval\" holds the configuration for your testing criteria and the structure of the data for your \"Runs\". An Eval can have many Runs, which are each evaluated using your testing criteria.\n\nWe're testing the following integration, a push notifications summary, which takes in multiple push notifications and collapses them into a single one, this is a chat completions call.\n\nI'm going to produce simulated production chat completions requests with two different prompt versions to test how each performs. The first is a \"good\" prompt, the second is a \"bad\" prompt. These will have different metadata which we'll use later.\nYou can view the completions you just created at https://platform.openai.com/logs.\n\nMake sure that the chat completions show up, as they are necessary for the next step.\n\nAn Eval holds the configuration that is shared across multiple Runs, it has two components:\nData source configuration data_source_config - the schema (columns) that your future Runs conform to.\n    The data_source_config uses JSON Schema to define what variables are available in the Eval.\nTesting Criteria testing_criteria - How you'll determine if your integration is working for each row of your data source.\n\nFor this use-case, we're using stored-completions, so we'll set up that data_source_config\n\nImportant\nYou are likely to have many different stored completions use-cases, metadata is the best way to keep track of this for evals to keep them focused and task oriented.\nThis data_source_config defines what variables are available throughout the eval.\n\nThe stored completions config provides two variables for you to use throughout your eval:\n{{item.input}} - the messages sent to the completions call\n{{sample.output_text}} - the text response from the assistant\n\nNow, we'll use those variables to set up our test criteria.\nThe push_notification_grader is a model grader (llm-as-a-judge), which looks at the input {{item.input}} and the generated summary {{sample.output_text}} and labels it as \"correct\" or \"incorrect\".\n\nNote: under the hood, this uses structured outputs so that labels are always valid.\n\nNow we'll create our eval!, and start adding data to it\n\nNow that we have our eval set-up with our test_criteria, we can start adding runs.\nI want to compare the performance between my two prompt versions\n\nTo do this, we just define our source as \"stored_completions\" with a metadata filter for each of our prompt versions.\nJust for to be thorough, let's see how this prompt would do with 4o, instead of 4o-mini, with both prompt versions as the starting point.\n\nAll we have to do is reference the input messages ({{item.input}}) and set the model to 4o. Since we don't already have any stored completions for 4o, this eval run will generate new completions.\nIf you view that report, you'll see that we can see that prompt_version=v2 has a regression!\n\nCongratulations, you just discovered a bug, you could revert it, or make another prompt change, etc.!"])</script><script>self.__next_f.push([1,"4c:T4db,In the following eval, we are going to compare how a new model (gpt-4.1-mini) compares to our old model (gpt-4o-mini) by evaluating it on some stored responses. The benefit of this is for most developers, they won't have to spend any time putting together a whole eval -- all of their data will already be stored in their logs page.\nWe want to see how gpt-4.1 compares to gpt-4o on explaining a code base. Since can only use the responses datasource if you already have user traffic, we're going to generate some example traffic using 4o, and then compare how it does to gpt-4.1.\n\nWe're going to get some example code files from the OpenAI SDK, and ask gpt-4o to explain them to us.\nNow, lets generate some responses.\nNote that in order for this to work, you'll have to be doing this on an org where data logging isn't disabled (through zdr, etc). If you aren't sure if this is the case for you, go to https://platform.openai.com/logs?api=responses and see if you can see the responses you just generated.\nFirst, lets kick off a run to evaluate how good the original responses were. To do this, we just set the filters for what responses we want to evaluate on\nNow, let's see how 4.1-mini does!\nNow, lets go to the dashboard to see how we did!4d:T119e,"])</script><script>self.__next_f.push([1,"This cookbook guides you through building dynamic, multi-tool workflows using OpenAI's Responses API. It demonstrates how to implement a Retrieval-Augmented Generation (RAG) approach that intelligently routes user queries to the appropriate in-built or external tools. Whether your query calls for general knowledge or requires accessing specific internal context from a vector database (like Pinecone), this guide shows you how to integrate function calls, web searches in-built tool, and leverage document retrieval to generate accurate, context-aware responses.\n\nFor a practical example of performing RAG on PDFs using the Responses API's file search feature, refer to this notebook.\n\nThis example showcases the flexibility of the Responses API, illustrating that beyond the internal file_search tool—which connects to an internal vector store—there is also the capability to easily connect to external vector databases. This allows for the implementation of a RAG approach in conjunction with hosted tooling, providing a versatile solution for various retrieval and generation tasks.\nIn this example we use a sample medical reasoning dataset from Hugging Face. We convert the dataset into a Pandas DataFrame and merge the “Question” and “Response” columns into a single string. This merged text is used for embedding and later stored as metadata.\nUse the dataset itself to determine the embedding dimensionality. For example, compute one embedding from the merged column and then create the index accordingly.\n\nProcess the dataset in batches, generate embeddings for each merged text, prepare metadata (including separate Question and Answer fields), and upsert each batch into the index. You may also update metadata for specific entries if needed.\nPinecone Image\n\nCreate a natural language query, compute its embedding, and perform a similarity search on the Pinecone index. The returned results include metadata that provides context for generating answers.\n\nSelect the best matching result from your query results and use the OpenAI Responses API to generate a final answer by combining the retrieved context with the original question.\n\nNow, we'll define the built-in function available through the Responses API, including the ability to invoke the external Vector Store - Pinecone as an example.\n\nWeb Search Preview Tool: Enables the model to perform live web searches and preview the results. This is ideal for retrieving real-time or up-to-date information from the internet.\n\nPinecone Search Tool: Allows the model to query a vector database using semantic search. This is especially useful for retrieving relevant documents—such as medical literature or other domain-specific content—that have been stored in a vectorized format.\nAs shown above, depending on the query, appropriate tool is invoked in order to determine the optimal response.\n\nFor instance, looking at the third example, when the model triggers the tool named \"PineconeSearchDocuments\", the code calls query_pinecone_index with the current query and then extracts the best match (or an appropriate context) as the result. For non health related inqueries or queries where explicit internet search is asked, the code calls the web_search_call function and for other queries, it may choose to not call any tool and rather provide a response based on the question under consideration.\n\nFinally, the tool call and its output are appended to the conversation, and the final answer is generated by the Responses API.\n\nNow let us try to modify the input query and the system instructions to the responses API in order to follow a tool calling sequence and generate the output.\n\nHere, we have seen  how to utilize OpenAI's Responses API to implement a Retrieval-Augmented Generation (RAG) approach with multi-tool calling capabilities. It showcases an example where the model selects the appropriate tool based on the input query: general questions may be handled by built-in tools such as web-search, while specific medical inquiries related to internal knowledge are addressed by retrieving context from a vector database (such as Pinecone) via function calls. Additonally, we have showcased how multiple tool calls can be sequentially combined to generate a final response based on our instructions provided to responses API.\n\nAs you continue to experiment and build upon these concepts, consider exploring additional resources and examples to further enhance your understanding and applications\n\nHappy coding!"])</script><script>self.__next_f.push([1,"4e:T1644,"])</script><script>self.__next_f.push([1,"We recently announced our new open-source Agents SDK, designed to help you build agentic AI applications using a lightweight, easy-to-use package with minimal abstractions.\n\nThis cookbook demonstrates how you can leverage the Agents SDK in combination with Stripe's API to handle dispute management, a common operational challenge many businesses face. Specifically, we focus on two real-world scenarios:\n\nCompany Mistake:\n   A scenario where the company clearly made an error, such as failing to fulfill an order, where accepting the dispute the appropriate action.\n\nCustomer Dispute (Final Sale):\n   A scenario where a customer knowingly disputes a transaction despite receiving the correct item and understanding that the purchase was final sale, requiring further investigation to gather supporting evidence.\n\nTo address these scenarios, we'll introduce three distinct agents:\n\nTriage Agent:**\n  Determines whether to accept or escalate a dispute based on the fulfillment status of the order.\n\nAcceptance Agent:**\n  Handles clear-cut cases by automatically accepting disputes, providing concise reasoning.\n\nInvestigator Agent:**\nPerforms thorough investigations into disputes by analyzing communication records and order information to collect essential evidence.\n\nThroughout this cookbook, we’ll guide you step-by-step, illustrating how custom agentic workflows can automate dispute management and support your business operations.\n\n\nBefore running this cookbook, you must set up the following accounts and complete a few setup actions. These prerequisites are essential to interact with the APIs used in this project.\n\n\nPurpose:**\n  You need an OpenAI account to access language models and use the Agents SDK featured in this cookbook.\n\nAction:**\n  Sign up for an OpenAI account if you don’t already have one. Once you have an account, create an API key by visiting the OpenAI API Keys page.\n\n\nPurpose:**\n  A Stripe account is required to simulate payment processing, manage disputes, and interact with the Stripe API as part of our demo workflow.\n\nAction:**\n  Create a free Stripe account by visiting the Stripe Signup Page.\n\nLocate Your API Keys:**\n  Log in to your Stripe dashboard and navigate to Developers \u003e API keys.\n\nUse Test Mode:**\n  Use your Test Secret Key for all development and testing.\n\n\n\nOPENAI_API_KEY=\nSTRIPE_SECRET_KEY=\nFirst we will install the necessary dependencies, then import the libraries and write some utility functions that we will use later on.\nThis section defines several helper function tools that support the dispute processing workflow.\n\nget_order, get_phone_logs and get_emails simulate external data lookups by returning order details and email/phone records based on provided identifiers.\nretrieve_payment_intent  interacts with the Stripe API to fetch payment intent details.\nclose_dispute  automatically closes a Stripe dispute using the provided dispute ID, ensuring that disputes are properly resolved and logged.\n\n\nThe Dispute Intake Agent (investigator_agent) is responsible for investigating disputes by gathering all relevant evidence and providing a report.\nThe Accept a Dispute Agent (accept_dispute_agent) handles disputes that are determined to be valid by automatically closing them and providing a brief explanation for the decision.\nThe Triage Agent (triage_agent) serves as the decision-maker by extracting the order ID from the payment intent's metadata, retrieving detailed order information, and then deciding whether to escalate the dispute to the investigator or to pass it to the accept dispute agent.\nTogether, these agents form a modular workflow that automates and streamlines the dispute resolution process by delegating specific tasks to specialized agents.\n\nThis function retrieves the dispute details from Stripe using the provided payment_intent_id and initiates the dispute-handling workflow by passing the retrieved dispute information to the specified triage_agent.\n\nThis scenario represents a situation where the company has clearly made an error—for instance, failing to fulfill or ship an order. In such cases, it may be appropriate to accept the dispute rather than contest it.\nThis scenario describes a situation where a customer intentionally disputes a transaction, despite having received the correct product and being fully aware that the purchase was clearly marked as a \"final sale\" (no refunds or returns). Such disputes typically require further investigation to collect evidence in order to effectively contest the dispute.\n\nIn this Jupyter Notebook, we explored the capabilities of the OpenAI Agents SDK, demonstrating how to efficiently create agent-based AI applications using a simple, Python-first approach. Specifically, we showcased the following SDK features:\n\nAgent Loop**: Manages tool calls, communicates results to the LLM, and loops until completion.\nHandoffs**: Enables coordination and delegation tasks between multiple specialized agents.\nFunction Tools**: Converts Python functions into tools with automatic schema generation and validation.\n\nAdditionally, the SDK offers built-in Tracing, accessible via the OpenAI dashboard. Tracing helps you visualize, debug, and monitor your agent workflows during both development and production phases. It also integrates smoothly with OpenAI’s evaluation, fine-tuning, and distillation tools.\n\nWhile we didn't cover it directly in this notebook, implementing Guardrails is strongly recommended for production applications to validate inputs and proactively detect errors.\n\nOverall, this notebook lays a clear foundation for further exploration, emphasizing how the OpenAI Agents SDK facilitates intuitive and effective agent-driven workflows."])</script><script>self.__next_f.push([1,"4f:Tc99,"])</script><script>self.__next_f.push([1,"The Responses API is a new way to interact with OpenAI models, designed to be simpler and more flexible than previous APIs. It makes it easy to build advanced AI applications that use multiple tools, handle multi-turn conversations, and work with different types of data (not just text).\n\nUnlike older APIs—such as Chat Completions, which were built mainly for text, or the Assistants API, which can require a lot of setup—the Responses API is built from the ground up for:\n\nSeamless multi-turn interactions (carry on a conversation across several steps in a single API call)\nEasy access to powerful hosted tools (like file search, web search, and code interpreter)\nFine-grained control over the context you send to the model\n\nAs AI models become more capable of complex, long-running reasoning, developers need an API that is both asynchronous and stateful. The Responses API is designed to meet these needs.\n\nIn this guide, you'll see some of the new features the Responses API offers, along with practical examples to help you get started.\nBy design, on the surface, the Responses API is very similar to the Completions API.\nOne key feature of the Response API is that it is stateful. This means that you do not have to manage the state of the conversation by yourself, the API will handle it for you. For example, you can retrieve the response at any time and it will include the full conversation history.\nYou can continue the conversation by referring to the previous response.\nYou can of course manage the context yourself. But one benefit of OpenAI maintaining the context for you is that you can fork the response at any point and continue the conversation from that point.\n\nAnother benefit of the Responses API is that it adds support for hosted tools like file_search and web_search. Instead of manually calling the tools, simply pass in the tools and the API will decide which tool to use and use it.\n\nHere is an example of using the web_search tool to incorporate web search results into the response.\n\nThe Responses API natively supports text, images, and audio modalities.\nTying everything together, we can build a fully multimodal, tool-augmented interaction with one API call through the responses API.\nIn the above example, we were able to use the web_search tool to search the web for news related to the image in one API call instead of multiple round trips that would be required if we were using the Chat Completions API.\nWith the responses API\n🔥 a single API call can handle:\n\n✅ Analyze a given image using a multimodal input.\n\n✅ Perform web search via the web_search hosted tool\n\n✅ Summarize the results.\n\nIn contrast, With Chat Completions API would require multiple steps, each requiring a round trip to the API:\n\n1️⃣ Upload image and get analysis → 1 request\n\n2️⃣ Extract info, call external web search → manual step + tool execution\n\n3️⃣ Re-submit tool results for summarization → another request\n\nSee the following diagram for a side by side visualized comparison!\n\nResponses vs Completions\n\n\nWe are very excited for you to try out the Responses API and see how it can simplify your code and make it easier to build complex, multimodal, tool-augmented interactions!"])</script><script>self.__next_f.push([1,"50:T2bce,"])</script><script>self.__next_f.push([1,"This notebook demonstrates the use of the logprobs parameter in the Chat Completions API. When logprobs is enabled, the API returns the log probabilities of each output token, along with a limited number of the most likely tokens at each token position and their log probabilities. The relevant request parameters are:\nlogprobs: Whether to return log probabilities of the output tokens or not. If true, returns the log probabilities of each output token returned in the content of message.\ntop_logprobs: An integer between 0 and 5 specifying the number of most likely tokens to return at each token position, each with an associated log probability. logprobs must be set to true if this parameter is used.\n\nLog probabilities of output tokens indicate the likelihood of each token occurring in the sequence given the context. To simplify, a logprob is log(p), where p = probability of a token occurring at a specific position based on the previous tokens in the context. Some key points about logprobs:\nHigher log probabilities suggest a higher likelihood of the token in that context. This allows users to gauge the model's confidence in its output or explore alternative responses the model considered.\nLogprob can be any negative number or 0.0. 0.0 corresponds to 100% probability.\nLogprobs allow us to compute the joint probability of a sequence as the sum of the logprobs of the individual tokens. This is useful for scoring and ranking model outputs. Another common approach is to take the average per-token logprob of a sentence to choose the best generation.\nWe can examine the logprobs assigned to different candidate tokens to understand what options the model considered plausible or implausible.\n\nWhile there are a wide array of use cases for logprobs, this notebook will focus on its use for:\n\nClassification tasks\n\nLarge Language Models excel at many classification tasks, but accurately measuring the model's confidence in its outputs can be challenging. logprobs provide a probability associated with each class prediction, enabling users to set their own classification or confidence thresholds.\n\nRetrieval (Q\u0026A) evaluation\n\nlogprobs can assist with self-evaluation in retrieval applications. In the Q\u0026A example, the model outputs a contrived has_sufficient_context_for_answer boolean, which can serve as a confidence score of whether the answer is contained in the retrieved content. Evaluations of this type can reduce retrieval-based hallucinations and enhance accuracy.\n\nAutocomplete\nlogprobs could help us decide how to suggest words as a user is typing.\n\nToken highlighting and outputting bytes\nUsers can easily create a token highlighter using the built in tokenization that comes with enabling logprobs. Additionally, the bytes parameter includes the ASCII encoding of each output character, which is particularly useful for reproducing emojis and special characters.\n\nCalculating perplexity\nlogprobs can be used to help us assess the model's overall confidence in a result and help us compare the confidence of results from different prompts.\nLet's say we want to create a system to classify news articles into a set of pre-defined categories. Without logprobs, we can use Chat Completions to do this, but it is much more difficult to assess the certainty with which the model made its classifications.\n\nNow, with logprobs enabled, we can see exactly how confident the model is in its predictions, which is crucial for creating an accurate and trustworthy classifier. For example, if the log probability for the chosen category is high, this suggests the model is quite confident in its classification. If it's low, this suggests the model is less confident. This can be particularly useful in cases where the model's classification is not what you expected, or when the model's output needs to be reviewed or validated by a human.\nWe'll begin with a prompt that presents the model with four categories: Technology, Politics, Sports, and Arts. The model is then tasked with classifying articles into these categories based solely on their headlines.\nLet's look at three sample headlines, and first begin with a standard Chat Completions output, without logprobs\nHere we can see the selected category for each headline. However, we have no visibility into the confidence of the model in its predictions. Let's rerun the same prompt but with logprobs enabled, and top_logprobs set to 2 (this will show us the 2 most likely output tokens for each token). Additionally we can also output the linear probability of each output token, in order to convert the log probability to the more easily interprable scale of 0-100%.\nAs expected from the first two headlines, gpt-4o-mini is 100% confident in its classifications, as the content is clearly technology and politics focused, respectively. However, the third headline combines both sports and art-related themes, resulting in slightly lower confidence at 97%, while still demonstrating strong certainty in its classification.\n\nlogprobs are quite useful for classification tasks. They allow us to set confidence thresholds or output multiple potential tokens if the log probability of the selected output is not sufficiently high. For instance, when creating a recommendation engine to tag articles, we can automatically classify headlines that exceed a certain threshold and send less certain ones for manual review.\nTo reduce hallucinations, and the performance of our RAG-based Q\u0026A system, we can use logprobs to evaluate how confident the model is in its retrieval.\nLet's say we have built a retrieval system using RAG for Q\u0026A, but are struggling with hallucinated answers to our questions. Note: we will use a hardcoded article for this example, but see other entries in the cookbook for tutorials on using RAG for Q\u0026A.\nNow, what we can do is ask the model to respond to the question, but then also evaluate its response. Specifically, we will ask the model to output a boolean has_sufficient_context_for_answer. We can then evaluate the logprobs to see just how confident the model is that its answer was contained in the provided context\nFor the first two questions, our model asserts with (near) 100% confidence that the article has sufficient context to answer the posed questions.\nOn the other hand, for the more tricky questions which are less clearly answered in the article, the model is less confident that it has sufficient context. This is a great guardrail to help ensure our retrieved content is sufficient.\nThis self-evaluation can help reduce hallucinations, as you can restrict answers or re-prompt the user when your sufficient_context_for_answer log probability is below a certain threshold. Methods like this have been shown to significantly reduce RAG for Q\u0026A hallucinations and errors (Example)\nAnother use case for logprobs are autocomplete systems. Without creating the entire autocomplete system end-to-end, let's demonstrate how logprobs could help us decide how to suggest words as a user is typing.\nFirst, let's come up with a sample sentence: \"My least favorite TV show is Breaking Bad.\" Let's say we want it to dynamically recommend the next word or token as we are typing the sentence, but only if the model is quite sure of what the next word will be. To demonstrate this, let's break up the sentence into sequential components.\nNow, we can ask gpt-4o-mini to act as an autocomplete engine with whatever context the model is given. We can enable logprobs and can see how confident the model is in its prediction.\nLet's look at the high confidence autocompletions:\nThese look reasonable! We can feel confident in those suggestions. It's pretty likely you want to write 'show' after writing 'My least favorite TV'! Now let's look at the autocompletion suggestions the model was less confident about:\nThese are logical as well. It's pretty unclear what the user is going to say with just the prefix 'my least favorite', and it's really anyone's guess what the author's favorite TV show is.\nSo, using gpt-4o-mini, we can create the root of a dynamic autocompletion engine with logprobs!\nLet's quickly touch on creating a simple token highlighter with logprobs, and using the bytes parameter. First, we can create a function that counts and highlights each token. While this doesn't use the log probabilities, it uses the built in tokenization that comes with enabling logprobs.\nNext, let's reconstruct a sentence using the bytes parameter. With logprobs enabled, we are given both each token and the ASCII (decimal utf-8) values of the token string. These ASCII values can be helpful when handling tokens of or containing emojis or special characters.\nHere, we see that while the first token was \\xf0\\x9f\\x92', we can get its ASCII value and append it to a bytes array. Then, we can easily decode this array into a full sentence, and validate with our assert statement that the decoded bytes is the same as our completion message!\n\nAdditionally, we can get the joint probability of the entire completion, which is the exponentiated product of each token's log probability. This gives us how likely this given completion is given the prompt. Since, our prompt is quite directive (asking for a certain emoji and its name), the joint probability of this output is high! If we ask for a random output however, we'll see a much lower joint probability. This can also be a good tactic for developers during prompt engineering.\n\nWhen looking to assess the model's confidence in a result, it can be useful to calculate perplexity, which is a measure of the uncertainty. Perplexity can be calculated by exponentiating the negative of the average of the logprobs. Generally, a higher perplexity indicates a more uncertain result, and a lower perplexity indicates a more confident result. As such, perplexity can be used to both assess the result of an individual model run and also to compare the relative confidence of results between model runs. While a high confidence doesn't guarantee result accuracy, it can be a helpful signal that can be paired with other evaluation metrics to build a better understanding of your prompt's behavior.\n\nFor example, let's say that I want to use gpt-4o-mini to learn more about artificial intelligence. I could ask a question about recent history and a question about the future:\nIn this example, gpt-4o-mini returned a lower perplexity score for a more deterministic question about recent history, and a higher perplexity score for a more speculative assessment about the near future. Again, while these differences don't guarantee accuracy, they help point the way for our interpretation of the model's results and our future use of them.\nNice! We were able to use the logprobs parameter to build a more robust classifier, evaluate our retrieval for Q\u0026A system, and encode and decode each 'byte' of our tokens! logprobs adds useful information and signal to our completions output, and we are excited to see how developers incorporate it to improve applications.\nThere are many other use cases for logprobs that are not covered in this cookbook. We can use logprobs for:\n  Moderation\n  Keyword selection\n  Improve prompts and interpretability of outputs\n  Token healing\n  and more!"])</script><script>self.__next_f.push([1,"51:T19fd,"])</script><script>self.__next_f.push([1,"This notebook illustrates the use of the new Assistants API (GPT-4), and DALL·E-3 in crafting informative and visually appealing slides.\nCreating slides is a pivotal aspect of many jobs, but can be laborious and time-consuming. Additionally, extracting insights from data and articulating them effectively on slides can be challenging.  This cookbook recipe will demonstrate how you can utilize the new Assistants API to facilitate the end to end slide creation process for you without you having to touch Microsoft PowerPoint or Google Slides, saving you valuable time and effort!\nIn this recipe, we will be creating a brief fictional presentation for the quarterly financial review of our company, NotReal Corporation. We want to highlight some key trends we are seeing that are affecting the profitability of our company. Let's say we have the some financial data at our disposal. Let's load in the data, and take a look...\nAs you can see, this data has quarterly revenue, costs and customer data across different distribution channels. Let's create an Assistant\nthat can act as a personal analyst and make a nice visualization for our PowerPoint!\nFirst, we need to upload our file so our Assistant can access it.\nNow, we're ready to create our Assistant. We can instruct our assistant to act as a data scientist, and take any queries we give it and run the necessary code to output the proper data visualization. The instructions parameter here is akin to system instructions in the ChatCompletions endpoint, and can help guide the assistant. We can also turn on the tool of Code Interpreter, so our Assistant will be able to code. Finally, we can specifiy any files we want to use, which in this case is just the financial_data file we created above.\nLet's create a thread now, and as our first request ask the Assistant to calculate quarterly profits, and then plot the profits by distribution channel over time. The assistant will automatically calculate the profit for each quarter, and also create a new column combining quarter and year, without us having to ask for that directly. We can also specify the colors of each line.\nNo we can execute the run of our thread\nWe can now start a loop that will check if the image has been created. Note: This may take a few minutes\nLet's see the messages the Assistant added.\nWe can see that the last message (latest message is shown first) from the assistant contains the image file we are looking for. An interesting note here is that the Assistant was able to attempt several times to parse the JSON data, as the first parsing was unsuccessful, demonstrating the assistant's adaptability.\nLet's load in the plot!\nThe Image\nNice! So, with just one sentence, we were able to have our assistant use code interpreter to\ncalculate the profitability, and graph the three lineplots of the various distribution channels.\nNow we have a nice visual for our slide, but we want some insights to go along with it.\nTo get insights from our image, we simply need to add a new message to our thread. Our Assistant will know to use the message history to give us some concise takeaways from the visual provided.\nNow, once the run has completed, we can see the latest message\nCool! So our assistant was able to identify the noteworthy growth in Online Sales profit, and infer that this shows the importance of a large digital presence. Now let's get a compelling title for the slide.\nAnd the title is:\nNice, now we have a title, a plot and two bullet points. We're almost ready to put this all on a slide, but as a final step, let's have DALL·E-3 come up with an image to use as the title slide of the presentation.\nNote: DALL·E-3 is not yet available within the assistants API but is coming soon!\nWe'll feed in a brief description of our company (NotRealCorp) and have DALL·E-3 do the rest!\nCool, now we can add this image to our thread. First, we can save the image locally, then upload it to the assistants API using the File upload endpoint. Let's also take a look at our image\n\nImage\nWe now have all the content we need to create the slides. While we could simply add a message asking for slides, but let's instead give the assistant a slide template, using the python-pptx library, to use. This will ensure we get a deck in the style we want. See the Extensions section at the end of the notebook for notes on creating the template.\nLet's set a few quick variables for our slides. We want the company name, NotRealCorp, to be on the title slide, and the title of the presentation should 'Quartlerly financial planning metting, Q3, 2023'.\nAnd for the data slide, we have:\nHere we have a template to create a Title Slide. The template below was created by uploading the image of a desirable title slide to GPT-V, and asking for the python-pptx code to create that template. The inputs to the template are the image_path, title_text, and subtitle_text.\nNow, we have a PPTX file saved with all of our created content!.\nLet's look at the screenshots of the .pptx we just created using JUST the assistants API and DALL·E-3. We don't have a seed parameter yet in the Assistants API, so the DALL·E-3 image and wordings will be slightly different from what you see when you run this notebook, due to the non-determinism of LLMs, but the outputs should be directionally the same.\nThe title slide:\nTitle Slide\nAnd the data slide:\nData Slide\nWoo! While these slides could use some formatting tweaks, we have made some great content using the Assistants API, GPT-4 and DALL·E-3. We were able to take a .csv file with financial data, and use our assisant to calculate profit by quarter across distribution channels, plot the results, identify insights and key takeaways from the visualization, and create a summarative title. And, given just a description of our company, NotRealCorp, we used DALL·E-3 to make an awesome title image.\nWhile we are still a ways away from entirely automating this process without a human in the loop, hopefully this notebook can make the slide creation process a bit easier for you. More importantly, this notebook can ideally give you a glimpse into the potential of the assistants API! We're excited to see what you build.\nWhen  DALL·E-3 is incorporated in the Assistants API, we will have the ability to request the generated title image within the thread.\nGPT-4-Vision is not yet supported in the Assistants API, but could have been used to gather insights from the line plot image.\nGPT-4-Vision was used to generate the python-pptx template included in this recipe, so a potential extension project could be demonstrating best practices around converting images to slide templates."])</script><script>self.__next_f.push([1,"52:Tc4b,"])</script><script>self.__next_f.push([1,"This notebook serves as a tool to preprocess and analyze the chat dataset used for fine-tuning a chat model.\nIt checks for format errors, provides basic statistics, and estimates token counts for fine-tuning costs.\nThe method shown here corresponds to the current fine-tuning method for gpt-3.5-turbo.\nSee legacy fine-tuning for models like babbage-002 and davinci-002.\n\nWe first load the chat dataset from an example JSONL file.\n\nWe can perform a variety of error checks to validate that each conversation in the dataset adheres to the format expected by the fine-tuning API. Errors are categorized based on their nature for easier debugging.\n\nData Type Check: Checks whether each entry in the dataset is a dictionary (dict). Error type: data_type.\nPresence of Message List: Checks if a messages list is present in each entry. Error type: missing_messages_list.\nMessage Keys Check: Validates that each message in the messages list contains the keys role and content. Error type: message_missing_key.\nUnrecognized Keys in Messages: Logs if a message has keys other than role, content, weight, function_call, and name. Error type: message_unrecognized_key.\nRole Validation: Ensures the role is one of \"system\", \"user\", or \"assistant\". Error type: unrecognized_role.\nContent Validation: Verifies that content has textual data and is a string. Error type: missing_content.\nAssistant Message Presence: Checks that each conversation has at least one message from the assistant. Error type: example_missing_assistant_message.\n\nThe code below performs these checks, and outputs counts for each type of error found are printed. This is useful for debugging and ensuring the dataset is ready for the next steps.\n\n\nLets define a few helpful utilities to be used in the rest of the notebook.\n\nWith some lightweight analysis we can identify potential issues in the dataset, like missing messages, and provide statistical insights into message and token counts.\n\nMissing System/User Messages: Counts the number of conversations missing a \"system\" or \"user\" message. Such messages are critical for defining the assistant's behavior and initiating the conversation.\nNumber of Messages Per Example: Summarizes the distribution of the number of messages in each conversation, providing insight into dialogue complexity.\nTotal Tokens Per Example: Calculates and summarizes the distribution of the total number of tokens in each conversation. Important for understanding fine-tuning costs.\nTokens in Assistant's Messages: Calculates the number of tokens in the assistant's messages per conversation and summarizes this distribution. Useful for understanding the assistant's verbosity.\nToken Limit Warnings: Checks if any examples exceed the maximum token limit (16,385 tokens), as such examples will be truncated during fine-tuning, potentially resulting in data loss.\n\n\nIn this final section, we estimate the total number of tokens that will be used for fine-tuning, which allows us to approximate the cost. It is worth noting that the duration of the fine-tuning jobs will also increase with the token count.\nSee https://openai.com/pricing to estimate total costs."])</script><script>self.__next_f.push([1,"53:T4a1,There are many ways to classify text. This notebook shares an example of text classification using embeddings. For many text classification tasks, we've seen fine-tuned models do better than embeddings. See an example of fine-tuned models for classification in Fine-tuned_classification.ipynb. We also recommend having more examples than embedding dimensions, which we don't quite achieve here.\n\nIn this text classification task, we predict the score of a food review (1 to 5) based on the embedding of the review's text. We split the dataset into a training and a testing set for all the following tasks, so we can realistically evaluate performance on unseen data. The dataset is created in the Get_embeddings_from_dataset Notebook.\n\nWe can see that the model has learnt to distinguish between the categories decently. 5-star reviews show the best performance overall, and this is not too surprising, since they are the most common in the dataset.\nUnsurprisingly 5-star and 1-star reviews seem to be easier to predict. Perhaps with more data, the nuances between 2-4 stars could be better predicted, but there's also probably more subjectivity in how people use the inbetween scores.54:T5d2,This notebook covers use cases where your data is unlabelled but has features that can be used to cluster them into meaningful categories. The challenge with clustering is making the features that make those clusters stand out human-readable, and that is where we'll look to use GPT-3 to generate meaningful cluster descriptions for us. We can then use these to apply labels to a previously unlabelled dataset.\n\nTo feed the model we use embeddings created using the approach displayed in the notebook Multiclass classification for transactions Notebook, applied to the full 359 transactions in the dataset to give us a bigger pool for learning\n\nWe'll reuse the approach from the Clustering Notebook, using K-Means to cluster our dataset using the feature embeddings we created previously. We'll then use the Completions endpoint to generate cluste"])</script><script>self.__next_f.push([1,"r descriptions for us and judge their effectiveness\n\nWe now have five new clusters that we can use to describe our data. Looking at the visualisation some of our clusters have some overlap and we'll need some tuning to get to the right place, but already we can see that GPT-3 has made some effective inferences. In particular, it picked up that items including legal deposits were related to literature archival, which is true but the model was given no clues on. Very cool, and with some tuning we can create a base set of clusters that we can then use with a multiclass classifier to generalise to other transactional datasets we might use.55:T657,This notebook shows how Ada embeddings can be used to implement semantic code search. For this demonstration, we use our own openai-python code repository. We implement a simple version of file parsing and extracting of functions from python files, which can be embedded, indexed, and queried.\n\nWe first setup some simple parsing functions that allow us to extract important information from our codebase.\n\nWe'll first load the openai-python folder and extract the needed information using the functions we defined above.\nNow that we have our content, we can pass the data to the text-embedding-3-small model and get back our vector embeddings.\n\nLet's test our endpoint with some simple queries. If you're familiar with the openai-python repository, you'll see that we're able to easily find functions we're looking for only a simple English description.\n\nWe define a search_functions method that takes our data that contains our embeddings, a query string, and some other configuration options. The process of searching our database works like such:\n\nWe first embed our query string (code_query) with text-embedding-3-small. The reasoning here is that a query string like 'a function that reverses a string' and a function like 'def reverse(string): return string[::-1]' will be very similar when embedded.\nWe then calculate the cosine similarity between our query string embedding and all data p"])</script><script>self.__next_f.push([1,"oints in our database. This gives a distance between each point and our query.\nWe finally sort all of our data points by their distance to our query string and return the number of results requested in the function parameters.56:Tccb,"])</script><script>self.__next_f.push([1,"This notebook demonstrates one way to customize OpenAI embeddings to a particular task.\n\nThe input is training data in the form of [text_1, text_2, label] where label is +1 if the pairs are similar and -1 if the pairs are dissimilar.\n\nThe output is a matrix that you can use to multiply your embeddings. The product of this multiplication is a 'custom embedding' that will better emphasize aspects of the text relevant to your use case. In binary classification use cases, we've seen error rates drop by as much as 50%.\n\nIn the following example, I use 1,000 sentence pairs picked from the SNLI corpus. Each pair of sentences are logically entailed (i.e., one implies the other). These pairs are our positives (label = 1). We generate synthetic negatives by combining sentences from different pairs, which are presumed to not be logically entailed (label = -1).\n\nFor a clustering use case, you can generate positives by creating pairs from texts in the same clusters and generate negatives by creating pairs from sentences in different clusters.\n\nWith other data sets, we have seen decent improvement with as little as ~100 training examples. Of course, performance will be better with  more examples.\n\nMost inputs are here. The key things to change are where to load your datset from, where to save a cache of embeddings to, and which embedding engine you want to use.\n\nDepending on how your data is formatted, you'll want to rewrite the process_input_data function.\n\nNote that it's important to split data into training and test sets before generating synethetic negatives or positives. You don't want any text strings in the training data to show up in the test data. If there's contamination, the test metrics will look better than they'll actually be in production.\n\nThis is another piece of the code that you will need to modify to match your use case.\n\nIf you have data with positives and negatives, you can skip this section.\n\nIf you have data with only positives, you can mostly keep it as is, where it generates negatives only.\n\nIf you have multiclass data, you will want to generate both positives and negatives. The positives can be pairs of text that share labels, and the negatives can be pairs of text that do not share labels.\n\nThe final output should be a dataframe with text pairs, where each pair is labeled -1 or 1.\n\nHere, I create a cache to save the embeddings. This is handy so that you don't have to pay again if you want to run the code again.\n\nHere we measure similarity of text using cosine similarity. In our experience, most distance functions (L1, L2, cosine similarity) all work about the same. Note that our embeddings are already normalized to length 1, so cosine similarity is equivalent to dot product.\n\nThe graphs show how much the overlap there is between the distribution of cosine similarities for similar and dissimilar pairs. If there is a high amount of overlap, that means there are some dissimilar pairs with greater cosine similarity than some similar pairs.\n\nThe accuracy I compute is the accuracy of a simple rule that predicts 'similar (1)' if the cosine similarity is above some threshold X and otherwise predicts 'dissimilar (0)'.\n\nThe better the matrix is, the more cleanly it will separate the similar and dissimilar pairs."])</script><script>self.__next_f.push([1,"57:Tb8a,"])</script><script>self.__next_f.push([1,"This notebook shows how we prepared a dataset of Wikipedia articles for search, used in Question_answering_using_embeddings.ipynb.\n\nProcedure:\n\nPrerequisites: Import libraries, set API key (if needed)\nCollect: We download a few hundred Wikipedia articles about the 2022 Olympics\nChunk: Documents are split into short, semi-self-contained sections to be embedded\nEmbed: Each section is embedded with the OpenAI API\nStore: Embeddings are saved in a CSV file (for large datasets, use a vector database)\n\nInstall any missing libraries with pip install in your terminal. E.g.,\n\npip install openai\n\n(You can also do this in a notebook cell with !pip install openai.)\n\nIf you install any libraries, be sure to restart the notebook kernel.\n\nNote that the OpenAI library will try to read your API key from the OPENAI_API_KEY environment variable. If you haven't already, set this environment variable by following these instructions.\n\nIn this example, we'll download a few hundred Wikipedia articles related to the 2022 Winter Olympics.\n\nNow that we have our reference documents, we need to prepare them for search.\n\nBecause GPT can only read a limited amount of text at once, we'll split each document into chunks short enough to be read.\n\nFor this specific example on Wikipedia articles, we'll:\nDiscard less relevant-looking sections like External Links and Footnotes\nClean up the text by removing reference tags (e.g., ), whitespace, and super short sections\nSplit each article into sections\nPrepend titles and subtitles to each section's text, to help GPT understand the context\nIf a section is long (say, \u003e 1,600 tokens), we'll recursively split it into smaller sections, trying to split along semantic boundaries like paragraphs\nNext, we'll recursively split long sections into smaller sections.\n\nThere's no perfect recipe for splitting text into sections.\n\nSome tradeoffs include:\nLonger sections may be better for questions that require more context\nLonger sections may be worse for retrieval, as they may have more topics muddled together\nShorter sections are better for reducing costs (which are proportional to the number of tokens)\nShorter sections allow more sections to be retrieved, which may help with recall\nOverlapping sections may help prevent answers from being cut by section boundaries\n\nHere, we'll use a simple approach and limit sections to 1,600 tokens each, recursively halving any sections that are too long. To avoid cutting in the middle of useful sentences, we'll split along paragraph boundaries when possible.\n\nNow that we've split our library into shorter self-contained strings, we can compute embeddings for each.\n\n(For large embedding jobs, use a script like api_request_parallel_processor.py to parallelize requests while throttling to stay under rate limits.)\n\nBecause this example only uses a few thousand strings, we'll store them in a CSV file.\n\n(For larger datasets, use a vector database, which will be more performant.)"])</script><script>self.__next_f.push([1,"58:Tac1,"])</script><script>self.__next_f.push([1,"OpenAI's embedding models cannot embed text that exceeds a maximum length. The maximum length varies by model, and is measured by tokens, not string length. If you are unfamiliar with tokenization, check out How to count tokens with tiktoken.\n\nThis notebook shows how to handle texts that are longer than a model's maximum context length. We'll demonstrate using embeddings from text-embedding-3-small, but the same ideas can be applied to other models and tasks. To learn more about embeddings, check out the OpenAI Embeddings Guide.\n\n\nFirst, we select the model and define a function to get embeddings from the API.\nThe text-embedding-3-small model has a context length of 8191 tokens with the cl100k_base encoding, and we can see that going over that limit causes an error.\nClearly we want to avoid these errors, particularly when handling programmatically with a large number of embeddings. Yet, we still might be faced with texts that are longer than the maximum context length. Below we describe and provide recipes for the main approaches to handling these longer texts: (1) simply truncating the text to the maximum allowed length, and (2) chunking the text and embedding each chunk individually.\n\nThe simplest solution is to truncate the input text to the maximum allowed length. Because the context length is measured in tokens, we have to first tokenize the text before truncating it. The API accepts inputs both in the form of text or tokens, so as long as you are careful that you are using the appropriate encoding, there is no need to convert the tokens back into string form. Below is an example of such a truncation function.\nOur example from before now works without error.\n\nThough truncation works, discarding potentially relevant text is a clear drawback. Another approach is to divide the input text into chunks and then embed each chunk individually. Then, we can either use the chunk embeddings separately, or combine them in some way, such as averaging (weighted by the size of each chunk).\n\nWe will take a function from Python's own cookbook that breaks up a sequence into chunks.\nNow we define a function that encodes a string into tokens and then breaks it up into chunks.\nFinally, we can write a function that safely handles embedding requests, even when the input text is longer than the maximum context length, by chunking the input tokens and embedding each chunk individually. The average flag can be set to True to return the weighted average of the chunk embeddings, or False to simply return the unmodified list of chunk embeddings.\nOnce again, we can now handle long input texts.\nIn some cases, it may make sense to split chunks on paragraph boundaries or sentence boundaries to help preserve the meaning of the text."])</script><script>self.__next_f.push([1,"59:T834,"])</script><script>self.__next_f.push([1,"GPT-3 can help us extract key figures, dates or other bits of important content from documents that are too big to fit into the context window. One approach for solving this is to chunk the document up and process each chunk separately, before combining into one list of answers.\n\nIn this notebook we'll run through this approach:\nLoad in a long PDF and pull the text out\nCreate a prompt to be used to extract key bits of information\nChunk up our document and process each chunk to pull any answers out\nCombine them at the end\nThis simple approach will then be extended to three more difficult questions\n\n\nSetup**: Take a PDF, a Formula 1 Financial Regulation document on Power Units, and extract the text from it for entity extraction. We'll use this to try to extract answers that are buried in the content.\nSimple Entity Extraction**: Extract key bits of information from chunks of a document by:\n    Creating a template prompt with our questions and an example of the format it expects\n    Create a function to take a chunk of text as input, combine with the prompt and get a response\n    Run a script to chunk the text, extract answers and output them for parsing\nComplex Entity Extraction**: Ask some more difficult questions which require tougher reasoning to work out\n\nWe've been able to extract the first two answers safely, while the third was confounded by the date that appeared on every page, though the correct answer is in there as well.\n\nTo tune this further you can consider experimenting with:\nA more descriptive or specific prompt\nIf you have sufficient training data, fine-tuning a model to find a set of outputs very well\nThe way you chunk your data - we have gone for 1000 tokens with no overlap, but more intelligent chunking that breaks info into sections, cuts by tokens or similar may get better results\n\nHowever, with minimal tuning we have now answered 6 questions of varying difficulty using the contents of a long document, and have a reusable approach that we can apply to any long document requiring entity extraction. Look forward to seeing what you can do with this!"])</script><script>self.__next_f.push([1,"5a:Tdfd,"])</script><script>self.__next_f.push([1,"We will fine-tune a babbage-002 classifier (replacement for the ada models) to distinguish between the two sports: Baseball and Hockey.\nData exploration\n The newsgroup dataset can be loaded using sklearn. First we will look at the data itself:\nOne sample from the baseball category can be seen above. It is an email to a mailing list. We can observe that we have 1197 examples in total, which are evenly split between the two sports.\nWe transform the dataset into a pandas dataframe, with a column for prompt and completion. The prompt contains the email from the mailing list, and the completion is a name of the sport, either hockey or baseball. For demonstration purposes only and speed of fine-tuning we take only 300 examples. In a real use case the more examples the better the performance.\nBoth baseball and hockey are single tokens. We save the dataset as a jsonl file.\nWe can now use a data preparation tool which will suggest a few improvements to our dataset before fine-tuning. Before launching the tool we update the openai library to ensure we're using the latest data preparation tool. We additionally specify -q which auto-accepts all suggestions.\nThe tool helpfully suggests a few improvements to the dataset and splits the dataset into training and validation set.\n\nA suffix between a prompt and a completion is necessary to tell the model that the input text has stopped, and that it now needs to predict the class. Since we use the same separator in each example, the model is able to learn that it is meant to predict either baseball or hockey following the separator.\nA whitespace prefix in completions is useful, as most word tokens are tokenized with a space prefix.\nThe tool also recognized that this is likely a classification task, so it suggested to split the dataset into training and validation datasets. This will allow us to easily measure expected performance on new data.\nThe tool suggests we run the following command to train the dataset. Since this is a classification task, we would like to know what the generalization performance on the provided validation set is for our classification use case.\n\nWe can simply copy the suggested command from the CLI tool. We specifically add -m ada to fine-tune a cheaper and faster ada model, which is usually comperable in performance to slower and more expensive models on classification use cases.\nThe model is successfully trained in about ten minutes. You can watch the finetune happen on https://platform.openai.com/finetune/\n\nYou can also check on its status programatically:\nWe can now download the results file to observe the expected performance on a held out validation set.\nThe accuracy reaches 99.6%. On the plot below we can see how accuracy on the validation set increases during the training run.\nWe can now call the model to get the predictions.\nWe need to use the same separator following the prompt which we used during fine-tuning. In this case it is \\n\\n###\\n\\n. Since we're concerned with classification, we want the temperature to be as low as possible, and we only require one token completion to determine the prediction of the model.\nTo get the log probabilities, we can specify logprobs parameter on the completion request\nWe can see that the model predicts hockey as a lot more likely than baseball, which is the correct prediction. By requesting log_probs, we can see the prediction (log) probability for each class.\nInterestingly, our fine-tuned classifier is quite versatile. Despite being trained on emails to different mailing lists, it also successfully predicts tweets."])</script><script>self.__next_f.push([1,"5b:T1621,"])</script><script>self.__next_f.push([1,"This notebook is centered around the integration of the Google Places API and custom user profiles to enhance location-based searches. Our approach involves using the Google Places API in combination with user preferences, aiming to make location discovery more personal and relevant. Please note that while we focus on the Google Places API in this instance, there are numerous other APIs you could explore and apply in a similar fashion.\n\nWe'll explore the application of three main components:\n\nCustomer profile: This mock profile captures individual preferences for types of places (e.g., restaurants, parks, museums), budget, preferred ratings, and other specific requirements.\n\nGoogle Places API: This API provides real-time data about nearby places. It factors in various data points such as ratings, types of venues, costs, and more from the locations around you.\n\nFunction calling: A single command such as \"I'm hungry\" or \"I want to visit a museum\" activates the function which combines the user profile data and Google Places API to identify suitable venues.\n\nThis notebook introduces two primary use cases:\n\nProfile-based recommendations: Learn how to create a user profile and make place recommendations based on individual preferences.\n\nAPI integration with function calling: Understand how to integrate and call Google Places API effectively to source real-time data of various places using function calling.\n\nPlease note that while this system is highly versatile, its effectiveness may vary based on user preferences and available place data. For the purposes of this notebook, the customer data is fake and the location is hardcoded.\n\nGoogle Places API\n\nTo use the Google Places API, you'll need two things:\n\nGoogle Account: If you don't already have one, you will need to create a Google account.\n\nGoogle Places API Key: The API key is a unique identifier that is used to authenticate requests associated with your project for usage and billing purposes. You can get your API key from the Google Cloud Console.\n\nPlease note that Google Places API is a paid service, and the cost is associated with the number of API calls made. Keep track of your usage to avoid any unexpected charges.\n\n\n\nThe requests library is also needed, you can download it by using the following command:\n\npip install requests\nIn this code snippet, we are defining a function fetch_customer_profile that accepts a user_id and returns a mock user profile.\n\nThis function simulates an API call that fetches user data from a database. For this demo, we're using hard-coded data. The user profile contains various details such as the user's location (set to the coordinates of the Golden Gate Bridge for this example), preferences in food and activities, app usage metrics, recent interactions, and user rank.\n\nIn a production environment, you would replace this hard-coded data with a real API call to your user database.\n\n\nThe function call_google_places_api serves to request information from the Google Places API and provide a list of the top two places based on a given place_type and optional food_preference. We've limited this function to the top two results to manage usage since this is a paid service. However, you can modify this to retrieve any number of results as per your requirement.\n\nThe function is configured with a hardcoded location (set to the coordinates of the Transamerica Pyramid), your Google API key, and specific request parameters. Depending on the place_type, it formulates the appropriate API request URL. If the place_type is a restaurant and a food_preference is specified, it is included in the API request.\n\nAfter sending the GET request, the function checks the response status. If it's successful, it processes the JSON response, extracts the relevant details using the get_place_details function, and returns them in a human-readable format. If the request fails, it prints out the error for debugging.\n\nThe get_place_details function is used to retrieve more detailed information about a place, given its place_id. It sends a GET request to the Google Place Details API and returns the result if the request is successful. If the request fails, it prints out the error for debugging.\n\nBoth functions handle exceptions and return an error message if something goes wrong.\n\nThe function provide_user_specific_recommendations interacts with GPT-3.5-Turbo and the Google Places API to provide responses tailored to a user's preferences and location.\n\nFirst, it fetches the customer's profile using their user_id. If no profile is found, it returns an error message.\n\nWith a valid profile, it extracts the customer's food preferences and then interacts with the OpenAI model. It provides an initial system message, giving context to the AI model about its role, user preferences, and the usage of the Google Places API function.\n\nThe user input is also sent to the model as a message, and the function call_google_places_api is defined in the functions parameter for the AI model to call as needed.\n\nFinally, it processes the model's response. If the model makes a function call to the Google Places API, the function is executed with the appropriate arguments, and the names of nearby places are returned. If there are no such places or the request isn't understood, appropriate error messages are returned.\n\n\nUpon execution, the function fetches the user's profile, interacts with the AI model, processes the model's response, calls the Google Places API if necessary, and ultimately returns a list of recommendations tailored to the user's preferences and location. The printed output would consist of these personalized recommendations."])</script><script>self.__next_f.push([1,"5c:T1486,"])</script><script>self.__next_f.push([1,"This notebook takes you through how to use LangChain to augment an OpenAI model with access to external tools. In particular, you'll be able to create LLM agents that use custom tools to answer user queries.\n\n\nLangChain is a framework for developing applications powered by language models. Their framework enables you to build layered LLM-powered applications that are context-aware and able to interact dynamically with their environment as agents, leading to simplified code for you and a more dynamic user experience for your customers.\n\nOne of the most common challenges with LLMs is overcoming the lack of recency and specificity in their training data - answers can be out of date, and they are prone to hallucinations given the huge variety in their knowledge base. Tools are a great method of allowing an LLM to answer within a controlled context that draws on your existing knowledge bases and internal APIs - instead of trying to prompt engineer the LLM all the way to your intended answer, you allow it access to tools that it calls on dynamically for info, parses, and serves to customer.\n\nProviding LLMs access to tools can enable them to answer questions with context directly from search engines, APIs or your own databases. Instead of answering directly, an LLM with access to tools can perform intermediate steps to gather relevant information. Tools can also be used in combination. For example, a language model can be made to use a search tool to lookup quantitative information and a calculator to execute calculations.\n\n\nSetup:** Import packages and connect to a Pinecone vector database.\nLLM Agent:** Build an agent that leverages a modified version of the ReAct framework to do chain-of-thought reasoning.\nLLM Agent with History:** Provide the LLM with access to previous steps in the conversation.\nKnowledge Base:** Create a knowledge base of \"Stuff You Should Know\" podcast episodes, to be accessed through a tool.\nLLM Agent with Tools:** Extend the agent with access to multiple tools and test that it uses them to answer questions.\n\nImport libraries and set up a connection to a Pinecone vector database.\n\nYou can substitute Pinecone for any other vectorstore or database - there are a selection that are supported by Langchain natively, while other connectors will need to be developed yourself.\nFor acquiring an API key to connect with Pinecone, you can set up a free account and store it in the api_key variable below or in your environment variables under PINECONE_API_KEY\nRun this code block if you want to clear the index, or if the index doesn't exist yet\n\nif index_name in pinecone.list_indexes():\n    pinecone.delete_index(index_name)\n\npinecone.create_index(name=index_name, dimension=1536)\nindex = pinecone.Index(index_name=index_name)\n\npinecone.list_indexes()\n\nAn LLM agent in Langchain has many configurable components, which are detailed in the Langchain documentation.\n\nWe'll employ a few of the core concepts to make an agent that talks in the way we want, can use tools to answer questions, and uses the appropriate language model to power the conversation.\nPrompt Template:** The input template to control the LLM's behaviour and how it accepts inputs and produces outputs - this is the brain that drives your application (docs).\nOutput Parser:** A method of parsing the output from the prompt. If the LLM produces output using certain headers, you can enable complex interactions where variables are generated by the LLM in their response and passed into the next step of the chain (docs).\nLLM Chain:* A Chain brings together a prompt template with an LLM that will execute it - in this case we'll be using Tool:* An external service that the LLM can use to retrieve information or execute commands should the user require it (docs).\nAgent:** The glue that brings all of this together, an agent can call multiple LLM Chains, each with their own tools. Agents can be extended with your own logic to allow retries, error handling and any other methods you choose to add reliability to your application (docs).\n\nNB: Before using this cookbook with the Search tool you'll need to sign up on https://serpapi.com/ and generate an API key. Once you have it, store it in an environment variable named\nExtend the LLM Agent with the ability to retain a memory and use it as context as it continues the conversation.\n\nWe use a simple\nCreate a custom vectorstore for the Agent to use as a tool to answer questions with. We'll store the results in Pinecone, which is supported by LangChain (Docs, API reference). For help getting started with Pinecone or other vector databases, we have a cookbook to help you get started.\n\nYou can check the LangChain documentation to see what other vectorstores and databases are available.\n\nFor this example we'll use the transcripts of the Stuff You Should Know podcast, which was provided thanks to OSF DOI 10.17605/OSF.IO/VM9NT\n\nExtend our list of tools by creating a RetrievalQA chain leveraging our Pinecone knowledge base.\nYou now have a template to deploy conversational agents with tools. If you want to extend this with a Custom Agent to add your own retry behaviour or treatment of input/output variables, then follow this article.\n\nWe look forward to seeing what you build!"])</script><script>self.__next_f.push([1,"5d:T59d,This notebook builds on the concepts in the argument generation notebook, by creating an agent with access to a knowledge base and two functions that it can call based on the user requirement.\n\nWe'll create an agent that uses data from arXiv to answer questions about academic subjects. It has two functions at its disposal:\nget_articles**: A function that gets arXiv articles on a subject and summarizes them for the user with links.\nread_article_and_summarize**: This function takes one of the previously searched articles, reads it in its entirety and summarizes the core argument, evidence and conclusions.\n\nThis will get you comfortable with a multi-function workflow that can choose from multiple services, and where some of the data from the first function is persisted to be used by the second.\n\n\nThis cookbook takes you through the following workflow:\n\nSearch utilities:** Creating the two functions that access arXiv for answers.\nConfigure Agent:** Building up the Agent behaviour that will assess the need for a function and, if one is required, call that function and present results back to the agent.\narXiv conversation:** Put all of this together in live conversation.\n\n\nWe'll first set up some utilities that will underpin our two functions.\n\nDownloaded papers will be stored in a directory (we use\nWe'll create our agent in this step, including a\nLet's put this all together by testing our functions out in conversation.5e:T1118,"])</script><script>self.__next_f.push([1,"This notebook covers how to use the Chat Completions API in combination with external functions to extend the capabilities of GPT models.\n\ntools is an optional parameter in the Chat Completion API which can be used to provide function specifications. The purpose of this is to enable models to generate function arguments which adhere to the provided specifications. Note that the API will not actually execute any function calls. It is up to developers to execute function calls using model outputs.\n\nWithin the tools parameter, if the functions parameter is provided then by default the model will decide when it is appropriate to use one of the functions. The API can be forced to use a specific function by setting the tool_choice parameter to {\"type\": \"function\", \"function\": {\"name\": \"my_function\"}}. The API can also be forced to not use any function by setting the tool_choice parameter to \"none\". If a function is used, the output will contain \"finish_reason\": \"tool_calls\" in the response, as well as a tool_calls object that has the name of the function and the generated function arguments.\n\n\nThis notebook contains the following 2 sections:\n\nHow to generate function arguments:** Specify a set of functions and use the API to generate function arguments.\nHow to call functions with model generated arguments:** Close the loop by actually executing functions with model generated arguments.\n\nFirst let's define a few utilities for making calls to the Chat Completions API and for maintaining and keeping track of the conversation state.\n\nLet's create some function specifications to interface with a hypothetical weather API. We'll pass these function specification to the Chat Completions API in order to generate function arguments that adhere to the specification.\nIf we prompt the model about the current weather, it will respond with some clarifying questions.\nOnce we provide the missing information, it will generate the appropriate function arguments for us.\nBy prompting it differently, we can get it to target the other function we've told it about.\nOnce again, the model is asking us for clarification because it doesn't have enough information yet. In this case it already knows the location for the forecast, but it needs to know how many days are required in the forecast.\nWe can force the model to use a specific function, for example get_n_day_weather_forecast by using the function_call argument. By doing so, we force the model to make assumptions about how to use it.\nWe can also force the model to not use a function at all. By doing so we prevent it from producing a proper function call.\n\nNewer models such as gpt-5, gpt-4.1 or gpt-4o can call multiple functions in one turn.\n\nIn our next example, we'll demonstrate how to execute functions whose inputs are model-generated, and use this to implement an agent that can answer questions for us about a database. For simplicity we'll use the Chinook sample database.\n\nNote: SQL generation can be high-risk in a production environment since models are not perfectly reliable at generating correct SQL.\n\nFirst let's define some helpful utility functions to extract data from a SQLite database.\nNow we can use these utility functions to extract a representation of the database schema.\nAs before, we'll define a function specification for the function we'd like the API to generate arguments for. Notice that we are inserting the database schema into the function specification. This will be important for the model to know about.\n\nNow let's implement the function that will actually excute queries against the database.\n\nStep 1: Prompt the model with content that may result in model selecting a tool to use. The description of the tools such as a function name and signature is defined in the 'Tools' list and passed to the model in API call. If selected, the function name and parameters are included in the response.\n\nStep 2: Check programmatically if model wanted to call a function. If true, proceed to step 3.\nStep 3: Extract the function name and parameters from response, call the function with parameters. Append the result to messages.\nStep 4: Invoke the chat completions API with the message list to get the response.\n\nSee our other notebook that demonstrates how to use the Chat Completions API and functions for knowledge retrieval to interact conversationally with a knowledge base."])</script><script>self.__next_f.push([1,"5f:T1142,"])</script><script>self.__next_f.push([1,"tiktoken is a fast open-source tokenizer by OpenAI.\n\nGiven a text string (e.g., \"tiktoken is great!\") and an encoding (e.g., \"cl100k_base\"), a tokenizer can split the text string into a list of tokens (e.g., [\"t\", \"ik\", \"token\", \" is\", \" great\", \"!\"]).\n\nSplitting text strings into tokens is useful because GPT models see text in the form of tokens. Knowing how many tokens are in a text string can tell you (a) whether the string is too long for a text model to process and (b) how much an OpenAI API call costs (as usage is priced by token).\n\n\n\nEncodings specify how text is converted into tokens. Different models use different encodings.\n\ntiktoken supports three encodings used by OpenAI models:\n\n| Encoding name           | OpenAI models                                       |\n|-------------------------|-----------------------------------------------------|\n| o200k_base            | gpt-4o, gpt-4o-mini                             |\n| cl100k_base           | gpt-4-turbo, gpt-4, gpt-3.5-turbo, text-embedding-ada-002, text-embedding-3-small, text-embedding-3-large  |\n| p50k_base             | Codex models, text-davinci-002, text-davinci-003|\n| r50k_base (or gpt2) | GPT-3 models like davinci                         |\n\nYou can retrieve the encoding for a model using tiktoken.encoding_for_model() as follows:\nencoding = tiktoken.encoding_for_model('gpt-4o-mini')\n\nNote that p50k_base overlaps substantially with r50k_base, and for non-code applications, they will usually give the same tokens.\n\n\nFor o200k_base, cl100k_base and p50k_base encodings:\nPython: tiktoken\n.NET / C#: SharpToken, TiktokenSharp\nJava: jtokkit\nGolang: tiktoken-go\nRust: tiktoken-rs\n\nFor r50k_base (gpt2) encodings, tokenizers are available in many languages.\nPython: tiktoken (or alternatively GPT2TokenizerFast)\nJavaScript: gpt-3-encoder\n.NET / C#: GPT Tokenizer\nJava: gpt2-tokenizer-java\nPHP: GPT-3-Encoder-PHP\nGolang: tiktoken-go\nRust: tiktoken-rs\n\n(OpenAI makes no endorsements or guarantees of third-party libraries.)\n\n\n\nIn English, tokens commonly range in length from one character to one word (e.g., \"t\" or \" great\"), though in some languages tokens can be shorter than one character or longer than one word. Spaces are usually grouped with the starts of words (e.g., \" is\" instead of \"is \" or \" \"+\"is\"). You can quickly check how a string is tokenized at the OpenAI Tokenizer, or the third-party Tiktokenizer webapp.\n\nIf needed, install tiktoken with pip:\n\nUse tiktoken.get_encoding() to load an encoding by name.\n\nThe first time this runs, it will require an internet connection to download. Later runs won't need an internet connection.\nUse tiktoken.encoding_for_model() to automatically load the correct encoding for a given model name.\n\n\nThe .encode() method converts a text string into a list of token integers.\nCount tokens by counting the length of the list returned by .encode().\n.decode() converts a list of token integers to a string.\nWarning: although .decode() can be applied to single tokens, beware that it can be lossy for tokens that aren't on utf-8 boundaries.\nFor single tokens, .decode_single_token_bytes() safely converts a single integer token to the bytes it represents.\n(The b in front of the strings indicates that the strings are byte strings.)\n\nDifferent encodings vary in how they split words, group spaces, and handle non-English characters. Using the methods above, we can compare different encodings on a few example strings.\n\nChatGPT models like gpt-4o-mini and gpt-4 use tokens in the same way as older completions models, but because of their message-based formatting, it's more difficult to count how many tokens will be used by a conversation.\n\nBelow is an example function for counting tokens for messages passed to gpt-3.5-turbo, gpt-4, gpt-4o and gpt-4o-mini.\n\nNote that the exact way that tokens are counted from messages may change from model to model. Consider the counts from the function below an estimate, not a timeless guarantee.\n\nIn particular, requests that use the optional functions input will consume extra tokens on top of the estimates calculated below.\n\nNext, we will look into how to apply this calculations to messages that may contain function calls. This is not immediately trivial, due to the formatting of the tools themselves.\n\nBelow is an example function for counting tokens for messages that contain tools, passed to gpt-3.5-turbo, gpt-4, gpt-4o and gpt-4o-mini."])</script><script>self.__next_f.push([1,"60:T1345,"])</script><script>self.__next_f.push([1,"Fine-tuning improves the model by training on many more examples than can fit in a prompt, letting you achieve better results on a wide number of tasks. This notebook provides a step-by-step guide for our new GPT-4o mini fine-tuning. We'll perform entity extraction using the RecipeNLG dataset, which provides various recipes and a list of extracted generic ingredients for each. This is a common dataset for named entity recognition (NER) tasks.\n\nNote: GPT-4o mini fine-tuning is available to developers in our Tier 4 and 5 usage tiers. You can start fine-tuning GPT-4o mini by visiting your fine-tuning dashboard, clicking \"create\", and selecting “gpt-4o-mini-2024-07-18” from the base model drop-down.\n\nWe will go through the following steps:\n\nSetup: Loading our dataset and filtering down to one domain to fine-tune on.\nData preparation: Preparing your data for fine-tuning by creating training and validation examples, and uploading them to the Files endpoint.\nFine-tuning: Creating your fine-tuned model.\nInference: Using your fine-tuned model for inference on new inputs.\n\nBy the end of this you should be able to train, evaluate and deploy a fine-tuned gpt-4o-mini-2024-07-18 model.\n\nFor more information on fine-tuning, you can refer to our documentation guide or API reference.\n\n\nFine-tuning works best when focused on a particular domain. It's important to make sure your dataset is both focused enough for the model to learn, but general enough that unseen examples won't be missed. Having this in mind, we have extracted a subset from the RecipesNLG dataset to only contain documents from cookbooks.com.\n\n\nWe'll begin by preparing our data. When fine-tuning with the ChatCompletion format, each training example is a simple list of messages. For example, an entry could look like:\n\n[{'role': 'system',\n  'content': 'You are a helpful recipe assistant. You are to extract the generic ingredients from each of the recipes provided.'},\n\n {'role': 'user',\n  'content': 'Title: No-Bake Nut Cookies\\n\\nIngredients: [\"1 c. firmly packed brown sugar\", \"1/2 c. evaporated milk\", \"1/2 tsp. vanilla\", \"1/2 c. broken nuts (pecans)\", \"2 Tbsp. butter or margarine\", \"3 1/2 c. bite size shredded rice biscuits\"]\\n\\nGeneric ingredients: '},\n\n {'role': 'assistant',\n  'content': '[\"brown sugar\", \"milk\", \"vanilla\", \"nuts\", \"butter\", \"bite size shredded rice biscuits\"]'}]\n\nDuring the training process this conversation will be split, with the final entry being the completion that the model will produce, and the remainder of the messages acting as the prompt. Consider this when building your training examples - if your model will act on multi-turn conversations, then please provide representative examples so it doesn't perform poorly when the conversation starts to expand.\n\nPlease note that currently there is a 4096 token limit for each training example. Anything longer than this will be truncated at 4096 tokens.\n\nLet's now do this for a subset of the dataset to use as our training data. You can begin with even 30-50 well-pruned examples. You should see performance continue to scale linearly as you increase the size of the training set, but your jobs will also take longer.\n\nIn addition to training data, we can also optionally provide validation data, which will be used to make sure that the model does not overfit your training set.\n\nWe then need to save our data as .jsonl files, with each line being one training example conversation.\n\nThis is what the first 5 lines of our training .jsonl file look like:\n\n\nYou can now upload the files to our Files endpoint to be used by the fine-tuned model.\n\n\nNow we can create our fine-tuning job with the generated files and an optional suffix to identify the model. The response will contain an id which you can use to retrieve updates on the job.\n\nNote: The files have to first be processed by our system, so you might get a File not ready error. In that case, simply retry a few minutes later.\n\n\nYou can make a GET request to the https://api.openai.com/v1/alpha/fine-tunes endpoint to list your alpha fine-tune jobs. In this instance you'll want to check that the ID you got from the previous step ends up as status: succeeded.\n\nOnce it is completed, you can use the result_files to sample the results from the validation set (if you uploaded one), and use the ID from the fine_tuned_model parameter to invoke your trained model.\n\nWe can track the progress of the fine-tune with the events endpoint. You can rerun the cell below a few times until the fine-tune is ready.\n\nNow that it's done, we can get a fine-tuned model ID from the job:\n\n\nThe last step is to use your fine-tuned model for inference. Similar to the classic FineTuning, you simply call ChatCompletions with your new fine-tuned model name filling the model parameter.\n\n\nCongratulations, you are now ready to fine-tune your own models using the ChatCompletion format! We look forward to seeing what you build"])</script><script>self.__next_f.push([1,"61:T18fe,"])</script><script>self.__next_f.push([1,"ChatGPT is powered by gpt-3.5-turbo and gpt-4, OpenAI's most advanced models.\n\nYou can build your own applications with gpt-3.5-turbo or gpt-4 using the OpenAI API.\n\nChat models take a series of messages as input, and return an AI-written message as output.\n\nThis guide illustrates the chat format with a few example API calls.\n\nA chat completion API call parameters,\nRequired\nmodel: the name of the model you want to use (e.g., gpt-3.5-turbo, gpt-4, gpt-3.5-turbo-16k-1106)\nmessages: a list of message objects, where each object has two required fields:\n    role: the role of the messenger (either system, user, assistant or tool)\n    content: the content of the message (e.g., Write me a beautiful poem)\n\nMessages can also contain an optional name field, which give the messenger a name. E.g., example-user, Alice, BlackbeardBot. Names may not contain spaces.\n\nOptional\nfrequency_penalty: Penalizes tokens based on their frequency, reducing repetition.\nlogit_bias: Modifies likelihood of specified tokens with bias values.\nlogprobs: Returns log probabilities of output tokens if true.\ntop_logprobs: Specifies the number of most likely tokens to return at each position.\nmax_tokens: Sets the maximum number of generated tokens in chat completion.\nn: Generates a specified number of chat completion choices for each input.\npresence_penalty: Penalizes new tokens based on their presence in the text.\nresponse_format: Specifies the output format, e.g., JSON mode.\nseed: Ensures deterministic sampling with a specified seed.\nstop: Specifies up to 4 sequences where the API should stop generating tokens.\nstream: Sends partial message deltas as tokens become available.\ntemperature: Sets the sampling temperature between 0 and 2.\ntop_p: Uses nucleus sampling; considers tokens with top_p probability mass.\ntools: Lists functions the model may call.\ntool_choice: Controls the model's function calls (none/auto/function).\nuser: Unique identifier for end-user monitoring and abuse detection.\n\n\nAs of January 2024, you can also optionally submit a list of functions that tell GPT whether it can generate JSON to feed into a function. For details, see the documentation, API reference, or the Cookbook guide How to call functions with chat models.\n\nTypically, a conversation will start with a system message that tells the assistant how to behave, followed by alternating user and assistant messages, but you are not required to follow this format.\n\nLet's look at an example chat API calls to see how the chat format works in practice.\nAs you can see, the response object has a few fields:\nid: the ID of the request\nchoices: a list of completion objects (only one, unless you set n greater than 1)\n    finish_reason: the reason the model stopped generating text (either stop, or length if max_tokens limit was reached)\n    index: The index of the choice in the list of choices.\n    logprobs: Log probability information for the choice.\n    message: the message object generated by the model\n        content: content of message\n        role: The role of the author of this message.\n        tool_calls: The tool calls generated by the model, such as function calls. if the tools is given\ncreated: the timestamp of the request\nmodel: the full name of the model used to generate the response\nobject: the type of object returned (e.g., chat.completion)\nsystem_fingerprint: This fingerprint represents the backend configuration that the model runs with.\nusage: the number of tokens used to generate the replies, counting prompt, completion, and total\nExtract just the reply with:\nEven non-conversation-based tasks can fit into the chat format, by placing the instruction in the first user message.\n\nFor example, to ask the model to explain asynchronous programming in the style of the pirate Blackbeard, we can structure conversation as follows:\n\nBest practices for instructing models may change from model version to model version. The advice that follows applies to gpt-3.5-turbo-0301 and may not apply to future models.\n\nThe system message can be used to prime the assistant with different personalities or behaviors.\n\nBe aware that gpt-3.5-turbo-0301 does not generally pay as much attention to the system message as gpt-4-0314 or gpt-3.5-turbo-0613. Therefore, for gpt-3.5-turbo-0301, we recommend placing important instructions in the user message instead. Some developers have found success in continually moving the system message near the end of the conversation to keep the model's attention from drifting away as conversations get longer.\n\nIn some cases, it's easier to show the model what you want rather than tell the model what you want.\n\nOne way to show the model what you want is with faked example messages.\n\nFor example:\nTo help clarify that the example messages are not part of a real conversation, and shouldn't be referred back to by the model, you can try setting the name field of system messages to example_user and example_assistant.\n\nTransforming the few-shot example above, we could write:\nNot every attempt at engineering conversations will succeed at first.\n\nIf your first attempts fail, don't be afraid to experiment with different ways of priming or conditioning the model.\n\nAs an example, one developer discovered an increase in accuracy when they inserted a user message that said \"Great job so far, these have been perfect\" to help condition the model into providing higher quality responses.\n\nFor more ideas on how to lift the reliability of the models, consider reading our guide on techniques to increase reliability. It was written for non-chat models, but many of its principles still apply.\n\nWhen you submit your request, the API transforms the messages into a sequence of tokens.\n\nThe number of tokens used affects:\nthe cost of the request\nthe time it takes to generate the response\nwhen the reply gets cut off from hitting the maximum token limit (4,096 for gpt-3.5-turbo or 8,192 for gpt-4)\n\nYou can use the following function to count the number of tokens that a list of messages will use.\n\nNote that the exact way that tokens are counted from messages may change from model to model. Consider the counts from the function below an estimate, not a timeless guarantee.\n\nIn particular, requests that use the optional functions input will consume extra tokens on top of the estimates calculated below.\n\nRead more about counting tokens in How to count tokens with tiktoken."])</script><script>self.__next_f.push([1,"62:T220d,"])</script><script>self.__next_f.push([1,"When you call the OpenAI API repeatedly, you may encounter error messages that say 429: 'Too Many Requests' or RateLimitError. These error messages come from exceeding the API's rate limits.\n\nThis guide shares tips for avoiding and handling rate limit errors.\n\nTo see an example script for throttling parallel requests to avoid rate limit errors, see api_request_parallel_processor.py.\n\n\nRate limits are a common practice for APIs, and they're put in place for a few different reasons.\n\nFirst, they help protect against abuse or misuse of the API. For example, a malicious actor could flood the API with requests in an attempt to overload it or cause disruptions in service. By setting rate limits, OpenAI can prevent this kind of activity.\nSecond, rate limits help ensure that everyone has fair access to the API. If one person or organization makes an excessive number of requests, it could bog down the API for everyone else. By throttling the number of requests that a single user can make, OpenAI ensures that everyone has an opportunity to use the API without experiencing slowdowns.\nLastly, rate limits can help OpenAI manage the aggregate load on its infrastructure. If requests to the API increase dramatically, it could tax the servers and cause performance issues. By setting rate limits, OpenAI can help maintain a smooth and consistent experience for all users.\n\nAlthough hitting rate limits can be frustrating, rate limits exist to protect the reliable operation of the API for its users.\n\nYour rate limit and spending limit (quota) are automatically adjusted based on a number of factors. As your usage of the OpenAI API goes up and you successfully pay the bill, we automatically increase your usage tier. You can find specific information regarding rate limits using the resources below.\n\n\nRead more about OpenAI's rate limits in these other resources:\n\nGuide: Rate limits\nHelp Center: Is API usage subject to any rate limits?\nHelp Center: How can I solve 429: 'Too Many Requests' errors?\n\n\nTo learn more about increasing your organization's usage tier and rate limit, visit your Limits settings page.\n\nA rate limit error will occur when API requests are sent too quickly. If using the OpenAI Python library, they will look something like:\n\nRateLimitError: Rate limit reached for default-codex in organization org-{id} on requests per min. Limit: 20.000000 / min. Current: 24.000000 / min. Contact support@openai.com if you continue to have issues or if you’d like to request an increase.\n\nBelow is example code for triggering a rate limit error.\n\n\nOne easy way to mitigate rate limit errors is to automatically retry requests with a random exponential backoff. Retrying with exponential backoff means performing a short sleep when a rate limit error is hit, then retrying the unsuccessful request. If the request is still unsuccessful, the sleep length is increased and the process is repeated. This continues until the request is successful or until a maximum number of retries is reached.\n\nThis approach has many benefits:\n\nAutomatic retries means you can recover from rate limit errors without crashes or missing data\nExponential backoff means that your first retries can be tried quickly, while still benefiting from longer delays if your first few retries fail\nAdding random jitter to the delay helps retries from all hitting at the same time\n\nNote that unsuccessful requests contribute to your per-minute limit, so continuously resending a request won’t work.\n\nBelow are a few example solutions.\n\nTenacity is an Apache 2.0 licensed general-purpose retrying library, written in Python, to simplify the task of adding retry behavior to just about anything.\n\nTo add exponential backoff to your requests, you can use the tenacity.retry decorator. The following example uses the tenacity.wait_random_exponential function to add random exponential backoff to a request.\n\nNote that the Tenacity library is a third-party tool, and OpenAI makes no guarantees about its reliability or security.\n\nAnother library that provides function decorators for backoff and retry is backoff.\n\nLike Tenacity, the backoff library is a third-party tool, and OpenAI makes no guarantees about its reliability or security.\n\nIf you don't want to use third-party libraries, you can implement your own backoff logic.\n\nIf you encounter rate limit errors on your primary model, one option is to switch to a secondary model. This approach helps keep your application responsive when your primary model is throttled or unavailable.\n\nHowever, fallback models can differ significantly in accuracy, latency, and cost. As a result, this strategy might not work for every use case; particularly those requiring highly consistent results. Additionally, keep in mind that some models share rate limits, which may reduce the effectiveness of simply switching models. You can see the models that share limits in your organizations limit page.\n\nBefore deploying this approach to production, thoroughly test how it affects output quality, user experience, and operational budgets. Validate your fallback solution with relevant evaluations to ensure it meets your requirements and maintains acceptable performance under real-world conditions.\n\nRate limit usage is calculated based on the greater of:\nmax_tokens - the maximum number of tokens allowed in a response.\nEstimated tokens in your input – derived from your prompt’s character count.\n\nIf you set max_tokens too high, your usage can be overestimated, even if the actual response is much shorter. To avoid hitting rate limits prematurely, configure max_tokens so it closely matches the size of the response you expect. This ensures more accurate usage calculations and helps prevent unintended throttling.\n\nIf you're processing real-time requests from users, backoff and retry is a great strategy to minimize latency while avoiding rate limit errors.\n\nHowever, if you're processing large volumes of batch data, where throughput matters more than latency, there are a few other things you can do in addition to backoff and retry.\n\n\nIf you are constantly hitting the rate limit, then backing off, then hitting the rate limit again, then backing off again, it's possible that a good fraction of your request budget will be 'wasted' on requests that need to be retried. This limits your processing throughput, given a fixed rate limit.\n\nHere, one potential solution is to calculate your rate limit and add a delay equal to its reciprocal (e.g., if your rate limit 20 requests per minute, add a delay of 3–6 seconds to each request). This can help you operate near the rate limit ceiling without hitting it and incurring wasted requests.\n\n\nThe OpenAI API enforces separate limits for requests per minute/day (RPM/RPD) and tokens per minute (TPM). If you’re hitting RPM limits but still have available TPM capacity, consider batching multiple tasks into each request.\n\nBy bundling several prompts together, you reduce the total number of requests sent per minute, which helps avoid hitting the RPM cap. This approach may also lead to higher overall throughput if you manage your TPM usage carefully. However, keep the following points in mind:\nEach model has a maximum number of tokens it can process in one request. If your batched prompt exceeds this limit, the request will fail or be truncated.\nBatching can introduce extra waiting time if tasks are delayed until they’re grouped into a single request. This might affect user experience for time-sensitive applications.\nWhen sending multiple prompts, the response object may not return in the same order or format as the prompts that were submitted. You should try to match each response back to its corresponding prompt by post-processing the output.\n\nOpenAI's Structured Outputs feature offers a robust way to batch multiple prompts in a single request.\n\nHere, rather than parsing raw text or hoping the model follows informal formatting, you specify a strict schema. This ensures your application can reliably parse the results by examining the defined structure. This eliminates the need for extensive validation or complicated parsing logic, as Structured Outputs guarantees consistent, type-safe data.\n\nWe've written an example script for parallel processing large quantities of API requests: api_request_parallel_processor.py.\n\nThe script combines some handy features:\nStreams requests from file, to avoid running out of memory for giant jobs\nMakes requests concurrently, to maximize throughput\nThrottles both request and token usage, to stay under rate limits\nRetries failed requests, to avoid missing data\nLogs errors, to diagnose problems with requests\n\nFeel free to use it as is or modify it to suit your needs."])</script><script>self.__next_f.push([1,"63:Tb2e,"])</script><script>self.__next_f.push([1,"By default, when you request a completion from the OpenAI, the entire completion is generated before being sent back in a single response.\n\nIf you're generating long completions, waiting for the response can take many seconds.\n\nTo get responses sooner, you can 'stream' the completion as it's being generated. This allows you to start printing or processing the beginning of the completion before the full completion is finished.\n\nTo stream completions, set stream=True when calling the chat completions or completions endpoints. This will return an object that streams back the response as data-only server-sent events. Extract chunks from the delta field rather than the message field.\n\n\nNote that using stream=True in a production application makes it more difficult to moderate the content of the completions, as partial completions may be more difficult to evaluate. This may have implications for approved usage.\n\n\nBelow, this notebook shows:\nWhat a typical chat completion response looks like\nWhat a streaming chat completion response looks like\nHow much time is saved by streaming a chat completion\nHow to get token usage data for streamed chat completion response\n\nWith a typical ChatCompletions API call, the response is first computed and then returned all at once.\nThe reply can be extracted with response.choices[0].message.\n\nThe content of the reply can be extracted with response.choices[0].message.content.\n\nWith a streaming API call, the response is sent back incrementally in chunks via an event stream. In Python, you can iterate over these events with a for loop.\n\nLet's see what it looks like:\nAs you can see above, streaming responses have a delta field rather than a message field. delta can hold things like:\na role token (e.g., {\"role\": \"assistant\"})\na content token (e.g., {\"content\": \"\\n\\n\"})\nnothing (e.g., {}), when the stream is over\n\nNow let's ask gpt-4o-mini to count to 100 again, and see how long it takes.\n\nIn the example above, both requests took about 4 to 5 seconds to fully complete. Request times will vary depending on load and other stochastic factors.\n\nHowever, with the streaming request, we received the first token after 0.1 seconds, and subsequent tokens every ~0.01-0.02 seconds.\n\nYou can get token usage statistics for your streamed response by setting stream_options={\"include_usage\": True}. When you do so, an extra chunk will be streamed as the final chunk. You can access the usage data for the entire request via the usage field on this chunk. A few important notes when you set stream_options={\"include_usage\": True}:\nThe value for the usage field on all chunks except for the last one will be null.\nThe usage field on the last chunk contains token usage statistics for the entire request.\nThe choices field on the last chunk will always be an empty array [].\n\nLet's see how it works using the example in 2."])</script><script>self.__next_f.push([1,"64:Tfe9,"])</script><script>self.__next_f.push([1,"For this notebook we will be looking to classify a public dataset of transactions into a number of categories that we have predefined. These approaches should be replicable to any multiclass classification use case where we are trying to fit transactional data into predefined categories, and by the end of running through this you should have a few approaches for dealing with both labelled and unlabelled datasets.\n\nThe different approaches we'll be taking in this notebook are:\nZero-shot Classification:** First we'll do zero shot classification to put transactions in one of five named buckets using only a prompt for guidance\nClassification with Embeddings:** Following this we'll create embeddings on a labelled dataset, and then use a traditional classification model to test their effectiveness at identifying our categories\nFine-tuned Classification:** Lastly we'll produce a fine-tuned model trained on our labelled dataset to see how this compares to the zero-shot and few-shot classification approaches\n\nWe're using a public transaction dataset of transactions over £25k for the Library of Scotland. The dataset has three features that we'll be using:\nSupplier: The name of the supplier\nDescription: A text description of the transaction\nValue: The value of the transaction in GBP\n\nSource:\n\nhttps://data.nls.uk/data/organisational-data/transactions-over-25k/\n\nWe'll first assess the performance of the base models at classifying these transactions using a simple prompt. We'll provide the model with 5 categories and a catch-all of \"Could not classify\" for ones that it cannot place.\nOur first attempt is correct, M \u0026 J Ballantyne Ltd are a house builder and the work they performed is indeed Building Improvement.\n\nLets expand the sample size to 25 and see how it performs, again with just a simple prompt to guide it\nInitial results are pretty good even with no labelled examples! The ones that it could not classify were tougher cases with few clues as to their topic, but maybe if we clean up the labelled dataset to give more examples we can get better performance.\n\nLets create embeddings from the small set that we've classified so far - we've made a set of labelled examples by running the zero-shot classifier on 101 transactions from our dataset and manually correcting the 15 Could not classify results that we got\n\n\nThis initial section reuses the approach from the Get_embeddings_from_dataset Notebook to create embeddings from a combined field concatenating all of our features\n\nNow that we have our embeddings, let see if classifying these into the categories we've named gives us any more success.\n\nFor this we'll use a template from the Classification_using_embeddings notebook\nPerformance for this model is pretty strong, so creating embeddings and using even a simpler classifier looks like an effective approach as well, with the zero-shot classifier helping us do the initial classification of the unlabelled dataset.\n\nLets take it one step further and see if a fine-tuned model trained on this same labelled datasets gives us comparable results\n\nFor this use case we're going to try to improve on the few-shot classification from above by training a fine-tuned model on the same labelled set of 101 transactions and applying this fine-tuned model on group of unseen transactions\n\nWe'll need to do some data prep first to get our data ready. This will take the following steps:\nTo prepare our training and validation sets, we'll create a set of message sequences. The first message for each will be the user prompt formatted with the details of the transaction, and the final message will be the expected classification response from the model\nOur test set will contain the initial user prompt for each transaction, along with the corresponding expected class label. We will then use the fine-tuned model to generate the actual classification for each transaction.\n\nNow we'll apply our classifier to see how it performs. We only had 31 unique observations in our training set and 8 in our validation set, so lets see how the performance is"])</script><script>self.__next_f.push([1,"65:Te33,"])</script><script>self.__next_f.push([1,"Searching for relevant information can sometimes feel like looking for a needle in a haystack, but don’t despair, GPTs can actually do a lot of this work for us. In this guide we explore a way to augment existing search systems with various AI techniques, helping us sift through the noise.\n\nTwo ways of retrieving information for GPT are:\n\nMimicking Human Browsing: GPT triggers a search, evaluates the results, and modifies the search query if necessary. It can also follow up on specific search results to form a chain of thought, much like a human user would do.\nRetrieval with Embeddings: Calculate embeddings for your content and a user query, and then retrieve the content most related as measured by cosine similarity. This technique is used heavily by search engines like Google.\n\nThese approaches are both promising, but each has their shortcomings: the first one can be slow due to its iterative nature and the second one requires embedding your entire knowledge base in advance, continuously embedding new content and maintaining a vector database.\n\nBy combining these approaches, and drawing inspiration from re-ranking methods, we identify an approach that sits in the middle. This approach can be implemented on top of any existing search system, like the Slack search API, or an internal ElasticSearch instance with private data. Here’s how it works:\n\nsearch_augmented_by_query_generation_and_embeddings_reranking.png\n\nStep 1: Search\n\nUser asks a question.\nGPT generates a list of potential queries.\nSearch queries are executed in parallel.\n\nStep 2: Re-rank\n\nEmbeddings for each result are used to calculate semantic similarity to a generated hypothetical ideal answer to the user question.\nResults are ranked and filtered based on this similarity metric.\n\nStep 3: Answer\n\nGiven the top search results, the model generates an answer to the user’s question, including references and links.\n\nThis hybrid approach offers relatively low latency and can be integrated into any existing search endpoint, without requiring the upkeep of a vector database. Let's dive into it! We will use the News API as an example domain to search over.\n\n\nIn addition to your OPENAI_API_KEY, you'll have to include a NEWS_API_KEY in your environment. You can get an API key here.\n\n\nIt all starts with a user question.\n\nNow, in order to be as exhaustive as possible, we use the model to generate a list of diverse queries based on this question.\n\nThe queries look good, so let's run the searches.\n\nAs we can see, oftentimes, the search queries will return a large number of results, many of which are not relevant to the original question asked by the user. In order to improve the quality of the final answer, we use embeddings to re-rank and filter the results.\n\n\nDrawing inspiration from HyDE (Gao et al.), we first generate a hypothetical ideal answer to rerank our compare our results against. This helps prioritize results that look like good answers, rather than those similar to our question. Here’s the prompt we use to generate our hypothetical answer.\n\nNow, let's generate embeddings for the search results and the hypothetical answer. We then calculate the cosine distance between these embeddings, giving us a semantic similarity metric. Note that we can simply calculate the dot product in lieu of doing a full cosine similarity calculation since the OpenAI embeddings are returned normalized in our API.\n\nFinally, we use these similarity scores to sort and filter the results.\n\nAwesome! These results look a lot more relevant to our original query. Now, let's use the top 5 results to generate a final answer.\n\n3. Answer"])</script><script>self.__next_f.push([1,"66:T2076,"])</script><script>self.__next_f.push([1,"GPT excels at answering questions, but only on topics it remembers from its training data.\n\nWhat should you do if you want GPT to answer questions about unfamiliar topics? E.g.,\nRecent events after October 2023 for GPT 4 series models\nYour non-public documents\nInformation from past conversations\netc.\n\nThis notebook demonstrates a two-step Search-Ask method for enabling GPT to answer questions using a library of reference text.\n\nSearch: search your library of text for relevant text sections\nAsk: insert the retrieved text sections into a message to GPT and ask it the question\n\nGPT can learn knowledge in two ways:\n\nVia model weights (i.e., fine-tune the model on a training set)\nVia model inputs (i.e., insert the knowledge into an input message)\n\nAlthough fine-tuning can feel like the more natural option—training on data is how GPT learned all of its other knowledge, after all—we generally do not recommend it as a way to teach the model knowledge. Fine-tuning is better suited to teaching specialized tasks or styles, and is less reliable for factual recall.\n\nAs an analogy, model weights are like long-term memory. When you fine-tune a model, it's like studying for an exam a week away. When the exam arrives, the model may forget details, or misremember facts it never read.\n\nIn contrast, message inputs are like short-term memory. When you insert knowledge into a message, it's like taking an exam with open notes. With notes in hand, the model is more likely to arrive at correct answers.\n\nOne downside of text search relative to fine-tuning is that each model is limited by a maximum amount of text it can read at once:\n\n| Model           | Maximum text length       |\n|-----------------|---------------------------|\n| gpt-4o-mini   | 128,000 tokens (~384 pages)|\n| gpt-4o        | 128,000 tokens (~384 pages)|\n\n\nContinuing the analogy, you can think of the model like a student who can only look at a few pages of notes at a time, despite potentially having shelves of textbooks to draw upon.\n\nTherefore, to build a system capable of drawing upon large quantities of text to answer questions, we recommend using a Search-Ask approach.\n\n\nText can be searched in many ways. E.g.,\n\nLexical-based search\nGraph-based search\nEmbedding-based search\n\nThis example notebook uses embedding-based search. Embeddings are simple to implement and work especially well with questions, as questions often don't lexically overlap with their answers.\n\nConsider embeddings-only search as a starting point for your own system. Better search systems might combine multiple search methods, along with features like popularity, recency, user history, redundancy with prior search results, click rate data, etc. Q\u0026A retrieval performance may also be improved with techniques like HyDE, in which questions are first transformed into hypothetical answers before being embedded. Similarly, GPT can also potentially improve search results by automatically transforming questions into sets of keywords or search terms.\n\nSpecifically, this notebook demonstrates the following procedure:\n\nPrepare search data (once per document)\n    Collect: We'll download a few hundred Wikipedia articles about the 2022 Olympics\n    Chunk: Documents are split into short, mostly self-contained sections to be embedded\n    Embed: Each section is embedded with the OpenAI API\n    Store: Embeddings are saved (for large datasets, use a vector database)\nSearch (once per query)\n    Given a user question, generate an embedding for the query from the OpenAI API\n    Using the embeddings, rank the text sections by relevance to the query\nAsk (once per query)\n    Insert the question and the most relevant sections into a message to GPT\n    Return GPT's answer\n\n\nBecause GPT models are more expensive than embeddings search, a system with a decent volume of queries will have its costs dominated by step 3.\n\nFor gpt-4o, considering 1000 tokens per query, it costs $0.0025 per query, or ~450 queries per dollar (as of Nov 2024)\nFor gpt-4o-mini, using 1000 tokens per query, it costs $0.00015 per query, or ~6000 queries per dollar (as of Nov 2024)\n\nOf course, exact costs will depend on the system specifics and usage patterns.\n\nWe'll begin by:\nImporting the necessary libraries\nSelecting models for embeddings search and question answering\n\n\n\nIf you need to install any of the libraries above, run pip install {library_name} in your terminal.\n\nFor example, to install the openai library, run:\npip install openai\n\n(You can also do this in a notebook cell with !pip install openai or %pip install openai.)\n\nAfter installing, restart the notebook kernel so the libraries can be loaded.\n\n\nThe OpenAI library will try to read your API key from the OPENAI_API_KEY environment variable. If you haven't already, you can set this environment variable by following these instructions.\n\nBecause the training data for gpt-4o-mini mostly ended in October 2023, the models cannot answer questions about more recent events, such as the 2024 Elections or recent games.\n\nFor example, let's try asking 'How many ?':\nIn this case, the model has no knowledge of 2024 and is unable to answer the question. In a similar way, if you ask a question pertaining to a recent political event (that occured in Nov 2024 for example), GPT-4o-mini models will not be able to answer due to its knowledge cut-off date of Oct 2023.\n\nTo help give the model knowledge of curling at the 2022 Winter Olympics, we can copy and paste the top half of a relevant Wikipedia article into our message:\nThanks to the Wikipedia article included in the input message, GPT answers correctly.\n\nOf course, this example partly relied on human intelligence. We knew the question was about summer olympics, so we inserted a Wikipedia article about 2024 paris olympics game.\n\nThe rest of this notebook shows how to automate this knowledge insertion with embeddings-based search.\n\nTo save you the time \u0026 expense, we've prepared a pre-embedded dataset of a few hundred Wikipedia articles about the 2022 Winter Olympics.\n\nTo see how we constructed this dataset, or to modify it yourself, see Embedding Wikipedia articles for search.\n\nNow we'll define a search function that:\nTakes a user query and a dataframe with text \u0026 embedding columns\nEmbeds the user query with the OpenAI API\nUses distance between query embedding and text embeddings to rank the texts\nReturns two lists:\n    The top N texts, ranked by relevance\n    Their corresponding relevance scores\n\nWith the search function above, we can now automatically retrieve relevant knowledge and insert it into messages to GPT.\n\nBelow, we define a function ask that:\nTakes a user query\nSearches for text relevant to the query\nStuffs that text into a message for GPT\nSends the message to GPT\nReturns GPT's answer\n\nFinally, let's ask our system our original question about gold medal curlers:\nWith latest model and using embedding search, our search system was able to retrieve reference text for the model to read, allowing it to correctly list the gold medal winners in the Men's and Women's tournaments.\nIn case we get any mistakes in the output, we can see whether a mistake is from a lack of relevant source text (i.e., failure of the search step) or a lack of reasoning reliability (i.e., failure of the ask step), you can look at the text GPT was given by setting print_message=True.\n\nIn this particular case, looking at the text below, it looks like the #1 article given to the model did contain medalists for all three events, but the later results emphasized the Men's and Women's tournaments, which may have distracted the model from giving a more complete answer.\nKnowing that sometimes, this mistake can be due to imperfect reasoning in the ask step, than imperfect retrieval in the search step, one can focus on improving the ask step.\n\nThe easiest way to improve results is to use a more capable models, such as GPT-4o-mini or GPT-4o models. Let's try it.\nGPT-4 models tend to succeed, correctly identifying all 12 gold medal winners in curling.\n\nBelow are a few more examples of the system in action. Feel free to try your own questions, and see how it does. In general, search-based systems do best on questions that have a simple lookup, and worst on questions that require multiple partial sources to be combined and reasoned about."])</script><script>self.__next_f.push([1,"67:T10ed,"])</script><script>self.__next_f.push([1,"Recommendations are widespread across the web.\n\n'Bought that item? Try these similar items.'\n'Enjoy that book? Try these similar titles.'\n'Not the help page you were looking for? Try these similar pages.'\n\nThis notebook demonstrates how to use embeddings to find similar items to recommend. In particular, we use AG's corpus of news articles as our dataset.\n\nOur model will answer the question: given an article, what other articles are most similar to it?\n\nNext, let's load the AG news data and see what it looks like.\nLet's take a look at those same examples, but not truncated by ellipses.\n\nBefore getting embeddings for these articles, let's set up a cache to save the embeddings we generate. In general, it's a good idea to save your embeddings so you can re-use them later. If you don't save them, you'll pay again each time you compute them again.\n\nThe cache is a dictionary that maps tuples of (text, model) to an embedding, which is a list of floats. The cache is saved as a Python pickle file.\nLet's check that it works by getting an embedding.\n\nTo find similar articles, let's follow a three-step plan:\nGet the similarity embeddings of all the article descriptions\nCalculate the distance between a source title and all other articles\nPrint out the other articles closest to the source title\n\nLet's look for articles similar to first one, which was about Tony Blair.\nPretty good! 4 of the 5 recommendations explicitly mention Tony Blair and the fifth is an article from London about climate change, topics that might be often associated with Tony Blair.\nLet's see how our recommender does on the second example article about NVIDIA's new chipset with more security.\nFrom the printed distances, you can see that the #1 recommendation is much closer than all the others (0.11 vs 0.14+). And the #1 recommendation looks very similar to the starting article - it's another article from PC World about increasing computer security. Pretty good!\n\nA more sophisticated way to build a recommender system is to train a machine learning model that takes in tens or hundreds of signals, such as item popularity or user click data. Even in this system, embeddings can be a very useful signal into the recommender, especially for items that are being 'cold started' with no user data yet (e.g., a brand new product added to the catalog without any clicks yet).\nTo get a sense of what our nearest neighbor recommender is doing, let's visualize the article embeddings. Although we can't plot the 2048 dimensions of each embedding vector, we can use techniques like t-SNE or PCA to compress the embeddings down into 2 or 3 dimensions, which we can chart.\n\nBefore visualizing the nearest neighbors, let's visualize all of the article descriptions using t-SNE. Note that t-SNE is not deterministic, meaning that results may vary from run to run.\nAs you can see in the chart above, even the highly compressed embeddings do a good job of clustering article descriptions by category. And it's worth emphasizing: this clustering is done with no knowledge of the labels themselves!\n\nAlso, if you look closely at the most egregious outliers, they are often due to mislabeling rather than poor embedding. For example, the majority of the blue World points in the green Sports cluster appear to be Sports stories.\nNext, let's recolor the points by whether they are a source article, its nearest neighbors, or other.\nLooking at the 2D chart above, we can see that the articles about Tony Blair are somewhat close together inside of the World news cluster. Interestingly, although the 5 nearest neighbors (red) were closest in high dimensional space, they are not the closest points in this compressed 2D space. Compressing the embeddings down to 2 dimensions discards much of their information, and the nearest neighbors in the 2D space don't seem to be as relevant as those in the full embedding space.\nFor the chipset security example, the 4 closest nearest neighbors in the full embedding space remain nearest neighbors in this compressed 2D visualization. The fifth is displayed as more distant, despite being closer in the full embedding space.\nShould you want to, you can also make an interactive 3D plot of the embeddings with the function chart_from_components_3D. (Doing so will require recomputing the t-SNE components with n_components=3.)"])</script><script>self.__next_f.push([1,"68:Tdc2,"])</script><script>self.__next_f.push([1,"This notebook takes you through examples of using a cross-encoder to re-rank search results.\n\nThis is a common use case with our customers, where you've implemented semantic search using embeddings (produced using a bi-encoder) but the results are not as accurate as your use case requires. A possible cause is that there is some business rule you can use to rerank the documents such as how recent or how popular a document is.\n\nHowever, often there are subtle domain-specific rules that help determine relevancy, and this is where a cross-encoder can be useful. Cross-encoders are more accurate than bi-encoders but they don't scale well, so using them to re-order a shortened list returned by semantic search is the ideal use case.\n\n\nConsider a search task with D documents and Q queries.\n\nThe brute force approach of computing every pairwise relevance is expensive; its cost scales as\nA faster approach is embeddings-based search, in which an embedding is computed once for each document and query, and then re-used multiple times to cheaply compute pairwise relevance. Because embeddings are only computed once, its cost scales as\nAlthough embeddings-based search is faster, the quality can be worse. To get the best of both, one common approach is to use embeddings (or another bi-encoder) to cheaply identify top candidates, and then use GPT (or another cross-encoder) to expensively re-rank those top candidates. The cost of this hybrid approach scales as\n\nTo illustrate this approach we'll use\nThis notebook drew on this great article by Weaviate, and this excellent explanation of bi-encoders vs. cross-encoders from Sentence Transformers.\n\nWe'll use the arXiv search service for this example, but this step could be performed by any search service you have. The key item to consider is over-fetching slightly to capture all the potentially relevant documents, before re-sorting them.\n\n\nWe'll create a cross-encoder using the Make your examples domain-specific - the strength of cross-encoders comes when you tailor them to your domain.\nThere is a trade-off between how many potential examples to re-rank vs. processing speed. Consider batching and parallel processing cross-encoder requests to process them more quickly.\n\nThe steps here are:\nBuild a prompt to assess relevance and provide few-shot examples to tune it to your domain.\nAdd a Return the classification of yes/no as well as the Rerank the results by the\nWe've shown how to create a tailored cross-encoder to rerank academic papers. This approach will work best where there are domain-specific nuances that can be used to pick the most relevant corpus for your users, and where some pre-filtering has taken place to limit the amount of data the cross-encoder will need to process.\n\nA few typical use cases we've seen are:\nReturning a list of 100 most relevant stock reports, then re-ordering into a top 5 or 10 based on the detailed context of a particular set of customer portfolios\nRunning after a classic rules-based search that gets the top 100 or 1000 most relevant results to prune it according to a specific user's context\n\n\n\nTaking the few-shot approach, as we have here, can work well when the domain is general enough that a small number of examples will cover most reranking cases. However, as the differences between documents become more specific you may want to consider the\nThere is also a latency impact of using\nWe've used the\nWe hope you find this useful for tuning your search use cases, and look forward to seeing what you build."])</script><script>self.__next_f.push([1,"69:T5a9,Complex tasks, such as writing unit tests, can benefit from multi-step prompts. In contrast to a single prompt, a multi-step prompt generates text from GPT and then feeds that output text back into subsequent prompts. This can help in cases where you want GPT to reason things out before answering, or brainstorm a plan before executing it.\n\nIn this notebook, we use a 3-step prompt to write unit tests in Python using the following steps:\n\nExplain: Given a Python function, we ask GPT to explain what the function is doing and why.\nPlan: We ask GPT to plan a set of unit tests for the function.\n    If the plan is too short, we ask GPT to elaborate with more ideas for unit tests.\nExecute: Finally, we instruct GPT to write unit tests that cover the planned cases.\n\nThe code example illustrates a few embellishments on the chained, multi-step prompt:\n\nConditional branching (e.g., asking for elaboration only if the first plan is too short)\nThe choice of different models for different steps\nA check that re-runs the function if the output is unsatisfactory (e.g., if the output code cannot be parsed by Python's ast module)\nStreaming output so that you can start reading the output before it's fully generated (handy for long, multi-step outputs)\nMake sure to check any code before using it, as GPT makes plenty of mistakes (especially on character-based tasks like this one). For best results, use the most powerful model (GPT-4, as of May 2023).6a:Tce0,"])</script><script>self.__next_f.push([1,"Complex tasks, such as writing unit tests, can benefit from multi-step prompts. In contrast to a single prompt, a multi-step prompt generates text from GPT-3 and then feeds that text back into subsequent prompts. This can help in cases where you want GPT-3 to explain its reasoning before answering, or brainstorm a plan before executing it.\n\nIn this notebook, we use a 3-step prompt to write unit tests in Python using the following steps:\n\nGiven a Python function, we first prompt GPT-3 to explain what the function is doing.\nSecond, we prompt GPT-3 to plan a set of unit tests for the function.\n    If the plan is too short, we ask GPT-3 to elaborate with more ideas for unit tests.\nFinally, we prompt GPT-3 to write the unit tests.\n\nThe code example illustrates a few optional embellishments on the chained, multi-step prompt:\n\nConditional branching (e.g., only asking for elaboration if the first plan is too short)\nDifferent models for different steps (e.g., gpt-3.5-turbo-instruct for the text planning steps and gpt-4 for the code writing step)\nA check that re-runs the function if the output is unsatisfactory (e.g., if the output code cannot be parsed by Python's ast module)\nStreaming output so that you can start reading the output before it's fully generated (useful for long, multi-step outputs)\n\nThe full 3-step prompt looks like this (using as an example pytest for the unit test framework and is_palindrome as the function):\n\nHow to write great unit tests with pytest\n\n    In this advanced tutorial for experts, we'll use Python 3.9 and pytest to write a suite of unit tests to verify the behavior of the following function.\n        def is_palindrome(s):\n        return s == s[::-1]\n\n    Before writing any unit tests, let's review what each element of the function is doing exactly and what the author's intentions may have been.\n    First,{GENERATED IN STEP 1}\n\n    A good unit test suite should aim to:\n    Test the function's behavior for a wide range of possible inputs\n    Test edge cases that the author may not have foreseen\n    Take advantage of the features of pytest to make the tests easy to write and maintain\n    Be easy to read and understand, with clean code and descriptive names\n    Be deterministic, so that the tests always pass or fail in the same way\n\n    pytest has many convenient features that make it easy to write and maintain unit tests. We'll use them to write unit tests for the function above.\n\n    For this particular function, we'll want our unit tests to handle the following diverse scenarios (and under each scenario, we include a few examples as sub-bullets):\n    -{GENERATED IN STEP 2}\n\n    [OPTIONALLY APPENDED]In addition to the scenarios above, we'll also want to make sure we don't forget to test rare or unexpected edge cases (and under each edge case, we include a few examples as sub-bullets):\n    -{GENERATED IN STEP 2B}\n\n    Before going into the individual tests, let's first look at the complete suite of unit tests as a cohesive whole. We've added helpful comments to explain what each line does.\n        import pytest  # used for our unit tests\n\n    def is_palindrome(s):\n        return s == s[::-1]\n\n    #Below, each test case is represented by a tuple passed to the @pytest.mark.parametrize decorator\n    {GENERATED IN STEP 3}"])</script><script>self.__next_f.push([1,"6b:T5f8,We calculate user and product embeddings based on the training set, and evaluate the results on the unseen test set. We will evaluate the results by plotting the user and product similarity versus the review score. The dataset is created in the Get_embeddings_from_dataset Notebook.\n\nWe calculate these embeddings simply by averaging all the reviews about the same product or written by the same user within the training set.\nWe can see that most of the users and products appear within the 50k examples only once.\n\nTo evaluate the recommendations, we look at the similarity of the user and product embeddings amongst the reviews in the unseen test set. We calculate the cosine distance between the user and product embeddings, which gives us a similarity score between 0 and 1. We then normalize the scores to be evenly split between 0 and 1, by calculating the percentile of the similarity score amongst all predicted scores.\n\nWe group the cosine similarity scores by the review score, and plot the distribution of cosine similarity scores for each review score.\nWe can observe a weak trend, showing that the higher the similarity score between the user and the product embedding, the higher the review score. Therefore, the user and product embeddings can weakly predict the review score - even before the user receives the product!\n\nBecause this signal works in a different way than the more commonly used collaborative filtering, it can act as an additional feature to slightly improve the performance on existing problems.6c:Te4c,"])</script><script>self.__next_f.push([1,"We are addressing the problem of enhancing the precision of transcriptions, particularly when it comes to company names and product references. Our solution involves a dual strategy that utilizes both the Whisper prompt parameter and GPT-4's post-processing capabilities.\n\nTwo approaches to correct inaccuracies are:\n\nWe input a list of correct spellings directly into Whisper's prompt parameter to guide the initial transcription.\n\nWe utilized GPT-4 to fix misspellings post transcription, again using the same list of correct spellings in the prompt.\n\nThese strategies aimed at ensuring precise transcription of unfamilar proper nouns.\n\n\nTo get started, let's:\n\nImport the OpenAI Python library (if you don't have it, you'll need to install it with Download the audio file example\n\nOur reference point is a monologue, which was generated by ChatGPT from prompts given by the author. The author then voiced this content. So, the author both guided the ChatGPT's output with prompts and brought it to life by speaking it.\nOur fictitious company, ZyntriQix, offers a range of tech products. These include Digique Plus, CynapseFive, VortiQore V8, EchoNix Array, OrbitalLink Seven, and DigiFractal Matrix. We also spearhead several initiatives such as PULSE, RAPT, B.R.I.C.K., Q.U.A.R.T.Z., and F.L.I.N.T.\nWhisper transcribed our company name, product names, and miscapitalized our acronyms incorrectly. Let's pass the correct names as a list in the prompt.\nWhen passing the list of product names, some of the product names are transcribed correctly while others are still misspelled.\n\nLeveraging GPT-4 proves especially useful when the speech content is unknown beforehand and we have a list of product names readily available.\n\nThe post-processing technique using GPT-4 is notably more scalable than depending solely on Whisper's prompt parameter, which has a token limit of 244. GPT-4 allows us to process larger lists of correct spellings, making it a more robust method for handling extensive product lists.\n\nHowever, this post-processing technique isn't without limitations. It's constrained by the context window of the chosen model, which may pose challenges when dealing with vast numbers of unique terms. For instance, companies with thousands of SKUs may find that the context window of GPT-4 is insufficient to handle their requirements, and they might need to explore alternative solutions.\n\nInterestingly, the GPT-4 post-processing technique seems more reliable than using Whisper alone. This method, which leverages a product list, enhances the reliability of our results. However, this increased reliability comes at a price, as using this approach can increase costs and can result in higher latency.\nNow, let's input the original product list into GPT-4 and evaluate its performance. By doing so, we aim to assess the AI model's ability to correctly spell the proprietary product names, even with no prior knowledge of the exact terms to appear in the transcription. In our experiment, GPT-4 was successful in correctly spelling our product names, confirming its potential as a reliable tool for ensuring transcription accuracy.\nIn this case, we supplied a comprehensive product list that included all the previously used spellings, along with additional new names. This scenario simulates a real-life situation where we have a substantial SKU list and uncertain about the exact terms to appear in the transcription. Feeding this extensive list of product names into the system resulted in a correctly transcribed output.\nWe are employing GPT-4 as a spell checker, using the same list of correct spellings that was previously used in the prompt."])</script><script>self.__next_f.push([1,"6d:T8da,"])</script><script>self.__next_f.push([1,"This notebook offers a guide to improve the Whisper's transcriptions. We'll streamline your audio data via trimming and segmentation, enhancing Whisper's transcription quality. After transcriptions, we'll refine the output by adding punctuation, adjusting product terminology (e.g., 'five two nine' to '529'), and mitigating Unicode issues. These strategies will help improve the clarity of your transcriptions, but remember, customization based on your unique use-case may be beneficial.\n\n\n\nTo get started let's import a few different libraries:\n\nPyDub is a simple and easy-to-use Python library for audio processing tasks such as slicing, concatenating, and exporting audio files.\n\nThe Audio class from the IPython.display module allows you to create an audio control that can play sound in Jupyter notebooks, providing a straightforward way to play audio data directly in your notebook.\n\nFor our audio file, we'll use a fictional earnings call written by ChatGPT and read aloud by the author.This audio file is relatively short, but hopefully provides you with an illustrative idea of how these pre and post processing steps can be applied to any audio file.\nAt times, files with long silences at the beginning can cause Whisper to transcribe the audio incorrectly. We'll use Pydub to detect and trim the silence.\n\nHere, we've set the decibel threshold of 20. You can change this if you would like.\nAt times, we've seen unicode character injection in transcripts, removing any non-ASCII characters should help mitigate this issue.\n\nKeep in mind you should not use this function if you are transcribing in Greek, Cyrillic, Arabic, Chinese, etc\nThis function will add formatting and punctuation to our transcript. Whisper generates a transcript with punctuation but without formatting.\nOur audio file is a recording from a fake earnings call that includes a lot of financial products. This function can help ensure that if Whisper transcribes these financial product names incorrectly, that they can be corrected.\nThis function will create a new file with 'trimmed' appended to the original file name\nOur fake earnings report audio file is fairly short in length, so we'll adjust the segments accordingly. Keep in mind you can adjust the segment length as you need."])</script><script>self.__next_f.push([1,"6e:Ted4,"])</script><script>self.__next_f.push([1,"OpenAI's audio transcription API has an optional parameter called prompt.\n\nThe prompt is intended to help stitch together multiple audio segments. By submitting the prior segment's transcript via the prompt, the Whisper model can use that context to better understand the speech and maintain a consistent writing style.\n\nHowever, prompts do not need to be genuine transcripts from prior audio segments. Fictitious prompts can be submitted to steer the model to use particular spellings or styles.\n\nThis notebook shares two techniques for using fictitious prompts to steer the model outputs:\n\nTranscript generation**: GPT can convert instructions into fictitious transcripts for Whisper to emulate.\nSpelling guide**: A spelling guide can tell the model how to spell names of people, products, companies, etc.\n\nThese techniques are not especially reliable, but can be useful in some situations.\n\n\nPrompting Whisper is not the same as prompting GPT. For example, if you submit an attempted instruction like \"Format lists in Markdown format\", the model will not comply, as it follows the style of the prompt, rather than any instructions contained within.\n\nIn addition, the prompt is limited to only 224 tokens. If the prompt is longer than 224 tokens, only the final 224 tokens of the prompt will be considered; all prior tokens will be silently ignored. The tokenizer used is the multilingual Whisper tokenizer.\n\nTo get good results, craft examples that portray your desired style.\n\nTo get started, let's:\nImport the OpenAI Python library (if you don't have it, you'll need to install it with pip install openai)\nDownload a few example audio files\n\nOur audio file for this example will be a segment of the NPR podcast, Up First.\n\nLet's get our baseline transcription, then introduce prompts.\nLet's explore how prompts influence the style of the transcript.  In the previous unprompted transcript, 'President Biden' is capitalized.\n\nLet's try and use a prompt to write \"president biden\" in lower case.  We can start by passing in a prompt of 'president biden' in lowercase and see if we can get Whisper to match the style and generate the transcript in all lowercase.\nBe aware that when prompts are short, Whisper may be less reliable at following their style.  Long prompts may be more reliable at steering Whisper.  Let's try that again with a longer prompt.\nThat worked better.\n\nIt's also worth noting that Whisper is less likely to follow rare or odd styles that are atypical for a transcript.\n\nWhisper may incorrectly transcribe uncommon proper nouns such as names of products, companies, or people.  In this manner, you can use prompts to help correct those spellings.\n\nWe'll illustrate with an example audio file full of product names.\nTo get Whisper to use our preferred spellings, let's pass the product and company names in the prompt, as a glossary for Whisper to follow.\nNow, let's switch to another audio recording authored specifically for this demonstration, on the topic of a odd barbecue.\n\nTo begin, we'll establish our baseline transcript using Whisper.\nWhile Whisper's transcription was accurate, it had to guess at various spellings. For example, it assumed the friends' names were spelled Amy and Sean rather than Aimee and Shawn. Let's see if we can steer the spelling with a prompt.\nSuccess!\n\nLet's try the same with more ambiguously spelled words.\n\nOne potential tool to generate fictitious prompts is GPT. We can give GPT instructions and use it to generate long fictitious transcripts with which to prompt Whisper.\nWhisper prompts are best for specifying otherwise ambiguous styles. The prompt will not override the model's comprehension of the audio. For example, if the speakers are not speaking in a deep Southern accent, a prompt will not cause the transcript to do so."])</script><script>self.__next_f.push([1,"6f:T672,In this notebook we will classify the sentiment of reviews using embeddings and zero labeled data! The dataset is created in the Get_embeddings_from_dataset Notebook.\n\nWe'll define positive sentiment to be 4- and 5-star reviews, and negative sentiment to be 1- and 2-star reviews. 3-star reviews are considered neutral and we won't use them for this example.\n\nWe will perform zero-shot classification by embedding descriptions of each class and then comparing new samples to those class embeddings.\nTo perform zero shot classification, we want to predict labels for our samples without any training. To do this, we can simply embed short descriptions of each label, such as positive and negative, and then compare the cosine distance between embeddings of samples and label descriptions.\n\nThe highest similarity label to the sample input is the predicted label. We can also define a prediction score to be the difference between the cosine distance to the positive and to the negative label. This score can be used for plotting a precision-recall curve, which can be used to select a different tradeoff between precision and recall, by selecting a different threshold.\nWe can see that this classifier already performs extremely well. We used similarity embeddings, and the simplest possible label name. Let's try to improve on this by using more descriptive label names, and search embeddings.\nUsing the search embeddings and descriptive names leads to an additional improvement in performance.\nAs shown above, zero-shot classification with embeddings can lead to great results, especially when the labels are more descriptive than just simple words.70:T9eb,"])</script><script>self.__next_f.push([1,"This example will cover chat completions using the Azure OpenAI service. It also includes information on content filtering.\n\nFirst, we install the necessary dependencies and import the libraries we will be using.\n\nThe Azure OpenAI service supports multiple authentication mechanisms that include API keys and Azure Active Directory token credentials.\n\nTo set up the OpenAI SDK to use an Azure API Key, we need to set api_key to a key associated with your endpoint (you can find this key in \"Keys and Endpoints\" under \"Resource Management\" in the Azure Portal). You'll also find the endpoint for your resource here.\nLet's now see how we can autheticate via Azure Active Directory. We'll start by installing the azure-identity library. This library will provide the token credentials we need to authenticate and help us build a token credential provider through the get_bearer_token_provider helper function. It's recommended to use get_bearer_token_provider over providing a static token to AzureOpenAI because this API will automatically cache and refresh tokens for you.\n\nFor more information on how to set up Azure Active Directory authentication with Azure OpenAI, see the documentation.\nNote: the AzureOpenAI infers the following arguments from their corresponding environment variables if they are not provided:\n\napi_key from AZURE_OPENAI_API_KEY\nazure_ad_token from AZURE_OPENAI_AD_TOKEN\napi_version from OPENAI_API_VERSION\nazure_endpoint from AZURE_OPENAI_ENDPOINT\n\n\nIn this section we are going to create a deployment of a GPT model that we can use to create chat completions.\nLet's deploy a model to use with chat completions. Go to https://portal.azure.com, find your Azure OpenAI resource, and then navigate to the Azure OpenAI Studio. Click on the \"Deployments\" tab and then create a deployment for the model you want to use for chat completions. The deployment name that you give the model will be used in the code below.\n\nNow let's create a chat completion using the client we built.\n\nWe can also stream the response.\n\nAzure OpenAI service includes content filtering of prompts and completion responses. You can learn more about content filtering and how to configure it here.\n\nIf the prompt is flagged by the content filter, the library will raise a BadRequestError exception with a content_filter error code. Otherwise, you can access the prompt_filter_results and content_filter_results on the response to see the results of the content filtering and what categories were flagged.\nChecking the result of the content filter"])</script><script>self.__next_f.push([1,"71:T14ef,"])</script><script>self.__next_f.push([1,"This example shows how to use Azure OpenAI service models with your own data. The feature is currently in preview.\n\nAzure OpenAI on your data enables you to run supported chat models such as GPT-3.5-Turbo and GPT-4 on your data without needing to train or fine-tune models. Running models on your data enables you to chat on top of, and analyze your data with greater accuracy and speed. One of the key benefits of Azure OpenAI on your data is its ability to tailor the content of conversational AI. Because the model has access to, and can reference specific sources to support its responses, answers are not only based on its pretrained knowledge but also on the latest information available in the designated data source. This grounding data also helps the model avoid generating responses based on outdated or incorrect information.\n\nAzure OpenAI on your own data with Azure AI Search (f.k.a. Azure Cognitive Search) provides a customizable, pre-built solution for knowledge retrieval, from which a conversational AI application can be built. To see alternative methods for knowledge retrieval and semantic search, check out the cookbook examples for vector databases.\n\nAzure OpenAI on your own data connects the model with your data, giving it the ability to retrieve and utilize data in a way that enhances the model's output. Together with Azure AI Search, data is retrieved from designated data sources based on the user input and provided conversation history. The data is then augmented and resubmitted as a prompt to the model, giving the model contextual information it can use to generate a response.\n\nSee the Data, privacy, and security for Azure OpenAI Service for more information.\nTo get started, we'll cover a few prerequisites.\n\nTo properly access the Azure OpenAI Service, we need to create the proper resources at the Azure Portal (you can check a detailed guide on how to do this in the Microsoft Docs)\n\nTo use your own data with Azure OpenAI models, you will need:\n\nAzure OpenAI access and a resource with a chat model deployed (for example, GPT-3 or GPT-4)\nAzure AI Search (f.k.a. Azure Cognitive Search) resource\nAzure Blob Storage resource\nYour documents to be used as data (See data source options)\n\n\nFor a full walk-through on how to upload your documents to blob storage and create an index using the Azure AI Studio, see this Quickstart.\n\nFirst, we install the necessary dependencies.\nIn this example, we'll use dotenv to load our environment variables. To connect with Azure OpenAI and the Search index, the following variables should be added to a .env file in KEY=VALUE format:\n\nAZURE_OPENAI_ENDPOINT - the Azure OpenAI endpoint. This can be found under \"Keys and Endpoints\" for your Azure OpenAI resource in the Azure Portal.\nAZURE_OPENAI_API_KEY - the Azure OpenAI API key. This can be found under \"Keys and Endpoints\" for your Azure OpenAI resource in the Azure Portal. Omit if using Azure Active Directory authentication (see below Authentication using Microsoft Active Directory)\nSEARCH_ENDPOINT - the AI Search endpoint. This URL be found on the \"Overview\" of your Search resource on the Azure Portal.\nSEARCH_KEY - the AI Search API key. Found under \"Keys\" for your Search resource in the Azure Portal.\nSEARCH_INDEX_NAME - the name of the index you created with your own data.\n\nThe Azure OpenAI service supports multiple authentication mechanisms that include API keys and Azure Active Directory token credentials.\n\nTo set up the OpenAI SDK to use an Azure API Key, we need to set api_key to a key associated with your endpoint (you can find this key in \"Keys and Endpoints\" under \"Resource Management\" in the Azure Portal). You'll also find the endpoint for your resource here.\nLet's now see how we can authenticate via Azure Active Directory. We'll start by installing the azure-identity library. This library will provide the token credentials we need to authenticate and help us build a token credential provider through the get_bearer_token_provider helper function. It's recommended to use get_bearer_token_provider over providing a static token to AzureOpenAI because this API will automatically cache and refresh tokens for you.\n\nFor more information on how to set up Azure Active Directory authentication with Azure OpenAI, see the documentation.\nNote: the AzureOpenAI infers the following arguments from their corresponding environment variables if they are not provided:\n\napi_key from AZURE_OPENAI_API_KEY\nazure_ad_token from AZURE_OPENAI_AD_TOKEN\napi_version from OPENAI_API_VERSION\nazure_endpoint from AZURE_OPENAI_ENDPOINT\n\nIn this example, we want our model to base its responses on Azure AI services documentation data. Following the Quickstart shared previously, we have added the markdown file for the Azure AI services and machine learning documentation page to our search index. The model is now ready to answer questions about Azure AI services and machine learning.\nNow we can use Azure on your own data with Chat Completions. Providing our search endpoint, key, and index name in dataSources, any questions posed to the model will now be grounded in our own data. An additional property, context, will be provided in the response to show the data the model referenced to answer the question.\nIf you would prefer to stream the response from the model, you can pass the stream=True keyword argument:"])</script><script>self.__next_f.push([1,"72:T778,This example will cover embeddings using the Azure OpenAI service.\n\nFirst, we install the necessary dependencies and import the libraries we will be using.\n\nThe Azure OpenAI service supports multiple authentication mechanisms that include API keys and Azure Active Directory token credentials.\n\nTo set up the OpenAI SDK to use an Azure API Key, we need to set api_key to a key associated with your endpoint (you can find this key in \"Keys and Endpoints\" under \"Resource Management\" in the Azure Portal). You'll also find the endpoint for your resource here.\nLet's now see how we can authenticate via Azure Active Directory. We'll start by installing the azure-identity library. This library will provide the token credentials we need to authenticate and help us build a token credential provider through the get_bearer_token_provider helper function. It's recommended to use get_bearer_token_provider over providing a static token to AzureOpenAI because this API will automatically cache and refresh tokens for you.\n\nFor more information on how to set up Azure Active Directory authentication with Azure OpenAI, see the documentation.\nNote: the AzureOpenAI infers the following arguments from their corresponding environment variables if they are not provided:\n\napi_key from AZURE_OPENAI_API_KEY\nazure_ad_token from AZURE_OPENAI_AD_TOKEN\napi_version from OPENAI_API_VERSION\nazure_endpoint from AZURE_OPENAI_ENDPOINT\n\n\nIn this section we are going to create a deployment of a model that we can use to create embeddings.\nLet's deploy a model to use with embeddings. Go to https://portal.azure.com, find your Azure OpenAI resource, and then navigate to the Azure OpenAI Studio. Click on the \"Deployments\" tab and then create a deployment for the model you want to use for embeddings. The deployment name that you give the model will be used in the code below.\n\nNow let's create embeddings using the client we built.73:Te73,"])</script><script>self.__next_f.push([1,"This notebook shows how to use the function calling capability with the Azure OpenAI service. Functions allow a caller of chat completions to define capabilities that the model can use to extend its\nfunctionality into external tools and data sources.\n\nYou can read more about chat functions on OpenAI's blog: https://openai.com/blog/function-calling-and-other-api-updates\n\nNOTE: Chat functions require model versions beginning with gpt-4 and gpt-35-turbo's -0613 labels. They are not supported by older versions of the models.\n\nFirst, we install the necessary dependencies and import the libraries we will be using.\n\nThe Azure OpenAI service supports multiple authentication mechanisms that include API keys and Azure Active Directory token credentials.\n\nTo set up the OpenAI SDK to use an Azure API Key, we need to set api_key to a key associated with your endpoint (you can find this key in \"Keys and Endpoints\" under \"Resource Management\" in the Azure Portal). You'll also find the endpoint for your resource here.\nLet's now see how we can authenticate via Azure Active Directory. We'll start by installing the azure-identity library. This library will provide the token credentials we need to authenticate and help us build a token credential provider through the get_bearer_token_provider helper function. It's recommended to use get_bearer_token_provider over providing a static token to AzureOpenAI because this API will automatically cache and refresh tokens for you.\n\nFor more information on how to set up Azure Active Directory authentication with Azure OpenAI, see the documentation.\nNote: the AzureOpenAI infers the following arguments from their corresponding environment variables if they are not provided:\n\napi_key from AZURE_OPENAI_API_KEY\nazure_ad_token from AZURE_OPENAI_AD_TOKEN\napi_version from OPENAI_API_VERSION\nazure_endpoint from AZURE_OPENAI_ENDPOINT\n\n\nIn this section we are going to create a deployment of a GPT model that we can use to call functions.\nLet's deploy a model to use with chat completions. Go to https://portal.azure.com, find your Azure OpenAI resource, and then navigate to the Azure OpenAI Studio. Click on the \"Deployments\" tab and then create a deployment for the model you want to use for chat completions. The deployment name that you give the model will be used in the code below.\n\nWith setup and authentication complete, you can now use functions with the Azure OpenAI service. This will be split into a few steps:\n\nDefine the function(s)\nPass function definition(s) into chat completions API\nCall function with arguments from the response\nFeed function response back into chat completions API\n\nA list of functions can be defined, each containing the name of the function, an optional description, and the parameters the function accepts (described as a JSON schema).\n\nNow we can pass the function into the chat completions API. If the model determines it should call the function, a finish_reason of \"tool_calls\" will be populated on the choice and the details of which function to call and its arguments will be present in the message. Optionally, you can set the tool_choice keyword argument to force the model to call a particular function (e.g. {\"type\": \"function\", \"function\": {\"name\": get_current_weather}}). By default, this is set to auto, allowing the model to choose whether to call the function or not.\n\nThe name of the function call will be one that was provided initially and the arguments will include JSON matching the schema included in the function definition.\n\nThe response from the function should be serialized into a new message with the role set to \"function\". Now the model will use the response data to formulate its answer."])</script><script>self.__next_f.push([1,"74:T68d,With permission of the author, we will demonstrate how to translate the book Euclidean Plane Geometry, written by Milan Mitrović from Slovenian into English, without modifying any of the LaTeX commands.\n\nTo achieve this, we will first split the book into chunks, each roughly a page long, then translate each chunk into English, and finally stitch them back together.\nIt turns out that a double newline is a good separator in this case, in order not to break the flow of the text. Also no individual chunk is larger than 1211 tokens. The model we will use is gpt-4o, which has a limit of 16,384 tokens, so we don't need to worry about breaking the chunks down further.\n\nWe will group the shorter chunks into chunks of around 15000 tokens, to increase the coherence of the text, and decrease the frequency of breaks within the text.\nNotice that adding a sample untranslated and translated first command, where only the content of the chapter name needs to be translated, helps to get more consistent results.\n\nThe format of the prompt sent to the model consists of:\nA high level instruction to translate only the text, but not commands into the desired language\nA sample untranslated command, where only the content of the chapter name needs to be translated\nThe chunk of text to be translated\nThe translated sample command from 2, which shows the model the beginning of the translation process\n\nThe expected output is the translated chunk of text.\nWe can see here that this one chunk in particular translates only the text, but leaves LaTeX commands intact.\n\nLet's now translate all the chunks in the book - this will take 2-3 hours, as we're processing requests sequentially.75:T6f7,Segment Anything is a model from Meta that can be used to select portions of images. Combined with DALL·E's ability to inpaint specified portions of images, you can use Segment Anything to easily select any part of an image you'd like to alter.\n\nIn this notebook, we'll use these tools to become fashion designers and dynamically replace our digital mode"])</script><script>self.__next_f.push([1,"ls' outfits with tailored, original creations. The notebook follows this flow:\nSetup:** Initialise your libraries and any location directories.\nGenerate original image:** Make an original image that we'll create dynamic masks from.\nGenerate mask:** Use Segment Anything to create a dynamic mask.\nCreate new image:** Generate a new image with the masked area inpainted with a fresh prompt.\n\nTo get started we'll need to follow the instructions for using the Segment Anything (SAM) model open-sourced by Meta. As of May 2023, the key steps are:\nInstall Pytorch (version 1.7+).\nInstall the library using Install dependencies using Download a model checkpoint to use (default size is 2.4 GB).\n\n\nFirst we'll create an original image which we'll generate masks from.\n\nNext we'll load up one of our images and generate masks.\n\nFor this demonstration we're picking a UX where we \"click\" on a point on the image to generate masks from. However, there are example notebooks provided by Meta which show how to generate every possible mask for an image, draw a box, and some other useful approaches.\n\nNow we'll combine our original image with the mask and the Edit endpoint for DALLE to inpaint the transparent area according to a new prompt. (as 0f January 2024 dall-e-2 is the only model that supports edits)\n\nBeautiful!\n\nNow you too can easily create dynamic masks to extend your images - enjoy the APIs, and please share what you build!76:T1103,"])</script><script>self.__next_f.push([1,"This notebook shows how to use OpenAI's DALL·E image API endpoints.\n\nThere are three API endpoints:\nGenerations:** generates an image or images based on an input caption\nEdits:** edits or extends an existing image\nVariations:** generates variations of an input image\n\nImport the packages you'll need\nImport your OpenAI API key: You can do this by running \\`export OPENAI_API_KEY=\"your API key\"\\` in your terminal.\nSet a directory to save images to\n\nThe generation API endpoint creates an image based on a text prompt. API Reference\n\nRequired inputs:\nprompt (str): A text description of the desired image(s). The maximum length is 1000 characters for dall-e-2 and 4000 characters for dall-e-3.\n\nOptional inputs:\nmodel (str): The model to use for image generation. Defaults to dall-e-2\nn (int): The number of images to generate. Must be between 1 and 10. Defaults to 1.\nquality (str): The quality of the image that will be generated. hd creates images with finer details and greater consistency across the image. This param is only supported for dall-e-3.\nresponse_format (str): The format in which the generated images are returned. Must be one of \"url\" or \"b64_json\". Defaults to \"url\".\nsize (str): The size of the generated images. Must be one of 256x256, 512x512, or 1024x1024 for dall-e-2. Must be one of 1024x1024, 1792x1024, or 1024x1792 for dall-e-3 models. Defaults to \"1024x1024\".\nstyle(str | null): The style of the generated images. Must be one of vivid or natural. Vivid causes the model to lean towards generating hyper-real and dramatic images. Natural causes the model to produce more natural, less hyper-real looking images. This param is only supported for dall-e-3.\nuser (str): A unique identifier representing your end-user, which will help OpenAI to monitor and detect abuse. Learn more.\n\nThe variations endpoint generates new images (variations) similar to an input image. API Reference\n\nHere we'll generate variations of the image generated above.\n\nRequired inputs:\nimage (str): The image to use as the basis for the variation(s). Must be a valid PNG file, less than 4MB, and square.\n\nOptional inputs:\nmodel (str): The model to use for image variations. Only dall-e-2 is supported at this time.\nn (int): The number of images to generate. Must be between 1 and 10. Defaults to 1.\nsize (str): The size of the generated images. Must be one of \"256x256\", \"512x512\", or \"1024x1024\". Smaller images are faster. Defaults to \"1024x1024\".\nresponse_format (str): The format in which the generated images are returned. Must be one of \"url\" or \"b64_json\". Defaults to \"url\".\nuser (str): A unique identifier representing your end-user, which will help OpenAI to monitor and detect abuse. Learn more.\n\n\nThe edit endpoint uses DALL·E to generate a specified portion of an existing image. Three inputs are needed: the image to edit, a mask specifying the portion to be regenerated, and a prompt describing the desired image. API Reference\n\nRequired inputs:\nimage (str): The image to edit. Must be a valid PNG file, less than 4MB, and square. If mask is not provided, image must have transparency, which will be used as the mask.\nprompt (str): A text description of the desired image(s). The maximum length is 1000 characters.\n\nOptional inputs:\nmask (file): An additional image whose fully transparent areas (e.g. where alpha is zero) indicate where image should be edited. Must be a valid PNG file, less than 4MB, and have the same dimensions as image.\nmodel (str): The model to use for edit image. Only dall-e-2 is supported at this time.\nn (int): The number of images to generate. Must be between 1 and 10. Defaults to 1.\nsize (str): The size of the generated images. Must be one of \"256x256\", \"512x512\", or \"1024x1024\". Smaller images are faster. Defaults to \"1024x1024\".\nresponse_format (str): The format in which the generated images are returned. Must be one of \"url\" or \"b64_json\". Defaults to \"url\".\nuser (str): A unique identifier representing your end-user, which will help OpenAI to monitor and detect abuse. Learn more.\n\n\nAn edit requires a \"mask\" to specify which portion of the image to regenerate. Any pixel with an alpha of 0 (transparent) will be regenerated. The code below creates a 1024x1024 mask where the bottom half is transparent.\n\nNow we supply our image, caption and mask to the API to get 5 examples of edits to our image"])</script><script>self.__next_f.push([1,"77:T2fc5,"])</script><script>self.__next_f.push([1,"In this notebook we delve into the evaluation techniques for abstractive summarization tasks using a simple example. We explore traditional evaluation methods like ROUGE and BERTScore, in addition to showcasing a more novel approach using LLMs as evaluators.\n\nEvaluating the quality of summaries is a time-consuming process, as it involves different quality metrics such as coherence, conciseness, readability and content. Traditional automatic evaluation metrics such as ROUGE and BERTScore and others are concrete and reliable, but they may not correlate well with the actual quality of summaries. They show relatively low correlation with human judgments, especially for open-ended generation tasks (Liu et al., 2023). There's a growing need to lean on human evaluations, user feedback, or model-based metrics while being vigilant about potential biases. While human judgment provides invaluable insights, it is often not scalable and can be cost-prohibitive.\n\nIn addition to these traditional metrics, we showcase a method (G-Eval) that leverages Large Language Models (LLMs) as a novel, reference-free metric for assessing abstractive summaries. In this case, we use gpt-4 to score candidate outputs. gpt-4 has effectively learned an internal model of language quality that allows it to differentiate between fluent, coherent text and low-quality text. Harnessing this internal scoring mechanism allows auto-evaluation of new candidate outputs generated by an LLM.\n\n\n\nFor the purposes of this notebook we'll use the example summarization below. Notice that we provide two generated summaries to compare, and a reference human-written summary, which evaluation metrics like ROUGE and BERTScore require.\n\nExcerpt (excerpt):\nOpenAI's mission is to ensure that artificial general intelligence (AGI) benefits all of humanity. OpenAI will build safe and beneficial AGI directly, but will also consider its mission fulfilled if its work aids others to achieve this outcome. OpenAI follows several key principles for this purpose. First, broadly distributed benefits - any influence over AGI's deployment will be used for the benefit of all, and to avoid harmful uses or undue concentration of power. Second, long-term safety - OpenAI is committed to doing the research to make AGI safe, and to promote the adoption of such research across the AI community. Third, technical leadership - OpenAI aims to be at the forefront of AI capabilities. Fourth, a cooperative orientation - OpenAI actively cooperates with other research and policy institutions, and seeks to create a global community working together to address AGI's global challenges.\n\nSummaries:\n\n| Reference Summary /ref_summary (human generated)                                                                                                                                                                                                                                                                                                                         | Eval Summary 1 / eval_summary_1 (system generated)                                                                                                                                                                                                                                                                                                                               | Eval Summary 2 / eval_summary_2 (system generated)                                                                                                                                                                                                                                                   |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| OpenAI aims to ensure artificial general intelligence (AGI) is used for everyone's benefit, avoiding harmful uses or undue power concentration. It is committed to researching AGI safety, promoting such studies among the AI community. OpenAI seeks to lead in AI capabilities and cooperates with global research and policy institutions to address AGI's challenges. | OpenAI aims to AGI benefits all humanity, avoiding harmful uses and power concentration. It pioneers research into safe and beneficial AGI and promotes adoption globally. OpenAI maintains technical leadership in AI while cooperating with global institutions to address AGI challenges. It seeks to lead a collaborative worldwide effort developing AGI for collective good. | OpenAI aims to ensure AGI is for everyone's use, totally avoiding harmful stuff or big power concentration. Committed to researching AGI's safe side, promoting these studies in AI folks. OpenAI wants to be top in AI things and works with worldwide research, policy groups to figure AGI's stuff. |\n\nTake a moment to figure out which summary you'd personally prefer and the one that captures OpenAI's mission really well.\n\n\nROUGE, which stands for Recall-Oriented Understudy for Gisting Evaluation, primarily gauges the overlap of words between a generated output and a reference text. It's a prevalent metric for evaluating automatic summarization tasks. Among its variants, ROUGE-L offers insights into the longest contiguous match between system-generated and reference summaries, gauging how well the system retains the original summary's essence.\n\nThe table shows the ROUGE scores for evaluating two different summaries against a reference text. In the case of rouge-1, Summary 2 outperforms Summary 1, indicating a better overlap of individual words and for rouge-l, Summary 2 has a higher score, implying a closer match in the longest common subsequences, and thus a potentially better overall summarization in capturing the main content and order of the original text. Since Summary 2 has many words and short phrases directly lifted from the excerpt, its overlap with the reference summary would likely be higher, leading to higher ROUGE scores.\n\nWhile ROUGE and similar metrics, such as BLEU and METEOR, offer quantitative measures, they often fail to capture the true essence of a well-generated summary. They also correlate worse with human scores. Given the advancements in LLMs, which are adept at producing fluent and coherent summaries, traditional metrics like ROUGE may inadvertently penalize these models. This is especially true if the summaries are articulated differently but still encapsulate the core information accurately.\n\n\nROUGE relies on the exact presence of words in both the predicted and reference texts, failing to interpret the underlying semantics. This is where BERTScore comes in and leverages the contextual embeddings from the BERT model, aiming to evaluate the similarity between a predicted and a reference sentence in the context of machine-generated text. By comparing embeddings from both sentences, BERTScore captures semantic similarities that might be missed by traditional n-gram based metrics.\n\nThe close F1 Scores between the summaries indicate that they may perform similarly in capturing the key information. However, this small difference should be interpreted with caution. Since BERTScore may not fully grasp subtleties and high-level concepts that a human evaluator might understand, reliance solely on this metric could lead to misinterpreting the actual quality and nuances of the summary. An integrated approach combining BERTScore with human judgment and other metrics could offer a more reliable evaluation.\n\n\nHere we implement an example reference-free text evaluator using gpt-4, inspired by the G-Eval) framework which evaluates the quality of generated text using large language models. Unlike metrics like ROUGE or BERTScore that rely on comparison to reference summaries, the gpt-4 based evaluator assesses the quality of generated content based solely on the input prompt and text, without any ground truth references. This makes it applicable to new datasets and tasks where human references are sparse or unavailable.\n\nHere's an overview of this method:\n\nWe define four distinct criteria:\n    Relevance: Evaluates if the summary includes only important information and excludes redundancies.\n    Coherence: Assesses the logical flow and organization of the summary.\n    Consistency: Checks if the summary aligns with the facts in the source document.\n    Fluency: Rates the grammar and readability of the summary.\nWe craft prompts for each of these criteria, taking the original document and the summary as inputs, and leveraging chain-of-thought generation and guiding the model to output a numeric score from 1-5 for each criteria.\nWe generate scores from gpt-4 with the defined prompts, comparing them across summaries.\n\nIn this demonstration, we're using a direct scoring function where gpt-4 generates a discrete score (1-5) for each metric. Normalizing the scores and taking a weighted sum could result in more robust, continuous scores that better reflect the quality and diversity of the summaries.\n\nOverall, the Summary 1 appears to outperform Summary 2 in three of the four categories (Coherence, Relevance and Fluency). Both summaries are found to be consistent with each other. The result might suggest that Summary 1 is generally preferable based on the given evaluation criteria.\n\n\nNote that LLM-based metrics could have a bias towards preferring LLM-generated texts over human-written texts. Additionally LLM based metrics are sensitive to system messages/prompts. We recommend experimenting with other techniques that can help improve performance and/or get consistent scores, striking the right balance between high-quality expensive evaluation and automated evaluations. It is also worth noting that this scoring methodology is currently limited by gpt-4's context window.\n\n\nEvaluating abstractive summarization remains an open area for further improvement. Traditional metrics like ROUGE, BLEU, and BERTScore provide useful automatic evaluation but have limitations in capturing semantic similarity and nuanced aspects of summarization quality. Moreover, they require reference outputs which can be expensive to collect/label. LLM-based metrics offer promise as a reference-free method of evaluating coherence, fluency, and relevance. However, they too have potential biases favoring text generated by LLMs. Ultimately, a combination of automatic metrics and human evaluation is ideal for reliably assessing abstractive summarization systems. While human evaluation is indispensable for gaining a comprehensive understanding of summary quality, it should be complemented with automated evaluation to enable efficient, large-scale testing. The field will continue to evolve more robust evaluation techniques, balancing quality, scalability, and fairness. Advancing evaluation methods is crucial for driving progress in production applications.\n\n\nG-EVAL: NLG Evaluation Using GPT-4 with Better Human Alignment - Liu Y, Iter D, Xu Y, Wang S, Xu R, Zhu C. Published May, 2023.\nBERTScore: Evaluating Text Generation with BERT - Zhang T, Kishore V, Wu F, Weinberger KQ, Artzi Y. Published online February, 2020.\nROUGE: A Package for Automatic Evaluation of Summaries - Lin CY. Published July, 2004.\nSummEval: Re-evaluating Summarization Evaluation - Fabbri et al. Published April, 2021."])</script><script>self.__next_f.push([1,"78:T2d80,"])</script><script>self.__next_f.push([1,"**Note: OpenAI now has a hosted evals product with an API! We recommend you use this instead.\nSee Evals**\n\nThe OpenAI Evals framework consists of\nA framework to evaluate an LLM (large language model) or a system built on top of an LLM.\nAn open-source registry of challenging evals\n\nThis notebook will cover:\nIntroduction to Evaluation and the OpenAI Evals library\nBuilding an Eval\nRunning an Eval\n\n\nEvaluation is the process of validating and testing the outputs that your LLM applications are producing. Having strong evaluations (\"evals\") will mean a more stable, reliable application that is resilient to code and model changes. An eval is a task used to measure the quality of the output of an LLM or LLM system. Given an input prompt, an output is generated. We evaluate this output with a set of ideal answers and find the quality of the LLM system.\n\n\nIf you are building with foundational models like GPT-4, creating high quality evals is one of the most impactful things you can do. Developing AI solutions involves an iterative design process. Without evals, it can be very difficult and time intensive to understand how different model versions and prompts might affect your use case.\n\nWith OpenAI’s continuous model upgrades, evals allow you to efficiently test model performance for your use cases in a standardized way. Developing a suite of evals customized to your objectives will help you quickly and effectively understand how new models may perform for your use cases. You can also make evals a part of your CI/CD pipeline to make sure you achieve the desired accuracy before deploying.\n\n\nThere are two main ways we can evaluate/grade completions: writing some validation logic in code\nor using the model itself to inspect the answer. We’ll introduce each with some examples.\n\nWriting logic for answer checking\n\nThe simplest and most common type of eval has an input and an ideal response or answer. For example,\nwe can have an eval sample where the input is \"What year was Obama elected president for the first\ntime?\" and the ideal answer is \"2008\". We feed the input to a model and get the completion. If the model\nsays \"2008\", it is then graded as correct. We can write a string match to check if the completion includes the phrase \"2008\". If it does, we consider it correct.\n\nConsider another eval where the input is to generate valid JSON: We can write some code that\nattempts to parse the completion as JSON and then considers the completion correct if it is\nparsable.\n\n**Model grading: A two stage process where the model first answers the question, then we ask a\nmodel to look at the response to check if it’s correct.**\n\nConsider an input that asks the model to write a funny joke. The model then generates a\ncompletion. We then create a new input to the model to answer the question: \"Is this following\njoke funny? First reason step by step, then answer yes or no\" that includes the completion.\" We\nfinally consider the original completion correct if the new model completion ends with \"yes\".\n\nModel grading works best with the latest, most powerful models like GPT-4 and if we give them the ability\nto reason before making a judgment. Model grading will have an error rate, so it is important to validate\nthe performance with human evaluation before running the evals at scale. For best results, it makes\nsense to use a different model to do grading from the one that did the completion, like using GPT-4 to\ngrade GPT-3.5 answers.\n\n\nIn using evals, we have discovered several \"templates\" that accommodate many different benchmarks. We have implemented these templates in the OpenAI Evals library to simplify the development of new evals. For example, we have defined 2 types of eval templates that can be used out of the box:\n\nBasic Eval Templates**: These contain deterministic functions to compare the output to the ideal_answers. In cases where the desired model response has very little variation, such as answering multiple choice questions or simple questions with a straightforward answer, we have found this following templates to be useful.\n\nModel-Graded Templates**: These contain functions where an LLM compares the output to the ideal_answers and attempts to judge the accuracy. In cases where the desired model response can contain significant variation, such as answering an open-ended question, we have found that using the model to grade itself is a viable strategy for automated evaluation.\n\n\nFirst, go to github.com/openai/evals, clone the repository with git clone git@github.com:openai/evals.git and go through the setup instructions.\n\nTo run evals later in this notebook, you will need to set up and specify your OpenAI API key. After you obtain an API key, specify it using the OPENAI_API_KEY environment variable.\n\nPlease be aware of the costs associated with using the API when running evals.\n\nAt its core, an eval is a dataset and an eval class that is defined in a YAML file. To start creating an eval, we need\n\nThe test dataset in the jsonl format.\nThe eval template to be used\n\nLets create a dataset for a use case where we are evaluating the model's ability to generate syntactically correct SQL. In this use case, we have a series of tables that are related to car manufacturing\n\nFirst we will need to create a system prompt that we would like to evaluate. We will pass in instructions for the model as well as an overview of the table structure:\n\"TASK: Answer the following question with syntactically correct SQLite SQL. The SQL should be correct and be in context of the previous question-answer pairs.\\nTable car_makers, columns = [,Id,Maker,FullName,Country]\\nTable car_names, columns = [,MakeId,Model,Make]\\nTable cars_data, columns = [,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]\\nTable continents, columns = [,ContId,Continent]\\nTable countries, columns = [,CountryId,CountryName,Continent]\\nTable model_list, columns = [,ModelId,Maker,Model]\\nForeign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]\"\n\nFor this prompt, we can ask a specific question:\n\"Q: how many car makers are their in germany?\"\n\nAnd we have an expected answer:\n\"A: SELECT count ( * )  FROM CAR_MAKERS AS T1 JOIN COUNTRIES AS T2 ON T1.Country   =   T2.CountryId WHERE T2.CountryName   =   'germany'\"\n\nThe dataset needs to be in the following format:\n\"input\": [{\"role\": \"system\", \"content\": \"\"}, {\"role\": \"user\", \"content\": }, \"ideal\": \"correct answer\"]\n\nPutting it all together, we get:\n{\"input\": [{\"role\": \"system\", \"content\": \"TASK: Answer the following question with syntactically correct SQLite SQL. The SQL should be correct and be in context of the previous question-answer pairs.\\nTable car_makers, columns = [,Id,Maker,FullName,Country]\\nTable car_names, columns = [,MakeId,Model,Make]\\nTable cars_data, columns = [,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]\\nTable continents, columns = [,ContId,Continent]\\nTable countries, columns = [,CountryId,CountryName,Continent]\\nTable model_list, columns = [,ModelId,Maker,Model]\\nForeign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]\\n\"}, {\"role\": \"system\", \"content\": \"Q: how many car makers are their in germany\"}, \"ideal\": [\"A: SELECT count ( * )  FROM CAR_MAKERS AS T1 JOIN COUNTRIES AS T2 ON T1.Country   =   T2.CountryId WHERE T2.CountryName   =   'germany'\"]}\n\n\nOne way to speed up the process of building eval datasets, is to use GPT-4 to generate synthetic data\nOnce we have the synthetic data, we need to convert it to match the format of the eval dataset.\nNext we need to create the eval registry to run it in the framework.\n\nThe evals framework requires a .yaml file structured with the following properties:\nid - An identifier for your eval\ndescription - A short description of your eval\ndisclaimer - An additional notes about your eval\nmetrics - There are three types of eval metrics we can choose from: match, includes, fuzzyMatch\n\nFor our eval, we will configure the following:\n\nWe can run this eval using the oaieval CLI. To get setup, install the library: pip install . (if you are running the OpenAI Evals library locally) or pip install oaieval if you are running an existing eval.\n\nThen, run the eval using the CLI: oaieval gpt-3.5-turbo spider-sql\n\nThis command expects a model name and an eval set name. Note that we provide two command line interfaces (CLIs): oaieval for running a single eval and oaievalset for running a set of evals. The valid eval names are specified in the YAML files under evals/registry/evals and their corresponding implementations can be found in evals/elsuite.\nThe oaieval CLI can accept various flags to modify the default behavior. You can run oaieval --help to see a full list of CLI options.\n\nAfter running that command, you’ll see the final report of accuracy printed to the console, as well as a file path to a temporary file that contains the full report.\noaieval will search for the spider-sql eval YAML file in the evals/registry/evals directory, following the format specified in cell 4 above. The path to the eval dataset is specified in the eval YAML file under the args: parameter as samples_jsonl: sql/spider_sql.jsonl, with the file content in JSONL format (as generated in step 3 above).\n\nAfter running that command, you’ll see the final report of accuracy printed to the console, as well as a file path to a temporary file that contains the full report.\noaievalset expects a model name and an eval set name, for which the valid options are specified in the YAML files under evals/registry/eval_sets.\n\nThe eval logs are located at /tmp/evallogs and different log files are created for each evaluation run.\nThis file will contain structured logs of the evaluation. The first entry provides a detailed specification of the evaluation, including the completion functions, evaluation name, run configuration, creator’s name, run ID, and creation timestamp.\nLet's also look at the entry which provides the final report of the evaluation.\nWe can also review individual evaluation events that provide specific samples (sample_id), results, event types, and metadata.\nLet's review our failures to understand which tests did not succeed.\nReviewing some of the failures we see the following:\nThe second incorrect answer had an unnecessary join with the 'Templates' table. Our eval was able to accurately identify this and flag this as incorrect.\nFew other answers have minor syntax differences that caused the answers to get flagged.\n  In situations like this, it would be worthwhile exploring whether we should continue iterating on the prompt to ensure certain stylistic choices, or if we should modify the evaluation suite to capture this variation.\n  This type of failure hints at the potential need for model-graded evals as a way to ensure accuracy in grading the results\nBuilding out effective evals is a core part of the development cycle of LLM-based applications. The OpenAI Evals framework provides the core structure of building evals out of the box, and allows you to quickly spin up new tests for your various use cases. In this guide, we demonstrated step-by-step how to create an eval, run it, and analyze the results.\n\nThe example shown in this guide represent a straightfoward use case for evals. As you continue to explore this framework, we recommend you explore creating more complex model-graded evals for actual production use cases. Happy evaluating!"])</script><script>self.__next_f.push([1,"79:Tbbe,"])</script><script>self.__next_f.push([1,"A guardrail is a set of rules and checks designed to ensure that the outputs of an LLM are accurate, appropriate, and aligned with user expectations. For more additional information on developing guardrails, you can refer to this guide on developing guardrails.\n\nIn this notebook, we'll walk through the process of developing an output guardrail that specifically checks model outputs for hallucinations.\n\nThis notebook will focus on:\nBuilding out a strong eval set\nIdentifying specific criteria to measure hallucinations\nImproving the accuracy of our guardrail with few-shot prompting\n\n\nImagine we are a customer support team that is building out an automated support agent. We will be feeding the assistant information from our knowledge base about a specific set of policies for how to handle tickets such as returns, refunds, feedback, and expect the model to follow the policy when interacting with customers.\n\nThe first thing we will do is use GPT-4o to build out a set of policies that we will want to follow.\n\nIf you want to do deep dive into generating synthetic data, you can review our Synthetic Data Generation Cookbook here\nNext we'll take these policies and generate sample customer interactions that do or do not follow the instructions.\nNow let's iterate through the policies and generate some examples.\n\nWhen building out our hallucination guardrail, here are some guiding principles:\n\nProvide very descriptive metrics to evaluate whether a response is accurate\nIt is important to break down this idea of \"truth\" in easily identifiable metrics that we can measure\nMetrics like truthfulness and relevance are difficult to measure. Giving concrete ways to score the statement can result in a more accurate guardrail\nEnsure consistency across key terminology\nIt is important to keep relevant terms such as knowledge base articles, assistants, and users consistent across the prompt\nIf we begin to use phrases such as assistant vs agent, the model could get confused\nStart with the most advanced model\nThere is a cost vs quality trade-off when using the most advanced models. Although GPT-4o may be more expensive, it is important to start with the most advanced model so we can ensure a high degree of accuracy\nOnce we have thoroughly tested out the guardrail and are confident in its performance, we can look to reducing cost by tuning it down to gpt-3.5-turbo\nEvaluate each sentence independently and the entire response as a whole\nIf the agent returns a long response, it can be useful to break down the response to individual sentences and evaluate them independently\nIn addition to that, evaluating the whole intent of the message as a whole can ensure that you don't lose important context\n\nWith all of this in mind, let's build out a guardrail system and measure its performance.\nFrom the results above we can see the program is performing well with a high precision and recall metric. This means that the guardrails are able to accurately identify hallucinations in the model outputs."])</script><script>self.__next_f.push([1,"7a:T9aa,"])</script><script>self.__next_f.push([1,"Note: To answer questions based on text documents, we recommend the procedure in Question Answering using Embeddings. Some of the code below may rely on deprecated API endpoints.\n\nThe idea of this project is to create a question answering model, based on a few paragraphs of provided text. Base GPT-3 models do a good job at answering questions when the answer is contained within the paragraph, however if the answer isn't contained, the base models tend to try their best to answer anyway, often leading to confabulated answers.\n\nTo create a model which answers questions only if there is sufficient context for doing so, we first create a dataset of questions and answers based on paragraphs of text. In order to train the model to answer only when the answer is present, we also add adversarial examples, where the question doesn't match the context. In those cases, we ask the model to output \"No sufficient context for answering the question\".\n\nWe will perform this task in three notebooks:\nThe first (this) notebook focuses on collecting recent data, which GPT-3 didn't see during its pre-training. We picked the topic of Olympic Games 2020 (which actually took place in the summer of 2021), and downloaded 713 unique pages. We organized the dataset by individual sections, which will serve as context for asking and answering the questions.\nThe second notebook will utilize Davinci-instruct to ask a few questions based on a Wikipedia section, as well as answer those questions, based on that section.\nThe third notebook will utilize the dataset of context, question and answer pairs to additionally create adversarial questions and context pairs, where the question was not generated on that context. In those cases the model will be prompted to answer \"No sufficient context for answering the question\". We will also train a discriminator model, which predicts whether the question can be answered based on the context or not.\nExtracting the data will take about half an hour, and processing will likely take about as much.\nWe remove sections unlikely to contain textual information, and ensure that each section is not longer than the token limit\nWe will save the section dataset, for the next notebook\nThere appear to be winter and summer Olympics 2020. We chose to leave a little ambiguity and noise in the dataset, even though we were interested only in the Summer Olympics 2020.\nWe can see that the majority of section are fairly short (less than 500 tokens)."])</script><script>self.__next_f.push([1,"7b:T128b,"])</script><script>self.__next_f.push([1,"Note: To answer questions based on text documents, we recommend the procedure in Question Answering using Embeddings. Some of the code below may rely on deprecated API endpoints.\nWe use davinci-instruct-beta-v3, a model specialized in following instructions, to create questions based on the given context. Then we also use davinci-instruct-beta-v3 to answer those questions, given the same context.\n\nThis is expensive, and will also take a long time, as we call the davinci engine for each section. You can simply download the final dataset instead.\n\nWe're using the dataset created using the previous notebook\nCreate a context by concatenating the title, the heading and the content of that section\nUse davinci-instruct to generate a number of plausible questions relating to the Wikipedia section contents.\n\nNote: We have used temperature=0, but it may be beneficial to experiment with a higher temperature to get a higher diversity of questions.\n\nWARNING: This step will last a long time, and consume a lot of tokens, as it calls davinci-instruct for every section to generate a number of questions.\nThe prompt is designed to generate a number of questions. Example questions above were generated based on the summary section of the 2020 Summer Olympics page.\n\nWe can observe that the questions 3 and 5 above repeat. Sometimes the generated questions could be ambiguous without the context. We will show that even despite these limitations we can create a successful model.\nUse davinci-instruct to answer the questions given the relevant Wikipedia section contents\n\nNote: We have used temperature=0, but it may be beneficial to experiment with a higher temperature to get a higher diversity of questions.\n\nWARNING: This step will last a long time, and consume a lot of tokens, as it calls davinci-instruct for every section to answer all the questions.\nThese are the answers to the questions above based on the context around the host city selection.\n\nWe can see that answers 3-5 contain the correct answer, but instead of answering the question directly, the answer is a verbatim extraction. Despite these occasional lower quality answers, we will show that the model can learn the task reasonably well, given a high number of examples.\nWe save the file for use in the next notebook\nWe create a search file (API reference), which can be used to retrieve the relevant context when a question is asked.\n\nDEPRECATED: The /search endpoint is deprecated in favour of using embeddings. Embeddings are cheaper, faster and can support a better search experience. See Question Answering Guide for a search implementation using the embeddings\n\n\nWe will use a simple implementation of the answers endpoint. This works by simply using the /search endpoint, which searches over an indexed file to obtain the relevant sections which can be included in the context, following by a question and answering prompt given a specified model.\nAfter we fine-tune the model for Q\u0026A we'll be able to use it instead of davinci-instruct-beta-v3, to obtain better answers when the question can't be answered based on the context. We see a downside of davinci-instruct-beta-v3, which always attempts to answer the question, regardless of the relevant context being present or not. (Note the second question is asking about a future event, set in 2024.)\nWe can see that davinci has a tendency to answer the question, even if the question can't be answered given the context provided. Note the question asked regarding 2048 Summer Olympics, which didn't happen yet, and the retrieved content has only returned results for 2020.\nWe utilize the generated questions based on context to estimate how often we can retrieve the original context. These questions are noisy, so this is not a perfect estimate.\n\nOur questions and answers are prefixed with numbered bullet points, however due to the way they were generated, they are missing the first number, hence we add \"1.\" to the list of questions (and answers).\n\nWe calculate the rank of the section retrieved using ada search, and the number of tokens in the context needed to retrieve the relevant section in full.\nThe relevant context can be obtained 74% of the time on this dataset\n7.4% of the time, this is due to the keyword search part of the search algorithm not retrieving the relevant context within the first 200 results.\n18.3% of the time this is due to the semantic search not placing the relevant context within the first 2000 tokens.\nWe can observe that the context is most likely to be returned as one of the first results, and most likely to be returned within the first 200-500 tokens.\nprobabilities of the relevant context being returned at each rank. (-2 means a processing error, -1 means the rank is \u003e200)"])</script><script>self.__next_f.push([1,"7c:Te18,"])</script><script>self.__next_f.push([1,"Note: To answer questions based on text documents, we recommend the procedure in Question Answering using Embeddings. Some of the code below may rely on deprecated API endpoints.\nThis notebook will utilize the dataset of context, question and answer pairs to additionally create adversarial questions and context pairs, where the question was not generated on that context. In those cases the model will be prompted to answer \"No sufficient context for answering the question\". We will also train a discriminator model, which predicts whether the question can be answered based on the context or not.\n\nWe will add hard adversarial examples as well, which will be based either on semantically similar sections, or neighbouring sections, originating from the same article.\nSplit the sections into a training and testing set\nwe check that the separator we intend to use isn't present within the contexts\nThe fine-tuning dataset is created in the following way. For every corresponding question, answer and context pair we create:\nPositive example: correct question, answer, context pair\nNegative examples:\n  random negative example, where the random context is paired with the question\n  two hard negative examples\n    one originating from the same wikipedia article\n    another, which is most similar to the correct context\n\nThis process is noisy, as sometimes the question might be answerable given a different context, but on average we hope this won't affect the performance too much.\n\nWe apply the same process of dataset creation for both the discriminator, and the Q\u0026A answering model. We apply the process separately for the training and testing set, to ensure that the examples from the training set don't feature within the test set.\nWe apply the same process of dataset creation for both the discriminator, and the Q\u0026A answering model. We apply the process separately for the training and testing set, to ensure that the examples from the training set don't feature within the test set.\nWe formatted the data according to the recommendations from the fine-tuning tool, which is available using\nopenai tools fine_tunes.prepare_data -f qa_train.jsonl\n\nWe highly recommend that you use this tool, which suggests improvements in your data formatting for fine-tuning.\n\n\nWe will now use the fine-tuned discriminator and the fine-tuned Q\u0026A model. By requesting logprobs, we can see how certain the discriminator is in a yes vs no answer.\nWe can see that the model can generalize well to different contexts and questions.\nWe can see that the model can answer the question, when the context is appropriate.\nWe can see that the model knows when to answer the question, and when to say that insufficient context is present to answer the question.\nWe can also combine a discriminator and a base model, or a fine-tuned Q\u0026A model. Discriminator can essentially serve as a decision whether the question can be answered given the context or not.\nThe above function illustrates how to potentially combine a discriminator and a fine-tuned Q\u0026A model. This gives a more fine-grained control over how certain we want the model to be before it answers the question.\n\nWe'll now take a look on how answers endpoint works - combining search to retrieve the relevant context from a knowledge base, and then using the fine-tuned Q\u0026A model to answer the question.\nFinally we can use a logic similar to the /answers endpoint, where we first search for the relevant context, and then ask a Q\u0026A model to answer the question given that context. If you'd like to see the implementation details, check out the answers_with_ft.py file."])</script><script>self.__next_f.push([1,"7d:T586,In this Jupyter Notebook, we construct a Kangas DataGrid containing the data and projections of the embeddings into 2 dimensions.\n\nKangas as an open source, mixed-media, dataframe-like tool for data scientists. It was developed by Comet, a company designed to help reduce the friction of moving models into production.\n\nTo get started, we pip install kangas, and import it.\n\nWe create a Kangas Datagrid with the original data and the embeddings. The data is composed of a rows of reviews, and the embeddings are composed of 1536 floating-point values. In this example, we get the data directly from github, in case you aren't running this notebook inside OpenAI's repo.\n\nWe use Kangas to read the CSV file into a DataGrid for further processing.\nWe can review the fields of the CSV file:\nAnd get a glimpse of the first and last rows:\nNow, we create a new DataGrid, converting the numbers into an Embedding:\nThe new DataGrid now has an Embedding column with proper datatype.\nWe simply save the datagrid, and we're done.\n\nTo render the data directly in the notebook, simply show it. Note that each row contains an embedding projection.\n\nScroll to far right to see embeddings projection per row.\n\nThe color of the point in projection space represents the Score.\nGroup by \"Score\" to see rows of each group.\nAn example of this datagrid is hosted here: https://kangas.comet.com/?datagrid=/data/openai_embeddings.datagrid7e:Tbed,"])</script><script>self.__next_f.push([1,"In this example notebook, we showcase how to perform financial analysis over 10-K documents with the LlamaIndex framework with just a few lines of code.\nIntroduction\nSetup\nData Loading \u0026 Indexing\nSimple QA\nAdvanced QA - Compare and Contrast\n\n\nLlamaIndex is a data framework for LLM applications.\nYou can get started with just a few lines of code and build a retrieval-augmented generation (RAG) system in minutes.\nFor more advanced users, LlamaIndex offers a rich toolkit for ingesting and indexing your data, modules for retrieval and re-ranking, and composable components for building custom query engines.\n\nSee full documentation for more details.\n\nA key part of a financial analyst's job is to extract information and synthesize insight from long financial documents.\nA great example is the 10-K form - an annual report required by the U.S. Securities and Exchange Commission (SEC), that gives a comprehensive summary of a company's financial performance.\nThese documents typically run hundred of pages in length, and contain domain-specific terminology that makes it challenging for a layperson to digest quickly.\n\n\nWe showcase how LlamaIndex can support a financial analyst in quickly extracting information and synthesize insights across multiple documents with very little coding.\nTo begin, we need to install the llama-index library\nNow, we import all modules used in this tutorial\nBefore we start, we can configure the LLM provider and model that will power our RAG system.\nHere, we pick gpt-3.5-turbo-instruct from OpenAI.\nWe construct a ServiceContext and set it as the global default, so all subsequent operations that depends on LLM calls will use the model we configured here.\nNow, we load and parse 2 PDFs (one for Uber 10-K in 2021 and another for Lyft 10-k in 2021).\nUnder the hood, the PDFs are converted to plain text Document objects, separate by page.\nNote: this operation might take a while to run, since each document is more than 100 pages.\nNow, we can build an (in-memory) VectorStoreIndex over the documents that we've loaded.\nNote: this operation might take a while to run, since it calls OpenAI API for computing vector embedding over document chunks.\nNow we are ready to run some queries against our indices!\nTo do so, we first configure a QueryEngine, which just captures a set of configurations for how we want to query the underlying index.\n\nFor a VectorStoreIndex, the most common configuration to adjust is similarity_top_k which controls how many document chunks (which we call Node objects) are retrieved to use as context for answering our question.\nLet's see some queries in action!\nFor more complex financial analysis, one often needs to reference multiple documents.\n\nAs a example, let's take a look at how to do compare-and-contrast queries over both Lyft and Uber financials.\nFor this, we build a SubQuestionQueryEngine, which breaks down a complex compare-and-contrast query, into simpler sub-questions to execute on respective sub query engine backed by individual indices.\nLet's see these queries in action!"])</script><script>self.__next_f.push([1,"7f:Td31,"])</script><script>self.__next_f.push([1,"This notebook guides you step by step on using PolarDB-PG as a vector database for OpenAI embeddings.\n\nThis notebook presents an end-to-end process of:\nUsing precomputed embeddings created by OpenAI API.\nStoring the embeddings in a cloud instance of PolarDB-PG.\nConverting raw text query to an embedding with OpenAI API.\nUsing PolarDB-PG to perform the nearest neighbour search in the created collection.\n\n\nPolarDB-PG is a high-performance vector database that adopts a read-write separation architecture. It is a cloud-native database managed by Alibaba Cloud, 100% compatible with PostgreSQL, and highly compatible with Oracle syntax. It supports processing massive vector data storage and queries, and greatly improves the efficiency of vector calculations through optimization of underlying execution algorithms, providing users with fast, elastic, high-performance, massive storage, and secure and reliable vector database services. Additionally, PolarDB-PG also supports multi-dimensional and multi-modal spatiotemporal information engines and geographic information engines.At the same time, PolarDB-PG is equipped with complete OLAP functionality and service level agreements, which has been recognized and used by many users;\n\n\n\n\n\n\n\n\nUsing PolarDB-PG Cloud Vector Database. Click here to fast deploy it.\n\nFor the purposes of this exercise we need to prepare a couple of things:\n\nPolarDB-PG cloud server instance.\nThe 'psycopg2' library to interact with the vector database. Any other postgresql client library is ok.\nAn OpenAI API key.\nWe might validate if the server was launched successfully by running a simple curl command:\n\nThis notebook obviously requires the openai and psycopg2 packages, but there are also some other additional libraries we will use. The following command installs them all:\n\nPrepare your OpenAI API key\nThe OpenAI API key is used for vectorization of the documents and queries.\n\nIf you don't have an OpenAI API key, you can get one from https://beta.openai.com/account/api-keys.\n\nOnce you get your key, please add it to your environment variables as OPENAI_API_KEY.\n\nIf you have any doubts about setting the API key through environment variables, please refer to Best Practices for API Key Safety.\nFirst add it to your environment variables. or you can just change the \"psycopg2.connect\" parameters below\n\nConnecting to a running instance of PolarDB server is easy with the official Python library:\nWe can test the connection by running any available method:\nThe downloaded file has to be then extracted:\n\nPolarDB stores data in relation where each object is described by at least one vector. Our relation will be called articles and each object will be described by both title and content vectors.\n\nWe will start with creating a relation and create a vector index on both title and content, and then we will fill it with our precomputed embeddings.\n\nIn this section we are going to load the data prepared previous to this session, so you don't have to recompute the embeddings of Wikipedia articles with your own credits.\n\nOnce the data is put into Qdrant we will start querying the collection for the closest vectors. We may provide an additional parameter vector_name to switch from title to content based search. Since the precomputed embeddings were created with text-embedding-3-small OpenAI model we also have to use it during search."])</script><script>self.__next_f.push([1,"80:T513,SingleStoreDB has first-class support for vector search through our Vector Functions. Our vector database subsystem, first made available in 2017 and subsequently enhanced, allows extremely fast nearest-neighbor search to find objects that are semantically similar, easily using SQL.\n\nSingleStoreDB supports vectors and vector similarity search using dot_product (for cosine similarity) and euclidean_distance functions. These functions are used by our customers for applications including face recognition, visual product photo search and text-based semantic search. With the explosion of generative AI technology, these capabilities form a firm foundation for text-based AI chatbots.\n\nBut remember, SingleStoreDB is a high-performance, scalable, modern SQL DBMS that supports multiple data models including structured data, semi-structured data based on JSON, time-series, full text, spatial, key-value and of course vector data. Start powering your next intelligent application with SingleStoreDB today!\n\nSingleStore Open AI\n\n\nThis folder contains examples of using SingleStoreDB and OpenAI together. We will keep adding more scenarios so stay tuned!\n\n| Name | Description |\n| --- | --- |\n| OpenAI wikipedia semantic search | Improve ChatGPT accuracy through SingleStoreDB semantic Search in QA |81:Tbb3,"])</script><script>self.__next_f.push([1,"This notebook guides you step by step on using AnalyticDB as a vector database for OpenAI embeddings.\n\nThis notebook presents an end-to-end process of:\nUsing precomputed embeddings created by OpenAI API.\nStoring the embeddings in a cloud instance of AnalyticDB.\nConverting raw text query to an embedding with OpenAI API.\nUsing AnalyticDB to perform the nearest neighbour search in the created collection.\n\n\nAnalyticDB is a high-performance distributed vector database. Fully compatible with PostgreSQL syntax, you can effortlessly utilize it. AnalyticDB is Alibaba Cloud managed cloud-native database with strong-performed vector compute engine. Absolute out-of-box experience allow to scale into billions of data vectors processing with rich features including indexing algorithms, structured \u0026 non-structured data features, realtime update, distance metrics, scalar filtering, time travel searches etc. Also equipped with full OLAP database functionality and SLA commitment for production usage promise;\n\n\nUsing AnalyticDB Cloud Vector Database. Click here to fast deploy it.\n\n\nFor the purposes of this exercise we need to prepare a couple of things:\n\nAnalyticDB cloud server instance.\nThe 'psycopg2' library to interact with the vector database. Any other postgresql client library is ok.\nAn OpenAI API key.\n\n\nWe might validate if the server was launched successfully by running a simple curl command:\n\n\nThis notebook obviously requires the openai and psycopg2 packages, but there are also some other additional libraries we will use. The following command installs them all:\n\n\nThe OpenAI API key is used for vectorization of the documents and queries.\n\nIf you don't have an OpenAI API key, you can get one from https://beta.openai.com/account/api-keys.\n\nOnce you get your key, please add it to your environment variables as OPENAI_API_KEY.\nFirst add it to your environment variables. or you can just change the \"psycopg2.connect\" parameters below\n\nConnecting to a running instance of AnalyticDB server is easy with the official Python library:\nWe can test the connection by running any available method:\nThe downloaded file has to be then extracted:\n\nAnalyticDB stores data in relation where each object is described by at least one vector. Our relation will be called articles and each object will be described by both title and content vectors. \\\n\nWe will start with creating a relation and create a vector index on both title and content, and then we will fill it with our precomputed embeddings.\n\nIn this section we are going to load the data prepared previous to this session, so you don't have to recompute the embeddings of Wikipedia articles with your own credits.\n\nOnce the data is put into Qdrant we will start querying the collection for the closest vectors. We may provide an additional parameter vector_name to switch from title to content based search. Since the precomputed embeddings were created with text-embedding-3-small OpenAI model we also have to use it during search."])</script><script>self.__next_f.push([1,"82:Td49,"])</script><script>self.__next_f.push([1,"This notebook presents how to implement a Question Answering system with Langchain, AnalyticDB as a knowledge based and OpenAI embeddings. If you are not familiar with AnalyticDB, it’s better to check out the Getting_started_with_AnalyticDB_and_OpenAI.ipynb notebook.\n\nThis notebook presents an end-to-end process of:\nCalculating the embeddings with OpenAI API.\nStoring the embeddings in an AnalyticDB instance to build a knowledge base.\nConverting raw text query to an embedding with OpenAI API.\nUsing AnalyticDB to perform the nearest neighbour search in the created collection to find some context.\nAsking LLM to find the answer in a given context.\n\nAll the steps will be simplified to calling some corresponding Langchain methods.\nFor the purposes of this exercise we need to prepare a couple of things:\nAnalyticDB cloud instance.\nLangchain as a framework.\nAn OpenAI API key.\nThis notebook requires the following Python packages: openai, tiktoken, langchain and psycopg2cffi.\nopenai provides convenient access to the OpenAI API.\ntiktoken is a fast BPE tokeniser for use with OpenAI's models.\nlangchain helps us to build applications with LLM more easily.\npsycopg2cffi library is used to interact with the vector database, but any other PostgreSQL client library is also acceptable.\nThe OpenAI API key is used for vectorization of the documents and queries.\n\nIf you don't have an OpenAI API key, you can get one from [https://platform.openai.com/account/api-keys ).\n\nOnce you get your key, please add it to your environment variables as OPENAI_API_KEY by running following command:\nTo build the AnalyticDB connection string, you need to have the following parameters: PG_HOST, PG_PORT, PG_DATABASE, PG_USER, and PG_PASSWORD. You need to export them first to set correct connect string. Then build the connection string.\nIn this section we are going to load the data containing some natural questions and answers to them. All the data will be used to create a Langchain application with AnalyticDB being the knowledge base.\n\nLangchain is already integrated with AnalyticDB and performs all the indexing for given list of documents. In our case we are going to store the set of answers we have.\nAt this stage all the possible answers are already stored in  AnalyticDB, so we can define the whole QA chain.\n\nOnce the data is put into AnalyticDB we can start asking some questions. A question will be automatically vectorized by OpenAI model, and the created vector will be used to find some possibly matching answers in AnalyticDB. Once retrieved, the most similar answers will be incorporated into the prompt sent to OpenAI Large Language Model.\n\n\nThe stuff chain type in Langchain uses a specific prompt with question and context documents incorporated. This is what the default prompt looks like:\n\nUse the following pieces of context to answer the question at the end. If you don't know the answer, just say that you don't know, don't try to make up an answer.\n{context}\nQuestion: {question}\nHelpful Answer:\n\nWe can, however, provide our prompt template and change the behaviour of the OpenAI LLM, while still using the stuff chain type. It is important to keep {context} and {question} as placeholders.\n\n\nWe can try using a different prompt template, so the model:\nResponds with a single-sentence answer if it knows it.\nSuggests a random song title if it doesn't know the answer to our question."])</script><script>self.__next_f.push([1,"83:T9e3,"])</script><script>self.__next_f.push([1,"This notebook provides step by step instuctions on using Azure AI Search (f.k.a Azure Cognitive Search) as a vector database with OpenAI embeddings. Azure AI Search is a cloud search service that gives developers infrastructure, APIs, and tools for building a rich search experience over private, heterogeneous content in web, mobile, and enterprise applications.\n\nFor the purposes of this exercise you must have the following:\nAzure AI Search Service\nOpenAI Key or Azure OpenAI credentials\n\nThis section guides you through setting up authentication for Azure OpenAI, allowing you to securely interact with the service using either Azure Active Directory (AAD) or an API key. Before proceeding, ensure you have your Azure OpenAI endpoint and credentials ready. For detailed instructions on setting up AAD with Azure OpenAI, refer to the official documentation.\n\nThis section explains how to set up the Azure AI Search client for integrating with the Vector Store feature. You can locate your Azure AI Search service details in the Azure Portal or programmatically via the Search Management SDK.\n\n\nThis code snippet demonstrates how to define and create a search index using the SearchIndexClient from the Azure AI Search Python SDK. The index incorporates both vector search and semantic ranker capabilities. For more details, visit our documentation on how to Create a Vector Index\n\nThe following code snippet outlines the process of uploading a batch of documents—specifically, Wikipedia articles with pre-computed embeddings—from a pandas DataFrame to an Azure AI Search index. For a detailed guide on data import strategies and best practices, refer to  Data Import in Azure AI Search.\n\nIf your dataset didn't already contain pre-computed embeddings, you can create embeddings by using the below function using the openai python library. You'll also notice the same function and model are being used to generate query embeddings for performing vector searches.\nHybrid search combines the capabilities of traditional keyword-based search with vector-based similarity search to provide more relevant and contextual results. This approach is particularly useful when dealing with complex queries that benefit from understanding the semantic meaning behind the text.\n\nThe provided code snippet demonstrates how to execute a hybrid search query:\nSemantic ranker measurably improves search relevance by using language understanding to rerank search results. Additionally, you can get extractive captions, answers, and highlights."])</script><script>self.__next_f.push([1,"84:T2b64,"])</script><script>self.__next_f.push([1,"In this quickstart you will learn how to build a \"philosophy quote finder \u0026 generator\" using OpenAI's vector embeddings and Apache Cassandra®, or equivalently DataStax Astra DB through CQL, as the vector store for data persistence.\n\nThe basic workflow of this notebook is outlined below. You will evaluate and store the vector embeddings for a number of quotes by famous philosophers, use them to build a powerful search engine and, after that, even a generator of new quotes!\n\nThe notebook exemplifies some of the standard usage patterns of vector search -- while showing how easy is it to get started with the vector capabilities of Cassandra / Astra DB through CQL.\n\nFor a background on using vector search and text embeddings to build a question-answering system, please check out this excellent hands-on notebook: Question answering using embeddings.\n\n\nPlease note that this notebook uses the Cassandra drivers and runs CQL (Cassandra Query Language) statements directly, but we cover other choices of technology to accomplish the same task. Check out this folder's README for other options. This notebook can run either as a Colab notebook or as a regular Jupyter notebook.\n\nTable of contents:\nSetup\nGet DB connection\nConnect to OpenAI\nLoad quotes into the Vector Store\nUse case 1: quote search engine\nUse case 2: quote generator\n(Optional) exploit partitioning in the Vector Store\n\nIndexing\n\nEach quote is made into an embedding vector with OpenAI's Embedding. These are saved in the Vector Store for later use in searching. Some metadata, including the author's name and a few other pre-computed tags, are stored alongside, to allow for search customization.\n\n1_vector_indexing_cql\n\nSearch\n\nTo find a quote similar to the provided search quote, the latter is made into an embedding vector on the fly, and this vector is used to query the store for similar vectors ... i.e. similar quotes that were previously indexed. The search can optionally be constrained by additional metadata (\"find me quotes by Spinoza similar to this one ...\").\n\n2_vector_search_cql\n\nThe key point here is that \"quotes similar in content\" translates, in vector space, to vectors that are metrically close to each other: thus, vector similarity search effectively implements semantic similarity. This is the key reason vector embeddings are so powerful.\n\nThe sketch below tries to convey this idea. Each quote, once it's made into a vector, is a point in space. Well, in this case it's on a sphere, since OpenAI's embedding vectors, as most others, are normalized to unit length. Oh, and the sphere is actually not three-dimensional, rather 1536-dimensional!\n\nSo, in essence, a similarity search in vector space returns the vectors that are closest to the query vector:\n\n3_vector_space\n\nGeneration\n\nGiven a suggestion (a topic or a tentative quote), the search step is performed, and the first returned results (quotes) are fed into an LLM prompt which asks the generative model to invent a new text along the lines of the passed examples and the initial suggestion.\n\n4_quote_generation\nInstall and import the necessary dependencies:\nDon't mind the next cell too much, we need it to detect Colabs and let you upload the SCB file (see below):\nA couple of secrets are required to create a Session object (a connection to your Astra DB instance).\n\n(Note: some steps will be slightly different on Google Colab and on local Jupyter, that's why the notebook will detect the runtime type.)\n\nThis is how you create a connection to Astra DB:\n\n(Incidentally, you could also use any Cassandra cluster (as long as it provides Vector capabilities), just by changing the parameters to the following Cluster instantiation.)\n\nYou need a table which support vectors and is equipped with metadata. Call it \"philosophers_cql\".\n\nEach row will store: a quote, its vector embedding, the quote author and a set of \"tags\". You also need a primary key to ensure uniqueness of rows.\n\nThe following is the full CQL command that creates the table (check out this page for more on the CQL syntax of this and the following statements):\nPass this statement to your database Session to execute it:\nIn order to run ANN (approximate-nearest-neighbor) searches on the vectors in the table, you need to create a specific index on the embedding_vector column.\n\nWhen creating the index, you can optionally choose the \"similarity function\" used to compute vector distances: since for unit-length vectors (such as those from OpenAI) the \"cosine difference\" is the same as the \"dot product\", you'll use the latter which is computationally less expensive.\n\nRun this CQL statement:\nThat is enough to run vector searches on the table ... but you want to be able to optionally specify an author and/or some tags to restrict the quote search. Create two other indexes to support this:\n\nQuickly check how one can get the embedding vectors for a list of input texts:\nNote: the above is the syntax for OpenAI v1.0+. If using previous versions, the code to get the embeddings will look different.\nGet a dataset with the quotes. (We adapted and augmented the data from this Kaggle dataset, ready to use in this demo.)\nA quick inspection:\nCheck the dataset size:\n\nYou will compute the embeddings for the quotes and save them into the Vector Store, along with the text itself and the metadata planned for later use.\n\nTo optimize speed and reduce the calls, you'll perform batched calls to the embedding OpenAI service.\n\nThe DB write is accomplished with a CQL statement. But since you'll run this particular insertion several times (albeit with different values), it's best to prepare the statement and then just run it over and over.\n\n(Note: for faster insertion, the Cassandra drivers would let you do concurrent inserts, which we don't do here for a more straightforward demo code.)\nFor the quote-search functionality, you need first to make the input quote into a vector, and then use it to query the store (besides handling the optional metadata into the search call, that is).\n\nEncapsulate the search-engine functionality into a function for ease of re-use:\nPassing just a quote:\nSearch restricted to an author:\nSearch constrained to a tag (out of those saved earlier with the quotes):\n\nThe vector similarity search generally returns the vectors that are closest to the query, even if that means results that might be somewhat irrelevant if there's nothing better.\n\nTo keep this issue under control, you can get the actual \"similarity\" between the query and each result, and then set a cutoff on it, effectively discarding results that are beyond that threshold.\nTuning this threshold correctly is not an easy problem: here, we'll just show you the way.\n\nTo get a feeling on how this works, try the following query and play with the choice of quote and threshold to compare the results:\n\nNote (for the mathematically inclined): this value is a rescaling between zero and one of the cosine difference between the vectors, i.e. of the scalar product divided by the product of the norms of the two vectors. In other words, this is 0 for opposite-facing vecors and +1 for parallel vectors. For other measures of similarity, check the documentation -- and keep in mind that the metric in the SELECT query should match the one used when creating the index earlier for meaningful, ordered results.\nFor this task you need another component from OpenAI, namely an LLM to generate the quote for us (based on input obtained by querying the Vector Store).\n\nYou also need a template for the prompt that will be filled for the generate-quote LLM completion task.\nLike for search, this functionality is best wrapped into a handy function (which internally uses search):\nNote: similar to the case of the embedding computation, the code for the Chat Completion API would be slightly different for OpenAI prior to v1.0.\nJust passing a text (a \"quote\", but one can actually just suggest a topic since its vector embedding will still end up at the right place in the vector space):\nUse inspiration from just a single philosopher:\nThere's an interesting topic to examine before completing this quickstart. While, generally, tags and quotes can be in any relationship (e.g. a quote having multiple tags), authors are effectively an exact grouping (they define a \"disjoint partitioning\" on the set of quotes): each quote has exactly one author (for us, at least).\n\nNow, suppose you know in advance your application will usually (or always) run queries on a single author. Then you can take full advantage of the underlying database structure: if you group quotes in partitions (one per author), vector queries on just an author will use less resources and return much faster.\n\nWe'll not dive into the details here, which have to do with the Cassandra storage internals: the important message is that if your queries are run within a group, consider partitioning accordingly to boost performance.\n\nYou'll now see this choice in action.\nThe partitioning per author calls for a new table schema: create a new table called \"philosophers_cql_partitioned\", along with the necessary indexes:\nNow repeat the compute-embeddings-and-insert step on the new table.\n\nYou could use the very same insertion code as you did earlier, because the differences are hidden \"behind the scenes\": the database will store the inserted rows differently according to the partitioning scheme of this new table.\n\nHowever, by way of demonstration, you will take advantage of a handy facility offered by the Cassandra drivers to easily run several queries (in this case, INSERTs) concurrently. This is something that Cassandra / Astra DB through CQL supports very well and can lead to a significant speedup, with very little changes in the client code.\n\n(Note: one could additionally have cached the embeddings computed previously to save a few API tokens -- here, however, we wanted to keep the code easier to inspect.)\nDespite the different table schema, the DB query behind the similarity search is essentially the same:\nThat's it: the new table still supports the \"generic\" similarity searches all right ...\n... but it's when an author is specified that you would notice a huge performance advantage:\nWell, you would notice a performance gain, if you had a realistic-size dataset. In this demo, with a few tens of entries, there's no noticeable difference -- but you get the idea.\n\nCongratulations! You have learned how to use OpenAI for vector embeddings and Astra DB / Cassandra for storage in order to build a sophisticated philosophical search engine and quote generator.\n\nThis example used the Cassandra drivers and runs CQL (Cassandra Query Language) statements directly to interface with the Vector Store - but this is not the only choice. Check the README for other options and integration with popular frameworks.\n\nTo find out more on how Astra DB's Vector Search capabilities can be a key ingredient in your ML/GenAI applications, visit Astra DB's web page on the topic.\n\nIf you want to remove all resources used for this demo, run this cell (warning: this will delete the tables and the data inserted in them!):"])</script><script>self.__next_f.push([1,"85:T2738,"])</script><script>self.__next_f.push([1,"In this quickstart you will learn how to build a \"philosophy quote finder \u0026 generator\" using OpenAI's vector embeddings and Apache Cassandra®, or equivalently DataStax Astra DB through CQL, as the vector store for data persistence.\n\nThe basic workflow of this notebook is outlined below. You will evaluate and store the vector embeddings for a number of quotes by famous philosophers, use them to build a powerful search engine and, after that, even a generator of new quotes!\n\nThe notebook exemplifies some of the standard usage patterns of vector search -- while showing how easy is it to get started with the vector capabilities of Cassandra / Astra DB through CQL.\n\nFor a background on using vector search and text embeddings to build a question-answering system, please check out this excellent hands-on notebook: Question answering using embeddings.\n\n\nPlease note that this notebook uses the CassIO library, but we cover other choices of technology to accomplish the same task. Check out this folder's README for other options. This notebook can run either as a Colab notebook or as a regular Jupyter notebook.\n\nTable of contents:\nSetup\nGet DB connection\nConnect to OpenAI\nLoad quotes into the Vector Store\nUse case 1: quote search engine\nUse case 2: quote generator\n(Optional) exploit partitioning in the Vector Store\n\nIndexing\n\nEach quote is made into an embedding vector with OpenAI's Embedding. These are saved in the Vector Store for later use in searching. Some metadata, including the author's name and a few other pre-computed tags, are stored alongside, to allow for search customization.\n\n1_vector_indexing\n\nSearch\n\nTo find a quote similar to the provided search quote, the latter is made into an embedding vector on the fly, and this vector is used to query the store for similar vectors ... i.e. similar quotes that were previously indexed. The search can optionally be constrained by additional metadata (\"find me quotes by Spinoza similar to this one ...\").\n\n2_vector_search\n\nThe key point here is that \"quotes similar in content\" translates, in vector space, to vectors that are metrically close to each other: thus, vector similarity search effectively implements semantic similarity. This is the key reason vector embeddings are so powerful.\n\nThe sketch below tries to convey this idea. Each quote, once it's made into a vector, is a point in space. Well, in this case it's on a sphere, since OpenAI's embedding vectors, as most others, are normalized to unit length. Oh, and the sphere is actually not three-dimensional, rather 1536-dimensional!\n\nSo, in essence, a similarity search in vector space returns the vectors that are closest to the query vector:\n\n3_vector_space\n\nGeneration\n\nGiven a suggestion (a topic or a tentative quote), the search step is performed, and the first returned results (quotes) are fed into an LLM prompt which asks the generative model to invent a new text along the lines of the passed examples and the initial suggestion.\n\n4_quote_generation\nFirst install some required packages:\nIn order to connect to your Astra DB through CQL, you need two things:\nA Token, with role \"Database Administrator\" (it looks like AstraCS:...)\nthe database ID (it looks like 3df2a5b6-...)\n\n    Make sure you have both strings -- which are obtained in the Astra UI once you sign in. For more information, see here: database ID and Token.\n\nIf you want to connect to a Cassandra cluster (which however must support Vector Search), replace with cassio.init(session=..., keyspace=...) with suitable Session and keyspace name for your cluster.\n\nThis is how you create a connection to Astra DB through CQL:\n\n(Incidentally, you could also use any Cassandra cluster (as long as it provides Vector capabilities), just by changing the parameters to the following Cluster instantiation.)\n\nYou need a table which support vectors and is equipped with metadata. Call it \"philosophers_cassio\":\n\nQuickly check how one can get the embedding vectors for a list of input texts:\nNote: the above is the syntax for OpenAI v1.0+. If using previous versions, the code to get the embeddings will look different.\n_Note: the above is the syntax for OpenAI v1.0+. If using previous versions, the code to get the embeddings will look different._\nA quick inspection:\nCheck the dataset size:\n\nYou will compute the embeddings for the quotes and save them into the Vector Store, along with the text itself and the metadata planned for later use. Note that the author is added as a metadata field along with the \"tags\" already found with the quote itself.\n\nTo optimize speed and reduce the calls, you'll perform batched calls to the embedding OpenAI service.\n\n(Note: for faster execution, Cassandra and CassIO would let you do concurrent inserts, which we don't do here for a more straightforward demo code.)\nFor the quote-search functionality, you need first to make the input quote into a vector, and then use it to query the store (besides handling the optional metadata into the search call, that is).\n\nEncapsulate the search-engine functionality into a function for ease of re-use:\nPassing just a quote:\nSearch restricted to an author:\nSearch constrained to a tag (out of those saved earlier with the quotes):\n\nThe vector similarity search generally returns the vectors that are closest to the query, even if that means results that might be somewhat irrelevant if there's nothing better.\n\nTo keep this issue under control, you can get the actual \"distance\" between the query and each result, and then set a cutoff on it, effectively discarding results that are beyond that threshold.\nTuning this threshold correctly is not an easy problem: here, we'll just show you the way.\n\nTo get a feeling on how this works, try the following query and play with the choice of quote and threshold to compare the results:\n\nNote (for the mathematically inclined): this \"distance\" is exactly the cosine similarity between the vectors, i.e. the scalar product divided by the product of the norms of the two vectors. As such, it is a number ranging from -1 to +1, where -1 is for exactly opposite-facing vectors and +1 for identically-oriented vectors. Elsewhere (e.g. in the \"CQL\" counterpart of this demo) you would get a rescaling of this quantity to fit the [0, 1] interval, which means the resulting numerical values and adequate thresholds there are transformed accordingly.\nFor this task you need another component from OpenAI, namely an LLM to generate the quote for us (based on input obtained by querying the Vector Store).\n\nYou also need a template for the prompt that will be filled for the generate-quote LLM completion task.\nLike for search, this functionality is best wrapped into a handy function (which internally uses search):\nNote: similar to the case of the embedding computation, the code for the Chat Completion API would be slightly different for OpenAI prior to v1.0.\nJust passing a text (a \"quote\", but one can actually just suggest a topic since its vector embedding will still end up at the right place in the vector space):\nUse inspiration from just a single philosopher:\nThere's an interesting topic to examine before completing this quickstart. While, generally, tags and quotes can be in any relationship (e.g. a quote having multiple tags), authors are effectively an exact grouping (they define a \"disjoint partitioning\" on the set of quotes): each quote has exactly one author (for us, at least).\n\nNow, suppose you know in advance your application will usually (or always) run queries on a single author. Then you can take full advantage of the underlying database structure: if you group quotes in partitions (one per author), vector queries on just an author will use less resources and return much faster.\n\nWe'll not dive into the details here, which have to do with the Cassandra storage internals: the important message is that if your queries are run within a group, consider partitioning accordingly to boost performance.\n\nYou'll now see this choice in action.\nFirst, you need a different table abstraction from CassIO:\nNow repeat the compute-embeddings-and-insert step on the new table.\n\nCompared to what you have seen earlier, there is a crucial difference in that now the quote's author is stored as the partition id for the inserted row, instead of being added to the catch-all \"metadata\" dictionary.\n\nWhile you are at it, by way of demonstration, you will insert all quotes by a given author concurrently: with CassIO, this is done by usng the asynchronous put_async method for each quote, collecting the resulting list of Future objects, and calling the result() method on them all afterwards, to ensure they all have executed. Cassandra / Astra DB well supports a high degree of concurrency in I/O operations.\n\n(Note: one could have cached the embeddings computed previously to save a few API tokens -- here, however, we wanted to keep the code easier to inspect.)\nWith this new table, the similarity search changes accordingly (note the arguments to ann_search):\nThat's it: the new table still supports the \"generic\" similarity searches all right ...\n... but it's when an author is specified that you would notice a huge performance advantage:\nWell, you would notice a performance gain, if you had a realistic-size dataset. In this demo, with a few tens of entries, there's no noticeable difference -- but you get the idea.\n\nCongratulations! You have learned how to use OpenAI for vector embeddings and Cassandra / Astra DB through CQL for storage in order to build a sophisticated philosophical search engine and quote generator.\n\nThis example used CassIO to interface with the Vector Store - but this is not the only choice. Check the README for other options and integration with popular frameworks.\n\nTo find out more on how Astra DB's Vector Search capabilities can be a key ingredient in your ML/GenAI applications, visit Astra DB's web page on the topic.\n\nIf you want to remove all resources used for this demo, run this cell (warning: this will delete the tables and the data inserted in them!):"])</script><script>self.__next_f.push([1,"86:T56b,The demos in this directory show how to use the Vector\nSearch capabilities available today in DataStax Astra DB, a serverless\nDatabase-as-a-Service built on Apache Cassandra®.\n\nThese example notebooks demonstrate implementation of\nthe same GenAI standard RAG workload with different libraries and APIs.\n\nTo use Astra DB\nwith its HTTP API interface, head to the \"AstraPy\" notebook (astrapy\nis the Python client to interact with the database).\n\nIf you prefer CQL access to the database (either with\nAstra DB\nor a Cassandra cluster\nsupporting vector search),\ncheck the \"CQL\" or \"CassIO\" notebooks -- they differ in the level of abstraction you get to work at.\n\nIf you want to know more about Astra DB and its Vector Search capabilities,\nhead over to datastax.com.\n\n\nThe following examples show how easily OpenAI and DataStax Astra DB can\nwork together to power vector-based AI applications. You can run them either\nwith your local Jupyter engine or as Colab notebooks:\n\n| Use case | Target database | Framework | Notebook | Google Colab |\n| -------- | --------------- | --------- | -------- | ------------ |\n| Search/generate quotes | Astra DB | AstraPy | Notebook | Colab |\n| Search/generate quotes | Cassandra / Astra DB through CQL | CassIO | Notebook | Colab |\n| Search/generate quotes | Cassandra / Astra DB through CQL | Plain Cassandra language | Notebook | Colab |\n\n\n3_vector_space87:Te61,"])</script><script>self.__next_f.push([1,"This notebook takes you through a simple flow to download some data, embed it, and then index and search it using a selection of vector databases. This is a common requirement for customers who want to store and search our embeddings with their own data in a secure environment to support production use cases such as chatbots, topic modelling and more.\n\n\nA vector database is a database made to store, manage and search embedding vectors. The use of embeddings to encode unstructured data (text, audio, video and more) as vectors for consumption by machine-learning models has exploded in recent years, due to the increasing effectiveness of AI in solving use cases involving natural language, image recognition and other unstructured forms of data. Vector databases have emerged as an effective solution for enterprises to deliver and scale these use cases.\n\n\nVector databases enable enterprises to take many of the embeddings use cases we've shared in this repo (question and answering, chatbot and recommendation services, for example), and make use of them in a secure, scalable environment. Many of our customers make embeddings solve their problems at small scale but performance and security hold them back from going into production - we see vector databases as a key component in solving that, and in this guide we'll walk through the basics of embedding text data, storing it in a vector database and using it for semantic search.\n\n\nThe demo flow is:\nSetup**: Import packages and set any required variables\nLoad data**: Load a dataset and embed it using OpenAI embeddings\nChroma**:\n    Setup: Here we'll set up the Python client for Chroma. For more details go here\n    Index Data: We'll create collections with vectors for titles and content\n    Search Data: We'll run a few searches to confirm it works\n\nOnce you've run through this notebook you should have a basic understanding of how to setup and use vector databases, and can move on to more complex use cases making use of our embeddings.\n\nImport the required libraries and set the embedding model that we'd like to use.\n\nIn this section we'll load embedded data that we've prepared previous to this session.\n\nWe'll index these embedded documents in a vector database and search them. The first option we'll look at is Chroma, an easy to use open-source self-hosted in-memory vector database, designed for working with embeddings together with LLMs.\n\nIn this section, we will:\nInstantiate the Chroma client\nCreate collections for each class of embedding\nQuery each collection\n\nCreate the Chroma client. By default, Chroma is ephemeral and runs in memory.\nHowever, you can easily set up a persistent configuration which writes to disk.\n\nChroma collections allow you to store and filter with arbitrary metadata, making it easy to query subsets of the embedded data.\n\nChroma is already integrated with OpenAI's embedding functions. The best way to use them is on construction of a collection, as follows.\nAlternatively, you can 'bring your own embeddings'. More information can be found here\n\nChroma collections allow you to populate, and filter on, whatever metadata you like. Chroma can also store the text alongside the vectors, and return everything in a single query call, when this is more convenient.\n\nFor this use-case, we'll just store the embeddings and IDs, and use these to index the original dataframe.\n\nChroma handles embedding queries for you if an embedding function is set, like in this example.\nNow that you've got a basic embeddings search running, you can hop over to the Chroma docs to learn more about how to add filters to your query, update/delete data in your collections, and deploy Chroma."])</script><script>self.__next_f.push([1,"88:T223c,"])</script><script>self.__next_f.push([1,"This notebook guides you step-by-step through answering questions about a collection of data, using Chroma, an open-source embeddings database, along with OpenAI's text embeddings and chat completion API's.\n\nAdditionally, this notebook demonstrates some of the tradeoffs in making a question answering system more robust. As we shall see, simple querying doesn't always create the best results!\n\nLarge language models (LLMs) like OpenAI's ChatGPT can be used to answer questions about data that the model may not have been trained on, or have access to. For example;\n\nPersonal data like e-mails and notes\nHighly specialized data like archival or legal documents\nNewly created data like recent news stories\n\nIn order to overcome this limitation, we can use a data store which is amenable to querying in natural language, just like the LLM itself. An embeddings store like Chroma represents documents as embeddings, alongside the documents themselves.\n\nBy embedding a text query, Chroma can find relevant documents, which we can then pass to the LLM to answer our question. We'll show detailed examples and variants of this approach.\n\nFirst we make sure the python dependencies we need are installed.\nWe use OpenAI's API's throughout this notebook. You can get an API key from https://beta.openai.com/account/api-keys\n\nYou can add your API key as an environment variable by executing the command export OPENAI_API_KEY=sk-xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx in a terminal. Note that you will need to reload the notebook if the environment variable wasn't set yet. Alternatively, you can set it in the notebook, see below.\n\nThroughout this notebook, we use the SciFact dataset. This is a curated dataset of expert annotated scientific claims, with an accompanying text corpus of paper titles and abstracts. Each claim may be supported, contradicted, or not have enough evidence either way, according to the documents in the corpus.\n\nHaving the corpus available as ground-truth allows us to investigate how well the following approaches to LLM question answering perform.\n\nChatGPT was trained on a large amount of scientific information. As a baseline, we'd like to understand what the model already knows without any further context. This will allow us to calibrate overall performance.\n\nWe construct an appropriate prompt, with some example facts, then query the model with each claim in the dataset. We ask the model to assess a claim as 'True', 'False', or 'NEE' if there is not enough evidence one way or the other.\nWe sample 50 claims from the dataset\nWe evaluate the ground-truth according to the dataset. From the dataset description, each claim is either supported or contradicted by the evidence, or else there isn't enough evidence either way.\nWe also output the confusion matrix, comparing the model's assessments with the ground truth, in an easy to read table.\nWe ask the model to directly assess the claims, without additional context.\n\nFrom these results we see that the LLM is strongly biased to assess claims as true, even when they are false, and also tends to assess false claims as not having enough evidence. Note that 'not enough evidence' is with respect to the model's assessment of the claim in a vacuum, without additional context.\n\n\nWe now add the additional context available from the corpus of paper titles and abstracts. This section shows how to load a text corpus into Chroma, using OpenAI text embeddings.\nFirst, we load the text corpus.\n\nThe next step is to load the corpus into Chroma. Given an embedding function, Chroma will automatically handle embedding each document, and will store it alongside its text and metadata, making it simple to query.\nWe instantiate a (ephemeral) Chroma client, and create a collection for the SciFact title and abstract corpus.\nChroma can also be instantiated in a persisted configuration; learn more at the Chroma docs.\nNext we load the corpus into Chroma. Because this data loading is memory intensive, we recommend using a batched loading scheme in batches of 50-1000. For this example it should take just over one minute for the entire corpus. It's being embedded in the background, automatically, using the embedding_function we specified earlier.\n\nNext we retrieve documents from the corpus which may be relevant to each claim in our sample. We want to provide these as context to the LLM for evaluating the claims. We retrieve the 3 most relevant documents for each claim, according to the embedding distance.\nWe create a new prompt, this time taking into account the additional context we retrieve from the corpus.\nThen ask the model to evaluate the claims with the retrieved context.\n\nWe see that the model performs better overall, and is now significantly better at correctly identifying false claims. Additionally, most NEE cases are also correctly identified now.\n\nTaking a look at the retrieved documents, we see that they are sometimes not relevant to the claim - this causes the model to be confused by the extra information, and it may decide that sufficient evidence is present, even when the information is irrelevant. This happens because we always ask for the 3 'most' relevant documents, but these might not be relevant at all beyond a certain point.\n\nAlong with the documents themselves, Chroma returns a distance score. We can try thresholding on distance, so that fewer irrelevant documents make it into the context we provide the model.\n\nIf, after filtering on the threshold, no context documents remain, we bypass the model and simply return that there is not enough evidence.\nNow we assess the claims using this cleaner context.\n\nThe model now assesses many fewer claims as True or False when there is not enough evidence present. However, it also  is now much more cautious, tending to label most items as not enough evidence, biasing away from certainty. Most claims are now assessed as having not enough evidence, because a large fraction of them are filtered out by the distance threshold. It's possible to tune the distance threshold to find the optimal operating point, but this can be difficult, and is dataset and embedding model dependent.\n\nWe want to be able to retrieve relevant documents, without retrieving less relevant ones which might confuse the model. One way to accomplish this is to improve the retrieval query.\n\nUntil now, we have queried the dataset using claims which are single sentence statements, while the corpus contains abstracts describing a scientific paper. Intuitively, while these might be related, there are significant differences in their structure and meaning. These differences are encoded by the embedding model, and so influence the distances between the query and the most relevant results.\n\nWe can overcome this by leveraging the power of LLMs to generate relevant text. While the facts might be hallucinated, the content and structure of the documents the models generate is more similar to the documents in our corpus, than the queries are. This could lead to better queries and hence better results.\n\nThis approach is called Hypothetical Document Embeddings (HyDE), and has been shown to be quite good at the retrieval task. It should help us bring more relevant information into the context, without polluting it.\n\nTL;DR:\nyou get much better matches when you embed whole abstracts rather than single sentences\nbut claims are usually single sentences\nSo HyDE shows that using GPT3 to expand claims into hallucinated abstracts and then searching based on those abstracts works (claims -\u003e abstracts -\u003e results) better than searching directly (claims -\u003e results)\nFirst, we use in-context examples to prompt the model to generate documents similar to what's in the corpus, for each claim we want to assess.\nWe hallucinate a document for each claim.\n\nNB: This can take a while, about 7m for 100 claims. You can reduce the number of claims we want to assess to get results more quickly.\nWe use the hallucinated documents as queries into the corpus, and filter the results using the same distance threshold.\nWe then ask the model to assess the claims, using the new context.\n\nCombining HyDE with a simple distance threshold leads to a significant improvement. The model no longer biases assessing claims as True, nor toward their not being enough evidence. It also correctly assesses when there isn't enough evidence more often.\n\nEquipping LLMs with a context based on a corpus of documents is a powerful technique for bringing the general reasoning and natural language interactions of LLMs to your own data. However, it's important to know that naive query and retrieval may not produce the best possible results! Ultimately understanding the data will help get the most out of the retrieval based question-answering approach."])</script><script>self.__next_f.push([1,"89:T10ec,"])</script><script>self.__next_f.push([1,"Open In Colab\n\nThis notebook demonstrates how to:\nIndex the OpenAI Wikipedia vector dataset into Elasticsearch\nEmbed a question with the OpenAI embeddings endpoint\nPerform semantic search on the Elasticsearch index using the encoded question\nSend the top search results to the OpenAI Chat Completions API endpoint for retrieval augmented generation (RAG)\n\nℹ️ If you've already worked through our semantic search notebook, you can skip ahead to the final step!\n\nℹ️ We're using an Elastic Cloud deployment of Elasticsearch for this notebook.\nIf you don't already have an Elastic deployment, you can sign up for a free Elastic Cloud trial.\n\nTo connect to Elasticsearch, you need to create a client instance with the Cloud ID and password for your deployment.\n\nFind the Cloud ID for your deployment by going to https://cloud.elastic.co/deployments and selecting your deployment.\n\nIn this step we download the OpenAI Wikipedia embeddings dataset, and extract the zip file.\n\nNext we use the Pandas library to read the unzipped CSV file into a DataFrame. This step makes it easier to index the data into Elasticsearch in bulk.\n\nNow we need to create an Elasticsearch index with the necessary mappings. This will enable us to index the data into Elasticsearch.\n\nWe use the dense_vector field type for the title_vector and  content_vector fields. This is a special field type that allows us to store dense vectors in Elasticsearch.\n\nLater, we'll need to target the dense_vector field for kNN search.\n\n\nThe following function generates the required bulk actions that can be passed to Elasticsearch's Bulk API, so we can index multiple documents efficiently in a single request.\n\nFor each row in the DataFrame, the function yields a dictionary representing a single document to be indexed.\nAs the dataframe is large, we will index data in batches of 100. We index the data into Elasticsearch using the Python client's helpers for the bulk API.\nLet's test the index with a simple match query.\n\nTo perform kNN search, we need to encode queries with the same embedding model used to encode the documents at index time.\nIn this example, we need to use the text-embedding-3-small model.\n\nYou'll need your OpenAI API key to generate the embeddings.\n\nNow we're ready to run queries against our Elasticsearch index using our encoded question. We'll be doing a k-nearest neighbors search, using the Elasticsearch kNN query option.\n\nFirst, we define a small function to pretty print the results.\nNow let's run our kNN query.\nSuccess! We've used kNN to perform semantic search over our dataset and found the top results.\n\nNow we can use the Chat Completions API to work some generative AI magic using the top search result as additional context.\n\nNow we can send the question and the text to OpenAI's chat completion API.\n\nUsing a LLM model together with a retrieval model is known as retrieval augmented generation (RAG). We're using Elasticsearch to do what it does best, retrieve relevant documents. Then we use the LLM to do what it does best, tasks like generating summaries and answering questions, using the retrieved documents as context.\n\nThe model will generate a response to the question, using the top kNN hit as context. Use the messages list to shape your prompt to the model. In this example, we're using the gpt-3.5-turbo model.\n\n\nHere's what that code does:\n\nUses OpenAI's model to generate a response\nSends a conversation containing a system message and a user message to the model\nThe system message sets the assistant's role as \"helpful assistant\"\nThe user message contains a question as specified in the original kNN query and some input text\nThe response from the model is stored in the summary.choices variable\n\nThat was just one example of how to combine Elasticsearch with the power of OpenAI's models, to enable retrieval augmented generation. RAG allows you to avoid the costly and complex process of training or fine-tuning models, by leveraging out-of-the-box models, enhanced with additional context.\n\nUse this as a blueprint for your own experiments.\n\nTo adapt the conversation for different use cases, customize the system message to define the assistant's behavior or persona. Adjust the user message to specify the task, such as summarization or question answering, along with the desired format of the response."])</script><script>self.__next_f.push([1,"8a:Tb30,"])</script><script>self.__next_f.push([1,"Open In Colab\n\nThis notebook demonstrates how to:\nIndex the OpenAI Wikipedia vector dataset into Elasticsearch\nEmbed a question with the OpenAI embeddings endpoint\nPerform semantic search on the Elasticsearch index using the encoded question\n\nℹ️ We're using an Elastic Cloud deployment of Elasticsearch for this notebook.\nIf you don't already have an Elastic deployment, you can sign up for a free Elastic Cloud trial.\n\nTo connect to Elasticsearch, you need to create a client instance with the Cloud ID and password for your deployment.\n\nFind the Cloud ID for your deployment by going to https://cloud.elastic.co/deployments and selecting your deployment.\n\nIn this step we download the OpenAI Wikipedia embeddings dataset, and extract the zip file.\n\nNext we use the Pandas library to read the unzipped CSV file into a DataFrame. This step makes it easier to index the data into Elasticsearch in bulk.\n\nNow we need to create an Elasticsearch index with the necessary mappings. This will enable us to index the data into Elasticsearch.\n\nWe use the dense_vector field type for the title_vector and  content_vector fields. This is a special field type that allows us to store dense vectors in Elasticsearch.\n\nLater, we'll need to target the dense_vector field for kNN search.\n\n\nThe following function generates the required bulk actions that can be passed to Elasticsearch's Bulk API, so we can index multiple documents efficiently in a single request.\n\nFor each row in the DataFrame, the function yields a dictionary representing a single document to be indexed.\nAs the dataframe is large, we will index data in batches of 100. We index the data into Elasticsearch using the Python client's helpers for the bulk API.\nLet's test the index with a simple match query.\n\nTo perform semantic search, we need to encode queries with the same embedding model used to encode the documents at index time.\nIn this example, we need to use the text-embedding-3-small model.\n\nYou'll need your OpenAI API key to generate the embeddings.\n\nNow we're ready to run queries against our Elasticsearch index using our encoded question. We'll be doing a k-nearest neighbors search, using the Elasticsearch kNN query option.\n\nFirst, we define a small function to pretty print the results.\nNow let's run our kNN query.\n\nSuccess! Now you know how to use Elasticsearch as a vector database to store embeddings, encode queries by calling the OpenAI embeddings endpoint, and run semantic search.\n\nPlay around with different queries, and if you want to try with your own data, you can experiment with different embedding models.\n\nℹ️ Check out our other notebook Retrieval augmented generation using Elasticsearch and OpenAI. That notebook builds on this example to demonstrate how to use Elasticsearch together with the OpenAI chat completions API for retrieval augmented generation (RAG)."])</script><script>self.__next_f.push([1,"8b:T104a,"])</script><script>self.__next_f.push([1,"This notebook guides you step by step on using Hologres as a vector database for OpenAI embeddings.\n\nThis notebook presents an end-to-end process of:\nUsing precomputed embeddings created by OpenAI API.\nStoring the embeddings in a cloud instance of Hologres.\nConverting raw text query to an embedding with OpenAI API.\nUsing Hologres to perform the nearest neighbour search in the created collection.\nProvide large language models with the search results as context in prompt engineering\n\n\nHologres is a unified real-time data warehousing service developed by Alibaba Cloud. You can use Hologres to write, update, process, and analyze large amounts of data in real time. Hologres supports standard SQL syntax, is compatible with PostgreSQL, and supports most PostgreSQL functions. Hologres supports online analytical processing (OLAP) and ad hoc analysis for up to petabytes of data, and provides high-concurrency and low-latency online data services. Hologres supports fine-grained isolation of multiple workloads and enterprise-level security capabilities. Hologres is deeply integrated with MaxCompute, Realtime Compute for Apache Flink, and DataWorks, and provides full-stack online and offline data warehousing solutions for enterprises.\n\nHologres provides vector database functionality by adopting Proxima.\n\nProxima is a high-performance software library developed by Alibaba DAMO Academy. It allows you to search for the nearest neighbors of vectors. Proxima provides higher stability and performance than similar open source software such as Facebook AI Similarity Search (Faiss). Proxima provides basic modules that have leading performance and effects in the industry and allows you to search for similar images, videos, or human faces. Hologres is deeply integrated with Proxima to provide a high-performance vector search service.\n\n\nClick here to fast deploy Hologres data warehouse.\n\n\nFor the purposes of this exercise we need to prepare a couple of things:\n\nHologres cloud server instance.\nThe 'psycopg2-binary' library to interact with the vector database. Any other postgresql client library is ok.\nAn OpenAI API key.\n\n\nWe might validate if the server was launched successfully by running a simple curl command:\n\n\nThis notebook obviously requires the openai and psycopg2-binary packages, but there are also some other additional libraries we will use. The following command installs them all:\n\n\nThe OpenAI API key is used for vectorization of the documents and queries.\n\nIf you don't have an OpenAI API key, you can get one from https://beta.openai.com/account/api-keys.\n\nOnce you get your key, please add it to your environment variables as OPENAI_API_KEY.\nFirst add it to your environment variables. or you can just change the \"psycopg2.connect\" parameters below\n\nConnecting to a running instance of Hologres server is easy with the official Python library:\nWe can test the connection by running any available method:\nThe downloaded file has to be then extracted:\n\nIn this section we are going to load the data prepared previous to this session, so you don't have to recompute the embeddings of Wikipedia articles with your own credits.\nTake a look at the data.\nHologres stores data in tables where each object is described by at least one vector. Our table will be called articles and each object will be described by both title and content vectors.\n\nWe will start with creating a table and create proxima indexes on both title and content, and then we will fill it with our precomputed embeddings.\nNow let's upload the data to the Hologres cloud instance using COPY statement. This might take 5-10 minutes according to the network bandwidth.\nThe proxima index will be built in the background. We can do searching during this period but the query will be slow without the vector index. Use this command to wait for finish building the index.\n\nOnce the data is uploaded we will start querying the collection for the closest vectors. We may provide an additional parameter vector_name to switch from title to content based search. Since the precomputed embeddings were created with text-embedding-3-small OpenAI model we also have to use it during search."])</script><script>self.__next_f.push([1,"8c:T6e1,This Notebook provides step by step instuctions on using Azure Data Explorer (Kusto) as a vector database with OpenAI embeddings.\nThis notebook presents an end-to-end process of:\n\nUsing precomputed embeddings created by OpenAI API.\nStoring the embeddings in Kusto.\nConverting raw text query to an embedding with OpenAI API.\nUsing Kusto to perform cosine similarity search in the stored embeddings\n\nFor the purposes of this exercise we need to prepare a couple of things:\n\nAzure Data Explorer(Kusto) server instance. https://azure.microsoft.com/en-us/products/data-explorer\nAzure OpenAI credentials or OpenAI API key.\n\n\nIn this section we are going to load prepared embedding data, so you don't have to recompute the embeddings of Wikipedia articles with your own credits.\n\n\nCreate a table \u0026 load the vectors in Kusto based on the contents in the dataframe. The spark option CreakeIfNotExists will automatically create a table if it doesn't exist\n\nThe OpenAI API key is used for vectorization of the documents and queries. You can follow the instructions to create and retrieve your Azure OpenAI key and endpoint. https://learn.microsoft.com/en-us/azure/cognitive-services/openai/tutorials/embeddings\n\n\nPlease make sure to use the text-embedding-3-small model. Since the precomputed embeddings were created with text-embedding-3-small model we also have to use it during search.\n\nOnly run this cell if you plan to use Open AI for embedding\nWe will search the Kusto table for the closest vectors.\n\nWe will be using the series-cosine-similarity-fl UDF for similarity search.\n\nPlease create the function in your database before proceeding -\nhttps://learn.microsoft.com/en-us/azure/data-explorer/kusto/functions-library/series-cosine-similarity-fl?tabs=query-defined8d:T44e,Azure Data Explorer aka Kusto is a cloud-based data analytics service that enables users to perform advanced analytics on large datasets in real-time. It is particularly well-suited for handling large volumes of data, making it an excellent choice for storing and searchi"])</script><script>self.__next_f.push([1,"ng vectors.\n\nKusto supports a special data type called dynamic, which can store unstructured data such as arrays and properties bag. Dynamic data type is perfect for storing vector values. You can further augment the vector value by storing metadata related to the original object as separate columns in your table.\nKusto also supports in-built function series_cosine_similarity_fl to perform vector similarity searches.\n\nGet started with Kusto for free.\n\nKusto_Vector\n\n\n\n\n\nWiki_embeddings\n\nsemantic_search_flow\n\nIf you’d like to try this demo, please follow the instructions in the Notebook.\n\nIt will allow you to -\n\nUse precomputed embeddings created by OpenAI API.\n\nStore the embeddings in Kusto.\n\nConvert raw text query to an embedding with OpenAI API.\n\nUse Kusto to perform cosine similarity search in the stored embeddings.8e:Ta20,"])</script><script>self.__next_f.push([1,"In this notebook we will be going over generating embeddings of movie descriptions with OpenAI and using those embeddings within Milvus to find relevant movies. To narrow our search results and try something new, we are going to be using filtering to do metadata searches. The dataset in this example is sourced from HuggingFace datasets, and contains a little over 8 thousand movie entries.\n\nLets begin by first downloading the required libraries for this notebook:\nopenai is used for communicating with the OpenAI embedding service\npymilvus is used for communicating with the Milvus server\ndatasets is used for downloading the dataset\ntqdm is used for the progress bars\n\nWith the required packages installed we can get started. Lets begin by launching the Milvus service. The file being run is the docker-compose.yaml found in the folder of this file. This command launches a Milvus standalone instance which we will use for this test.\nWith Milvus running we can setup our global variables:\nHOST: The Milvus host address\nPORT: The Milvus port number\nCOLLECTION_NAME: What to name the collection within Milvus\nDIMENSION: The dimension of the embeddings\nOPENAI_ENGINE: Which embedding model to use\nopenai.api_key: Your OpenAI account key\nINDEX_PARAM: The index settings to use for the collection\nQUERY_PARAM: The search parameters to use\nBATCH_SIZE: How many movies to embed and insert at once\nWith Milvus up and running we can begin grabbing our data. Hugging Face Datasets is a hub that holds many different user datasets, and for this example we are using HuggingLearners's netflix-shows dataset. This dataset contains movies and their metadata pairs for over 8 thousand movies. We are going to embed each description and store it within Milvus along with its title, type, release_year and rating.\nNow that we have our data on our machine we can begin embedding it and inserting it into Milvus. The embedding function takes in text and returns the embeddings in a list format.\nThis next step does the actual inserting. We iterate through all the entries and create batches that we insert once we hit our set batch size. After the loop is over we insert the last remaning batch if it exists.\nWith our data safely inserted in Milvus, we can now perform a query. The query takes in a tuple of the movie description you are searching for an the filter to use. More info about the filter can be found here. The search first prints out your description and filter expression. After that for each result we print the score, title, type, release year, rating, and description of the result movies."])</script><script>self.__next_f.push([1,"8f:T9ef,"])</script><script>self.__next_f.push([1,"In this notebook we will be going over generating embeddings of book descriptions with OpenAI and using those embeddings within Milvus to find relevant books. The dataset in this example is sourced from HuggingFace datasets, and contains a little over 1 million title-description pairs.\n\nLets begin by first downloading the required libraries for this notebook:\nopenai is used for communicating with the OpenAI embedding service\npymilvus is used for communicating with the Milvus server\ndatasets is used for downloading the dataset\ntqdm is used for the progress bars\n\nWith the required packages installed we can get started. Lets begin by launching the Milvus service. The file being run is the docker-compose.yaml found in the folder of this file. This command launches a Milvus standalone instance which we will use for this test.\nWith Milvus running we can setup our global variables:\nHOST: The Milvus host address\nPORT: The Milvus port number\nCOLLECTION_NAME: What to name the collection within Milvus\nDIMENSION: The dimension of the embeddings\nOPENAI_ENGINE: Which embedding model to use\nopenai.api_key: Your OpenAI account key\nINDEX_PARAM: The index settings to use for the collection\nQUERY_PARAM: The search parameters to use\nBATCH_SIZE: How many texts to embed and insert at once\nThis segment deals with Milvus and setting up the database for this use case. Within Milvus we need to setup a collection and index the collection.\nWith Milvus up and running we can begin grabbing our data. Hugging Face Datasets is a hub that holds many different user datasets, and for this example we are using Skelebor's book dataset. This dataset contains title-description pairs for over 1 million books. We are going to embed each description and store it within Milvus along with its title.\nNow that we have our data on our machine we can begin embedding it and inserting it into Milvus. The embedding function takes in text and returns the embeddings in a list format.\nThis next step does the actual inserting. Due to having so many datapoints, if you want to immidiately test it out you can stop the inserting cell block early and move along. Doing this will probably decrease the accuracy of the results due to less datapoints, but it should still be good enough.\nWith our data safely inserted in Milvus, we can now perform a query. The query takes in a string or a list of strings and searches them. The resuts print out your provided description and the results that include the result score, the result title, and the result book description."])</script><script>self.__next_f.push([1,"90:T986,"])</script><script>self.__next_f.push([1,"This notebook provides a step-by-step guide on using MyScale as a vector database for OpenAI embeddings. The process includes:\n\nUtilizing precomputed embeddings generated by OpenAI API.\nStoring these embeddings in a cloud instance of MyScale.\nConverting raw text query to an embedding using OpenAI API.\nLeveraging MyScale to perform nearest neighbor search within the created collection.\n\n\nMyScale is a database built on Clickhouse that combines vector search and SQL analytics to offer a high-performance, streamlined, and fully managed experience. It's designed to facilitate joint queries and analyses on both structured and vector data, with comprehensive SQL support for all data processing.\n\n\n\nDeploy and execute vector search with SQL on your cluster within two minutes by using MyScale Console.\n\n\nTo follow this guide, you will need to have the following:\n\nA MyScale cluster deployed by following the quickstart guide.\nThe 'clickhouse-connect' library to interact with MyScale.\nAn OpenAI API key for vectorization of queries.\n\nThis notebook requires the openai, clickhouse-connect, as well as some other dependencies. Use the following command to install them:\n\nTo use the OpenAI API, you'll need to set up an API key. If you don't have one already, you can obtain it from OpenAI.\n\nFollow the connections details section to retrieve the cluster host, username, and password information from the MyScale console, and use it to create a connection to your cluster as shown below:\nWe need to load the dataset of precomputed vector embeddings for Wikipedia articles provided by OpenAI. Use the wget package to download the dataset.\nAfter the download is complete, extract the file using the zipfile package:\nNow, we can load the data from vector_database_wikipedia_articles_embedded.csv into a Pandas DataFrame:\n\nWe will create an SQL table called articles in MyScale to store the embeddings data. The table will include a vector index with a cosine distance metric and a constraint for the length of the embeddings. Use the following code to create and insert data into the articles table:\nWe need to check the build status of the vector index before proceeding with the search, as it is automatically built in the background.\n\nOnce indexed in MyScale, we can perform vector search to find similar content. First, we will use the OpenAI API to generate embeddings for our query. Then, we will perform the vector search using MyScale."])</script><script>self.__next_f.push([1,"91:Td71,"])</script><script>self.__next_f.push([1,"This notebook takes you through a simple flow to download some data, embed it, and then index and search it using a selection of vector databases. This is a common requirement for customers who want to store and search our embeddings with their own data in a secure environment to support production use cases such as chatbots, topic modelling and more.\n\n\nA vector database is a database made to store, manage and search embedding vectors. The use of embeddings to encode unstructured data (text, audio, video and more) as vectors for consumption by machine-learning models has exploded in recent years, due to the increasing effectiveness of AI in solving use cases involving natural language, image recognition and other unstructured forms of data. Vector databases have emerged as an effective solution for enterprises to deliver and scale these use cases.\n\n\nVector databases enable enterprises to take many of the embeddings use cases we've shared in this repo (question and answering, chatbot and recommendation services, for example), and make use of them in a secure, scalable environment. Many of our customers make embeddings solve their problems at small scale but performance and security hold them back from going into production - we see vector databases as a key component in solving that, and in this guide we'll walk through the basics of embedding text data, storing it in a vector database and using it for semantic search.\n\n\nThe demo flow is:\nSetup**: Import packages and set any required variables\nLoad data**: Load a dataset and embed it using OpenAI embeddings\nMyScale**\n    Setup: Set up the MyScale Python client. For more details go here\n    Index Data: We'll create a table and index it for content.\n    Search Data: Run a few example queries with various goals in mind.\n\nOnce you've run through this notebook you should have a basic understanding of how to setup and use vector databases, and can move on to more complex use cases making use of our embeddings.\n\nImport the required libraries and set the embedding model that we'd like to use.\n\nIn this section we'll load embedded data that we've prepared previous to this session.\nThe next vector database we'll consider is MyScale.\n\nMyScale is a database built on Clickhouse that combines vector search and SQL analytics to offer a high-performance, streamlined, and fully managed experience. It's designed to facilitate joint queries and analyses on both structured and vector data, with comprehensive SQL support for all data processing.\n\nDeploy and execute vector search with SQL on your cluster within two minutes by using MyScale Console.\n\nFollow the connections details section to retrieve the cluster host, username, and password information from the MyScale console, and use it to create a connection to your cluster as shown below:\n\nWe will create an SQL table called articles in MyScale to store the embeddings data. The table will include a vector index with a cosine distance metric and a constraint for the length of the embeddings. Use the following code to create and insert data into the articles table:\nWe need to check the build status of the vector index before proceeding with the search, as it is automatically built in the background.\n\nOnce indexed in MyScale, we can perform vector search to find similar content. First, we will use the OpenAI API to generate embeddings for our query. Then, we will perform the vector search using MyScale."])</script><script>self.__next_f.push([1,"92:Tc44,"])</script><script>self.__next_f.push([1,"In this notebook we will learn how to query relevant contexts to our queries from Pinecone, and pass these to a GPT-4 model to generate an answer backed by real data sources.\n\nGPT-4 is a big step up from previous OpenAI completion models. It also exclusively uses the ChatCompletion endpoint, so we must use it in a slightly different way to usual. However, the power of the model makes the change worthwhile, particularly when augmented with an external knowledge base like the Pinecone vector database.\n\nRequired installs for this notebook are:\nIn this example, we will download the LangChain docs from langchain.readthedocs.io/. We get all .html files located on the site like so:\nThis downloads all HTML into the rtdocs directory. Now we can use LangChain itself to process these docs. We do this using the ReadTheDocsLoader like so:\nThis leaves us with hundreds of processed doc pages. Let's take a look at the format each one contains:\nWe access the plaintext page content like so:\nWe can also find the source of each document:\nWe can use these to create our data list:\nIt's pretty ugly but it's good enough for now. Let's see how we can process all of these. We will chunk everything into ~400 token chunks, we can do this easily with langchain and tiktoken:\nProcess the data into more chunks using this approach.\nOur chunks are ready so now we move onto embedding and indexing everything.\n\nWe use text-embedding-3-small as the embedding model. We can embed text like so:\nIn the response res we will find a JSON-like object containing our new embeddings within the 'data' field.\nInside 'data' we will find two records, one for each of the two sentences we just embedded. Each vector embedding contains 1536 dimensions (the output dimensionality of the text-embedding-3-small model.\nWe will apply this same embedding logic to the langchain docs dataset we've just scraped. But before doing so we must create a place to store the embeddings.\nNow we need a place to store these embeddings and enable a efficient vector search through them all. To do that we use Pinecone, we can get a free API key and enter it below where we will initialize our connection to Pinecone and create a new index.\nWe can see the index is currently empty with a total_vector_count of 0. We can begin populating it with OpenAI text-embedding-3-small built embeddings like so:\nNow we've added all of our langchain docs to the index. With that we can move on to retrieval and then answer generation using GPT-4.\nTo search through our documents we first need to create a query vector xq. Using xq we will retrieve the most relevant chunks from the LangChain docs, like so:\nWith retrieval complete, we move on to feeding these into GPT-4 to produce answers.\nGPT-4 is currently accessed via the ChatCompletions endpoint of OpenAI. To add the information we retrieved into the model, we need to pass it into our user prompts alongside our original query. We can do that like so:\nNow we ask the question:\nTo display this response nicely, we will display it in markdown.\nLet's compare this to a non-augmented query...\nIf we drop the \"I don't know\" part of the primer?"])</script><script>self.__next_f.push([1,"93:T1210,"])</script><script>self.__next_f.push([1,"In this notebook we will learn how to query relevant contexts to our queries from Pinecone, and pass these to a generative OpenAI model to generate an answer backed by real data sources.\n\nA common problem with using GPT-3 to factually answer questions is that GPT-3 can sometimes make things up. The GPT models have a broad range of general knowledge, but this does not necessarily apply to more specific information. For that we use the Pinecone vector database as our \"external knowledge base\" — like long-term memory for GPT-3.\n\nRequired installs for this notebook are:\nFor many questions state-of-the-art (SOTA) LLMs are more than capable of answering correctly.\nHowever, that isn't always the case. First let's first rewrite the above into a simple function so we're not rewriting this every time.\nNow let's ask a more specific question about training a type of transformer model called a sentence transformer. The ideal answer we'd be looking for is \"Multiple Negatives Ranking (MNR) loss\".\n\nDon't worry if this is a new term to you, it isn't required to understand what we're doing or demoing here.\nOne of the common answers we get to this is:\n\nThe best training method to use for fine-tuning a pre-trained model with sentence transformers is the Masked Language Model (MLM) training. MLM training involves randomly masking some of the words in a sentence and then training the model to predict the masked words. This helps the model to learn the context of the sentence and better understand the relationships between words.\n\nThis answer seems pretty convincing right? Yet, it's wrong. MLM is typically used in the pretraining step of a transformer model but \"cannot\" be used to fine-tune a sentence-transformer, and has nothing to do with having \"pairs of related sentences\".\n\nAn alternative answer we receive (and the one we returned above) is about supervised learning approach being the most suitable. This is completely true, but it's not specific and doesn't answer the question.\n\nWe have two options for enabling our LLM in understanding and correctly answering this question:\n\nWe fine-tune the LLM on text data covering the topic mentioned, likely on articles and papers talking about sentence transformers, semantic search training methods, etc.\n\nWe use Retrieval Augmented Generation (RAG), a technique that implements an information retrieval component to the generation process. Allowing us to retrieve relevant information and feed this information into the generation model as a secondary source of information.\n\nWe will demonstrate option 2.\nWith option 2 the retrieval of relevant information requires an external \"Knowledge Base\", a place where we can store and use to efficiently retrieve information. We can think of this as the external long-term memory of our LLM.\n\nWe will need to retrieve information that is semantically related to our queries, to do this we need to use \"dense vector embeddings\". These can be thought of as numerical representations of the meaning behind our sentences.\n\nTo create these dense vectors we use the text-embedding-3-small model.\n\nWe have already authenticated our OpenAI connection, to create an embedding we just do:\nIn the response res we will find a JSON-like object containing our new embeddings within the 'data' field.\nInside 'data' we will find two records, one for each of the two sentences we just embedded. Each vector embedding contains 1536 dimensions (the output dimensionality of the text-embedding-3-small model.\nWe will apply this same embedding logic to a dataset containing information relevant to our query (and many other queries on the topics of ML and AI).\n\n\nThe dataset we will be using is the jamescalam/youtube-transcriptions from Hugging Face Datasets. It contains transcribed audio from several ML and tech YouTube channels. We download it with:\nThe dataset contains many small snippets of text data. We will need to merge many snippets from each video to create more substantial chunks of text that contain more information.\nNow we need a place to store these embeddings and enable a efficient vector search through them all. To do that we use Pinecone, we can get a free API key and enter it below where we will initialize our connection to Pinecone and create a new index.\nWe can see the index is currently empty with a total_vector_count of 0. We can begin populating it with OpenAI text-embedding-3-small built embeddings like so:\nNow we search, for this we need to create a query vector xq:\nAnd we get a pretty great answer straight away, specifying to use multiple-rankings loss (also called multiple negatives ranking loss)."])</script><script>self.__next_f.push([1,"94:T576,Vector search is an innovative technology that enables developers and engineers to efficiently store, search, and recommend information by representing complex data as mathematical vectors. By comparing the similarities between these vectors, you can quickly retrieve relevant information in a seamless and intuitive manner.\n\nPinecone is a vector database designed with developers and engineers in mind. As a managed service, it alleviates the burden of maintenance and engineering, allowing you to focus on extracting valuable insights from your data. The free tier supports up to 5 million vectors, making it an accessible and cost-effective way to experiment with vector search capabilities. With Pinecone, you'll experience impressive speed, accuracy, and scalability, as well as access to advanced features like single-stage metadata filtering and the cutting-edge sparse-dense index.\n\n\nThis folder contains examples of using Pinecone and OpenAI together. More will be added over time so check back for updates!\n\n| Name | Description | Google Colab |\n| --- | --- | --- |\n| GPT-4 Retrieval Augmentation | How to supercharge GPT-4 with retrieval augmentation | Open In Colab |\n| Generative Question-Answering | A simple walkthrough demonstrating the use of Generative Question-Answering | Open In Colab |\n| Semantic Search | A guide to building a simple semantic search process | Open In Colab |95:Ta6c,"])</script><script>self.__next_f.push([1,"In this guide you will learn how to use the OpenAI Embedding API to generate language embeddings, and then index those embeddings in the Pinecone vector database for fast and scalable vector search.\n\nThis is a powerful and common combination for building semantic search, question-answering, threat-detection, and other applications that rely on NLP and search over a large corpus of text data.\n\nThe basic workflow looks like this:\n\nEmbed and index\n\nUse the OpenAI Embedding API to generate vector embeddings of your documents (or any text data).\nUpload those vector embeddings into Pinecone, which can store and index millions/billions of these vector embeddings, and search through them at ultra-low latencies.\n\nSearch\n\nPass your query text or document through the OpenAI Embedding API again.\nTake the resulting vector embedding and send it as a query to Pinecone.\nGet back semantically similar documents, even if they don't share any keywords with the query.\n\nArchitecture overview\n\nLet's get started...\nWe first need to setup our environment and retrieve API keys for OpenAI and Pinecone. Let's start with our environment, we need HuggingFace Datasets for our data, and the OpenAI and Pinecone clients:\n\nThen we initialize our connection to OpenAI Embeddings and Pinecone vector DB. Sign up for an API key over at OpenAI and Pinecone.\nWe can now create embeddings with the OpenAI Ada similarity model like so:\nNext, we initialize our index to store vector embeddings with Pinecone.\nInitialize connection to Pinecone, you can get a free API key in the Pinecone dashboard.\n\n\nNow we will take 1K questions from the TREC dataset\nThen we create a vector embedding for each phrase using OpenAI, and upsert the ID, vector embedding, and original text for each phrase to Pinecone.\nWith our data indexed, we're now ready to move onto performing searches. This follows a similar process to indexing. We start with a text query, that we would like to use to find similar sentences. As before we encode this with OpenAI's text similarity Babbage model to create a query vector xq. We then use xq to query the Pinecone index.\nNow query...\nThe response from Pinecone includes our original text in the metadata field, let's print out the top_k most similar questions and their respective similarity scores.\nLooks good, let's make it harder and replace \"depression\" with the incorrect term \"recession\".\nAnd again...\nLooks great, our semantic search pipeline is clearly able to identify the meaning between each of our queries and return the most semantically similar questions from the already indexed questions.\n\nOnce we're finished with the index we delete it to save resources."])</script><script>self.__next_f.push([1,"96:Tc7a,"])</script><script>self.__next_f.push([1,"This notebook takes you through a simple flow to download some data, embed it, and then index and search it using a selection of vector databases. This is a common requirement for customers who want to store and search our embeddings with their own data in a secure environment to support production use cases such as chatbots, topic modelling and more.\n\n\nA vector database is a database made to store, manage and search embedding vectors. The use of embeddings to encode unstructured data (text, audio, video and more) as vectors for consumption by machine-learning models has exploded in recent years, due to the increasing effectiveness of AI in solving use cases involving natural language, image recognition and other unstructured forms of data. Vector databases have emerged as an effective solution for enterprises to deliver and scale these use cases.\n\n\nVector databases enable enterprises to take many of the embeddings use cases we've shared in this repo (question and answering, chatbot and recommendation services, for example), and make use of them in a secure, scalable environment. Many of our customers make embeddings solve their problems at small scale but performance and security hold them back from going into production - we see vector databases as a key component in solving that, and in this guide we'll walk through the basics of embedding text data, storing it in a vector database and using it for semantic search.\n\n\nThe demo flow is:\nSetup**: Import packages and set any required variables\nLoad data**: Load a dataset and embed it using OpenAI embeddings\nPinecone**\n    Setup: Here we'll set up the Python client for Pinecone. For more details go here\n    Index Data: We'll create an index with namespaces for titles and content\n    Search Data: We'll test out both namespaces with search queries to confirm it works\n\nOnce you've run through this notebook you should have a basic understanding of how to setup and use vector databases, and can move on to more complex use cases making use of our embeddings.\n\nImport the required libraries and set the embedding model that we'd like to use.\n\nIn this section we'll load embedded data that we've prepared in this article.\n\nThe next option we'll look at is Pinecone, a managed vector database which offers a cloud-native option.\n\nBefore you proceed with this step you'll need to navigate to Pinecone, sign up and then save your API key as an environment variable titled\nFor section we will:\nCreate an index with multiple namespaces for article titles and content\nStore our data in the index with separate searchable \"namespaces\" for article titles and content\nFire some similarity search queries to verify our setup is working\n\nFirst we will need to create an index, which we'll call wikipedia-articles. Once we have an index, we can create multiple namespaces, which can make a single index searchable for various use cases. For more details, consult Pinecone documentation.\n\nIf you want to batch insert to your index in parallel to increase insertion speed then there is a great guide in the Pinecone documentation on batch inserts in parallel.\n\nNow we'll enter some dummy searches and check we get decent results back"])</script><script>self.__next_f.push([1,"97:Te74,"])</script><script>self.__next_f.push([1,"This notebook guides you step by step on using Qdrant as a vector database for OpenAI embeddings. Qdrant is a high-performant vector search database written in Rust. It offers RESTful and gRPC APIs to manage your embeddings. There is an official Python qdrant-client that eases the integration with your apps.\n\nThis notebook presents an end-to-end process of:\nUsing precomputed embeddings created by OpenAI API.\nStoring the embeddings in a local instance of Qdrant.\nConverting raw text query to an embedding with OpenAI API.\nUsing Qdrant to perform the nearest neighbour search in the created collection.\n\n\nQdrant is an Open Source vector database that allows storing neural embeddings along with the metadata, a.k.a payload. Payloads are not only available for keeping some additional attributes of a particular point, but might be also used for filtering. Qdrant offers a unique filtering mechanism which is built-in into the vector search phase, what makes it really efficient.\n\n\nQdrant might be launched in various ways, depending on the target load on the application it might be hosted:\n\nLocally or on premise, with Docker containers\nOn Kubernetes cluster, with the Helm chart\nUsing Qdrant Cloud\n\n\nQdrant provides both RESTful and gRPC APIs which makes integration easy, no matter the programming language you use. However, there are some official clients for the most popular languages available, and if you use Python then the Python Qdrant client library might be the best choice.\n\nFor the purposes of this exercise we need to prepare a couple of things:\n\nQdrant server instance. In our case a local Docker container.\nThe qdrant-client library to interact with the vector database.\nAn OpenAI API key.\n\n\nWe're going to use a local Qdrant instance running in a Docker container. The easiest way to launch it is to use the attached [docker-compose.yaml] file and run the following command:\nWe might validate if the server was launched successfully by running a simple curl command:\n\nThis notebook obviously requires the openai and qdrant-client packages, but there are also some other additional libraries we will use. The following command installs them all:\n\n\nThe OpenAI API key is used for vectorization of the documents and queries.\n\nIf you don't have an OpenAI API key, you can get one from https://beta.openai.com/account/api-keys.\n\nOnce you get your key, please add it to your environment variables as OPENAI_API_KEY by running following command:\n\nConnecting to a running instance of Qdrant server is easy with the official Python library:\nWe can test the connection by running any available method:\n\nIn this section we are going to load the data prepared previous to this session, so you don't have to recompute the embeddings of Wikipedia articles with your own credits.\nThe downloaded file has to be then extracted:\nAnd we can finally load it from the provided CSV file:\n\nQdrant stores data in collections where each object is described by at least one vector and may contain an additional metadata called payload. Our collection will be called Articles and each object will be described by both title and content vectors. Qdrant does not require you to set up any kind of schema beforehand, so you can freely put points to the collection with a simple setup only.\n\nWe will start with creating a collection, and then we will fill it with our precomputed embeddings.\n\nOnce the data is put into Qdrant we will start querying the collection for the closest vectors. We may provide an additional parameter vector_name to switch from title to content based search. Since the precomputed embeddings were created with text-embedding-ada-002 OpenAI model we also have to use it during search."])</script><script>self.__next_f.push([1,"98:Tcaf,"])</script><script>self.__next_f.push([1,"This notebook presents how to implement a Question Answering system with Langchain, Qdrant as a knowledge based and OpenAI embeddings. If you are not familiar with Qdrant, it's better to check out the Getting_started_with_Qdrant_and_OpenAI.ipynb notebook.\n\nThis notebook presents an end-to-end process of:\nCalculating the embeddings with OpenAI API.\nStoring the embeddings in a local instance of Qdrant to build a knowledge base.\nConverting raw text query to an embedding with OpenAI API.\nUsing Qdrant to perform the nearest neighbour search in the created collection to find some context.\nAsking LLM to find the answer in a given context.\n\nAll the steps will be simplified to calling some corresponding Langchain methods.\n\nFor the purposes of this exercise we need to prepare a couple of things:\n\nQdrant server instance. In our case a local Docker container.\nThe qdrant-client library to interact with the vector database.\nLangchain as a framework.\nAn OpenAI API key.\n\n\nWe're going to use a local Qdrant instance running in a Docker container. The easiest way to launch it is to use the attached [docker-compose.yaml] file and run the following command:\nWe might validate if the server was launched successfully by running a simple curl command:\n\nThis notebook obviously requires the openai, langchain and qdrant-client packages.\n\n\nThe OpenAI API key is used for vectorization of the documents and queries.\n\nIf you don't have an OpenAI API key, you can get one from https://beta.openai.com/account/api-keys.\n\nOnce you get your key, please add it to your environment variables as OPENAI_API_KEY by running following command:\n\nIn this section we are going to load the data containing some natural questions and answers to them. All the data will be used to create a Langchain application with Qdrant being the knowledge base.\n\nLangchain is already integrated with Qdrant and performs all the indexing for given list of documents. In our case we are going to store the set of answers we have.\nAt this stage all the possible answers are already stored in Qdrant, so we can define the whole QA chain.\n\nOnce the data is put into Qdrant we can start asking some questions. A question will be automatically vectorized by OpenAI model, and the created vector will be used to find some possibly matching answers in Qdrant. Once retrieved, the most similar answers will be incorporated into the prompt sent to OpenAI Large Language Model. The communication between all the services is shown on a graph:\n\n\n\n\nThe stuff chain type in Langchain uses a specific prompt with question and context documents incorporated. This is what the default prompt looks like:\n\nUse the following pieces of context to answer the question at the end. If you don't know the answer, just say that you don't know, don't try to make up an answer.\n{context}\nQuestion: {question}\nHelpful Answer:\n\nWe can, however, provide our prompt template and change the behaviour of the OpenAI LLM, while still using the stuff chain type. It is important to keep {context} and {question} as placeholders.\n\n\nWe can try using a different prompt template, so the model:\nResponds with a single-sentence answer if it knows it.\nSuggests a random song title if it doesn't know the answer to our question."])</script><script>self.__next_f.push([1,"99:T1049,"])</script><script>self.__next_f.push([1,"This notebook takes you through a simple flow to download some data, embed it, and then index and search it using a selection of vector databases. This is a common requirement for customers who want to store and search our embeddings with their own data in a secure environment to support production use cases such as chatbots, topic modelling and more.\n\n\nA vector database is a database made to store, manage and search embedding vectors. The use of embeddings to encode unstructured data (text, audio, video and more) as vectors for consumption by machine-learning models has exploded in recent years, due to the increasing effectiveness of AI in solving use cases involving natural language, image recognition and other unstructured forms of data. Vector databases have emerged as an effective solution for enterprises to deliver and scale these use cases.\n\n\nVector databases enable enterprises to take many of the embeddings use cases we've shared in this repo (question and answering, chatbot and recommendation services, for example), and make use of them in a secure, scalable environment. Many of our customers make embeddings solve their problems at small scale but performance and security hold them back from going into production - we see vector databases as a key component in solving that, and in this guide we'll walk through the basics of embedding text data, storing it in a vector database and using it for semantic search.\n\n\nThe demo flow is:\nSetup**: Import packages and set any required variables\nLoad data**: Load a dataset and embed it using OpenAI embeddings\nQdrant**\n    Setup: Here we'll set up the Python client for Qdrant. For more details go here\n    Index Data: We'll create a collection with vectors for titles and content\n    Search Data: We'll run a few searches to confirm it works\n\nOnce you've run through this notebook you should have a basic understanding of how to setup and use vector databases, and can move on to more complex use cases making use of our embeddings.\n\nImport the required libraries and set the embedding model that we'd like to use.\n\nIn this section we'll load embedded data that we've prepared previous to this session.\n\nQdrant. is a high-performant vector search database written in Rust. It offers both on-premise and cloud version, but for the purposes of that example we're going to use the local deployment mode.\n\nSetting everything up will require:\nSpinning up a local instance of Qdrant\nConfiguring the collection and storing the data in it\nTrying out with some queries\n\nFor the local deployment, we are going to use Docker, according to the Qdrant documentation: https://qdrant.tech/documentation/quick_start/. Qdrant requires just a single container, but an example of the docker-compose.yaml file is available at ./qdrant/docker-compose.yaml in this repo.\n\nYou can start Qdrant instance locally by navigating to this directory and running docker-compose up -d \nYou might need to increase the memory limit for Docker to 8GB or more. Or Qdrant might fail to execute with an error message like 7 Killed.\n\n\nQdrant stores data in collections where each object is described by at least one vector and may contain an additional metadata called payload. Our collection will be called Articles and each object will be described by both title and content vectors.\n\nWe'll be using an official qdrant-client package that has all the utility methods already built-in.\nIn addition to the vector configuration defined under vector, we can also define the payload configuration. Payload is an optional field that allows you to store additional metadata alongside the vectors. In our case, we'll store the id, title, and url of the articles. As we return the title of nearest articles in the search results from payload, we can also provide the user with the URL to the article (which is part of the meta-data).\n\nOnce the data is put into Qdrant we will start querying the collection for the closest vectors. We may provide an additional parameter vector_name to switch from title to content based search.  Ensure you use the text-embedding-ada-002 model as the original embeddings in file were created with this model."])</script><script>self.__next_f.push([1,"9a:T1a4a,"])</script><script>self.__next_f.push([1,"Most developers from a web services background are probably familiar with Redis. At it's core, Redis is an open-source key-value store that can be used as a cache, message broker, and database. Developers choice Redis because it is fast, has a large ecosystem of client libraries, and has been deployed by major enterprises for years.\n\nIn addition to the traditional uses of Redis. Redis also provides Redis Modules which are a way to extend Redis with new capabilities, commands and data types. Example modules include RedisJSON, RedisTimeSeries, RedisBloom and RediSearch.\n\n\n\nThere are a number of ways to deploy Redis. For local development, the quickest method is to use the Redis Stack docker container which we will use here. Redis Stack contains a number of Redis modules that can be used together to create a fast, multi-model data store and query engine.\n\nFor production use cases, The easiest way to get started is to use the Redis Cloud service. Redis Cloud is a fully managed Redis service. You can also deploy Redis on your own infrastructure using Redis Enterprise. Redis Enterprise is a fully managed Redis service that can be deployed in kubernetes, on-premises or in the cloud.\n\nAdditionally, every major cloud provider (AWS Marketplace, Google Marketplace, or Azure Marketplace) offers Redis Enterprise in a marketplace offering.\n\n\n\nRediSearch is a Redis module that provides querying, secondary indexing, full-text search and vector search for Redis. To use RediSearch, you first declare indexes on your Redis data. You can then use the RediSearch clients to query that data. For more information on the feature set of RediSearch, see the RediSearch documentation.\n\n\n\nRediSearch uses compressed, inverted indexes for fast indexing with a low memory footprint. RediSearch indexes enhance Redis by providing exact-phrase matching, fuzzy search, and numeric filtering, among many other features. Such as:\n\nFull-Text indexing of multiple fields in Redis hashes\nIncremental indexing without performance loss\nVector similarity search\nDocument ranking (using tf-idf, with optional user-provided weights)\nField weighting\nComplex boolean queries with AND, OR, and NOT operators\nPrefix matching, fuzzy matching, and exact-phrase queries\nSupport for double-metaphone phonetic matching\nAuto-complete suggestions (with fuzzy prefix suggestions)\nStemming-based query expansion in many languages (using Snowball)\nSupport for Chinese-language tokenization and querying (using Friso)\nNumeric filters and ranges\nGeospatial searches using Redis geospatial indexing\nA powerful aggregations engine\nSupports for all utf-8 encoded text\nRetrieve full documents, selected fields, or only the document IDs\nSorting results (for example, by creation date)\nJSON support through RedisJSON\n\n\n\nGiven the large ecosystem around Redis, there are most likely client libraries in the language you need. You can use any standard Redis client library to run RediSearch commands, but it's easiest to use a library that wraps the RediSearch API. Below are a few examples, but you can find more client libraries here.\n\n| Project | Language | License | Author | Stars |\n|----------|---------|--------|---------|-------|\n| jedis | Java | MIT | Redis | Stars |\n| redis-py | Python | MIT | Redis | Stars |\n| node-redis | Node.js | MIT | Redis | Stars |\n| nredisstack | .NET | MIT | Redis | Stars |\n\n[redis-url]: https://redis.com\n\n[redis-py-url]: https://github.com/redis/redis-py\n[redis-py-stars]: https://img.shields.io/github/stars/redis/redis-py.svg?style=social\u0026amp;label=Star\u0026amp;maxAge=2592000\n[redis-py-package]: https://pypi.python.org/pypi/redis\n\n[jedis-url]: https://github.com/redis/jedis\n[jedis-stars]: https://img.shields.io/github/stars/redis/jedis.svg?style=social\u0026amp;label=Star\u0026amp;maxAge=2592000\n[Jedis-package]: https://search.maven.org/artifact/redis.clients/jedis\n\n[nredisstack-url]: https://github.com/redis/nredisstack\n[nredisstack-stars]: https://img.shields.io/github/stars/redis/nredisstack.svg?style=social\u0026amp;label=Star\u0026amp;maxAge=2592000\n[nredisstack-package]: https://www.nuget.org/packages/nredisstack/\n\n[node-redis-url]: https://github.com/redis/node-redis\n[node-redis-stars]: https://img.shields.io/github/stars/redis/node-redis.svg?style=social\u0026amp;label=Star\u0026amp;maxAge=2592000\n[node-redis-package]: https://www.npmjs.com/package/redis\n\n[redis-om-python-url]: https://github.com/redis/redis-om-python\n[redis-om-python-author]: https://redis.com\n[redis-om-python-stars]: https://img.shields.io/github/stars/redis/redis-om-python.svg?style=social\u0026amp;label=Star\u0026amp;maxAge=2592000\n\n[redisearch-go-url]: https://github.com/RediSearch/redisearch-go\n[redisearch-go-author]: https://redis.com\n[redisearch-go-stars]: https://img.shields.io/github/stars/RediSearch/redisearch-go.svg?style=social\u0026amp;label=Star\u0026amp;maxAge=2592000\n\n[redisearch-api-rs-url]: https://github.com/RediSearch/redisearch-api-rs\n[redisearch-api-rs-author]: https://redis.com\n[redisearch-api-rs-stars]: https://img.shields.io/github/stars/RediSearch/redisearch-api-rs.svg?style=social\u0026amp;label=Star\u0026amp;maxAge=2592000\n\n\n\nThere are many ways to deploy Redis with RediSearch. The easiest way to get started is to use Docker, but there are are many potential options for deployment such as\n\nRedis Cloud\nCloud marketplaces: AWS Marketplace, Google Marketplace, or Azure Marketplace\nOn-premise: Redis Enterprise Software\nKubernetes: Redis Enterprise Software on Kubernetes\nDocker (RediSearch)\nDocker (Redis Stack)\n\n\n\nRediSearch has a distributed cluster version that scales to billions of documents across hundreds of servers. At the moment, distributed RediSearch is available as part of Redis Enterprise Cloud and Redis Enterprise Software.\n\nSee RediSearch on Redis Enterprise for more information.\n\n\nProduct Search - eCommerce product search (with image and text)\nProduct Recommendations with DocArray / Jina - Content-based product recommendations example with Redis and DocArray.\nRedis VSS in RecSys - 3 end-to-end Redis \u0026 NVIDIA Merlin Recommendation System Architectures.\nAzure OpenAI Embeddings Q\u0026A - OpenAI and Redis as a Q\u0026A service on Azure.\nArXiv Paper Search - Semantic search over arXiv scholarly papers\n\n\n\nFor more information on how to use Redis as a vector database, check out the following resources:\n\nRedis Vector Similarity Docs - Redis official docs for Vector Search.\nRedis-py Search Docs - Redis-py client library docs for RediSearch.\nVector Similarity Search: From Basics to Production - Introductory blog post to VSS and Redis as a VectorDB.\nAI-Powered Document Search - Blog post covering AI Powered Document Search Use Cases \u0026 Architectures.\nVector Database Benchmarks - Jina AI VectorDB benchmarks comparing Redis against others."])</script><script>self.__next_f.push([1,"9b:T1ee1,"])</script><script>self.__next_f.push([1,"This notebook takes you through a simple flow to download some data, embed it, and then index and search it using a selection of vector databases. This is a common requirement for customers who want to store and search our embeddings with their own data in a secure environment to support production use cases such as chatbots, topic modelling and more.\n\n\nA vector database is a database made to store, manage and search embedding vectors. The use of embeddings to encode unstructured data (text, audio, video and more) as vectors for consumption by machine-learning models has exploded in recent years, due to the increasing effectiveness of AI in solving use cases involving natural language, image recognition and other unstructured forms of data. Vector databases have emerged as an effective solution for enterprises to deliver and scale these use cases.\n\n\nVector databases enable enterprises to take many of the embeddings use cases we've shared in this repo (question and answering, chatbot and recommendation services, for example), and make use of them in a secure, scalable environment. Many of our customers make embeddings solve their problems at small scale but performance and security hold them back from going into production - we see vector databases as a key component in solving that, and in this guide we'll walk through the basics of embedding text data, storing it in a vector database and using it for semantic search.\n\n\nThe demo flow is:\nSetup**: Import packages and set any required variables\nLoad data**: Load a dataset and embed it using OpenAI embeddings\nRedis**\n    Setup: Set up the Redis-Py client. For more details go here\n    Index Data: Create the search index for vector search and hybrid search (vector + full-text search) on all available fields.\n    Search Data: Run a few example queries with various goals in mind.\n\nOnce you've run through this notebook you should have a basic understanding of how to setup and use vector databases, and can move on to more complex use cases making use of our embeddings.\n\nImport the required libraries and set the embedding model that we'd like to use.\n\nIn this section we'll load embedded data that we've prepared previous to this session.\n\nThe next vector database covered in this tutorial is Redis. You most likely already know Redis. What you might not be aware of is the RediSearch module. Enterprises have been using Redis with the RediSearch module for years now across all major cloud providers, Redis Cloud, and on premise. Recently, the Redis team added vector storage and search capability to this module in addition to the features RediSearch already had.\n\nGiven the large ecosystem around Redis, there are most likely client libraries in the language you need. You can use any standard Redis client library to run RediSearch commands, but it's easiest to use a library that wraps the RediSearch API. Below are a few examples, but you can find more client libraries here.\n\n| Project | Language | License | Author | Stars |\n|----------|---------|--------|---------|-------|\n| jedis | Java | MIT | Redis | Stars |\n| redis-py | Python | MIT | Redis | Stars |\n| node-redis | Node.js | MIT | Redis | Stars |\n| nredisstack | .NET | MIT | Redis | Stars |\n| redisearch-go | Go | BSD | Redis | [redisearch-go-stars] |\n| redisearch-api-rs | Rust | BSD | Redis | [redisearch-api-rs-stars] |\n\n[redis-url]: https://redis.com\n\n[redis-py-url]: https://github.com/redis/redis-py\n[redis-py-stars]: https://img.shields.io/github/stars/redis/redis-py.svg?style=social\u0026amp;label=Star\u0026amp;maxAge=2592000\n[redis-py-package]: https://pypi.python.org/pypi/redis\n\n[jedis-url]: https://github.com/redis/jedis\n[jedis-stars]: https://img.shields.io/github/stars/redis/jedis.svg?style=social\u0026amp;label=Star\u0026amp;maxAge=2592000\n[Jedis-package]: https://search.maven.org/artifact/redis.clients/jedis\n\n[nredisstack-url]: https://github.com/redis/nredisstack\n[nredisstack-stars]: https://img.shields.io/github/stars/redis/nredisstack.svg?style=social\u0026amp;label=Star\u0026amp;maxAge=2592000\n[nredisstack-package]: https://www.nuget.org/packages/nredisstack/\n\n[node-redis-url]: https://github.com/redis/node-redis\n[node-redis-stars]: https://img.shields.io/github/stars/redis/node-redis.svg?style=social\u0026amp;label=Star\u0026amp;maxAge=2592000\n[node-redis-package]: https://www.npmjs.com/package/redis\n\n[redis-om-python-url]: https://github.com/redis/redis-om-python\n[redis-om-python-author]: https://redis.com\n[redis-om-python-stars]: https://img.shields.io/github/stars/redis/redis-om-python.svg?style=social\u0026amp;label=Star\u0026amp;maxAge=2592000\n\n[redisearch-go-url]: https://github.com/RediSearch/redisearch-go\n[redisearch-go-author]: https://redis.com\n[redisearch-go-stars]: https://img.shields.io/github/stars/RediSearch/redisearch-go.svg?style=social\u0026amp;label=Star\u0026amp;maxAge=2592000\n\n[redisearch-api-rs-url]: https://github.com/RediSearch/redisearch-api-rs\n[redisearch-api-rs-author]: https://redis.com\n[redisearch-api-rs-stars]: https://img.shields.io/github/stars/RediSearch/redisearch-api-rs.svg?style=social\u0026amp;label=Star\u0026amp;maxAge=2592000\n\n\nIn the below cells, we will walk you through using Redis as a vector database. Since many of you are likely already used to the Redis API, this should be familiar to most.\n\nThere are many ways to deploy Redis with RediSearch. The easiest way to get started is to use Docker, but there are are many potential options for deployment. For other deployment options, see the redis directory in this repo.\n\nFor this tutorial, we will use Redis Stack on Docker.\n\nStart a version of Redis with RediSearch (Redis Stack) by running the following docker command\n\n$ cd redis\n$ docker compose up -d\nThis also includes the RedisInsight GUI for managing your Redis database which you can view at http://localhost:8001 once you start the docker container.\n\nYou're all set up and ready to go! Next, we import and create our client for communicating with the Redis database we just created.\n\nThe below cells will show how to specify and create a search index in Redis. We will\n\nSet some constants for defining our index like the distance metric and the index name\nDefine the index schema with RediSearch fields\nCreate the index\n\n\nNow that we have a search index, we can load documents into it. We will use the same documents we used in the previous examples. In Redis, either the Hash or JSON (if using RedisJSON in addition to RediSearch) data types can be used to store documents. We will use the HASH data type in this example. The below cells will show how to load documents into the index.\n\nNow that we have a search index and documents loaded into it, we can run search queries. Below we will provide a function that will run a search query and return the results. Using this function we run a few queries that will show how you can utilize Redis as a vector database. Each example will demonstrate specific features to keep in mind when developing your search application with Redis.\n\nReturn Fields: You can specify which fields you want to return in the search results. This is useful if you only want to return a subset of the fields in your documents and doesn't require a separate call to retrieve documents. In the below example, we will only return the title field in the search results.\nHybrid Search: You can combine vector search with any of the other RediSearch fields for hybrid search such as full text search, tag, geo, and numeric. In the below example, we will combine vector search with full text search.\n\n\nThe previous examples showed how run vector search queries with RediSearch. In this section, we will show how to combine vector search with other RediSearch fields for hybrid search. In the below example, we will combine vector search with full text search.\nFor more example with Redis as a vector database, see the README and examples within the `vector_databases/redis` directory of this repository"])</script><script>self.__next_f.push([1,"9c:T1474,"])</script><script>self.__next_f.push([1,"This notebook provides an introduction to using Redis as a vector database with OpenAI embeddings. Redis is a scalable, real-time database that can be used as a vector database when using the RediSearch Module. The RediSearch module allows you to index and search for vectors in Redis. This notebook will show you how to use the RediSearch module to index and search for vectors created by using the OpenAI API and stored in Redis.\n\n\nMost developers from a web services background are probably familiar with Redis. At it's core, Redis is an open-source key-value store that can be used as a cache, message broker, and database. Developers choice Redis because it is fast, has a large ecosystem of client libraries, and has been deployed by major enterprises for years.\n\nIn addition to the traditional uses of Redis. Redis also provides Redis Modules which are a way to extend Redis with new data types and commands. Example modules include RedisJSON, RedisTimeSeries, RedisBloom and RediSearch.\n\n\nRediSearch is a Redis module that provides querying, secondary indexing, full-text search and vector search for Redis. To use RediSearch, you first declare indexes on your Redis data. You can then use the RediSearch clients to query that data. For more information on the feature set of RediSearch, see the README or the RediSearch documentation.\n\n\nThere are a number of ways to deploy Redis. For local development, the quickest method is to use the Redis Stack docker container which we will use here. Redis Stack contains a number of Redis modules that can be used together to create a fast, multi-model data store and query engine.\n\nFor production use cases, The easiest way to get started is to use the Redis Cloud service. Redis Cloud is a fully managed Redis service. You can also deploy Redis on your own infrastructure using Redis Enterprise. Redis Enterprise is a fully managed Redis service that can be deployed in kubernetes, on-premises or in the cloud.\n\nAdditionally, every major cloud provider (AWS Marketplace, Google Marketplace, or Azure Marketplace) offers Redis Enterprise in a marketplace offering.\n\n\n\nBefore we start this project, we need to set up the following:\n\nstart a Redis database with RediSearch (redis-stack)\ninstall libraries\n    Redis-py\nget your OpenAI API key\n\n\n\n\nTo keep this example simple, we will use the Redis Stack docker container which we can start as follows\n\n$ docker-compose up -d\n\nThis also includes the RedisInsight GUI for managing your Redis database which you can view at http://localhost:8001 once you start the docker container.\n\nYou're all set up and ready to go! Next, we import and create our client for communicating with the Redis database we just created.\n\nRedis-Py is the python client for communicating with Redis. We will use this to communicate with our Redis-stack database.\n\nThe OpenAI API key is used for vectorization of query data.\n\nIf you don't have an OpenAI API key, you can get one from https://beta.openai.com/account/api-keys.\n\nOnce you get your key, please add it to your environment variables as OPENAI_API_KEY by using following command:\n\nIn this section we'll load embedded data that has already been converted into vectors. We'll use this data to create an index in Redis and then search for similar vectors.\n\nNow that we have our Redis database running, we can connect to it using the Redis-py client. We will use the default host and port for the Redis database which is localhost:6379.\n\n\n\nThe below cells will show how to specify and create a search index in Redis. We will:\n\nSet some constants for defining our index like the distance metric and the index name\nDefine the index schema with RediSearch fields\nCreate the index\n\nNow that we have a search index, we can load documents into it. We will use the same documents we used in the previous examples. In Redis, either the HASH or JSON (if using RedisJSON in addition to RediSearch) data types can be used to store documents. We will use the HASH data type in this example. The below cells will show how to load documents into the index.\n\nNow that we have a search index and documents loaded into it, we can run search queries. Below we will provide a function that will run a search query and return the results. Using this function we run a few queries that will show how you can utilize Redis as a vector database.\n\nThe previous examples showed how run vector search queries with RediSearch. In this section, we will show how to combine vector search with other RediSearch fields for hybrid search. In the below example, we will combine vector search with full text search.\n\nUp until now, we've been using the `FLAT or \"brute-force\" index to run our queries. Redis also supports the HNSW index which is a fast, approximate index. The HNSW index is a graph-based index that uses a hierarchical navigable small world graph to store vectors. The HNSW` index is a good choice for large datasets where you want to run approximate queries.\n\n`HNSW will take longer to build and consume more memory for most cases than FLAT` but will be faster to run queries on, especially for large datasets.\n\nThe following cells will show how to create an `HNSW` index and run queries with it using the same data as before."])</script><script>self.__next_f.push([1,"9d:Td94,"])</script><script>self.__next_f.push([1,"This notebook provides an introduction to using Redis as a vector database with OpenAI embeddings and running hybrid queries that combine VSS and lexical search using Redis Query and Search capability. Redis is a scalable, real-time database that can be used as a vector database when using the RediSearch Module. The Redis Query and Search capability allows you to index and search for vectors in Redis. This notebook will show you how to use the Redis Query and Search to index and search for vectors created by using the OpenAI API and stored in Redis.\n\nHybrid queries combine vector similarity with traditional Redis Query and Search filtering capabilities on GEO, NUMERIC, TAG or TEXT data simplifying application code. A common example of a hybrid query in an e-commerce use case is to find items visually similar to a given query image limited to items available in a GEO location and within a price range.\n\nBefore we start this project, we need to set up the following:\n\nstart a Redis database with RediSearch (redis-stack)\ninstall libraries\n    Redis-py\nget your OpenAI API key\n\n\n\n\nTo keep this example simple, we will use the Redis Stack docker container which we can start as follows\n\n$ docker-compose up -d\n\nThis also includes the RedisInsight GUI for managing your Redis database which you can view at http://localhost:8001 once you start the docker container.\n\nYou're all set up and ready to go! Next, we import and create our client for communicating with the Redis database we just created.\n\nRedis-Py is the python client for communicating with Redis. We will use this to communicate with our Redis-stack database.\n\nThe OpenAI API key is used for vectorization of query data.\n\nIf you don't have an OpenAI API key, you can get one from https://beta.openai.com/account/api-keys.\n\nOnce you get your key, please add it to your environment variables as OPENAI_API_KEY by using following command:\n\nIn this section we'll load and clean an ecommerce dataset. We'll generate embeddings using OpenAI and use this data to create an index in Redis and then search for similar vectors.\n\nNow that we have our Redis database running, we can connect to it using the Redis-py client. We will use the default host and port for the Redis database which is localhost:6379.\n\n\n\nThe below cells will show how to specify and create a search index in Redis. We will:\n\nSet some constants for defining our index like the distance metric and the index name\nDefine the index schema with RediSearch fields\nCreate the index\n\nNow that we have a search index, we can load documents into it. We will use the dataframe containing the styles dataset loaded previously. In Redis, either the HASH or JSON (if using RedisJSON in addition to RediSearch) data types can be used to store documents. We will use the HASH data type in this example. The cells below will show how to get OpenAI embeddings for the different products and load documents into the index.\n\nNow that we have a search index and documents loaded into it, we can run search queries. Below we will provide a function that will run a search query and return the results. Using this function we run a few queries that will show how you can utilize Redis as a vector database.\n\nThe previous examples showed how run vector search queries with RediSearch. In this section, we will show how to combine vector search with other RediSearch fields for hybrid search. In the example below, we will combine vector search with full text search."])</script><script>self.__next_f.push([1,"9e:T574,This notebook demonstrates how to use Redis as high-speed context memory with ChatGPT.\n\nRedis instance with the Redis Search and Redis JSON modules\nRedis-py client lib\nOpenAI Python client lib\nOpenAI API key\n\nInstall Python modules necessary for the examples.\nCreate a .env file and add your OpenAI key to it\nKey load + helper function for chat completion\nGpt-3.5-turbo was trained on data up to Sep 2021.  Let's ask it a question about something that is beyond that date.  In this case, the FTX/Sam Bankman-Fried scandal. We are using an old model here for demonstration. Newer models such as got-4o has later knowledge cutoffs (late 2023) and will work here as well.\nAn unfortunate behavior of these AI systems is the system will provide a confident-sounding response - even when the system is not confident with its result.  One way to mitigate this is prompt re-engineering, as seen below.\nAnother way to combat incomplete information is to give the system more information such that it can make intelligent decisions vs guessing.  We'll use Redis as the source for that additional context.  We'll pull in business news articles from after the GPT knowledge cut-off date such that the system will have a better understanding of how FTX was actually managed.\nFT.CREATE\nRedis JSON\nKNN Search\nNow that we have relevant context, add that to the prompt to OpenAI and get a very different response.9f:Td7b,"])</script><script>self.__next_f.push([1,"This notebook guides you step by step on using Tair as a vector database for OpenAI embeddings.\n\nThis notebook presents an end-to-end process of:\nUsing precomputed embeddings created by OpenAI API.\nStoring the embeddings in a cloud instance of Tair.\nConverting raw text query to an embedding with OpenAI API.\nUsing Tair to perform the nearest neighbour search in the created collection.\n\n\nTair is a cloud native in-memory database service that is developed by Alibaba Cloud. Tair is compatible with open source Redis and provides a variety of data models and enterprise-class capabilities to support your real-time online scenarios. Tair also introduces persistent memory-optimized instances that are based on the new non-volatile memory (NVM) storage medium. These instances can reduce costs by 30%, ensure data persistence, and provide almost the same performance as in-memory databases. Tair has been widely used in areas such as government affairs, finance, manufacturing, healthcare, and pan-Internet to meet their high-speed query and computing requirements.\n\nTairvector is an in-house data structure that provides high-performance real-time storage and retrieval of vectors. TairVector provides two indexing algorithms: Hierarchical Navigable Small World (HNSW) and Flat Search. Additionally, TairVector supports multiple distance functions, such as Euclidean distance, inner product, and Jaccard distance. Compared with traditional vector retrieval services, TairVector has the following advantages:\nStores all data in memory and supports real-time index updates to reduce latency of read and write operations.\nUses an optimized data structure in memory to better utilize storage capacity.\nFunctions as an out-of-the-box data structure in a simple and efficient architecture without complex modules or dependencies.\n\n\nUsing Tair Cloud Vector Database. Click here to fast deploy it.\n\n\nFor the purposes of this exercise we need to prepare a couple of things:\n\nTair cloud server instance.\nThe 'tair' library to interact with the tair database.\nAn OpenAI API key.\n\n\n\nThis notebook obviously requires the openai and tair packages, but there are also some other additional libraries we will use. The following command installs them all:\n\n\nThe OpenAI API key is used for vectorization of the documents and queries.\n\nIf you don't have an OpenAI API key, you can get one from https://beta.openai.com/account/api-keys.\n\nOnce you get your key, please add it by getpass.\nFirst add it to your environment variables.\n\nConnecting to a running instance of Tair server is easy with the official Python library.\nWe can test the connection by ping:\nThe downloaded file has to then be extracted:\n\nTair stores data in indexes where each object is described by one key. Each key contains a vector and multiple attribute_keys.\n\nWe will start with creating two indexes, one for title_vector and one for content_vector, and then we will fill it with our precomputed embeddings.\n\nIn this section we are going to load the data prepared previous to this session, so you don't have to recompute the embeddings of Wikipedia articles with your own credits.\n\nOnce the data is put into Tair we will start querying the collection for the closest vectors. We may provide an additional parameter vector_name to switch from title to content based search. Since the precomputed embeddings were created with text-embedding-3-small OpenAI model, we also have to use it during search."])</script><script>self.__next_f.push([1,"a0:Tbc8,"])</script><script>self.__next_f.push([1,"This notebook presents how to implement a Question Answering system with Langchain, Tair as a knowledge based and OpenAI embeddings. If you are not familiar with Tair, it’s better to check out the Getting_started_with_Tair_and_OpenAI.ipynb notebook.\n\nThis notebook presents an end-to-end process of:\nCalculating the embeddings with OpenAI API.\nStoring the embeddings in an Tair instance to build a knowledge base.\nConverting raw text query to an embedding with OpenAI API.\nUsing Tair to perform the nearest neighbour search in the created collection to find some context.\nAsking LLM to find the answer in a given context.\n\nAll the steps will be simplified to calling some corresponding Langchain methods.\nFor the purposes of this exercise we need to prepare a couple of things:\nTair cloud instance.\nLangchain as a framework.\nAn OpenAI API key.\nThis notebook requires the following Python packages: openai, tiktoken, langchain and tair.\nopenai provides convenient access to the OpenAI API.\ntiktoken is a fast BPE tokeniser for use with OpenAI's models.\nlangchain helps us to build applications with LLM more easily.\ntair library is used to interact with the tair vector database.\nThe OpenAI API key is used for vectorization of the documents and queries.\n\nIf you don't have an OpenAI API key, you can get one from [https://platform.openai.com/account/api-keys ).\n\nOnce you get your key, please add it by getpass.\nTo build the Tair connection, you need to have TAIR_URL.\nIn this section we are going to load the data containing some natural questions and answers to them. All the data will be used to create a Langchain application with Tair being the knowledge base.\n\nLangchain is already integrated with Tair and performs all the indexing for given list of documents. In our case we are going to store the set of answers we have.\nAt this stage all the possible answers are already stored in Tair, so we can define the whole QA chain.\n\nOnce the data is put into Tair we can start asking some questions. A question will be automatically vectorized by OpenAI model, and the created vector will be used to find some possibly matching answers in Tair. Once retrieved, the most similar answers will be incorporated into the prompt sent to OpenAI Large Language Model.\n\n\nThe stuff chain type in Langchain uses a specific prompt with question and context documents incorporated. This is what the default prompt looks like:\n\nUse the following pieces of context to answer the question at the end. If you don't know the answer, just say that you don't know, don't try to make up an answer.\n{context}\nQuestion: {question}\nHelpful Answer:\n\nWe can, however, provide our prompt template and change the behaviour of the OpenAI LLM, while still using the stuff chain type. It is important to keep {context} and {question} as placeholders.\n\n\nWe can try using a different prompt template, so the model:\nResponds with a single-sentence answer if it knows it.\nSuggests a random song title if it doesn't know the answer to our question."])</script><script>self.__next_f.push([1,"a1:T7e5,Typesense is an open source, in-memory search engine, that you can either self-host or run on Typesense Cloud.\n\n\nTypesense focuses on performance by storing the entire index in RAM (with a backup on disk) and also focuses on providing an out-of-the-box developer experience by simplifying available options and setting good defaults.\n\nIt also lets you combine attribute-based filtering together with vector queries, to fetch the most relevant documents.\n\n\nBesides vector storage and search, Typesense also offers the following features:\n\nTypo Tolerance: Handles typographical errors elegantly, out-of-the-box.\nTunable Ranking: Easy to tailor your search results to perfection.\nSorting: Dynamically sort results based on a particular field at query time (helpful for features like \"Sort by Price (asc)\").\nFaceting \u0026 Filtering: Drill down and refine results.\nGrouping \u0026 Distinct: Group similar results together to show more variety.\nFederated Search: Search across multiple collections (indices) in a single HTTP request.\nScoped API Keys: Generate API keys that only allow access to certain records, for multi-tenant applications.\nSynonyms: Define words as equivalents of each other, so searching for a word will also return results for the synonyms defined.\nCuration \u0026 Merchandizing: Boost particular records to a fixed position in the search results, to feature them.\nRaft-based Clustering: Set up a distributed cluster that is highly available.\nSeamless Version Upgrades: As new versions of Typesense come out, upgrading is as simple as swapping out the binary and restarting Typesense.\nNo Runtime Dependencies: Typesense is a single binary that you can run locally or in production with a single command.\n\n\nTo learn more about how to use Typesense with OpenAI embeddings, see the notebook here for an example: examples/vector_databases/Using_vector_databases_for_embeddings_search.ipynb\nTo learn more about Typesense's vector search feature, read the docs here: https://typesense.org/docs/0.24.1/api/vector-search.html.a2:Tfa4,"])</script><script>self.__next_f.push([1,"This notebook takes you through a simple flow to download some data, embed it, and then index and search it using a selection of vector databases. This is a common requirement for customers who want to store and search our embeddings with their own data in a secure environment to support production use cases such as chatbots, topic modelling and more.\n\n\nA vector database is a database made to store, manage and search embedding vectors. The use of embeddings to encode unstructured data (text, audio, video and more) as vectors for consumption by machine-learning models has exploded in recent years, due to the increasing effectiveness of AI in solving use cases involving natural language, image recognition and other unstructured forms of data. Vector databases have emerged as an effective solution for enterprises to deliver and scale these use cases.\n\n\nVector databases enable enterprises to take many of the embeddings use cases we've shared in this repo (question and answering, chatbot and recommendation services, for example), and make use of them in a secure, scalable environment. Many of our customers make embeddings solve their problems at small scale but performance and security hold them back from going into production - we see vector databases as a key component in solving that, and in this guide we'll walk through the basics of embedding text data, storing it in a vector database and using it for semantic search.\n\n\nThe demo flow is:\nSetup**: Import packages and set any required variables\nLoad data**: Load a dataset and embed it using OpenAI embeddings\nTypesense**\n    Setup: Set up the Typesense Python client. For more details go here\n    Index Data: We'll create a collection and index it for both titles and content.\n    Search Data: Run a few example queries with various goals in mind.\n\nOnce you've run through this notebook you should have a basic understanding of how to setup and use vector databases, and can move on to more complex use cases making use of our embeddings.\n\nImport the required libraries and set the embedding model that we'd like to use.\n\nIn this section we'll load embedded data that we've prepared previous to this session.\n\nThe next vector store we'll look at is Typesense, which is an open source, in-memory search engine, that you can either self-host or run on Typesense Cloud.\n\nTypesense focuses on performance by storing the entire index in RAM (with a backup on disk) and also focuses on providing an out-of-the-box developer experience by simplifying available options and setting good defaults. It also lets you combine attribute-based filtering together with vector queries.\n\nFor this example, we will set up a local docker-based Typesense server, index our vectors in Typesense and then do some nearest-neighbor search queries. If you use Typesense Cloud, you can skip the docker setup part and just obtain the hostname and API keys from your cluster dashboard.\n\nTo run Typesense locally, you'll need Docker. Following the instructions contained in the Typesense documentation here, we created an example docker-compose.yml file in this repo saved at ./typesense/docker-compose.yml.\n\nAfter starting Docker, you can start Typesense locally by navigating to the examples/vector_databases/typesense/ directory and running docker-compose up -d.\n\nThe default API key is set to xyz in the Docker compose file, and the default Typesense port to 8108.\n\nTo index vectors in Typesense, we'll first create a Collection (which is a collection of Documents) and turn on vector indexing for a particular field. You can even store multiple vector fields in a single document.\n\nNow that we've imported the vectors into Typesense, we can do a nearest neighbor search on the title_vector or content_vector field.\nThanks for following along, you're now equipped to set up your own vector databases and use embeddings to do all kinds of cool things - enjoy! For more complex use cases please continue to work through other cookbook examples in this repo."])</script><script>self.__next_f.push([1,"a3:T5cc,​Weaviate is an open-source vector search engine (docs - Github) that can store and search through OpenAI embeddings and data objects. The database allows you to do similarity search, hybrid search (the combining of multiple search techniques, such as keyword-based and vector search), and generative search (like Q\u0026A). Weaviate also supports a wide variety of OpenAI-based modules (e.g., text2vec-openai, qna-openai), allowing you to vectorize and query data fast and efficiently.\n\nYou can run Weaviate (including the OpenAI modules if desired) in three ways:\n\nOpen source inside a Docker-container (example)\nUsing the Weaviate Cloud Service (get started)\nIn a Kubernetes cluster (learn more)\n\n\nThis folder contains a variety of Weaviate and OpenAI examples.\n\n| Name | Description | language | Google Colab |\n| --- | --- | --- | --- |\n| Getting Started with Weaviate and OpenAI | A simple getting started for semantic vector search using the OpenAI vectorization module in Weaviate (text2vec-openai) | Python Notebook | link |\n| Hybrid Search with Weaviate and OpenAI | A simple getting started for hybrid search using the OpenAI vectorization module in Weaviate (text2vec-openai) | Python Notebook | link |\n| Question Answering with Weaviate and OpenAI | A simple getting started for question answering (Q\u0026A) using the OpenAI Q\u0026A module in Weaviate (qna-openai) | Python Notebook | link |\n| Docker-compose example | A Docker-compose file with all OpenAI modules enabled | Docker |a4:T1267,"])</script><script>self.__next_f.push([1,"This notebook takes you through a simple flow to download some data, embed it, and then index and search it using a selection of vector databases. This is a common requirement for customers who want to store and search our embeddings with their own data in a secure environment to support production use cases such as chatbots, topic modelling and more.\n\n\nA vector database is a database made to store, manage and search embedding vectors. The use of embeddings to encode unstructured data (text, audio, video and more) as vectors for consumption by machine-learning models has exploded in recent years, due to the increasing effectiveness of AI in solving use cases involving natural language, image recognition and other unstructured forms of data. Vector databases have emerged as an effective solution for enterprises to deliver and scale these use cases.\n\n\nVector databases enable enterprises to take many of the embeddings use cases we've shared in this repo (question and answering, chatbot and recommendation services, for example), and make use of them in a secure, scalable environment. Many of our customers make embeddings solve their problems at small scale but performance and security hold them back from going into production - we see vector databases as a key component in solving that, and in this guide we'll walk through the basics of embedding text data, storing it in a vector database and using it for semantic search.\n\n\nThe demo flow is:\nSetup**: Import packages and set any required variables\nLoad data**: Load a dataset and embed it using OpenAI embeddings\nWeaviate**\n    Setup: Here we'll set up the Python client for Weaviate. For more details go here\n    Index Data: We'll create an index with title search vectors in it\n    Search Data: We'll run a few searches to confirm it works\n\nOnce you've run through this notebook you should have a basic understanding of how to setup and use vector databases, and can move on to more complex use cases making use of our embeddings.\n\nImport the required libraries and set the embedding model that we'd like to use.\n\nIn this section we'll load embedded data that we've prepared previous to this session.\n\nAnother vector database option we'll explore is Weaviate, which offers both a managed, SaaS option, as well as a self-hosted open source option. As we've already looked at a cloud vector database, we'll try the self-hosted option here.\n\nFor this we will:\nSet up a local deployment of Weaviate\nCreate indices in Weaviate\nStore our data there\nFire some similarity search queries\nTry a real use case\n\n\nIn this cookbook, we provide the data with already generated vectors. This is a good approach for scenarios, where your data is already vectorized.\n\nFor scenarios, where your data is not vectorized yet, you can delegate the vectorization task with OpenAI to Weaviate.\nWeaviate offers a built-in module text2vec-openai, which takes care of the vectorization for you at:\nimport\nfor any CRUD operations\nfor semantic search\n\nCheck out the Getting Started with Weaviate and OpenAI module cookbook to learn step by step how to import and vectorize data in one step.\n\nTo run Weaviate locally, you'll need Docker. Following the instructions contained in the Weaviate documentation here, we created an example docker-compose.yml file in this repo saved at ./weaviate/docker-compose.yml.\n\nAfter starting Docker, you can start Weaviate locally by navigating to the examples/vector_databases/weaviate/ directory and running docker-compose up -d.\n\nAlternatively you can use Weaviate Cloud Service (WCS) to create a free Weaviate cluster.\ncreate a free account and/or login to WCS\ncreate a Weaviate Cluster with the following settings:\n    Sandbox: Sandbox Free\n    Weaviate Version: Use default (latest)\n    OIDC Authentication: Disabled\nyour instance should be ready in a minute or two\nmake a note of the Cluster Id. The link will take you to the full path of your cluster (you will need it later to connect to it). It should be something like: https://your-project-name-suffix.weaviate.network\n\nIn Weaviate you create schemas to capture each of the entities you will be searching.\n\nIn this case we'll create a schema called Article with the title vector from above included for us to search by.\n\nThe next few steps closely follow the documentation Weaviate provides here.\n\n\nAs above, we'll fire some queries at our new Index and get back results based on the closeness to our existing vectors\n\nWeaviate has a built-in module for OpenAI, which takes care of the steps required to generate a vector embedding for your queries and any CRUD operations.\n\nThis allows you to run a vector query with the with_near_text filter, which uses your OPEN_API_KEY."])</script><script>self.__next_f.push([1,"a5:T8f0,"])</script><script>self.__next_f.push([1,"This notebook is prepared for a scenario where:\nYour data is already in Weaviate\nYou want to use Weaviate with the Generative OpenAI module (generative-openai).\n\n\n\nThis cookbook only coveres Generative Search examples, however, it doesn't cover the configuration and data imports.\n\nIn order to make the most of this cookbook, please complete the Getting Started cookbook first, where you will learn the essentials of working with Weaviate and import the demo data.\n\nChecklist:\ncompleted Getting Started cookbook,\ncrated a Weaviate instance,\nimported data into your Weaviate instance,\nyou have an OpenAI API key\n\n\nThe OpenAI API key is used for vectorization of your data at import, and for running queries.\n\nIf you don't have an OpenAI API key, you can get one from https://beta.openai.com/account/api-keys.\n\nOnce you get your key, please add it to your environment variables as OPENAI_API_KEY.\n\nIn this section, we will:\n\ntest env variable OPENAI_API_KEY – make sure you completed the step in #Prepare-your-OpenAI-API-key\nconnect to your Weaviate with your OpenAI API Key\nand test the client connection\n\n\nAfter this step, the client object will be used to perform all Weaviate-related operations.\nWeaviate offers a Generative Search OpenAI module, which generates responses based on the data stored in your Weaviate instance.\n\nThe way you construct a generative search query is very similar to a standard semantic search query in Weaviate.\n\nFor example:\nsearch in \"Articles\",\nreturn \"title\", \"content\", \"url\"\nlook for objects related to \"football clubs\"\nlimit results to 5 objects\n\n    result = (\n        client.query\n        .get(\"Articles\", [\"title\", \"content\", \"url\"])\n        .with_near_text(\"concepts\": \"football clubs\")\n        .with_limit(5)\ngenerative query will go here\n        .do()\n    )\n\nNow, you can add with_generate() function to apply generative transformation. with_generate takes either:\nsingle_prompt - to generate a response for each returned object,\ngrouped_task – to generate a single response from all returned objects.\n\nThanks for following along, you're now equipped to set up your own vector databases and use embeddings to do all kinds of cool things - enjoy! For more complex use cases please continue to work through other cookbook examples in this repo."])</script><script>self.__next_f.push([1,"a6:T1aa7,"])</script><script>self.__next_f.push([1,"This notebook is prepared for a scenario where:\nYour data is not vectorized\nYou want to run Vector Search on your data\nYou want to use Weaviate with the OpenAI module (text2vec-openai), to generate vector embeddings for you.\n\nThis notebook takes you through a simple flow to set up a Weaviate instance, connect to it (with OpenAI API key), configure data schema, import data (which will automatically generate vector embeddings for your data), and run semantic search.\n\nThis is a common requirement for customers who want to store and search our embeddings with their own data in a secure environment to support production use cases such as chatbots, topic modelling and more.\n\n\nWeaviate is an open-source vector search engine that stores data objects together with their vectors. This allows for combining vector search with structured filtering.\n\nWeaviate uses KNN algorithms to create an vector-optimized index, which allows your queries to run extremely fast. Learn more here.\n\nWeaviate let you use your favorite ML-models, and scale seamlessly into billions of data objects.\n\n\nWhatever your scenario or production setup, Weaviate has an option for you. You can deploy Weaviate in the following setups:\nSelf-hosted – you can deploy Weaviate with docker locally, or any server you want.\nSaaS – you can use Weaviate Cloud Service (WCS) to host your Weaviate instances.\nHybrid-SaaS – you can deploy Weaviate in your own private Cloud Service.\n\n\nWeaviate offers four client libraries, which allow you to communicate from your apps:\nPython\nJavaScript\nJava\nGo\n\nAdditionally, Weaviate has a REST layer. Basically you can call Weaviate from any language that supports REST requests.\nThe demo flow is:\nPrerequisites Setup**: Create a Weaviate instance and install the required libraries\nConnect**: Connect to your Weaviate instance\nSchema Configuration**: Configure the schema of your data\n    Note: Here we can define which OpenAI Embedding Model to use\n    Note: Here we can configure which properties to index\nImport data**: Load a demo dataset and import it into Weaviate\n    Note: The import process will automatically index your data - based on the configuration in the schema\n    Note: You don't need to explicitly vectorize your data, Weaviate will communicate with OpenAI to do it for you\nRun Queries**: Query\n    Note: You don't need to explicitly vectorize your queries, Weaviate will communicate with OpenAI to do it for you\n\nOnce you've run through this notebook you should have a basic understanding of how to setup and use vector databases, and can move on to more complex use cases making use of our embeddings.\nAll Weaviate instances come equipped with the text2vec-openai module.\n\nThis module is responsible for handling vectorization during import (or any CRUD operations) and when you run a query.\n\nThis is great news for you. With text2vec-openai you don't need to manually vectorize your data, as Weaviate will call OpenAI for you whenever necessary.\n\nAll you need to do is:\nprovide your OpenAI API Key – when you connected to the Weaviate Client\ndefine which OpenAI vectorizer to use in your Schema\n\nBefore we start this project, we need setup the following:\n\ncreate a Weaviate instance\ninstall libraries\n    weaviate-client\n    datasets\n    apache-beam\nget your OpenAI API key\n\n\n\nTo create a Weaviate instance we have 2 options:\n\n(Recommended path) Weaviate Cloud Service – to host your Weaviate instance in the cloud. The free sandbox should be more than enough for this cookbook.\nInstall and run Weaviate locally with Docker.\n\n\nUse Weaviate Cloud Service (WCS) to create a free Weaviate cluster.\ncreate a free account and/or login to WCS\ncreate a Weaviate Cluster with the following settings:\n    Sandbox: Sandbox Free\n    Weaviate Version: Use default (latest)\n    OIDC Authentication: Disabled\nyour instance should be ready in a minute or two\nmake a note of the Cluster Id. The link will take you to the full path of your cluster (you will need it later to connect to it). It should be something like: https://your-project-name.weaviate.network\n\nInstall and run Weaviate locally with Docker.\nDownload the ./docker-compose.yml file\nThen open your terminal, navigate to where your docker-compose.yml file is located, and start docker with: docker-compose up -d\nOnce this is ready, your instance should be available at http://localhost:8080\n\nNote. To shut down your docker instance you can call: docker-compose down\n\nTo learn more, about using Weaviate with Docker see the installation documentation.\n\n\nBefore running this project make sure to have the following libraries:\n\n\nThe Weaviate Python client allows you to communicate with your Weaviate instance from your Python project.\n\n\nTo load sample data, you need the datasets library and its dependency apache-beam.\n\n\nThe OpenAI API key is used for vectorization of your data at import, and for running queries.\n\nIf you don't have an OpenAI API key, you can get one from https://beta.openai.com/account/api-keys.\n\nOnce you get your key, please add it to your environment variables as OPENAI_API_KEY.\n\nIn this section, we will:\n\ntest env variable OPENAI_API_KEY – make sure you completed the step in #Prepare-your-OpenAI-API-key\nconnect to your Weaviate with your OpenAI API Key\nand test the client connection\n\n\nAfter this step, the client object will be used to perform all Weaviate-related operations.\n\nIn this section, we will:\nconfigure the data schema for your data\nselect OpenAI module\nThis is the second and final step, which requires OpenAI specific configuration.\nAfter this step, the rest of instructions wlll only touch on Weaviate, as the OpenAI tasks will be handled automatically.\n\n\n\nIn Weaviate you create schemas to capture each of the entities you will be searching.\n\nA schema is how you tell Weaviate:\nwhat embedding model should be used to vectorize the data\nwhat your data is made of (property names and types)\nwhich properties should be vectorized and indexed\n\nIn this cookbook we will use a dataset for Articles, which contains:\ntitle\ncontent\nurl\n\nWe want to vectorize title and content, but not the url.\n\nTo vectorize and query the data, we will use text-embedding-3-small.\n\nIn this section we will:\nload the Simple Wikipedia dataset\nconfigure Weaviate Batch import (to make the import more efficient)\nimport the data into Weaviate\nNote:\nLike mentioned before. We don't need to manually vectorize the data.\nThe text2vec-openai module will take care of that.\n\nAs above, we'll fire some queries at our new Index and get back results based on the closeness to our existing vectors\nThanks for following along, you're now equipped to set up your own vector databases and use embeddings to do all kinds of cool things - enjoy! For more complex use cases please continue to work through other cookbook examples in this repo."])</script><script>self.__next_f.push([1,"a7:T1af4,"])</script><script>self.__next_f.push([1,"This notebook is prepared for a scenario where:\nYour data is not vectorized\nYou want to run Hybrid Search (learn more) on your data\nYou want to use Weaviate with the OpenAI module (text2vec-openai), to generate vector embeddings for you.\n\nThis notebook takes you through a simple flow to set up a Weaviate instance, connect to it (with OpenAI API key), configure data schema, import data (which will automatically generate vector embeddings for your data), and run hybrid search (mixing of vector and BM25 search).\n\nThis is a common requirement for customers who want to store and search our embeddings with their own data in a secure environment to support production use cases such as chatbots, topic modelling and more.\n\n\nWeaviate is an open-source vector search engine that stores data objects together with their vectors. This allows for combining vector search with structured filtering.\n\nWeaviate uses KNN algorithms to create an vector-optimized index, which allows your queries to run extremely fast. Learn more here.\n\nWeaviate let you use your favorite ML-models, and scale seamlessly into billions of data objects.\n\n\nWhatever your scenario or production setup, Weaviate has an option for you. You can deploy Weaviate in the following setups:\nSelf-hosted – you can deploy Weaviate with docker locally, or any server you want.\nSaaS – you can use Weaviate Cloud Service (WCS) to host your Weaviate instances.\nHybrid-SaaS – you can deploy Weaviate in your own private Cloud Service\n\nWeaviate offers four client libraries, which allow you to communicate from your apps:\nPython\nJavaScript\nJava\nGo\n\nAdditionally, Weaviate has a REST layer. Basically you can call Weaviate from any language that supports REST requests.\nThe demo flow is:\nPrerequisites Setup**: Create a Weaviate instance and install required libraries\nConnect**: Connect to your Weaviate instance\nSchema Configuration**: Configure the schema of your data\n    Note: Here we can define which OpenAI Embedding Model to use\n    Note: Here we can configure which properties to index\nImport data**: Load a demo dataset and import it into Weaviate\n    Note: The import process will automatically index your data - based on the configuration in the schema\n    Note: You don't need to explicitly vectorize your data, Weaviate will communicate with OpenAI to do it for you\nRun Queries**: Query\n    Note: You don't need to explicitly vectorize your queries, Weaviate will communicate with OpenAI to do it for you\n\nOnce you've run through this notebook you should have a basic understanding of how to setup and use vector databases, and can move on to more complex use cases making use of our embeddings.\nAll Weaviate instances come equipped with the text2vec-openai module.\n\nThis module is responsible for handling vectorization during import (or any CRUD operations) and when you run a query.\n\nThis is great news for you. With text2vec-openai you don't need to manually vectorize your data, as Weaviate will call OpenAI for you whenever necessary.\n\nAll you need to do is:\nprovide your OpenAI API Key – when you connected to the Weaviate Client\ndefine which OpenAI vectorizer to use in your Schema\n\nBefore we start this project, we need setup the following:\n\ncreate a Weaviate instance\ninstall libraries\n    weaviate-client\n    datasets\n    apache-beam\nget your OpenAI API key\n\n\n\nTo create a Weaviate instance we have 2 options:\n\n(Recommended path) Weaviate Cloud Service – to host your Weaviate instance in the cloud. The free sandbox should be more than enough for this cookbook.\nInstall and run Weaviate locally with Docker.\n\n\nUse Weaviate Cloud Service (WCS) to create a free Weaviate cluster.\ncreate a free account and/or login to WCS\ncreate a Weaviate Cluster with the following settings:\n    Sandbox: Sandbox Free\n    Weaviate Version: Use default (latest)\n    OIDC Authentication: Disabled\nyour instance should be ready in a minute or two\nmake a note of the Cluster Id. The link will take you to the full path of your cluster (you will need it later to connect to it). It should be something like: https://your-project-name.weaviate.network\n\nInstall and run Weaviate locally with Docker.\nDownload the ./docker-compose.yml file\nThen open your terminal, navigate to where your docker-compose.yml file is located, and start docker with: docker-compose up -d\nOnce this is ready, your instance should be available at http://localhost:8080\n\nNote. To shut down your docker instance you can call: docker-compose down\n\nTo learn more, about using Weaviate with Docker see the installation documentation.\n\n\nBefore running this project make sure to have the following libraries:\n\n\nThe Weaviate Python client allows you to communicate with your Weaviate instance from your Python project.\n\n\nTo load sample data, you need the datasets library and its' dependency apache-beam.\n\n\nThe OpenAI API key is used for vectorization of your data at import, and for running queries.\n\nIf you don't have an OpenAI API key, you can get one from https://beta.openai.com/account/api-keys.\n\nOnce you get your key, please add it to your environment variables as OPENAI_API_KEY.\n\nIn this section, we will:\n\ntest env variable OPENAI_API_KEY – make sure you completed the step in #Prepare-your-OpenAI-API-key\nconnect to your Weaviate your OpenAI API Key\nand test the client connection\n\n\nAfter this step, the client object will be used to perform all Weaviate-related operations.\n\nIn this section, we will:\nconfigure the data schema for your data\nselect OpenAI module\nThis is the second and final step, which requires OpenAI specific configuration.\nAfter this step, the rest of instructions wlll only touch on Weaviate, as the OpenAI tasks will be handled automatically.\n\n\n\nIn Weaviate you create schemas to capture each of the entities you will be searching.\n\nA schema is how you tell Weaviate:\nwhat embedding model should be used to vectorize the data\nwhat your data is made of (property names and types)\nwhich properties should be vectorized and indexed\n\nIn this cookbook we will use a dataset for Articles, which contains:\ntitle\ncontent\nurl\n\nWe want to vectorize title and content, but not the url.\n\nTo vectorize and query the data, we will use text-embedding-3-small.\n\nIn this section we will:\nload the Simple Wikipedia dataset\nconfigure Weaviate Batch import (to make the import more efficient)\nimport the data into Weaviate\nNote:\nLike mentioned before. We don't need to manually vectorize the data.\nThe text2vec-openai module will take care of that.\n\nAs above, we'll fire some queries at our new Index and get back results based on the closeness to our existing vectors\n\nLearn more about the alpha setting here\nThanks for following along, you're now equipped to set up your own vector databases and use embeddings to do all kinds of cool things - enjoy! For more complex use cases please continue to work through other cookbook examples in this repo."])</script><script>self.__next_f.push([1,"a8:T1ab1,"])</script><script>self.__next_f.push([1,"This notebook is prepared for a scenario where:\nYour data is not vectorized\nYou want to run Q\u0026A (learn more) on your data based on the OpenAI completions endpoint.\nYou want to use Weaviate with the OpenAI module (text2vec-openai), to generate vector embeddings for you.\n\nThis notebook takes you through a simple flow to set up a Weaviate instance, connect to it (with OpenAI API key), configure data schema, import data (which will automatically generate vector embeddings for your data), and run question answering.\n\n\nWeaviate is an open-source vector search engine that stores data objects together with their vectors. This allows for combining vector search with structured filtering.\n\nWeaviate uses KNN algorithms to create an vector-optimized index, which allows your queries to run extremely fast. Learn more here.\n\nWeaviate let you use your favorite ML-models, and scale seamlessly into billions of data objects.\n\n\nWhatever your scenario or production setup, Weaviate has an option for you. You can deploy Weaviate in the following setups:\nSelf-hosted – you can deploy Weaviate with docker locally, or any server you want.\nSaaS – you can use Weaviate Cloud Service (WCS) to host your Weaviate instances.\nHybrid-SaaS – you can deploy Weaviate in your own private Cloud Service\n\nWeaviate offers four client libraries, which allow you to communicate from your apps:\nPython\nJavaScript\nJava\nGo\n\nAdditionally, Weaviate has a REST layer. Basically you can call Weaviate from any language that supports REST requests.\nThe demo flow is:\nPrerequisites Setup**: Create a Weaviate instance and install required libraries\nConnect**: Connect to your Weaviate instance\nSchema Configuration**: Configure the schema of your data\n    Note: Here we can define which OpenAI Embedding Model to use\n    Note: Here we can configure which properties to index\nImport data**: Load a demo dataset and import it into Weaviate\n    Note: The import process will automatically index your data - based on the configuration in the schema\n    Note: You don't need to explicitly vectorize your data, Weaviate will communicate with OpenAI to do it for you\nRun Queries**: Query\n    Note: You don't need to explicitly vectorize your queries, Weaviate will communicate with OpenAI to do it for you\n    Note: The qna-openai module automatically communicates with the OpenAI completions endpoint\n\nOnce you've run through this notebook you should have a basic understanding of how to setup and use vector databases for question answering.\nAll Weaviate instances come equipped with the text2vec-openai and the qna-openai modules.\n\nThe first module is responsible for handling vectorization at import (or any CRUD operations) and when you run a search query. The second module communicates with the OpenAI completions endpoint.\n\nThis is great news for you. With text2vec-openai you don't need to manually vectorize your data, as Weaviate will call OpenAI for you whenever necessary.\n\nAll you need to do is:\nprovide your OpenAI API Key – when you connected to the Weaviate Client\ndefine which OpenAI vectorizer to use in your Schema\n\nBefore we start this project, we need setup the following:\n\ncreate a Weaviate instance\ninstall libraries\n    weaviate-client\n    datasets\n    apache-beam\nget your OpenAI API key\n\n\n\nTo create a Weaviate instance we have 2 options:\n\n(Recommended path) Weaviate Cloud Service – to host your Weaviate instance in the cloud. The free sandbox should be more than enough for this cookbook.\nInstall and run Weaviate locally with Docker.\n\n\nUse Weaviate Cloud Service (WCS) to create a free Weaviate cluster.\ncreate a free account and/or login to WCS\ncreate a Weaviate Cluster with the following settings:\n    Sandbox: Sandbox Free\n    Weaviate Version: Use default (latest)\n    OIDC Authentication: Disabled\nyour instance should be ready in a minute or two\nmake a note of the Cluster Id. The link will take you to the full path of your cluster (you will need it later to connect to it). It should be something like: https://your-project-name.weaviate.network\n\nInstall and run Weaviate locally with Docker.\nDownload the ./docker-compose.yml file\nThen open your terminal, navigate to where your docker-compose.yml file is located, and start docker with: docker-compose up -d\nOnce this is ready, your instance should be available at http://localhost:8080\n\nNote. To shut down your docker instance you can call: docker-compose down\n\nTo learn more, about using Weaviate with Docker see the installation documentation.\n\n\nBefore running this project make sure to have the following libraries:\n\n\nThe Weaviate Python client allows you to communicate with your Weaviate instance from your Python project.\n\n\nTo load sample data, you need the datasets library and its' dependency apache-beam.\n\n\nThe OpenAI API key is used for vectorization of your data at import, and for queries.\n\nIf you don't have an OpenAI API key, you can get one from https://beta.openai.com/account/api-keys.\n\nOnce you get your key, please add it to your environment variables as OPENAI_API_KEY.\n\nIn this section, we will:\n\ntest env variable OPENAI_API_KEY – make sure you completed the step in #Prepare-your-OpenAI-API-key\nconnect to your Weaviate your OpenAI API Key\nand test the client connection\n\n\nAfter this step, the client object will be used to perform all Weaviate-related operations.\n\nIn this section, we will:\nconfigure the data schema for your data\nselect OpenAI module\nThis is the second and final step, which requires OpenAI specific configuration.\nAfter this step, the rest of instructions wlll only touch on Weaviate, as the OpenAI tasks will be handled automatically.\n\n\n\nIn Weaviate you create schemas to capture each of the entities you will be searching.\n\nA schema is how you tell Weaviate:\nwhat embedding model should be used to vectorize the data\nwhat your data is made of (property names and types)\nwhich properties should be vectorized and indexed\n\nIn this cookbook we will use a dataset for Articles, which contains:\ntitle\ncontent\nurl\n\nWe want to vectorize title and content, but not the url.\n\nTo vectorize and query the data, we will use text-embedding-3-small. For Q\u0026A we will use gpt-3.5-turbo-instruct.\n\nIn this section we will:\nload the Simple Wikipedia dataset\nconfigure Weaviate Batch import (to make the import more efficient)\nimport the data into Weaviate\nNote:\nLike mentioned before. We don't need to manually vectorize the data.\nThe text2vec-openai module will take care of that.\n\nAs above, we'll fire some queries at our new Index and get back results based on the closeness to our existing vectors\nThanks for following along, you're now equipped to set up your own vector databases and use embeddings to do all kinds of cool things - enjoy! For more complex use cases please continue to work through other cookbook examples in this repo."])</script><script>self.__next_f.push([1,"a9:T988,"])</script><script>self.__next_f.push([1,"In this notebook we will be going over generating embeddings of movie descriptions with OpenAI and using those embeddings within Zilliz to find relevant movies. To narrow our search results and try something new, we are going to be using filtering to do metadata searches. The dataset in this example is sourced from HuggingFace datasets, and contains a little over 8 thousand movie entries.\n\nLets begin by first downloading the required libraries for this notebook:\nopenai is used for communicating with the OpenAI embedding service\npymilvus is used for communicating with the Zilliz server\ndatasets is used for downloading the dataset\ntqdm is used for the progress bars\n\nTo get Zilliz up and running take a look here. With your account and database set up, proceed to set the following values:\nURI: The URI your database is running on\nUSER: Your database username\nPASSWORD: Your database password\nCOLLECTION_NAME: What to name the collection within Zilliz\nDIMENSION: The dimension of the embeddings\nOPENAI_ENGINE: Which embedding model to use\nopenai.api_key: Your OpenAI account key\nINDEX_PARAM: The index settings to use for the collection\nQUERY_PARAM: The search parameters to use\nBATCH_SIZE: How many texts to embed and insert at once\nWith Zilliz up and running we can begin grabbing our data. Hugging Face Datasets is a hub that holds many different user datasets, and for this example we are using HuggingLearners's netflix-shows dataset. This dataset contains movies and their metadata pairs for over 8 thousand movies. We are going to embed each description and store it within Zilliz along with its title, type, release_year and rating.\nNow that we have our data on our machine we can begin embedding it and inserting it into Zilliz. The embedding function takes in text and returns the embeddings in a list format.\nThis next step does the actual inserting. We iterate through all the entries and create batches that we insert once we hit our set batch size. After the loop is over we insert the last remaning batch if it exists.\nWith our data safely inserted into Zilliz, we can now perform a query. The query takes in a tuple of the movie description you are searching for and the filter to use. More info about the filter can be found here. The search first prints out your description and filter expression. After that for each result we print the score, title, type, release year, rating and description of the result movies."])</script><script>self.__next_f.push([1,"aa:T94d,"])</script><script>self.__next_f.push([1,"In this notebook we will be going over generating embeddings of book descriptions with OpenAI and using those embeddings within Zilliz to find relevant books. The dataset in this example is sourced from HuggingFace datasets, and contains a little over 1 million title-description pairs.\n\nLets begin by first downloading the required libraries for this notebook:\nopenai is used for communicating with the OpenAI embedding service\npymilvus is used for communicating with the Zilliz instance\ndatasets is used for downloading the dataset\ntqdm is used for the progress bars\n\nTo get Zilliz up and running take a look here. With your account and database set up, proceed to set the following values:\nURI: The URI your database is running on\nUSER: Your database username\nPASSWORD: Your database password\nCOLLECTION_NAME: What to name the collection within Zilliz\nDIMENSION: The dimension of the embeddings\nOPENAI_ENGINE: Which embedding model to use\nopenai.api_key: Your OpenAI account key\nINDEX_PARAM: The index settings to use for the collection\nQUERY_PARAM: The search parameters to use\nBATCH_SIZE: How many texts to embed and insert at once\nThis segment deals with Zilliz and setting up the database for this use case. Within Zilliz we need to setup a collection and index it.\nWith Zilliz up and running we can begin grabbing our data. Hugging Face Datasets is a hub that holds many different user datasets, and for this example we are using Skelebor's book dataset. This dataset contains title-description pairs for over 1 million books. We are going to embed each description and store it within Zilliz along with its title.\nNow that we have our data on our machine we can begin embedding it and inserting it into Zilliz. The embedding function takes in text and returns the embeddings in a list format.\nThis next step does the actual inserting. Due to having so many datapoints, if you want to immediately test it out you can stop the inserting cell block early and move along. Doing this will probably decrease the accuracy of the results due to less datapoints, but it should still be good enough.\nWith our data safely inserted in Zilliz, we can now perform a query. The query takes in a string or a list of strings and searches them. The results print out your provided description and the results that include the result score, the result title, and the result book description."])</script><script>self.__next_f.push([1,"ab:T9030,"])</script><script>self.__next_f.push([1,"When GPT-3 fails on a task, what should you do?\n\nSearch for a better prompt that elicits more reliable answers?\nInvest in thousands of examples to fine-tune a custom model?\nAssume the model is incapable of the task, and move on?\n\nThere is no simple answer - it depends. However, if your task involves logical reasoning or complexity, consider trying the techniques in this article to build more reliable, high-performing prompts.\n\n\nIf you were asked to multiply 13 by 17, would the answer pop immediately into your mind? For most of us, probably not. Yet, that doesn't mean humans are incapable of two-digit multiplication. With a few seconds, and some pen and paper, it's not too taxing to work out that 13 x 17 = 130 + 70 + 21 = 221.\n\nSimilarly, if you give GPT-3 a task that's too complex to do in the time it takes to calculate its next token, it may confabulate an incorrect guess. Yet, akin to humans, that doesn't necessarily mean the model is incapable of the task. With some time and space to reason things out, the model still may be able to answer reliably.\n\nAs an example, if you ask gpt-3.5-turbo-instruct the following math problem about juggling balls, it answers incorrectly:\n\nQ: A juggler has 16 balls. Half of the balls are golf balls and half of the golf balls are blue. How many blue golf balls are there?\nA:\n\nThere are 8 blue golf balls.\n\nDoes this mean that GPT-3 cannot do simple math problems? No; in fact, it turns out that by prompting the model with Let's think step by step, the model solves the problem reliably:\n\nQ: A juggler has 16 balls. Half of the balls are golf balls and half of the golf balls are blue. How many blue golf balls are there?\nA: Let's think step by step.\n\nThere are 16 balls in total.\nHalf of the balls are golf balls.\nThat means that there are 8 golf balls.\nHalf of the golf balls are blue.\nThat means that there are 4 blue golf balls.\n\nOf course, it's hard to tell from only a single example whether this Let's think step by step trick actually works in general or just got lucky on this particular problem. But it really does work. On a benchmark of word math problems, the Let's think step by step trick raised GPT-3's solve rate massively, from a worthless 18% to a decent 79%!\n\n\nWhen learning to work with GPT-3, one common conceptual mistake is to believe that its capabilities are fixed across all contexts. E.g., if GPT-3 gets a simple logic question wrong, then it must be incapable of simple logic.\n\nBut as the Let's think step by step example illustrates, apparent failures of GPT-3 can sometimes be remedied with a better prompt that helps the model steer itself toward the correct output.\n\n\nThe rest of this article shares techniques for improving reliability of large language models on complex tasks. Although some of the techniques are specific to certain types of problems, many of them are built upon general principles that can be applied to a wide range of tasks, e.g.:\n\nGive clearer instructions\nSplit complex tasks into simpler subtasks\nStructure the instruction to keep the model on task\nPrompt the model to explain before answering\nAsk for justifications of many possible answers, and then synthesize\nGenerate many outputs, and then use the model to pick the best one\nFine-tune custom models to maximize performance\n\n\nOne way to give a model more time and space to think is to break tasks into simpler pieces.\n\nAs an example, consider a task where we ask the model a multiple-choice question about some text - in this case, a game of Clue. When asked directly, gpt-3.5-turbo-instruct isn't able to put clues 3 \u0026 5 together, and answers incorrectly:\n\nUse the following clues to answer the following multiple-choice question.\n\nClues:\nMiss Scarlett was the only person in the lounge.\nThe person with the pipe was in the kitchen.\nColonel Mustard was the only person in the observatory.\nProfessor Plum was not in the library nor the billiard room.\nThe person with the candlestick was in the observatory.\n\nQuestion: Was Colonel Mustard in the observatory with the candlestick?\n(a) Yes; Colonel Mustard was in the observatory with the candlestick\n(b) No; Colonel Mustard was not in the observatory with the candlestick\n(c) Unknown; there is not enough information to determine whether Colonel Mustard was in the observatory with the candlestick\n\nSolution:\n\n(c) Unknown; there is not enough information to determine whether Colonel Mustard was in the observatory with the candlestick\n\nAlthough clues 3 and 5 establish that Colonel Mustard was the only person in the observatory and that the person in the observatory had the candlestick, the model fails to combine them into a correct answer of (a) Yes.\n\nHowever, instead of asking for the answer directly, we can split the task into three pieces:\n\nFirst, go through the clues one by one and consider whether the clue is potentially relevant\nSecond, combine the relevant clues to reason out the answer to the question\nThird, write the final answer: either (a), (b), or (c)\n\nUse the following clues to answer the following multiple-choice question, using the following procedure:\n(1) First, go through the clues one by one and consider whether the clue is potentially relevant\n(2) Second, combine the relevant clues to reason out the answer to the question\n(3) Third, map the answer to one of the multiple choice answers: either (a), (b), or (c)\n\nClues:\nMiss Scarlett was the only person in the lounge.\nThe person with the pipe was in the kitchen.\nColonel Mustard was the only person in the observatory.\nProfessor Plum was not in the library nor the billiard room.\nThe person with the candlestick was in the observatory.\n\nQuestion: Was Colonel Mustard in the observatory with the candlestick?\n(a) Yes; Colonel Mustard was in the observatory with the candlestick\n(b) No; Colonel Mustard was not in the observatory with the candlestick\n(c) Unknown; there is not enough information to determine whether Colonel Mustard was in the observatory with the candlestick\n\nSolution:\n(1) First, go through the clues one by one and consider whether the clue is potentially relevant:\n\nClue 1: Miss Scarlett was the only person in the lounge. This clue is not relevant.\nClue 2: The person with the pipe was in the kitchen. This clue is not relevant.\nClue 3: Colonel Mustard was the only person in the observatory. This clue is relevant.\nClue 4: Professor Plum was not in the library nor the billiard room. This clue is not relevant.\nClue 5: The person with the candlestick was in the observatory. This clue is relevant.\n\n(2) Second, combine the relevant clues to reason out the answer to the question:\nClue 3 and Clue 5 both say that the person with the candlestick was in the observatory. Colonel Mustard was the only person in the observatory, so Colonel Mustard was the person with the candlestick.\n\n(3) Third, write the final answer:\n(a) Yes; Colonel Mustard was in the observatory with the candlestick\n\nBy giving the model more time and space to think, and guiding it along a reasoning plan, it's able to figure out the correct answer of (a) Yes.\n\nAnother benefit of splitting complex instructions into smaller subtasks is that it can help keep the model focused on each subtask.\n\nFor example, if we ask gpt-3.5-turbo-instruct to summarize a text in its original language, the model can lapse back into English:\n\nSummarize the text using the original language of the text. The summary should be one sentence long.\n\nText:\n\"\"\"\nLa estadística (la forma femenina del término alemán Statistik, derivado a su vez del italiano statista, \"hombre de Estado\")​ es una ciencia que estudia la variabilidad, colección, organización, análisis, interpretación, y presentación de los datos, así como el proceso aleatorio que los genera siguiendo las leyes de la probabilidad.​ La estadística es una ciencia formal deductiva, con un conocimiento propio, dinámico y en continuo desarrollo obtenido a través del método científico formal. En ocasiones, las ciencias fácticas necesitan utilizar técnicas estadísticas durante su proceso de investigación factual, con el fin de obtener nuevos conocimientos basados en la experimentación y en la observación. En estos casos, la aplicación de la estadística permite el análisis de datos provenientes de una muestra representativa, que busca explicar las correlaciones y dependencias de un fenómeno físico o natural, de ocurrencia en forma aleatoria o condicional.\n\"\"\"\n\nSummary:\n\nThe text explains that statistics is a science that studies the variability, collection, organization, analysis, interpretation, and presentation of data, as well as the random process that generates them following the laws of probability.\n\nHowever, if we first ask the model to identify the language of the text, and then summarize the text, it becomes more reliable:\n\nFirst, identify the language of the text. Second, summarize the text using the original language of the text. The summary should be one sentence long.\n\nText:\n\"\"\"\nLa estadística (la forma femenina del término alemán Statistik, derivado a su vez del italiano statista, \"hombre de Estado\")​ es una ciencia que estudia la variabilidad, colección, organización, análisis, interpretación, y presentación de los datos, así como el proceso aleatorio que los genera siguiendo las leyes de la probabilidad.​ La estadística es una ciencia formal deductiva, con un conocimiento propio, dinámico y en continuo desarrollo obtenido a través del método científico formal. En ocasiones, las ciencias fácticas necesitan utilizar técnicas estadísticas durante su proceso de investigación factual, con el fin de obtener nuevos conocimientos basados en la experimentación y en la observación. En estos casos, la aplicación de la estadística permite el análisis de datos provenientes de una muestra representativa, que busca explicar las correlaciones y dependencias de un fenómeno físico o natural, de ocurrencia en forma aleatoria o condicional.\n\"\"\"\n\nLanguage:\n\nSpanish\n\nLa estadística es una ciencia que estudia la variabilidad, colección, organización, análisis, interpretación, y presentación de los datos, así como el proceso aleatorio que los genera siguiendo las leyes de la probabilidad.\n\n\nAnother powerful technique for improving the reliability of answers is to prompt the model to gradually reason out the answer rather than jumping immediately to the final answer. By 'thinking aloud' the model can be far more likely to arrive at the correct answer.\n\n\n\nPublished by Takeshi Kojima et al. in 2022, the easiest way to prompt a model to reason out the answer is to simply prepend answers with Let's think step by step. Figure 2 illustrates an example:\n\nzero-shot reasoning example\nSource: Large Language Models are Zero-Shot Reasoners by Takeshi Kojima et al. (2022).\n\n\nApplying this simple trick to the MultiArith math dataset, the authors found Let's think step by step quadrupled the accuracy, from 18% to 79%!\n\nzero-shot reasoning example\nSource: Large Language Models are Zero-Shot Reasoners by Takeshi Kojima et al. (2022).\n\n\nAlthough the Let's think step by step trick works well on math problems, it's not effective on all tasks. The authors found that it was most helpful for multi-step arithmetic problems, symbolic reasoning problems, strategy problems, and other reasoning problems. It didn't help with simple math problems or common sense questions, and presumably wouldn't help with many other non-reasoning tasks either.\n\nzero-shot reasoning example\nSource: Large Language Models are Zero-Shot Reasoners by Takeshi Kojima et al. (2022).\n\nTo learn more, read the full paper.\n\nIf you apply this technique to your own tasks, don't be afraid to experiment with customizing the instruction. Let's think step by step is rather generic, so you may find better performance with instructions that hew to a stricter format customized to your use case. For example, you can try more structured variants like First, think step by step about why X might be true. Second, think step by step about why Y might be true. Third, think step by step about whether X or Y makes more sense.. And you can even give the model an example format to help keep it on track, e.g.:\n\nUsing the IRS guidance below, answer the following questions using this format:\n(1) For each criterion, determine whether it is met by the vehicle purchase\n{Criterion} Let's think step by step. {explanation} {yes or no, or if the question does not apply then N/A}.\n(2) After considering each criterion in turn, phrase the final answer as \"Because of {reasons}, the answer is likely {yes or no}.\"\n\nIRS guidance:\n\"\"\"\nYou may be eligible for a federal tax credit under Section 30D if you purchased a car or truck that meets the following criteria:\nDoes the vehicle have at least four wheels?\nDoes the vehicle weigh less than 14,000 pounds?\nDoes the vehicle draw energy from a battery with at least 4 kilowatt hours that may be recharged from an external source?\nWas the vehicle purchased in a year before 2022?\n  If so, has the manufacturer sold less than 200,000 qualifying vehicles? (Tesla and GM have sold more than 200,000 qualifying vehicles.)\nWas the vehicle purchased in a year after 2022?\n  If so, is the vehicle present in the following list of North American-assembled vehicles? (The only electric vehicles assembled in North America are the Audi Q5, BMW 330e, BMW X5, Chevrolet Bolt EUV, Chevrolet Bolt EV, Chrysler Pacifica PHEV, Ford Escape PHEV, Ford F Series, Ford Mustang MACH E, Ford Transit Van, GMC Hummer Pickup, GMC Hummer SUV, Jeep Grand Cherokee PHEV, Jeep Wrangler PHEV, Lincoln Aviator PHEV, Lincoln Corsair Plug-in, Lucid Air, Nissan Leaf, Rivian EDV, Rivian R1S, Rivian R1T, Tesla Model 3, Tesla Model S, Tesla Model X, Tesla Model Y, Volvo S60, BMW 330e, Bolt EV, Cadillac Lyriq, Mercedes EQS SUV, and Nissan Leaf.)\n\"\"\"\n\nQuestion: Can I claim a federal tax credit for my Toyota Prius Prime bought in 2021?\n\nSolution:\n\n(1) For each criterion, determine whether it is met by the vehicle purchase\nDoes the vehicle have at least four wheels? Let's think step by step.\n\n The Toyota Prius Prime has four wheels, so the answer is yes.\nDoes the vehicle weigh less than 14,000 pounds? Let's think step by step. The Toyota Prius Prime weighs less than 14,000 pounds, so the answer is yes.\nDoes the vehicle draw energy from a battery with at least 4 kilowatt hours that may be recharged from an external source? Let's think step by step. The Toyota Prius Prime has a battery with at least 4 kilowatt hours that may be recharged from an external source, so the answer is yes.\nWas the vehicle purchased in a year before 2022? Let's think step by step. The Toyota Prius Prime was purchased in 2021, which is before 2022, so the answer is yes.\nWas the vehicle purchased in a year after 2022? N/A\nIf so, is the vehicle present in the following list of North American-assembled vehicles? N/A\n\n(2) After considering each criterion in turn, phrase the final answer as \"Because of {reasons}, the answer is likely {yes or no}.\"\n\nBecause the Toyota Prius Prime meets all of the criteria for a federal tax credit, the answer is likely yes.\n\n\n\nPrompting the model to reason out its answers can be done in many ways. One way is to demonstrate with a few examples ('few-shot'), as studied by Jason Wei and Denny Zhou et al. from Google. Here's an example few-shot chain-of-thought prompt:\n\nchain of thought example\nSource: Chain of Thought Prompting Elicits Reasoning in Large Language Models Jason Wei and Denny Zhou et al. (2022)\n\nMore demonstrations of reasoning chains written by human labelers:\n\nchain of thought example\nSource: Chain of Thought Prompting Elicits Reasoning in Large Language Models Jason Wei and Denny Zhou et al. (2022)\n\n(Note that it has been called into question whether pears actually float)\n\n\nTesting on grade school math problems, the authors found that chain of thought prompting tripled the solve rate, from 18% to 57%.\n\nchain of thought example\nSource: Chain of Thought Prompting Elicits Reasoning in Large Language Models Jason Wei and Denny Zhou et al. (2022)\n\nIn addition to math problems, chain of thought prompting also lifted performance on questions related to sports understanding, coin flip tracking, and last letter concatenation. In most cases, not many examples were need to saturate the performance gains (less than 8 or so).\n\nchain of thought example\nSource: Chain of Thought Prompting Elicits Reasoning in Large Language Models Jason Wei and Denny Zhou et al. (2022)\n\nTo learn more, read the full paper.\n\n\nOne advantage of the few-shot example-based approach relative to the Let's think step by step technique is that you can more easily specify the format, length, and style of reasoning that you want the model to perform before landing on its final answer. This can be particularly helpful in cases where the model isn't initially reasoning in the right way or depth.\n\n\n\nIn general, to eke out maximum performance on a task, you'll need to fine-tune a custom model. However, fine-tuning a model using explanations may take thousands of example explanations, which are costly to write.\n\nIn 2022, Eric Zelikman and Yuhuai Wu et al. published a clever procedure for using a few-shot prompt to generate a dataset of explanations that could be used to fine-tune a model. The idea is to use a few-shot prompt to generate candidate explanations, and only keep the explanations that produce the correct answer. Then, to get additional explanations for some of the incorrect answers, retry the few-shot prompt but with correct answers given as part of the question. The authors called their procedure STaR (Self-taught Reasoner):\n\nSTaR procedure\nSource: STaR: Bootstrapping Reasoning With Reasoning by Eric Zelikman and Yujuai Wu et al. (2022)\n\nWith this technique, you can combine the benefits of fine-tuning with the benefits of chain-of-thought prompting without needing to write thousands of example explanations.\n\n\nWhen the authors applied this technique to a Common Sense Q\u0026A dataset, they found that STaR outperformed both chain-of-thought prompting alone (73% \u003e 37%) and fine-tuning alone (73% \u003e 60%):\n\nSTaR results\nSource: STaR: Bootstrapping Reasoning With Reasoning by Eric Zelikman and Yujuai Wu et al. (2022)\n\nTo learn more, read the full paper.\n\n\nUsing a few-shot prompt to extend or modify a fine-tuning dataset is an idea that can be generalized beyond explanation writing. For example, if you have large quantities of unstructured text that you want to train on, you may find opportunities to use a prompt to extract a structured dataset from your unstructured text, and then fine-tune a custom model on that structured dataset.\n\n\nA number of extensions of chain-of-thought prompting have been published as well.\n\n\n\nPublished by Antonia Creswell et al., one extension of the chain-of-thought technique is to split the single prompt for generating explanations and answers into smaller parts. First, a prompt selects a relevant subset of facts from the text ('selection prompt'). Then, a second prompt infers a conclusion from the selected facts ('inference prompt'). These prompts are then alternated in a loop to generate multiple steps of reasoning and eventually land on a final answer. The authors illustrate the idea in the following figure:\n\nSelection-inference prompting\nSource: Selection-Inference: Exploiting Large Language Models for Interpretable Logical Reasoning by Antonia Creswell et al. (2022)\n\n\nWhen applied to a 7B-parameter model, the authors found that selection-inference prompting substantially improved performance relative to chain-of-thought prompting on the bAbi and Proof Writer benchmark tasks (both of which require longer sequences of reasoning steps). The best performance they achieved combined both selection-inference prompting with fine-tuning.\n\nSelection-inference prompting\nSource: Selection-Inference: Exploiting Large Language Models for Interpretable Logical Reasoning by Antonia Creswell et al. (2022)\n\n\nAlthough the gains on these benchmarks were large, these benchmarks were specifically chosen because they required longer sequences of reasoning. On problems that don't require reasoning with many steps, the gains are likely smaller.\n\nThe results highlight a couple of general lessons for working with large language models. One, splitting up complex tasks into smaller tasks is a great way to improve reliability and performance; the more atomic the task, the less room there is for the model to err. Two, getting maximum performance often means combining fine-tuning with whatever approach you've chosen.\n\nTo learn more, read the full paper.\n\n\nA few months after publishing the selection-inference prompting technique, the authors extended the technique in a follow-up paper, with ideas for:\n\nfiguring out when the selection-inference cycle should stop or continue\nadding a value function to help search over multiple reasoning paths\nreducing hallucination of fake facts by fine-tuning a model to reason about sentence labels (e.g., sen1) rather than writing out the sentences themselves\n\n\nIn the original selection-inference technique, specialized 'selection' and 'inference' prompts are alternated to select facts and make inferences from those facts, combining to generate a sequence of reasoning steps.\n\nThe authors extend this technique with two additional components.\n\nFirst, the authors add a 'halter' model that, after each inference step, is asked whether the inferences thus far are sufficient to answer the question. If yes, then the model generates a final answer.\n\nThe halter models brings a couple of advantages:\n\nit can tell the selection-inference process to stop or keep going, as necessary.\nif the process never halts, you'll get no answer, which is often preferable to a hallucinated guess\n\nFaithful reasoning\nSource: Faithful Reasoning Using Large Language Models by Antonia Creswell et al. (2022)\n\nFaithful reasoning\nSource: Faithful Reasoning Using Large Language Models by Antonia Creswell et al. (2022)\n\nSecond, the authors add a value function, which is used to assess the quality of reasoning steps and search over multiple reasoning trajectories. This echoes a common theme for increasing reliability; instead of generating a single answer from the model, generate a set of answers and then use some type of value function / discriminator / verifier model to pick the best one.\n\nFaithful reasoning\nSource: Faithful Reasoning Using Large Language Models by Antonia Creswell et al. (2022)\n\nIn addition to these two extensions, the authors also use a trick to reduce hallucination of fake facts. Rather than asking the model to write out factual sentences, they fine-tune a model to work with sentence labels (e.g., sen1) instead. This helps prevent the model from hallucinating fake facts not mentioned in the prompt context.\n\nFaithful reasoning\nSource: Faithful Reasoning Using Large Language Models by Antonia Creswell et al. (2022)\n\n\nThe authors evaluated their technique on two benchmarks: the ProofWriter task (not shown) and EntailmentBankQA (shown). The technique increased accuracy substantially, especially on harder reasoning problems.\n\nFaithful reasoning\nSource: Faithful Reasoning Using Large Language Models by Antonia Creswell et al. (2022)](https://arxiv.org/abs/2208.14271)\n\nIn addition, their sentence label manipulation trick essentially eliminated hallucination!\n\nFaithful reasoning\nSource: Faithful Reasoning Using Large Language Models by Antonia Creswell et al. (2022)](https://arxiv.org/abs/2208.14271)\n\n\nThis paper illustrates a number of helpful lessons for improving the reliability of large language models:\n\nSplit complex tasks into smaller, more reliable subtasks\nGenerate your answer in a step-by-step fashion, evaluating it along the way\nGenerate many possible answers and use another model or function to pick the ones that look best\nReduce hallucination by constraining what the model can say (e.g., by using sentence labels instead of sentences)\nMaximize performance of models by fine-tuning them on specialized tasks\n\nTo learn more, read the full paper.\n\n\nIn addition to doing poorly on long reasoning chains (where selection-inference shines), chain-of-thought prompting can especially struggle when the examples are short but the task is long.\n\n\nLeast-to-most prompting is another technique that splits up reasoning tasks into smaller, more reliable subtasks. The idea is to elicit a subtask from the model by prompting it with something like To solve {question}, we need to first solve: \". Then, with that subtask in hand, the model can generate a solution. The solution is appended to the original question and the process is repeated until a final answer is produced.\n\nLeast-to-most prompting\nSource: Least-to-most Prompting Enables Complex Reasoning in Large Language Models by Denny Zhou et al. (2022)\n\n\nWhen applied to benchmarks involving long reasoning chains using code-davinci-002 (which is optimized for code but can still understand text), the authors measured gains as large as 16% -\u003e 99.7%!\n\n\nLeast-to-most prompting results on last-letter-concatenation task\nLeast-to-most prompting results on SCAN\nLeast-to-most prompting results on DROP numerical reasoning\nSource: Least-to-most Prompting Enables Complex Reasoning in Large Language Models by Denny Zhou et al. (2022)\n\n\nAlthough the above gains from least-to-most prompting are impressive, they are measured on a very narrow set of tasks that require long reasoning chains.\n\nStill, they illustrate a common theme: increase reliability by (a) breaking complex tasks into smaller subtasks and (b) giving the model more time and space to work out the answer.\n\nTo learn more, read the full paper.\n\n\n\n\nIn contrast to the previous techniques, which try to maximize the likelihood of correct answers, another approach is to use GPT-3 to generate a tree of possible explanations (both correct and incorrect), and then analyze their relationships to guess at which set is correct. This technique was coined maieutic prompting by Jaehun Jung et al. in May 2022 (maieutic means relating to the Socratic method of asking questions to elicit ideas).\n\nThe method is complicated, and works as follows:\n\nFirst, build a maieutic tree, where each node is a statement that could be true or false:\n  Start with a multiple-choice question or true/false statement (e.g. War cannot have a tie)\n  For each possible answer to the question, use the model to generate a corresponding explanation (with a prompt like War cannot have a tie? True, because)\n  Then, prompt the model with the question and the generated explanation, and ask it to produce the answer. If reversing the explanation (with a prefix like It is wrong to say that {explanation}) reverses the answer, then the explanation is considered 'logically integral.'\n  If an explanation is not logically integral, then repeat the above process recursively, with each explanation turned into a True or False question, and generate more explanations for each new question.\n  After all of the recursive explaining is done, you end up with a tree of explanations, where each leaf on the tree has the property that reversing the explanation reverses the model's answer.\nSecond, convert the tree into a graph of relations:\n  For each node in the tree, calculate the model's relative belief in each node (inferred from the probability of getting an answer of True to given an explanation)\n  For each pair of nodes in the tree, use the model to identify whether they are entailed (implied) or contradicted\nThird, find the most consistent set of beliefs and take those to be true:\n  Specifically, using the strength of belief in each node and the logical relationships between them, formulate the problem as a weighted maximum satisfiability problem (MAX-SAT)\n  Use a solver to the find the most self-consistent set of beliefs, and take those as true\n\n\nMaieutic prompting\nMaieutic prompting\nSource: Maieutic Prompting: Logically Consistent Reasoning with Recursive Explanations by Jaehun Jung et al. (2022)\n\n\nMaieutic prompting results\nSource: Maieutic Prompting: Logically Consistent Reasoning with Recursive Explanations by Jaehun Jung et al. (2022)\n\n\nBeyond the complexity, one limitation of this method is that it appears to only apply to questions that can be posed as multiple-choice.\n\nTo learn more, read the full paper.\n\n\n\n\nFor tasks with a discrete set of answers, one simple way to improve reliability is to sample multiple explanations \u0026 answers from the model (using a positive temperature) and then pick the final answer that appears most often.\n\nSelf-consistency method\nSource: Self-Consistency Improves Chain of Thought Reasoning in Language Models by Xuezhi Wang et al. (2022)\n\n\nThis technique lifted accuracies by anywhere from 1 to 24 percentage points on a suite of math and reasoning benchmarks. (Plotted below are results from Google's LaMDA model; using Google's larger PaLM model, the baselines were higher but the gains were a bit smaller.)\n\nSelf-consistency results\nSource: Self-Consistency Improves Chain of Thought Reasoning in Language Models by Xuezhi Wang et al. (2022)\n\n\nAlthough this technique is simple to implement, it can be costly. Generating a set of 10 answers will increase your costs by 10x.\n\nAlso, as with many of these techniques, it applies only to tasks with a limited set of answers. For open-ended tasks where each answer is unique (such as writing a poem), it's not obvious what it would mean to pick the most common answer.\n\nLastly, this technique ought to be most beneficial when there are multiple paths or phrasings to reach an answer; if there's only one path, then the technique may not help at all. An extreme example: If the task was to generate a single token answer, then taking the most common token from 100 generations would be no different than taking the token with the highest logprobs (which you can get with a single generation at temperature=0).\n\n\nAnother key technique for improving task performance is to train a verifier or discriminator model to evaluate the outputs of the main generative model. If the discriminator rejects the output, then you can resample the generative model until you get an acceptable output. In many cases, it's easier to judge an answer than it is to create an answer, which helps explain the power of this method.\n\n\nIn 2021, OpenAI researchers applied this technique to grade school math problems, using the following procedure:\n\nFirst, they fine-tuned a model on questions and solutions\nFor each problem in the training set, they generated 100 solutions\nEach of those 100 solutions was automatically labeled as either correct or incorrect, based on whether the final answer was correct\nUsing those solutions, with some labeled correct and some labeled incorrect, they fine-tuned a verifier model to classify whether a question and candidate solution was correct or incorrect\nFinally, at test time, the generative model creates 100 solutions to each problem, and the one with the highest score according to the verifier model is picked as the final answer\n\nVerifier method\nSource: Training Verifiers to Solve Math Word Problems by Karl Cobbe et al. (2021)\n\n\nWith a 175B GPT-3 model and 8,000 training examples, this technique substantially lifted grade school math accuracy from 33% to 55%.\n\nVerifier results\nSource: Training Verifiers to Solve Math Word Problems by Karl Cobbe et al. (2021)\n\n\nSimilar to the self-consistency technique, this method can get expensive, as generating, say, 100 solutions per task will increase your costs by roughly ~100x.\n\n\nAlthough the techniques above vary in their approach, they all share the goal of improving reliability on complex tasks. Mainly they do this by:\n\ndecomposing unreliable operations into smaller, more reliable operations (e.g., selection-inference prompting)\nusing multiple steps or multiple relationships to make the system's reliability greater than any individual component (e.g., maieutic prompting)\n\n\nThis paradigm of trying to build a reliable system out of less reliable components is reminiscent of probabilistic programming, and many of the analysis techniques of that field can be applied to this one.\n\nIn the paper Language Model Cascades, David Dohan et al. interpret the above techniques in the paradigm of probabilistic graphical models:\n\n\ngraphical model of chain of thought prompting\nSource: Language Model Cascades by David Dohan et al. (2022)\n\n\ngraphical model of fine-tuned chain of thought prompting\nSource: Language Model Cascades by David Dohan et al. (2022)\n\n\ngraphical model of selection-inference prompting\nSource: Language Model Cascades by David Dohan et al. (2022)\n\n\ngraphical model of verifiers\nSource: Language Model Cascades by David Dohan et al. (2022)\n\n\nAlthough formulating these techniques as probabilistic graphical models may not be immediately useful for solving any particular problem, the framework may be helpful in selecting, combining, and discovering new techniques.\n\n\nResearch into large language models is very active and evolving rapidly. Not only do researchers continue to improve the models, they also continue to improve our understanding of how to best employ the models. To underscore the pace of these developments, note that all of the papers shared above were published within the past 12 months (as I write in Sep 2022).\n\nIn the future, expect better models and better techniques to be published. Even if the specific techniques here are eclipsed by future best practices, the general principles behind them will likely remain a key part of any expert user's toolkit.\n\n\n| Lesson                                                                                                                         | Paper                                                                                                                                     | Date     |\n| ------------------------------------------------------------------------------------------------------------------------------ | ----------------------------------------------------------------------------------------------------------------------------------------- | -------- |\n| Break complex tasks into simpler subtasks (and consider exposing the intermediate outputs to users)                            | AI Chains: Transparent and Controllable Human-AI Interaction by Chaining Large Language Model Prompts | 2021 Oct |\n| You can improve output by generating many candidates, and then picking the one that looks best                                 | Training Verifiers to Solve Math Word Problems                                                        | 2021 Oct |\n| On reasoning tasks, models do better when they reason step-by-step before answering                                            | Chain of Thought Prompting Elicits Reasoning in Large Language Models                                 | 2022 Jan |\n| You can improve step-by-step reasoning by generating many explanation-answer outputs, and picking the most popular answer      | Self-Consistency Improves Chain of Thought Reasoning in Language Models                               | 2022 Mar |\n| If you want to fine-tune a step-by-step reasoner, you can do it with multiple-choice question \u0026 answer data alone              | STaR: Bootstrapping Reasoning With Reasoning                                                          | 2022 Mar |\n| The step-by-step reasoning method works great even with zero examples                                                          | Large Language Models are Zero-Shot Reasoners                                                         | 2022 May |\n| You can do better than step-by-step reasoning by alternating a ‘selection’ prompt and an ‘inference’ prompt                    | Selection-Inference: Exploiting Large Language Models for Interpretable Logical Reasoning             | 2022 May |\n| On long reasoning problems, you can improve step-by-step reasoning by splitting the problem into pieces to solve incrementally | Least-to-most Prompting Enables Complex Reasoning in Large Language Models                            | 2022 May |\n| You can have the model analyze both good and bogus explanations to figure out which set of explanations are most consistent    | Maieutic Prompting: Logically Consistent Reasoning with Recursive Explanations                        | 2022 May |\n| You can think about these techniques in terms of probabilistic programming, where systems comprise unreliable components       | Language Model Cascades                                                                               | 2022 Jul |\n| You can eliminate hallucination with sentence label manipulation, and you can reduce wrong answers with a 'halter' prompt      | Faithful Reasoning Using Large Language Models                                                        | 2022 Aug |"])</script><script>self.__next_f.push([1,"ac:T1d4f,"])</script><script>self.__next_f.push([1,"Large language models are functions that map text to text. Given an input string of text, a large language model predicts the text that should come next.\n\nThe magic of large language models is that by being trained to minimize this prediction error over vast quantities of text, the models end up learning concepts useful for these predictions. For example, they learn:\n\nhow to spell\nhow grammar works\nhow to paraphrase\nhow to answer questions\nhow to hold a conversation\nhow to write in many languages\nhow to code\netc.\n\nThey do this by “reading” a large amount of existing text and learning how words tend to appear in context with other words, and uses what it has learned to predict the next most likely word that might appear in response to a user request, and each subsequent word after that.\n\nGPT-3 and GPT-4 power many software products, including productivity apps, education apps, games, and more.\n\n\nOf all the inputs to a large language model, by far the most influential is the text prompt.\n\nLarge language models can be prompted to produce output in a few ways:\n\nInstruction**: Tell the model what you want\nCompletion**: Induce the model to complete the beginning of what you want\nScenario**: Give the model a situation to play out\nDemonstration**: Show the model what you want, with either:\n  A few examples in the prompt\n  Many hundreds or thousands of examples in a fine-tuning training dataset\n\nAn example of each is shown below.\n\n\nWrite your instruction at the top of the prompt (or at the bottom, or both), and the model will do its best to follow the instruction and then stop. Instructions can be detailed, so don't be afraid to write a paragraph explicitly detailing the output you want, just stay aware of how many tokens the model can process.\n\nExample instruction prompt:\n\nExtract the name of the author from the quotation below.\n\n“Some humans theorize that intelligent species go extinct before they can expand into outer space. If they're correct, then the hush of the night sky is the silence of the graveyard.”\n― Ted Chiang, Exhalation\n\nOutput:\n\nTed Chiang\n\n\nCompletion-style prompts take advantage of how large language models try to write text they think is most likely to come next. To steer the model, try beginning a pattern or sentence that will be completed by the output you want to see. Relative to direct instructions, this mode of steering large language models can take more care and experimentation. In addition, the models won't necessarily know where to stop, so you will often need stop sequences or post-processing to cut off text generated beyond the desired output.\n\nExample completion prompt:\n\n“Some humans theorize that intelligent species go extinct before they can expand into outer space. If they're correct, then the hush of the night sky is the silence of the graveyard.”\n― Ted Chiang, Exhalation\n\nThe author of this quote is\n\nOutput:\n\n Ted Chiang\n\n\nGiving the model a scenario to follow or role to play out can be helpful for complex queries or when seeking imaginative responses. When using a hypothetical prompt, you set up a situation, problem, or story, and then ask the model to respond as if it were a character in that scenario or an expert on the topic.\n\nExample scenario prompt:\n\nYour role is to extract the name of the author from any given text\n\n“Some humans theorize that intelligent species go extinct before they can expand into outer space. If they're correct, then the hush of the night sky is the silence of the graveyard.”\n― Ted Chiang, Exhalation\n\nOutput:\n\n Ted Chiang\n\n\nSimilar to completion-style prompts, demonstrations can show the model what you want it to do. This approach is sometimes called few-shot learning, as the model learns from a few examples provided in the prompt.\n\nExample demonstration prompt:\n\nQuote:\n“When the reasoning mind is forced to confront the impossible again and again, it has no choice but to adapt.”\n― N.K. Jemisin, The Fifth Season\nAuthor: N.K. Jemisin\n\nQuote:\n“Some humans theorize that intelligent species go extinct before they can expand into outer space. If they're correct, then the hush of the night sky is the silence of the graveyard.”\n― Ted Chiang, Exhalation\nAuthor:\n\nOutput:\n\n Ted Chiang\n\n\nWith enough training examples, you can fine-tune a custom model. In this case, instructions become unnecessary, as the model can learn the task from the training data provided. However, it can be helpful to include separator sequences (e.g., -\u003e or ### or any string that doesn't commonly appear in your inputs) to tell the model when the prompt has ended and the output should begin. Without separator sequences, there is a risk that the model continues elaborating on the input text rather than starting on the answer you want to see.\n\nExample fine-tuned prompt (for a model that has been custom trained on similar prompt-completion pairs):\n\n“Some humans theorize that intelligent species go extinct before they can expand into outer space. If they're correct, then the hush of the night sky is the silence of the graveyard.”\n― Ted Chiang, Exhalation\n\n\n\n\nOutput:\n\n Ted Chiang\n\n\nLarge language models aren't only great at text - they can be great at code too. OpenAI's GPT-4 model is a prime example.\n\nGPT-4 powers numerous innovative products, including:\n\n[GitHub Copilot] (autocompletes code in Visual Studio and other IDEs)\nReplit (can complete, explain, edit and generate code)\nCursor (build software faster in an editor designed for pair-programming with AI)\n\nGPT-4 is more advanced than previous models like gpt-3.5-turbo-instruct. But, to get the best out of GPT-4 for coding tasks, it's still important to give clear and specific instructions. As a result, designing good prompts can take more care.\n\n\nFor more prompt examples, visit OpenAI Examples.\n\nIn general, the input prompt is the best lever for improving model outputs. You can try tricks like:\n\nBe more specific** E.g., if you want the output to be a comma separated list, ask it to return a comma separated list. If you want it to say \"I don't know\" when it doesn't know the answer, tell it 'Say \"I don't know\" if you do not know the answer.' The more specific your instructions, the better the model can respond.\nProvide Context**: Help the model understand the bigger picture of your request. This could be background information, examples/demonstrations of what you want or explaining the purpose of your task.\nAsk the model to answer as if it was an expert.** Explicitly asking the model to produce high quality output or output as if it was written by an expert can induce the model to give higher quality answers that it thinks an expert would write. Phrases like \"Explain in detail\" or \"Describe step-by-step\" can be effective.\nPrompt the model to write down the series of steps explaining its reasoning.** If understanding the 'why' behind an answer is important, prompt the model to include its reasoning. This can be done by simply adding a line like \"Let's think step by step\" before each answer.\n\n[Fine Tuning Docs]: https://platform.openai.com/docs/guides/fine-tuning\n[OpenAI Customer Stories]: https://openai.com/customer-stories\n[Large language models Blog Post]: https://openai.com/research/better-language-models\n[GitHub Copilot]: https://github.com/features/copilot/\n[GPT-4 and GPT-4 Turbo]: https://platform.openai.com/docs/models/gpt-4-and-gpt-4-turbo\n[GPT3 Apps Blog Post]: https://openai.com/blog/gpt-3-apps/\n[OpenAI Examples]: https://platform.openai.com/examples"])</script><script>self.__next_f.push([1,"ad:Tb6c,"])</script><script>self.__next_f.push([1,"The OpenAI API embeddings endpoint can be used to measure relatedness or similarity between pieces of text.\n\nBy leveraging GPT-3's understanding of text, these embeddings achieved state-of-the-art results on benchmarks in unsupervised learning and transfer learning settings.\n\nEmbeddings can be used for semantic search, recommendations, cluster analysis, near-duplicate detection, and more.\n\nFor more information, read OpenAI's blog post announcements:\n\nIntroducing Text and Code Embeddings (Jan 2022)\nNew and Improved Embedding Model (Dec 2022)\n\nFor comparison with other embedding models, see Massive Text Embedding Benchmark (MTEB) Leaderboard\n\n\nEmbeddings can be used for search either by themselves or as a feature in a larger system.\n\nThe simplest way to use embeddings for search is as follows:\n\nBefore the search (precompute):\n  Split your text corpus into chunks smaller than the token limit (8,191 tokens for text-embedding-3-small)\n  Embed each chunk of text\n  Store those embeddings in your own database or in a vector search provider like Pinecone, Weaviate or Qdrant\nAt the time of the search (live compute):\n  Embed the search query\n  Find the closest embeddings in your database\n  Return the top results\n\nAn example of how to use embeddings for search is shown in Semantic_text_search_using_embeddings.ipynb.\n\nIn more advanced search systems, the cosine similarity of embeddings can be used as one feature among many in ranking search results.\n\n\nThe best way to get reliably honest answers from GPT-3 is to give it source documents in which it can locate correct answers. Using the semantic search procedure above, you can cheaply search through a corpus of documents for relevant information and then give that information to GPT-3 via the prompt to answer a question. We demonstrate this in Question_answering_using_embeddings.ipynb.\n\n\nRecommendations are quite similar to search, except that instead of a free-form text query, the inputs are items in a set.\n\nAn example of how to use embeddings for recommendations is shown in Recommendation_using_embeddings.ipynb.\n\nSimilar to search, these cosine similarity scores can either be used on their own to rank items or as features in larger ranking algorithms.\n\n\nAlthough OpenAI's embedding model weights cannot be fine-tuned, you can nevertheless use training data to customize embeddings to your application.\n\nIn Customizing_embeddings.ipynb, we provide an example method for customizing your embeddings using training data. The idea of the method is to train a custom matrix to multiply embedding vectors by in order to get new customized embeddings. With good training data, this custom matrix will help emphasize the features relevant to your training labels. You can equivalently consider the matrix multiplication as (a) a modification of the embeddings or (b) a modification of the distance function used to measure the distances between embeddings."])</script><script>self.__next_f.push([1,"ae:T1da1,"])</script><script>self.__next_f.push([1,"Elato Logo\n\n\nThis guide shows how to build a AI voice agent device with Realtime AI Speech powered by OpenAI Realtime API, ESP32, Secure WebSockets, and Deno Edge Functions for \u003e10-minute uninterrupted global conversations.\n\nAn active version of this README is available at ElatoAI.\n\n\nThe reference implementation uses an ESP32-S3 microcontroller with minimal additional components:\n\n\n\nRequired Components:\nESP32-S3 development board\nI2S microphone (e.g., INMP441)\nI2S amplifier and speaker (e.g., MAX98357A)\nPush button to start/stop the conversation\nRGB LED for visual feedback\nOptional: touch sensor for alternative control\n\nHardware options:\nA fully assembled PCB and device is available in the ElatoAI store.\n\n\nControl your ESP32 AI device from your phone with your own webapp.\n\n\n\n| Select from a list of AI characters | Talk to your AI with real-time responses | Create personalized AI characters |\n|:--:|:--:|:--:|\n\n\nClone the repository\n\nHead over to the ElatoAI GitHub repository and clone the repository.\n\ngit clone https://github.com/akdeb/ElatoAI.git\ncd ElatoAI\n\nSet your environment variables (OPENAI_API_KEY, SUPABASE_ANON_KEY)\n\nIn the frontend-nextjs directory, create a .env.local file and set your environment variables.\n\ncd frontend-nextjs\ncp .env.example .env.local\n\n\nIn the server-deno directory, create a .env file and set your environment variables.\n\ncd server-deno\ncp .env.example .env\n\n\nStart Supabase\n\nInstall Supabase CLI and set up your Local Supabase Backend. From the root directory, run:\nbrew install supabase/tap/supabase\nsupabase start # Starts your local Supabase server with the default migrations and seed data.\n\nSet up your NextJS Frontend\n\n(See the Frontend README)\n\nFrom the frontend-nextjs directory, run the following commands. (Login creds: Email: admin@elatoai.com, Password: admin)\ncd frontend-nextjs\nnpm install\n\nnpm run dev\n\nStart the Deno server\n\n(See the Deno server README)\ncd server-deno\n\ndeno run -A --env-file=.env main.ts\n\nSetup the ESP32 Device firmware\n\n(See the ESP32 Device README)\n\nIn Config.cpp set ws_server and backend_server to your local IP address. Run ifconfig in your console and find en0 -\u003e inet -\u003e 192.168.1.100 (it may be different for your Wifi network). This tells the ESP32 device to connect to your NextJS frontend and Deno server running on your local machine. All services should be on the same Wifi network.\n\nSetup the ESP32 Device Wifi\n\nBuild and upload the firmware to your ESP32 device. The ESP32 should open an ELATO-DEVICE captive portal to connect to Wifi. Connect to it and go to http://192.168.4.1 to configure the device wifi.\n\nOnce your Wifi credentials are configured, turn the device OFF and ON again and it should connect to your Wifi and your server.\n\nNow you can talk to your AI Character!\n\n\nRegister your device by adding your ESP32 Device's MAC Address and a unique user code to the devices table in Supabase.\nPro Tip: To find your ESP32-S3 Device's MAC Address, build and upload test/print_mac_address_test.cpp using PlatformIO and view the serial monitor.\n\n\nOn your frontend client in the Settings page, add the unique user code so that the device is linked to your account in Supabase.\n\n\nIf you're testing locally, you can keep enabled the DEV_MODE macro in firmware-arduino/Config.h and the Deno server env variable to use your local IP addresses for testing.\n\n\nNow you can register multiple devices to your account by repeating the process above.\n\n\nElatoAI consists of three main components:\n\nFrontend Client (Next.js hosted on Vercel) - to create and talk to your AI agents and 'send' it to your ESP32 device\nEdge Server Functions (Deno running on Deno/Supabase Edge) - to handle the websocket connections from the ESP32 device and the OpenAI API calls\nESP32 IoT Client (PlatformIO/Arduino) - to receive the websocket connections from the Edge Server Functions and send audio to the OpenAI API via the Deno edge server.\n\n\n\nRealtime Speech-to-Speech: Instant speech conversion powered by OpenAI's Realtime APIs.\nCreate Custom AI Agents: Create custom agents with different personalities and voices.\nCustomizable Voices: Choose from a variety of voices and personalities.\nSecure WebSockets: Reliable, encrypted WebSocket communication.\nServer VAD Turn Detection: Intelligent conversation flow handling for smooth interactions.\nOpus Audio Compression: High-quality audio streaming with minimal bandwidth.\nGlobal Edge Performance: Low latency Deno Edge Functions ensuring seamless global conversations.\nESP32 Arduino Framework: Optimized and easy-to-use hardware integration.\nConversation History: View your conversation history.\nDevice Management and Authentication: Register and manage your devices.\nUser Authentication: Secure user authentication and authorization.\nConversations with WebRTC and Websockets: Talk to your AI with WebRTC on the NextJS webapp and with websockets on the ESP32.\nVolume Control: Control the volume of the ESP32 speaker from the NextJS webapp.\nRealtime Transcripts: The realtime transcripts of your conversations are stored in the Supabase DB.\nOTA Updates: Over the Air Updates for the ESP32 firmware.\nWifi Management with captive portal: Connect to your Wifi network from the ESP32 device.\nFactory Reset: Factory reset the ESP32 device from the NextJS webapp.\nButton and Touch Support: Use the button OR touch sensor to control the ESP32 device.\nNo PSRAM Required: The ESP32 device does not require PSRAM to run the speech to speech AI.\nOAuth for Web client: OAuth for your users to manage their AI characters and devices.\n\n\n| Component       | Technology Used                          |\n|-----------------|------------------------------------------|\n| Frontend        | Next.js, Vercel            |\n| Backend         | Supabase DB  |\n| Edge Functions  | Edge Functions on Deno / Supabase Edge Runtime         |\n| IoT Client      | PlatformIO, Arduino Framework, ESP32-S3  |\n| Audio Codec     | Opus                                     |\n| Communication   | Secure WebSockets                        |\n| Libraries       | ArduinoJson, WebSockets, AsyncWebServer, ESP32_Button, Arduino Audio Tools, ArduinoLibOpus        |\n\n\nWe have a Usecases.md file that outlines the core use cases for the Elato AI device or any other custom conversational AI device.\n\n\n\n\n\n\n\n\n[env:esp32-s3-devkitc-1]\nplatform = espressif32 @ 6.10.0\nboard = esp32-s3-devkitc-1\nframework = arduino\nmonitor_speed = 115200\n\nlib_deps =\n    bblanchon/ArduinoJson@^7.1.0\n    links2004/WebSockets@^2.4.1\n    ESP32Async/ESPAsyncWebServer@^3.7.6\n    https://github.com/esp-arduino-libs/ESP32_Button.git#v0.0.1\n    https://github.com/pschatzmann/arduino-audio-tools.git#v1.0.1\n    https://github.com/pschatzmann/arduino-libopus.git#a1.1.0\n\n\n⚡️ Latency: \u003c2s round-trip globally\n🎧 Audio Quality: Opus codec at bitrate 12kbps (high clarity)\n⏳ Uninterrupted Conversations: Up to 10 minutes continuous conversations\n🌎 Global Availability: Optimized with edge computing with Deno\n\n\nSecure WebSockets (WSS) for encrypted data transfers\nOptional: API Key encryption with 256-bit AES\nSupabase DB for secure authentication\nSupabase RLS for all tables\n\n3-4s Cold start time while connecting to edge server\nLimited to upto 10 minutes of uninterrupted conversations\nEdge server stops when wall clock time is exceeded\nNo speech interruption detection on ESP32\n\n\nThis project is licensed under the MIT License - see the LICENSE file for details.\n\nThis example is part of the OpenAI Cookbook. For the full project and latest updates, check out ElatoAI and consider giving it a ⭐️ if you find it useful!"])</script><script>self.__next_f.push([1,"af:T1aed,"])</script><script>self.__next_f.push([1,"People are writing great tools and papers for improving outputs from GPT. Here are some cool ones we've seen:\n\n\nArthur Shield: A paid product for detecting toxicity, hallucination, prompt injection, etc.\nBaserun: A paid product for testing, debugging, and monitoring LLM-based apps\nChainlit: A Python library for making chatbot interfaces.\nElatoAI: A platform for running OpenAI Realtime API Speech on ESP32 on Arduino using Deno Edge Runtime and Supabase.\nEmbedchain: A Python library for managing and syncing unstructured data with LLMs.\nFLAML (A Fast Library for Automated Machine Learning \u0026 Tuning): A Python library for automating selection of models, hyperparameters, and other tunable choices.\nGuidance: A handy looking Python library from Microsoft that uses Handlebars templating to interleave generation, prompting, and logical control.\nHaystack: Open-source LLM orchestration framework to build customizable, production-ready LLM applications in Python.\nHoneyHive: An enterprise platform to evaluate, debug, and monitor LLM apps.\nLangChain: A popular Python/JavaScript library for chaining sequences of language model prompts.\nLiteLLM: A minimal Python library for calling LLM APIs with a consistent format.\nLlamaIndex: A Python library for augmenting LLM apps with data.\nLLMOps Database: Database of how companies actually deploy LLMs in production.\nLMQL: A programming language for LLM interaction with support for typed prompting, control flow, constraints, and tools.\nOpenAI Evals: An open-source library for evaluating task performance of language models and prompts.\nOutlines: A Python library that provides a domain-specific language to simplify prompting and constrain generation.\nParea AI: A platform for debugging, testing, and monitoring LLM apps.\nPortkey: A platform for observability, model management, evals, and security for LLM apps.\nPromptify: A small Python library for using language models to perform NLP tasks.\nPromptPerfect: A paid product for testing and improving prompts.\nPrompttools: Open-source Python tools for testing and evaluating models, vector DBs, and prompts.\nScale Spellbook: A paid product for building, comparing, and shipping language model apps.\nSemantic Kernel: A Python/C#/Java library from Microsoft that supports prompt templating, function chaining, vectorized memory, and intelligent planning.\nVellum: A paid AI product development platform to experiment with, evaluate, and deploy advanced LLM apps.\nWeights \u0026 Biases: A paid product for tracking model training and prompt engineering experiments.\nYiVal: An open-source GenAI-Ops tool for tuning and evaluating prompts, retrieval configurations, and model parameters using customizable datasets, evaluation methods, and evolution strategies.\n\n\nBrex's Prompt Engineering Guide: Brex's introduction to language models and prompt engineering.\nlearnprompting.org: An introductory course to prompt engineering.\nLil'Log Prompt Engineering: An OpenAI researcher's review of the prompt engineering literature (as of March 2023).\nOpenAI Cookbook: Techniques to improve reliability: A slightly dated (Sep 2022) review of techniques for prompting language models.\npromptingguide.ai: A prompt engineering guide that demonstrates many techniques.\nXavi Amatriain's Prompt Engineering 101 Introduction to Prompt Engineering and 202 Advanced Prompt Engineering: A basic but opinionated introduction to prompt engineering and a follow up collection with many advanced methods starting with CoT.\n\n\nAndrew Ng's DeepLearning.AI: A short course on prompt engineering for developers.\nAndrej Karpathy's Let's build GPT: A detailed dive into the machine learning underlying GPT.\nPrompt Engineering by DAIR.AI: A one-hour video on various prompt engineering techniques.\nScrimba course about Assistants API: A 30-minute interactive course about the Assistants API.\nLinkedIn course: Introduction to Prompt Engineering: How to talk to the AIs: Short video introduction to prompt engineering\n\n\nChain-of-Thought Prompting Elicits Reasoning in Large Language Models (2022): Using few-shot prompts to ask models to think step by step improves their reasoning. PaLM's score on math word problems (GSM8K) rises from 18% to 57%.\nSelf-Consistency Improves Chain of Thought Reasoning in Language Models (2022): Taking votes from multiple outputs improves accuracy even more. Voting across 40 outputs raises PaLM's score on math word problems further, from 57% to 74%, and code-davinci-002's from 60% to 78%.\nTree of Thoughts: Deliberate Problem Solving with Large Language Models (2023): Searching over trees of step by step reasoning helps even more than voting over chains of thought. It lifts GPT-4's scores on creative writing and crosswords.\nLanguage Models are Zero-Shot Reasoners (2022): Telling instruction-following models to think step by step improves their reasoning. It lifts text-davinci-002's score on math word problems (GSM8K) from 13% to 41%.\nLarge Language Models Are Human-Level Prompt Engineers (2023): Automated searching over possible prompts found a prompt that lifts scores on math word problems (GSM8K) to 43%, 2 percentage points above the human-written prompt in Language Models are Zero-Shot Reasoners.\nReprompting: Automated Chain-of-Thought Prompt Inference Through Gibbs Sampling (2023): Automated searching over possible chain-of-thought prompts improved ChatGPT's scores on a few benchmarks by 0–20 percentage points.\nFaithful Reasoning Using Large Language Models (2022): Reasoning can be improved by a system that combines: chains of thought generated by alternative selection and inference prompts, a halter model that chooses when to halt selection-inference loops, a value function to search over multiple reasoning paths, and sentence labels that help avoid hallucination.\nSTaR: Bootstrapping Reasoning With Reasoning (2022): Chain of thought reasoning can be baked into models via fine-tuning. For tasks with an answer key, example chains of thoughts can be generated by language models.\nReAct: Synergizing Reasoning and Acting in Language Models (2023): For tasks with tools or an environment, chain of thought works better if you prescriptively alternate between Reasoning steps (thinking about what to do) and Acting (getting information from a tool or environment).\nReflexion: an autonomous agent with dynamic memory and self-reflection (2023): Retrying tasks with memory of prior failures improves subsequent performance.\nDemonstrate-Search-Predict: Composing retrieval and language models for knowledge-intensive NLP (2023): Models augmented with knowledge via a \"retrieve-then-read\" can be improved with multi-hop chains of searches.\nImproving Factuality and Reasoning in Language Models through Multiagent Debate (2023): Generating debates between a few ChatGPT agents over a few rounds improves scores on various benchmarks. Math word problem scores rise from 77% to 85%."])</script><script>self.__next_f.push([1,"b0:T3b8e,"])</script><script>self.__next_f.push([1,"The aim of this notebook is to walk through a comprehensive example of how to fine-tune OpenAI models for Retrieval Augmented Generation (RAG).\n\nWe will also be integrating Qdrant and Few-Shot Learning to boost the model's performance and reduce hallucinations. This could serve as a practical guide for ML practitioners, data scientists, and AI Engineers interested in leveraging the power of OpenAI models for specific use-cases. 🤩\n\nNote: This notebook uses the gpt-3.5-turbo model. Fine-tuning on the SQuAD dataset with this setup yields only minimal gains for more advanced models such as gpt-4o or gpt-4.1. As such, this notebook is primarily intended as a guide for fine-tuning workflows and retrieval-augmented generation (RAG) practices\n\n\nYou want to learn how to\nFine-tune OpenAI models for specific use-cases\nUse Qdrant to improve the performance of your RAG model\nUse fine-tuning to improve the correctness of your RAG model and reduce hallucinations\n\nTo begin, we've selected a dataset where we've a guarantee that the retrieval is perfect. We've selected a subset of the SQuAD dataset, which is a collection of questions and answers about Wikipedia articles. We've also included samples where the answer is not present in the context, to demonstrate how RAG handles this case.\n\nSetting up the Environment\n\nData Preparation: SQuADv2 Dataset\nAnswering using Base gpt-3.5-turbo-0613 model\nFine-tuning and Answering using Fine-tuned model\nEvaluation: How well does the model perform?\n\n\nUsing Qdrant to Improve RAG Prompt\nFine-Tuning OpenAI Model with Qdrant\nEvaluation\n\nConclusion\n    Aggregate Results\n    Observations\n\nRetrieval Augmented Generation (RAG)?\nThe phrase Retrieval Augmented Generation (RAG) comes from a recent paper by Lewis et al. from Facebook AI. The idea is to use a pre-trained language model (LM) to generate text, but to use a separate retrieval system to find relevant documents to condition the LM on.\n\nWhat is Qdrant?\nQdrant is an open-source vector search engine that allows you to search for similar vectors in a large dataset. It is built in Rust and here we'll use the Python client to interact with it. This is the Retrieval part of RAG.\n\nWhat is Few-Shot Learning?\nFew-shot learning is a type of machine learning where the model is \"improved\" via training or fine-tuning on a small amount of data. In this case, we'll use it to fine-tune the RAG model on a small number of examples from the SQuAD dataset. This is the Augmented part of RAG.\n\nWhat is Zero-Shot Learning?\nZero-shot learning is a type of machine learning where the model is \"improved\" via training or fine-tuning without any dataset specific information.\n\nWhat is Fine-Tuning?\nFine-tuning is a type of machine learning where the model is \"improved\" via training or fine-tuning on a small amount of data. In this case, we'll use it to fine-tune the RAG model on a small number of examples from the SQuAD dataset. The LLM is what makes the Generation part of RAG.\n\nGet your OpenAI keys here and Qdrant keys after making a free cluster here.\n\n\nFor the purpose of demonstration, we'll make small slices from the train and validation splits of the SQuADv2 dataset. This dataset has questions and contexts where the answer is not present in the context, to help us evaluate how LLM handles this case.\n\nWe'll read the data from the JSON files and create a dataframe with the following columns: question, context, answer, is_impossible.\n\n\n\nLet's start by using the base gpt-3.5-turbo-0613 model to answer the questions. This prompt is a simple concatenation of the question and context, with a separator token in between: \\n\\n. We've a simple instruction part of the prompt:\nAnswer the following Question based on the Context only. Only answer from the Context. If you don't know the answer, say 'I don't know'.\n\nOther prompts are possible, but this is a good starting point. We'll use this prompt to answer the questions in the validation set.\n\nNext, you'll need some re-usable functions which make an OpenAI API Call and return the answer. You'll use the ChatCompletion.create endpoint of the API, which takes a prompt and returns the completed text.\n⏰ Time to run: ~3 min, 🛜 Needs Internet Connection\n\nFor the complete fine-tuning process, please refer to the OpenAI Fine-Tuning Docs.\n\n\nWe need to prepare the data for fine-tuning. We'll use a few samples from train split of same dataset as before, but we'll add the answer to the context. This will help the model learn to retrieve the answer from the context.\n\nOur instruction prompt is the same as before, and so is the system prompt.\nTip: 💡 Verify the Fine-Tuning Data\n\nYou can see this cookbook for more details on how to prepare the data for fine-tuning.\n\n\nIf you're new to OpenAI Model Fine-Tuning, please refer to the How to finetune Chat models notebook. You can also refer to the OpenAI Fine-Tuning Docs for more details.\n⏰ Time to run: ~10-20 minutes, 🛜 Needs Internet Connection\n\nLet's try out the fine-tuned model on the same validation set as before. You'll use the same prompt as before, but you will use the fine-tuned model instead of the base model. Before you do that, you can make a simple call to get a sense of how the fine-tuned model is doing.\n\nThis is the same as before, but you'll use the fine-tuned model instead of the base model.\n\n⏰ Time to run: ~5 min, 🛜 Needs Internet Connection\n\nTo evaluate the model's performance, compare the predicted answer to the actual answers -- if any of the actual answers are present in the predicted answer, then it's a match. We've also created error categories to help you understand where the model is struggling.\n\nWhen we know that a correct answer exists in the context, we can measure the model's performance, there are 3 possible outcomes:\n\n✅ Answered Correctly: The model responded the correct answer. It may have also included other answers that were not in the context.\n❎ Skipped: The model responded with \"I don't know\" (IDK) while the answer was present in the context. It's better than giving the wrong answer. It's better for the model say \"I don't know\" than giving the wrong answer. In our design, we know that a true answer exists and hence we're able to measure it -- this is not always the case. This is a model error. We exclude this from the overall error rate.\n❌ Wrong: The model responded with an incorrect answer. This is a model ERROR.\n\nWhen we know that a correct answer does not exist in the context, we can measure the model's performance, there are 2 possible outcomes:\n\n❌ Hallucination: The model responded with an answer, when \"I don't know\" was expected. This is a model ERROR.\n✅ I don't know: The model responded with \"I don't know\" (IDK) and the answer was not present in the context. This is a model WIN.\nNotice that the fine-tuned model skips questions more often -- and makes fewer mistakes. This is because the fine-tuned model is more conservative and skips questions when it's not sure.\nNotice that the fine-tuned model has learnt to say \"I don't know\" a lot better than the prompt. Or, the model has gotten good at skipping questions.\n\n\nThe fine-tuned model is better at saying \"I don't know\"\nHallucinations drop from 100% to 15% with fine-tuning\nWrong answers drop from 17% to 6% with fine-tuning\n\nCorrect answers also drop from 83% to 60% with fine-tuning - this is because the fine-tuned model is more conservative and says \"I don't know\" more often. This is a good thing because it's better to say \"I don't know\" than to give a wrong answer.\n\nThat said, we want to improve the correctness of the model, even if that increases the hallucinations. We're looking for a model that is both correct and conservative, striking a balance between the two. We'll use Qdrant and Few-Shot Learning to achieve this.\n💪 You're 2/3rds of the way there! Keep reading!\n\n\nWe'll select a few examples from the dataset, including cases where the answer is not present in the context. We'll then use these examples to create a prompt that we can use to fine-tune the model. We'll then measure the performance of the fine-tuned model.\n\nWhat is next?\n\nFine-Tuning OpenAI Model with Qdrant\n    6.1 Embed the Fine-Tuning Data\n    6.2 Embedding the Questions\nUsing Qdrant to Improve RAG Prompt\nEvaluation\n\n\n\nSo far, we've been using the OpenAI model to answer questions without using examples of the answer. The previous step made it work better on in-context examples, while this one helps it generalize to unseen data, and attempt to learn when to say \"I don't know\" and when to give an answer.\n\nThis is where few-shot learning comes in!\n\nFew-shot learning is a type of transfer learning that allows us to answer questions where the answer is not present in the context. We can do this by providing a few examples of the answer we're looking for, and the model will learn to answer questions where the answer is not present in the context.\n\nEmbeddings are a way to represent sentences as an array of floats. We'll use the embeddings to find the most similar questions to the ones we're looking for.\nNow that we've the Qdrant imports in place,\n\nNext, you'll embed the entire training set questions. You'll use the question to question similarity to find the most similar questions to the question we're looking for. This is a workflow which is used in RAG to leverage the OpenAI model ability of incontext learning with more examples. This is what we call Few Shot Learning here.\n\n❗️⏰ Important Note: This step can take up to 3 hours to complete. Please be patient. If you see Out of Memory errors or Kernel Crashes, please reduce the batch size to 32, restart the kernel and run the notebook again. This code needs to be run only ONCE.\n\n\nInitialization: batch_size = 512 and total_batches set the stage for how many questions will be processed in one go. This is to prevent memory issues. If your machine can handle more, feel free to increase the batch size. If your kernel crashes, reduce the batch size to 32 and try again.\nProgress Bar: tqdm gives you a nice progress bar so you don't fall asleep.\nBatch Loop: The for-loop iterates through batches. start_idx and end_idx define the slice of the DataFrame to process.\nGenerate Embeddings: batch_embeddings = embedding_model.embed(batch, batch_size=batch_size) - This is where the magic happens. Your questions get turned into embeddings.\nPointStruct Generation: Using .progress_apply, it turns each row into a PointStruct object. This includes an ID, the embedding vector, and other metadata.\n\nReturns the list of PointStruct objects, which can be used to create a collection in Qdrant.\n\nNote that configuring Qdrant is outside the scope of this notebook. Please refer to the Qdrant for more information. We used a timeout of 600 seconds for the upload, and grpc compression to speed up the upload.\n\nNow that we've uploaded the embeddings to Qdrant, we can use Qdrant to find the most similar questions to the question we're looking for. We'll use the top 5 most similar questions to create a prompt that we can use to fine-tune the model. We'll then measure the performance of the fine-tuned model on the same validation set, but with few shot prompting!\n\nOur main function get_few_shot_prompt serves as the workhorse for generating prompts for few-shot learning. It does this by retrieving similar questions from Qdrant - a vector search engine, using an embeddings model. Here is the high-level workflow:\n\nRetrieve similar questions from Qdrant where the answer is present in the context\nRetrieve similar questions from Qdrant where the answer is IMPOSSIBLE i.e. the expected answer is \"I don't know\" to find in the context\nCreate a prompt using the retrieved questions\nFine-tune the model using the prompt\nEvaluate the fine-tuned model on the validation set with the same prompting technique\n\n\n⏰ Time to run: ~15-30 minutes\n⏰ Time to run: 5-15 min\n\nBut how well does the model perform? Let's compare the results from the 3 different models we've looked at so far:\nThis is quite amazing -- we're able to get the best of both worlds! We're able to get the model to be both correct and conservative:\n\nThe model is correct 83% of the time -- this is the same as the base model\nThe model gives the wrong answer only 8% of the time -- down from 17% with the base model\nNext, let's look at the hallucinations. We want to reduce the hallucinations, but not at the cost of correctness. We want to strike a balance between the two. We've struck a good balance here:\n\nThe model hallucinates 53% of the time -- down from 100% with the base model\nThe model says \"I don't know\" 47% of the time -- up from NEVER with the base model\nFew Shot Fine-Tuning with Qdrant is a great way to control and steer the performance of your RAG system. Here, we made the model less conservative compared to zero shot and more confident by using Qdrant to find similar questions.\n\nYou can also use Qdrant to make the model more conservative. We did this by giving examples of questions where the answer is not present in the context.\nThis is biasing the model to say \"I don't know\" more often.\n\nSimilarly, one can also use Qdrant to make the model more confident by giving examples of questions where the answer is present in the context. This biases the model to give an answer more often. The trade-off is that the model will also hallucinate more often.\n\nYou can make this trade off by adjusting the training data: distribution of questions and examples, as well as the kind and number of examples you retrieve from Qdrant.\n\n\nIn this notebook, we've demonstrated how to fine-tune OpenAI models for specific use-cases. We've also demonstrated how to use Qdrant and Few-Shot Learning to improve the performance of the model.\n\n\nSo far, we've looked at the results for each scenario separately, i.e. each scenario summed to 100. Let's look at the results as an aggregate to get a broader sense of how the model is performing:\n\n| Category | Base | Fine-Tuned | Fine-Tuned with Qdrant |\n| --- | --- | --- | --- |\n| Correct | 44% | 32% | 44% |\n| Skipped | 0% | 18% | 5% |\n| Wrong | 9% | 3% | 4% |\n| Hallucination | 47% | 7% | 25% |\n| I don't know | 0% | 40% | 22% |\n\nThe few shot fine-tuned with Qdrant model is as good as the base model at answering questions where the answer is present in the context.\nThe few shot fine-tuned with Qdrant model is better at saying \"I don't know\" when the answer is not present in the context.\nThe few shot fine-tuned with Qdrant model is better at reducing hallucinations.\n\n\nThe few shot fine-tuned with Qdrant model gets more correct answers than the fine-tuned model: 83% of the questions are answered correctly vs 60% for the fine-tuned model\nThe few shot fine-tuned with Qdrant model is better at deciding when to say \"I don't know\" when the answer is not present in the context. 34% skip rate for the plain fine-tuning mode, vs 9% for the few shot fine-tuned with Qdrant model\n\n\nNow, you should be able to:\n\nNotice the trade-offs between number of correct answers and hallucinations -- and how training dataset choice influences that!\nFine-tune OpenAI models for specific use-cases and use Qdrant to improve the performance of your RAG model\nGet started on how to evaluate the performance of your RAG model"])</script><script>self.__next_f.push([1,"b1:T7fb,This code demonstrates how to interact with ChatGPT functions to perform tasks related to Amazon S3 buckets. The notebook covers S3 bucket key functionalities such as running simple listing commands, searching for a specific file in all buckets, uploading a file to a bucket, and downloading a file from a bucket. The OpenAI Chat API understands the user instructions, generates the natural language responses, and extracts appropriate function calls based on the user's input.\n\nRequirements:\nTo run the notebook generate AWS access key with S3 bucket writing permission and store them in a local environment file alongside the Openai key. The \".env\" file format:\nAWS_ACCESS_KEY_ID=\nAWS_SECRET_ACCESS_KEY=\nOPENAI_API_KEY=\nTo connect user questions or commands to the appropriate function, we need to provide ChatGPT with the necessary function details and expected parameters.\nCreate helper functions to interact with the S3 service, such as listing buckets, listing objects, downloading and uploading files, and searching for specific files.\nThe below dictionary connects the name with the function to use it for execution based on ChatGPT responses.\nCreate a main function for the chatbot, which takes user input, sends it to the OpenAI Chat API, receives a response, executes any function calls generated by the API, and returns a final response to the user.\nIn the following examples, make sure to replace the placeholders such as `, , and ` with your specific values before execution.\nLet's start by listing all the available buckets.\nYou can ask the assistant to search for a specific file name either in all the buckets or in a specific one.\nThe model is expected to clarify the ask from the user in case of ambiguity in the parameters values as described in the system message.\n\nWe also instructed the model to reject irrelevant tasks. Let's test it out and see how it works in action.\nThe provided functions are not limited to just retrieving information. They can also assist the user in uploading or downloading files.\nUpload a f"])</script><script>self.__next_f.push([1,"ileb2:T8a0,"])</script><script>self.__next_f.push([1,"Neon is Serverless Postgres built for the cloud. Neon separates compute and storage to offer modern developer features such as autoscaling, database branching, scale-to-zero, and more.\n\n\nNeon supports vector search using the pgvector open-source PostgreSQL extension, which enables Postgres as a vector database for storing and querying embeddings.\n\n\nCheck out the notebook in this repo for working with Neon Serverless Postgres as your vector database.\n\n\nIn this notebook you will learn how to:\n\nUse embeddings created by OpenAI API\nStore embeddings in a Neon Serverless Postgres database\nConvert a raw text query to an embedding with OpenAI API\nUse Neon with the pgvector extension to perform vector similarity search\n\n\nNeon enables you to scale your AI applications with the following features:\n\nAutoscaling: If your AI application experiences heavy load during certain hours of the day or at different times, Neon can automatically scale compute resources without manual intervention. During periods of inactivity, Neon is able to scale to zero.\nInstant read replicas: Neon supports instant read replicas, which are independent read-only compute instances designed to perform read operations on the same data as your read-write computes. With read replicas, you can offload reads from your read-write compute instance to a dedicated read-only compute instance for your AI application.\nThe Neon serverless driver: Neon supports a low-latency serverless PostgreSQL driver for JavaScript and TypeScript applications that allows you to query data from serverless and edge environments, making it possible to achieve sub-10ms queries.\n\n\nBuild an AI-powered semantic search application - Submit a startup idea and get a list of similar ideas that YCombinator has invested in before\nBuild an AI-powered chatbot - A Postgres Q\u0026A chatbot that uses Postgres as a vector database\nVercel Postgres pgvector Starter - Vector similarity search with Vercel Postgres (powered by Neon)\n\n\nBuilding AI applications with Neon\nNeon AI \u0026 embeddings documentation\nBuilding an AI-powered Chatbot using Vercel, OpenAI, and Postgres\nWeb-based AI SQL Playground and connecting to Postgres from the browser\npgvector GitHub repository"])</script><script>self.__next_f.push([1,"b3:Tc9a,"])</script><script>self.__next_f.push([1,"This notebook guides you through using Neon Serverless Postgres as a vector database for OpenAI embeddings. It demonstrates how to:\n\nUse embeddings created by OpenAI API.\nStore embeddings in a Neon Serverless Postgres database.\nConvert a raw text query to an embedding with OpenAI API.\nUse Neon with the pgvector extension to perform vector similarity search.\n\nBefore you begin, ensure that you have the following:\n\nA Neon Postgres database. You can create an account and set up a project with a ready-to-use neondb database in a few simple steps. For instructions, see Sign up and Create your first project.\nA connection string for your Neon database. You can copy it from the Connection Details widget on the Neon Dashboard. See Connect from any application.\nThe pgvector extension. Install the extension in Neon by running CREATE EXTENSION vector;. For instructions, see Enable the pgvector extension.\nYour OpenAI API key.\nPython and pip.\n\nThis notebook requires the openai, psycopg2, pandas, wget, and python-dotenv packages. You can install them with pip:\n\n\nAn OpenAI API key is required to generate vectors for documents and queries.\n\nIf you do not have an OpenAI API key, obtain one from https://platform.openai.com/account/api-keys.\n\nAdd the OpenAI API key as an operating system environment variable or provide it for the session when prompted. If you define an environment variable, name the variable OPENAI_API_KEY.\n\nFor information about configuring your OpenAI API key as an environment variable, refer to Best Practices for API Key Safety.\n\nProvide your Neon database connection string below or define it in an .env file using a DATABASE_URL variable. For information about obtaining a Neon connection string, see Connect from any application.\nTest the connection to your database:\nThis guide uses pre-computed Wikipedia article embeddings available in the OpenAI Cookbook examples directory so that you do not have to compute embeddings with your own OpenAI credits.\n\nImport the pre-computed embeddings zip file:\nExtract the downloaded zip file:\n\nThe vector table created in your database is called articles. Each object has title and content vectors.\n\nAn index is defined on both the title and content vector columns.\n\nLoad the pre-computed vector data into your articles table from the .csv file. There are 25000 records, so expect the operation to take several minutes.\nCheck the number of records to ensure the data has been been loaded. There should be 25000 records.\n\nAfter the data is stored in your Neon database, you can query the data for nearest neighbors.\n\nStart by defining the query_neon function, which is executed when you run the vector similarity search. The function creates an embedding based on the user's query, prepares the SQL query, and runs the SQL query with the embedding. The pre-computed embeddings that you loaded into your database were created with text-embedding-3-small OpenAI model, so you must use the same model to create an embedding for the similarity search.\n\nA vector_name parameter is provided that allows you to search based on \"title\" or \"content\".\nRun a similarity search based on title_vector embeddings:\nRun a similarity search based on content_vector embeddings:"])</script><script>self.__next_f.push([1,"b4:T5e5,This notebook shows how to implement a question answering system with LangChain, Deep Lake as a vector store and OpenAI embeddings. We will take the following steps to achieve this:\n\nLoad a Deep Lake text dataset\nInitialize a Deep Lake vector store with LangChain\nAdd text to the vector store\nRun queries on the database\nDone!\n\nYou can also follow other tutorials such as question answering over any type of data (PDFs, json, csv, text): chatting with any data stored in Deep Lake, code understanding, or question answering over PDFs, or recommending songs.\nLet's install the following packages.\nProvide your OpenAI API key here:\nWe will use a 20000 sample subset of the cohere-wikipedia-22 dataset for this example.\nLet's take a look at a few samples:\nLet's define a dataset_path, this is where your Deep Lake vector store will house the text embeddings.\nWe will setup OpenAI's text-embedding-3-small as our embedding function and initialize a Deep Lake vector store at dataset_path...\n... and populate it with samples, one batch at a time, using the add_texts method.\nThe underlying Deep Lake dataset object is accessible through db.vectorstore.dataset, and the data structure can be summarized using db.vectorstore.summary(), which shows 4 tensors with 10 samples:\nWe will now setup QA on our vector store with GPT-3.5-Turbo as our LLM.\nLet's try running a prompt and check the output. Internally, this API performs an embedding search to find the most relevant data to feed into the LLM context.\nEt voila!b5:Tf2a,"])</script><script>self.__next_f.push([1,"Note: you will need an OpenAI API key to run this colab.\nIf you use OpenAI's API to fine-tune ChatGPT-3.5, you can now use the W\u0026B integration to track experiments, models, and datasets in your central dashboard.\n\nAll it takes is one line: openai wandb sync\n\nSee the OpenAI section in the Weights \u0026 Biases documentation for full details of the integration\n\nIt's always more fun to experiment with your own projects so if you have already used the openai API to fine-tune an OpenAI model, just skip this section.\n\nOtherwise let's fine-tune ChatGPT-3.5 on a legal dataset!\nStart your Weigths \u0026 Biases run. If you don't have an account you can sign up for one for free at www.wandb.ai\n\nWe download a dataset from LegalBench, a project to curate tasks for evaluating legal reasoning, specifically the Contract NLI Explicit Identification task.\n\nThis comprises of a total of 117 examples, from which we will create our own train and test datasets\nLet's look at a few samples.\nWe modify the base_prompt from the LegalBench task to make it a zero-shot prompt, as we are training the model instead of using few-shot prompting\nWe now split it into training/validation dataset, lets train on 30 samples and test on the remainder\n\n\nSave the data in a train and test file first\nNext, we validate that our training data is in the correct format using a script from the OpenAI fine-tuning documentation\nValidate train data\nLog our data to Weigths \u0026 Biases Artifacts for storage and versioning\nWe'll now use OpenAI API to fine-tune ChatGPT-3.5\n\nLet's first download our training \u0026 validation files and save them to a folder called my_data. We will retrieve the latest version of the artifact, but it could also be v0, v1 or any alias we associated with it\nThen we upload the training data to OpenAI. OpenAi has to process the data, so this will take a few minutes depending on the size of your dataset.\nLet's define our ChatGPT-3.5 fine-tuning hyper-parameters.\nthis takes around 5 minutes to train, and you get an email from OpenAI when finished.\nThats it!\n\nNow your model is training on OpenAI's machines. To get the current state of your fine-tuning job, run:\nShow recent events for our fine-tuning job\nWe can run a few different fine-tunes with different parameters or even with different datasets.\nWe can log our fine-tunes with a simple command.\nCalling openai wandb sync will log all un-synced fine-tuned jobs to W\u0026B\n\nBelow we are just logging 1 job, passing:\nour OpenAI key as an environment variable\nthe id of the fine-tune job we'd like to log\nthe W\u0026B project of where to log it to\n\nSee the OpenAI section in the Weights \u0026 Biases documentation for full details of the integration\nOur fine-tunes are now successfully synced to Weights \u0026 Biases.\n\nimage.png\n\nAnytime we have new fine-tunes, we can just call openai wandb sync to add them to our dashboard.\nThe best way to evaluate a generative model is to explore sample predictions from your evaluation set.\n\nLet's generate a few inference samples and log them to W\u0026B and see how the performance compares to a baseline ChatGPT-3.5 model\nSet up OpenAI call with retries\nLet's get our trained model id\nRun evaluation and log results to W\u0026B\nCalculate the accuracy of the fine-tuned model and log to W\u0026B\n\n\nLets compare our model to the baseline model, gpt-3.5-turbo\nCalculate the accuracy of the fine-tuned model and log to W\u0026B\nAnd thats it! In this example we have prepared our data, logged it to Weights \u0026 Biases, fine-tuned an OpenAI model using that data, logged the results to Weights \u0026 Biases and then run evaluation on the fine-tuned model.\n\nFrom here you can start to train on larger or more complex tasks, or else explore other ways to modify ChatGPT-3.5 such as giving it a different tone and style or response.\n\n\nOpenAI Fine-Tuning Guide\nW\u0026B Integration with OpenAI API Documentation\nW\u0026B Report: GPT-3 exploration \u0026 fine-tuning tips"])</script><script>self.__next_f.push([1,"b6:Tb9b,"])</script><script>self.__next_f.push([1,"Note: you will need an OpenAI API key to run this colab.\n\nUse the W\u0026B OpenAI integration to monitor OpenAI API calls and understand how your projects and teams are leveraging LLMs.\nIn this example, we'll generate templated Weave Boards: LLM usage monitoring dashboards which you can explore and customize from the UI.\n\nautomatically track LLM usage and aggregate useful metrics like  cost, latency and throughput across your projects/teams\ndynamically query and derive insights from the logs of all your OpenAI API calls\niterate visually to slice, aggregate, and explore your data; customize panels to focus on interesting patterns; share progress more easily with your team through an interactive dashboard\n\n\n\nPlay with a live version of this Weave Board →\n\n\n\nInstall dependencies, login to W\u0026B so you can save and share your work, and authenticate with OpenAI.\n\nSet WB_ENTITY to your wandb username or team name. Log in to W\u0026B and navigate to Home Page at wandb.ai/home to see valid options under your \"Profile\" and \"Teams\" in the left sidebar.\n\nTo start monitoring OpenAI API usage, call init_monitor(), where ` has the form //`. The stream records and stores all the OpenAI API calls.\n\nRunning this cell will print out a link to view the current project in the Weave UI.\n\nClick on the link above to preview the data stream, then click \"OpenAI Monitor Board\" in the right sidebar to create a Weave Board for this data stream.\n\n\n\n\nTo save your work, rename the board by clicking on the autogenerated name at the top of the page. To share your board, click \\\"Publish\\\" in the top right.\n\n\n\nTo visualize your work in real-time as you iterate, you can:\nkeep the Board open in a separate tab and refresh to view the latest data\nrename the Board for easier reference at any point and \\\"Publish\\\" that version to share a link with others\nfind previously saved Boards by navigating to the relevant W\u0026B entity and W\u0026B project name from weave.wandb.ai\nor open a new instance of a Board template to start fresh with all the data accumulated so far\n\n\nNext we'll illustrate a few ways you could track OpenAI API calls. There are many more possibilities depending on your use case, and we can't wait to see what you create from these starter templates.\n\n\n\nMonitor a ChatCompletion request and print the corresponding response, extracting only the text of the completion.\n\nFactor out parameters of interest and track them as attributes on the logged record.\nHere we track the \"system prompt\" separately from the \"prompt template\" and the \"equation\" parameter. This time we'll print the full structured response from the ChatCompletion call.\n\nMonitor a stream of messages and log the result as a single record. Note: tokens are not counted in this format.\n\nHere we compare a few toy options for the system prompt, user question, and intended audience. Try your own experiments and see if any interesting insights emerge as you explore in the Board and group by different parameters."])</script><script>self.__next_f.push([1,"b7:T2b36,"])</script><script>self.__next_f.push([1,"OpenAI functions enable your app to take action based on user inputs. This means that it can, e.g., search the web, send emails, or book tickets on behalf of your users, making it more powerful than a regular chatbot.\n\nIn this tutorial, you will build an app that uses OpenAI functions along with the latest version of the Node.js SDK. The app runs in the browser, so you only need a code editor and, e.g., VS Code Live Server to follow along locally. Alternatively, write your code directly in the browser via this code playground at Scrimba.\n\n\nOur app is a simple agent that helps you find activities in your area.\nIt has access to two functions, getLocation() and getCurrentWeather(),\nwhich means it can figure out where you’re located and what the weather\nis at the moment.\n\nAt this point, it's important to understand that\nOpenAI doesn't execute any code for you. It just tells your app which\nfunctions it should use in a given scenario, and then leaves it up to\nyour app to invoke them.\n\nOnce our agent knows your location and the weather, it'll use GPT’s\ninternal knowledge to suggest suitable local activities for you.\n\n\nWe start by importing the OpenAI SDK at the top of our JavaScript file and authenticate with our API key, which we have stored as an environment variable.\n\nimport OpenAI from \"openai\";\n\nconst openai = new OpenAI({\n  apiKey: process.env.OPENAI_API_KEY,\n  dangerouslyAllowBrowser: true,\n});\n\nSince we're running our code in a browser environment at Scrimba, we also need to set dangerouslyAllowBrowser: true to confirm we understand the risks involved with client-side API requests. Please note that you should move these requests over to a Node server in a production app.\n\n\nNext, we'll create the two functions. The first one - getLocation -\nuses the IP API to get the location of the\nuser.\n\nasync function getLocation() {\n  const response = await fetch(\"https://ipapi.co/json/\");\n  const locationData = await response.json();\n  return locationData;\n}\n\nThe IP API returns a bunch of data about your location, including your\nlatitude and longitude, which we’ll use as arguments in the second\nfunction getCurrentWeather. It uses the Open Meteo\nAPI to get the current weather data, like\nthis:\n\nasync function getCurrentWeather(latitude, longitude) {\n  const url = https://api.open-meteo.com/v1/forecast?latitude=${latitude}\u0026longitude=${longitude}\u0026hourly=apparent_temperature;\n  const response = await fetch(url);\n  const weatherData = await response.json();\n  return weatherData;\n}\n\n\nFor OpenAI to understand the purpose of these functions, we need to\ndescribe them using a specific schema. We'll create an array called\ntools that contains one object per function. Each object\nwill have two keys: type, function, and the function key has\nthree subkeys: name, description, and parameters.\n\nconst tools = [\n  {\n    type: \"function\",\n    function: {\n      name: \"getCurrentWeather\",\n      description: \"Get the current weather in a given location\",\n      parameters: {\n        type: \"object\",\n        properties: {\n          latitude: {\n            type: \"string\",\n          },\n          longitude: {\n            type: \"string\",\n          },\n        },\n        required: [\"longitude\", \"latitude\"],\n      },\n    }\n  },\n  {\n    type: \"function\",\n    function: {\n      name: \"getLocation\",\n      description: \"Get the user's location based on their IP address\",\n      parameters: {\n        type: \"object\",\n        properties: {},\n      },\n    }\n  },\n];\n\n\nWe also need to define a messages array. This will keep track of all of the messages back and forth between our app and OpenAI.\n\nThe first object in the array should always have the role property set to \"system\", which tells OpenAI that this is how we want it to behave.\n\nconst messages = [\n  {\n    role: \"system\",\n    content:\n      \"You are a helpful assistant. Only use the functions you have been provided with.\",\n  },\n];\n\n\nWe are now ready to build the logic of our app, which lives in the\nagent function. It is asynchronous and takes one argument: the\nuserInput.\n\nWe start by pushing the userInput to the messages array. This time, we set the role to \"user\", so that OpenAI knows that this is the input from the user.\n\nasync function agent(userInput) {\n  messages.push({\n    role: \"user\",\n    content: userInput,\n  });\n  const response = await openai.chat.completions.create({\n    model: \"gpt-4\",\n    messages: messages,\n    tools: tools,\n  });\n  console.log(response);\n}\n\nNext, we'll send a request to the Chat completions endpoint via the\nchat.completions.create() method in the Node SDK. This method takes a\nconfiguration object as an argument. In it, we'll specify three\nproperties:\n\nmodel - Decides which AI model we want to use (in our case,\n  GPT-4).\nmessages - The entire history of messages between the user and the\n  AI up until this point.\ntools - A list of tools the model may call. Currently, only\n  functions are supported as a tool., we'll we use the tools array we\n  created earlier.\n\n\nLet's try to run the agent with an input that requires a function call to give a suitable reply.\n\nagent(\"Where am I located right now?\");\n\nWhen we run the code above, we see the response from OpenAI logged out\nto the console like this:\n\n{\n    id: \"chatcmpl-84ojoEJtyGnR6jRHK2Dl4zTtwsa7O\",\n    object: \"chat.completion\",\n    created: 1696159040,\n    model: \"gpt-4-0613\",\n    choices: [{\n        index: 0,\n        message: {\n            role: \"assistant\",\n            content: null,\n            tool_calls: [\n              id: \"call_CBwbo9qoXUn1kTR5pPuv6vR1\",\n              type: \"function\",\n              function: {\n                name: \"getLocation\",\n                arguments: \"{}\"\n              }\n            ]\n        },\n        logprobs: null,\n        finish_reason: \"tool_calls\" // OpenAI wants us to call a function\n    }],\n    usage: {\n        prompt_tokens: 134,\n        completion_tokens: 6,\n        total_tokens: 140\n    }\n     system_fingerprint: null\n}\n\nThis response tells us that we should call one of our functions, as it contains the following key: finish_reason: \"tool_calls\".\n\nThe name of the function can be found in the\nresponse.choices[0].message.tool_calls[0].function.name key, which is set to\n\"getLocation\".\n\n\nNow that we have the name of the function as a string, we'll need to\ntranslate that into a function call. To help us with that, we'll gather\nboth of our functions in an object called availableTools:\n\nconst availableTools = {\n  getCurrentWeather,\n  getLocation,\n};\n\nThis is handy because we'll be able to access the getLocation function\nvia bracket notation and the string we got back from OpenAI, like this:\navailableTools[\"getLocation\"].\n\nconst { finish_reason, message } = response.choices[0];\n\nif (finish_reason === \"tool_calls\" \u0026\u0026 message.tool_calls) {\n  const functionName = message.tool_calls[0].function.name;\n  const functionToCall = availableTools[functionName];\n  const functionArgs = JSON.parse(message.tool_calls[0].function.arguments);\n  const functionArgsArr = Object.values(functionArgs);\n  const functionResponse = await functionToCall.apply(null, functionArgsArr);\n  console.log(functionResponse);\n}\n\nWe're also grabbing ahold of any arguments OpenAI wants us to pass into\nthe function: message.tool_calls[0].function.arguments.\nHowever, we won't need any arguments for this first function call.\n\nIf we run the code again with the same input\n(\"Where am I located right now?\"), we'll see that functionResponse\nis an object filled with location about where the user is located right\nnow. In my case, that is Oslo, Norway.\n\n{ip: \"193.212.60.170\", network: \"193.212.60.0/23\", version: \"IPv4\", city: \"Oslo\", region: \"Oslo County\", region_code: \"03\", country: \"NO\", country_name: \"Norway\", country_code: \"NO\", country_code_iso3: \"NOR\", country_capital: \"Oslo\", country_tld: \".no\", continent_code: \"EU\", in_eu: false, postal: \"0026\", latitude: 59.955, longitude: 10.859, timezone: \"Europe/Oslo\", utc_offset: \"+0200\", country_calling_code: \"+47\", currency: \"NOK\", currency_name: \"Krone\", languages: \"no,nb,nn,se,fi\", country_area: 324220, country_population: 5314336, asn: \"AS2119\", org: \"Telenor Norge AS\"}\n\nWe'll add this data to a new item in the messages array, where we also\nspecify the name of the function we called.\n\nmessages.push({\n  role: \"function\",\n  name: functionName,\n  content: `The result of the last function was this: ${JSON.stringify(\n    functionResponse\n  )}\n  `,\n});\n\nNotice that the role is set to \"function\". This tells OpenAI\nthat the content parameter contains the result of the function call\nand not the input from the user.\n\nAt this point, we need to send a new request to OpenAI with this updated\nmessages array. However, we don’t want to hard code a new function\ncall, as our agent might need to go back and forth between itself and\nGPT several times until it has found the final answer for the user.\n\nThis can be solved in several different ways, e.g. recursion, a\nwhile-loop, or a for-loop. We'll use a good old for-loop for the sake of\nsimplicity.\n\n\nAt the top of the agent function, we'll create a loop that lets us run\nthe entire procedure up to five times.\n\nIf we get back finish_reason: \"tool_calls\" from GPT, we'll just\npush the result of the function call to the messages array and jump to\nthe next iteration of the loop, triggering a new request.\n\nIf we get finish_reason: \"stop\" back, then GPT has found a suitable\nanswer, so we'll return the function and cancel the loop.\n\nfor (let i = 0; i\nComplete code\n\nimport OpenAI from \"openai\";\n\nconst openai = new OpenAI({\n  apiKey: process.env.OPENAI_API_KEY,\n  dangerouslyAllowBrowser: true,\n});\n\nasync function getLocation() {\n  const response = await fetch(\"https://ipapi.co/json/\");\n  const locationData = await response.json();\n  return locationData;\n}\n\nasync function getCurrentWeather(latitude, longitude) {\n  const url = https://api.open-meteo.com/v1/forecast?latitude=${latitude}\u0026longitude=${longitude}\u0026hourly=apparent_temperature;\n  const response = await fetch(url);\n  const weatherData = await response.json();\n  return weatherData;\n}\n\nconst tools = [\n  {\n    type: \"function\",\n    function: {\n      name: \"getCurrentWeather\",\n      description: \"Get the current weather in a given location\",\n      parameters: {\n        type: \"object\",\n        properties: {\n          latitude: {\n            type: \"string\",\n          },\n          longitude: {\n            type: \"string\",\n          },\n        },\n        required: [\"longitude\", \"latitude\"],\n      },\n    }\n  },\n  {\n    type: \"function\",\n    function: {\n      name: \"getLocation\",\n      description: \"Get the user's location based on their IP address\",\n      parameters: {\n        type: \"object\",\n        properties: {},\n      },\n    }\n  },\n];\n\nconst availableTools = {\n  getCurrentWeather,\n  getLocation,\n};\n\nconst messages = [\n  {\n    role: \"system\",\n    content: You are a helpful assistant. Only use the functions you have been provided with.,\n  },\n];\n\nasync function agent(userInput) {\n  messages.push({\n    role: \"user\",\n    content: userInput,\n  });\n\n  for (let i = 0; i"])</script><script>self.__next_f.push([1,"b8:T14f1,"])</script><script>self.__next_f.push([1,"Named Entity Recognition (NER) is a Natural Language Processing task that identifies and classifies named entities (NE) into predefined semantic categories (such as persons, organizations, locations, events, time expressions, and quantities). By converting raw text into structured information, NER makes data more actionable, facilitating tasks like information extraction, data aggregation, analytics, and social media monitoring.\n\nThis notebook demonstrates how to carry out NER with chat completion and functions-calling to enrich a text with links to a knowledge base such as Wikipedia:\n\nText:\n\nIn Germany, in 1440, goldsmith Johannes Gutenberg invented the movable-type printing press. His work led to an information revolution and the unprecedented mass-spread of literature throughout Europe. Modelled on the design of the existing screw presses, a single Renaissance movable-type printing press could produce up to 3,600 pages per workday.\n\nText enriched with Wikipedia links:\n\nIn Germany, in 1440, goldsmith Johannes Gutenberg invented the movable-type printing press. His work led to an information revolution and the unprecedented mass-spread of literature throughout Europe. Modelled on the design of the existing screw presses, a single Renaissance movable-type printing press could produce up to 3,600 pages per workday.\n\nInference Costs: The notebook also illustrates how to estimate OpenAI API costs.\nYou can generate an API key in the OpenAI web interface. See https://platform.openai.com/account/api-keys for details.\nThis notebook works with the latest OpeanAI models gpt-3.5-turbo-0613 and gpt-4-0613.\nWe define a standard set of NER labels to showcase a wide range of use cases. However, for our specific task of enriching text with knowledge base links, only a subset is practically required.\nThe chat completions API takes a list of messages as input and delivers a model-generated message as an output. While the chat format is primarily designed for facilitating multi-turn conversations, it is equally efficient for single-turn tasks without any preceding conversation. For our purposes, we will specify a message for the system, assistant, and user roles.\nThe system message (prompt) sets the assistant's behavior by defining its desired persona and task. We also delineate the specific set of entity labels we aim to identify.\nAlthough one can instruct the model to format its response, it has to be noted that both gpt-3.5-turbo-0613 and gpt-4-0613 have been fine-tuned to discern when a function should be invoked, and to reply with JSON formatted according to the function's signature. This capability streamlines our prompt and enables us to receive structured data directly from the model.\nAssistant messages usually store previous assistant responses. However, as in our scenario, they can also be crafted to provide examples of the desired behavior. While OpenAI is able to execute zero-shot Named Entity Recognition, we have found that a one-shot approach produces more precise results.\nThe user message provides the specific text for the assistant task:\nIn an OpenAI API call, we can describe functions to gpt-3.5-turbo-0613 and gpt-4-0613 and have the model intelligently choose to output a JSON object containing arguments to call those functions. It's important to note that the chat completions API doesn't actually execute the function. Instead, it provides the JSON output, which can then be used to call the function in our code. For more details, refer to the OpenAI Function Calling Guide.\nOur function, enrich_entities(text, label_entities) gets a block of text and a dictionary containing identified labels and entities as parameters. It then associates the recognized entities with their corresponding links to the Wikipedia articles.\nAs previously highlighted, gpt-3.5-turbo-0613 and gpt-4-0613 have been fine-tuned to detect when a function should to be called. Moreover, they can produce a JSON response that conforms to the function signature. Here's the sequence we follow:\n\nDefine our function and its associated JSON Schema.\nInvoke the model using the messages, tools and tool_choice parameters.\nConvert the output into a JSON object, and then call the function with the arguments provided by the model.\n\nIn practice, one might want to re-invoke the model again by appending the function response as a new message, and let the model summarize the results back to the user. Nevertheless, for our purposes, this step is not needed.\n\nNote that in a real-case scenario it is strongly recommended to build in user confirmation flows before taking actions.\nSince we want the model to output a dictionary of labels and recognized entities:\n\n{\n    \"gpe\": [\"Germany\", \"Europe\"],\n    \"date\": [\"1440\"],\n    \"person\": [\"Johannes Gutenberg\"],\n    \"product\": [\"movable-type printing press\"],\n    \"event\": [\"Renaissance\"],\n    \"quantity\": [\"3,600 pages\"],\n    \"time\": [\"workday\"]\n}\nwe need to define the corresponding JSON schema to be passed to the tools parameter:\nNow, we invoke the model. It's important to note that we direct the API to use a specific function by setting the tool_choice parameter to {\"type\": \"function\", \"function\" : {\"name\": \"enrich_entities\"}}.\nTo estimate the inference costs, we can parse the response's \"usage\" field. Detailed token costs per model are available in the OpenAI Pricing Guide:"])</script><script>self.__next_f.push([1,"b9:T2289,"])</script><script>self.__next_f.push([1,"Documentation puts useful information inside other people’s heads. Follow these tips to write better documentation.\n\n\nFew readers read linearly from top to bottom. They’ll jump around, trying to assess which bit solves their problem, if any. To reduce their search time and increase their odds of success, make docs easy to skim.\n\nSplit content into sections with titles. Section titles act as signposts, telling readers whether to focus in or move on.\n\nPrefer titles with informative sentences over abstract nouns. For example, if you use a title like “Results”, a reader will need to hop into the following text to learn what the results actually are. In contrast, if you use the title “Streaming reduced time to first token by 50%”, it gives the reader the information immediately, without the burden of an extra hop.\n\nInclude a table of contents. Tables of contents help readers find information faster, akin to how hash maps have faster lookups than linked lists. Tables of contents also have a second, oft overlooked benefit: they give readers clues about the doc, which helps them understand if it’s worth reading.\n\nKeep paragraphs short. Shorter paragraphs are easier to skim. If you have an essential point, consider putting it in its own one-sentence paragraph to reduce the odds it’s missed. Long paragraphs can bury information.\n\nBegin paragraphs and sections with short topic sentences that give a standalone preview. When people skim, they look disproportionately at the first word, first line, and first sentence of a section. Write these sentences in a way that don’t depend on prior text. For example, consider the first sentence “Building on top of this, let’s now talk about a faster way.” This sentence will be meaningless to someone who hasn’t read the prior paragraph. Instead, write it in a way that can understood standalone: e.g., “Vector databases can speed up embeddings search.”\n\nPut topic words at the beginning of topic sentences. Readers skim most efficiently when they only need to read a word or two to know what a paragraph is about. Therefore, when writing topic sentences, prefer putting the topic at the beginning of the sentence rather than the end. For example, imagine you’re writing a paragraph on vector databases in the middle of a long article on embeddings search. Instead of writing “Embeddings search can be sped up by vector databases” prefer “Vector databases speed up embeddings search.” The second sentence is better for skimming, because it puts the paragraph topic at the beginning of the paragraph.\n\nPut the takeaways up front. Put the most important information at the tops of documents and sections. Don’t write a Socratic big build up. Don’t introduce your procedure before your results.\n\nUse bullets and tables. Bulleted lists and tables make docs easier to skim. Use them frequently.\n\nBold important text. Don’t be afraid to bold important text to help readers find it.\n\n\nBadly written text is taxing to read. Minimize the tax on readers by writing well.\n\nKeep sentences simple. Split long sentences into two. Cut adverbs. Cut unnecessary words and phrases. Use the imperative mood, if applicable. Do what writing books tell you.\n\nWrite sentences that can be parsed unambiguously. For example, consider the sentence “Title sections with sentences.” When a reader reads the word “Title”, their brain doesn’t yet know whether “Title” is going to be a noun or verb or adjective. It takes a bit of brainpower to keep track as they parse the rest of the sentence, and can cause a hitch if their brain mispredicted the meaning. Prefer sentences that can be parsed more easily (e.g., “Write section titles as sentences”) even if longer. Similarly, avoid noun phrases like “Bicycle clearance exercise notice” which can take extra effort to parse.\n\nAvoid left-branching sentences. Linguistic trees show how words relate to each other in sentences. Left-branching trees require readers to hold more things in memory than right-branching sentences, akin to breadth-first search vs depth-first search. An example of a left-branching sentence is “You need flour, eggs, milk, butter and a dash of salt to make pancakes.” In this sentence you don’t find out what ‘you need’ connects to until you reach the end of the sentence. An easier-to-read right-branching version is “To make pancakes, you need flour, eggs, milk, butter, and a dash of salt.” Watch out for sentences in which the reader must hold onto a word for a while, and see if you can rephrase them.\n\nAvoid demonstrative pronouns (e.g., “this”), especially across sentences. For example, instead of saying “Building on our discussion of the previous topic, now let’s discuss function calling” try “Building on message formatting, now let’s discuss function calling.” The second sentence is easier to understand because it doesn’t burden the reader with recalling the previous topic. Look for opportunities to cut demonstrative pronouns altogether: e.g., “Now let’s discuss function calling.”\n\nBe consistent. Human brains are amazing pattern matchers. Inconsistencies will annoy or distract readers. If we use Title Case everywhere, use Title Case. If we use terminal commas everywhere, use terminal commas. If all of the Cookbook notebooks are named with underscores and sentence case, use underscores and sentence case. Don’t do anything that will cause a reader to go ‘huh, that’s weird.’ Help them focus on the content, not its inconsistencies.\n\nDon’t tell readers what they think or what to do. Avoid sentences like “Now you probably want to understand how to call a function” or “Next, you’ll need to learn to call a function.” Both examples presume a reader’s state of mind, which may annoy them or burn our credibility. Use phrases that avoid presuming the reader’s state. E.g., “To call a function, …”\n\n\nPeople come to documentation with varying levels of knowledge, language proficiency, and patience. Even if we target experienced developers, we should try to write docs helpful to everyone.\n\nWrite simply. Explain things more simply than you think you need to. Many readers might not speak English as a first language. Many readers might be really confused about technical terminology and have little excess brainpower to spend on parsing English sentences. Write simply. (But don’t oversimplify.)\n\nAvoid abbreviations. Write things out. The cost to experts is low and the benefit to beginners is high. Instead of IF, write instruction following. Instead of RAG, write retrieval-augmented generation (or my preferred term: the search-ask procedure).\n\nOffer solutions to potential problems. Even if 95% of our readers know how to install a Python package or save environment variables, it can still be worth proactively explaining it. Including explanations is not costly to experts—they can skim right past them. But excluding explanations is costly to beginners—they might get stuck or even abandon us. Remember that even an expert JavaScript engineer or C++ engineer might be a beginner at Python. Err on explaining too much, rather than too little.\n\nPrefer terminology that is specific and accurate. Jargon is bad. Optimize the docs for people new to the field, instead of ourselves. For example, instead of writing “prompt”, write “input.” Or instead of writing “context limit” write “max token limit.” The latter terms are more self-evident, and are probably better than the jargon developed in base model days.\n\nKeep code examples general and exportable. In code demonstrations, try to minimize dependencies. Don’t make users install extra libraries. Don’t make them have to refer back and forth between different pages or sections. Try to make examples simple and self-contained.\n\nPrioritize topics by value. Documentation that covers common problems—e.g., how to count tokens—is magnitudes more valuable than documentation that covers rare problems—e.g., how to optimize an emoji database. Prioritize accordingly.\n\nDon’t teach bad habits. If API keys should not be stored in code, never share an example that stores an API key in code.\n\nIntroduce topics with a broad opening. For example, if explaining how to program a good recommender, consider opening by briefly mentioning that recommendations are widespread across the web, from YouTube videos to Amazon items to Wikipedia. Grounding a narrow topic with a broad opening can help people feel more secure before jumping into uncertain territory. And if the text is well-written, those who already know it may still enjoy it.\n\n\nUltimately, do what you think is best. Documentation is an exercise in empathy. Put yourself in the reader’s position, and do what you think will help them the most."])</script><script>self.__next_f.push([1,"ba:T1174,"])</script><script>self.__next_f.push([1,"Much of the internet is powered by RESTful APIs. Giving GPT the ability to call them opens up a world of possibilities. This notebook demonstrates how GPTs can be used to intelligently call APIs. It leverages OpenAPI specifications and chained function calls.\n\nThe OpenAPI Specification (OAS) is a universally accepted standard for describing the details of RESTful APIs in a format that machines can read and interpret. It enables both humans and computers to understand the capabilities of a service, and it can be leveraged to show GPT how to call APIs.\n\nThis notebook is divided into two main sections:\n\nHow to convert a sample OpenAPI specification into a list of function definitions for the chat completions API.\nHow to use the chat completions API to intelligently invoke these functions based on user instructions.\n\nWe recommend familiariazing yourself with function-calling before proceding.\n\n\nThe example OpenAPI spec we use here was created using gpt-4. We will transform this sample spec into a set of function definitions that can be supplied to the chat completion API. The model, based on the provided user instructions, generates a JSON object containing the necessary arguments to call these functions.\n\nBefore we proceed, let's inspect this generated spec. OpenAPI specs include details about the API's endpoints, the operations they support, the parameters they accept, the requests they can handle, and the responses they return. The spec is defined in JSON format.\n\nThe endpoints in the spec include operations for:\n\nListing all events\nCreating a new event\nRetrieving an event by ID\nDeleting an event by ID\nUpdating an event name by ID\n\nEach operation in the spec has an operationId, which we will use as the function name when we parse the spec into function specifications. The spec also includes schemas that define the data types and structures of the parameters for each operation.\n\nYou can see the schema here:\n\nNow that we have a good understanding of the OpenAPI spec, we can proceed to parse it into function specifications.\n\nWe can write a simple openapi_to_functions function to generate a list of definitions, where each function is represented as a dictionary containing the following keys:\n\nname: This corresponds to the operation identifier of the API endpoint as defined in the OpenAPI specification.\ndescription: This is a brief description or summary of the function, providing an overview of what the function does.\nparameters: This is a schema that defines the expected input parameters for the function. It provides information about the type of each parameter, whether it is required or optional, and other related details.\n\nFor each of the endpoints defined in the schema, we need to do the following:\n\nResolve JSON references: In an OpenAPI specification, it's common to use JSON references (also known as $ref) to avoid duplication. These references point to definitions that are used in multiple places. For example, if multiple API endpoints return the same object structure, that structure can be defined once and then referenced wherever it's needed. We need to resolve and replace these references with the content they point to.\n\nExtract a name for the functions: We will simply use the operationId as the function name. Alternatively, we could use the endpoint path and operation as the function name.\n\nExtract a description and parameters: We will iterate through the description, summary, requestBody and parameters fields to populate the function's description and parameters.\n\nHere's the implementation:\n\n\nNow that we have these function definitions, we can leverage GPT to call them intelligently based on user inputs.\n\nIt's important to note that the chat completions API does not execute the function; instead, it generates the JSON that you can use to call the function in your own code.\n\nFor more information on function-calling, refer to our dedicated function-calling guide.\n\n\nWe have demonstrated how to convert OpenAPI specs into function specifications that can be given to GPT for it to intelligently call them, and shown how these can be chained together to perform complex operations.\n\nPossible extensions of this system could include handling more complex user instructions that require conditional logic or looping, integrating with real APIs to perform actual operations, and improving error handling and validation to ensure the instructions are feasible and the function calls are successful."])</script><script>self.__next_f.push([1,"bb:T1b9b,"])</script><script>self.__next_f.push([1,"This notebook covers how to fine-tune to increase function calling accuracy and reliability. You can find more information on function calling here, and on fine tuning here\n\nFor context, from the function calling notebook above:\ntools is an optional parameter in the Chat Completion API which can be used to provide function specifications. The purpose of this is to enable models to generate function arguments which adhere to the provided specifications. Note that the API will not actually execute any function calls. It is up to developers to execute function calls using model outputs.\n\nFunction calling is a very powerful tool when it functions as intended. However, we have seen that as the number of functions increases, and the complexity of the task at hand increases, function calling becomes less accurate (e.g.: more hallucinated invocations, and incorrect invocations).\n\nBefore fine tuning for function calling, it's best to begin with:\n\nImprovements to the function definitions. Make them more clear, and more distinct from one another.\nExperiment with prompt engineering: often a more detailed prompt can help the model call the correct function.\n\nIf the steps above fail to improve function calling to a satisfactory level, then you can try fine tuning for function calling.\n\n\nThis notebook contains three sections\n\nAssessing baseline function calling performance:** Evaluating an out-of-the-box gpt-3.5-turbo model on our given function (let's assume that for latency + cost reasons we cannot use gpt-4o for a drone copilot)\nGenerating synthetic data:** Using gpt-4o to create 'golden' set of prompts and function invocations to use as training data\nFine-tuning**: Running the fine tuning job, and evaluating the fine-tuned model\n\nNote: This notebook provides an example of how to create synthetic training data for fine tuning for function calling given just a list of functions. While real-world production test evals are preferable, this method produces strong results and can be used in conjunction with real-world training data.\n\n\n\nLet's define utility functions for making calls to the Chat Completions API, one to get the completion and one to get the function call.\n\n\nLet's build an intelligent drone co-pilot. We want to be able to give the co-pilot commands, and have it either call the function\nfor that command, or deny that request if the command is unfeasible.\nWe can first define a system prompt for the copilot.\n\nNow let's define functions for all of the actions the copilot can take.\n\nFor starters, let's see how function calling performs with some straight forward feasible prompts, and then couple of obviously impossible requests which call the 'reject_request' function.\n\nNice! The model performs quite well with these requests. Now let's try some more difficult requests: requests that are almost feasible and are drone-related, but that the drone cannot actually do, and the pilot should reject.\n\nNow we run into some problems.\nThe model here should reject all of these requests, as they are impossible/conflicting/ambiguous given the functions, however instead the model calls functions that are somewhat related to the request, but incorrect. For example, the model sets follow_me_mode when asked to initiate following on social media.\n\n\nIn this simple case, more prompt engineering may resolve some of these issues, but for the purpose of this example we will demonstrate how fine tuning can be used to improve performance. Additionally, while this case is relatively straightforward, as the number of and complexity of the functions increases, fine tuning becomes more and more impactful.\n\nAgain, our goal here is to improve performance and use less tokens, so fine-tuning allows us to:\n\nOmit function and parameter descriptions: remove the description field from function and parameters\nOmit parameters: remove the entire properties field from the parameters object\nOmit function entirely: remove the entire function object from the functions array\n\n\n\nWe want to generate every invocation of every function, so that we have\nfull coverage of all potential invocations to create synthetic data for. Then, we will use gpt-4o to come up with prompts that would call each invocation, and we will use that prompt - function invocation pair as training data.\n\nGenerating every invocation for a function with fixed enums is more simple, but for a function such as\ncontrol_gimbal we need to set the tilt and pan integer values, so to generate those synthetic invocations we will first set a placeholder, and then later use gpt-4o to come up with reasonable values.\n\nThe functions below take in all the functions from the function list, and look\nat all the potential invocations of those functions given each function's parameters.\nThe functions also account for required parameters, so that all the invocations\nare actually feasible.\n\n\nPrompts:\n\nIn the below snippet, we generate the invocation of each function except for the reject_request function.\n\nTo perform effective fine-tuning we need correctly labeled data. We could manually come up with examples and label the data,\\\nor we can generate synthetic data with the help of gpt-4o\n\nEmpirically, gpt-4o needs a bit more help to get good realistic examples of prompts that would generate the reject_request function, so we'll do that next...\n\nNow that we have all the invocations, let's use gpt-4o to generate prompts that would result in those invocations\n\nNow let's format the training examples properly. For more documentation on the proper training data formatting for fine tuning for function calling, see here: https://platform.openai.com/docs/guides/fine-tuning/fine-tuning-examples\n\nNow, back to the rejection function. Let's generate some prompts that are nearly possible, but should result in the reject_request function being called. To do so, we queried gpt-4o asking for requests that are related to, but not quite possible with, the given list of functions.\n\nNow combine all the training examples together\n\n\nFinally, we can kick off the fine-tuning job\n\nIn addition to creating a fine-tuning job, you can also list existing jobs, retrieve the status of a job, or cancel a job.\n\nAfter a fine-tuning job has finished, you can also see metrics around how the training process went by querying a fine-tuning job, extracting a file ID from the result_files, and then retrieving that files content. Each results CSV file has the following columns: step, train_loss, train_accuracy, valid_loss, and valid_mean_token_accuracy. While metrics can he helpful, evaluating samples from the fine-tuned model provides the most relevant sense of model quality.\n\n\nGreat! We trained a fine-tuned model for function calling. Let's see how it does on our evaluation set for prompts that the drone assistant\nshould automatically reject.\n\nGreat! While the original model only rejected 60%, the fine tuned model rejected 100% requests and used less tokens to do so.\n\n\nCongratulations! You are now ready to fine tune your model for function calling. We can't wait to see what you build."])</script><script>self.__next_f.push([1,"bc:T46d,This notebook demonstrates how to use GPT's visual capabilities with a video. Although GPT-4.1-mini doesn't take videos as input directly, we can use vision and the 1M token context window to describe the static frames of a whole video at once. We'll walk through two examples:\n\nUsing GPT-4.1-mini to get a description of a video\nGenerating a voiceover for a video with GPT-4o TTS API\n\n\nFirst, we use OpenCV to extract frames from a nature video containing bisons and wolves:\n\nDisplay frames to make sure we've read them in correctly:\n\nOnce we have the video frames, we craft our prompt and send a request to GPT (Note that we don't need to send every frame for GPT to understand what's going on):\n\n\nLet's create a voiceover for this video in the style of David Attenborough. Using the same video frames we prompt GPT to give us a short script:\n\nNow, we can work with the GPT-4o TTS model and provide it a set of instructions on how the voice should sound. You can play around with the voice models and instructers at OpenAI.fm. We can then pass in the script we generated above with GPT-4.1-mini and generate audio of the voiceover:bd:T2c26,"])</script><script>self.__next_f.push([1,"DALL·E-3 is the latest version of our DALL-E text-to-image generation models. As the current state of the art in text-to-image generation, DALL·E is capable of generating high-quality images across a wide variety of domains. If you're interested in more technical details of how DALL·E-3 was built, you can read more about in our research paper. I'll be going over some of the new features and capabilities of DALL·E-3 in this article, as well as some examples of what new products you can build with the API.\n\nAs a reminder, the Image generation API hasn't changed and maintains the same endpoints and formatting as with DALL·E-2. If you're looking for a guide on how to use the Image API, see the Cookbook article on the subject.\n\nThe only API endpoint available for use with DALL·E-3 right now is Generations (/v1/images/generations). We don’t support variations or inpainting yet, though the Edits and Variations endpoints are available for use with DALL·E-2.\n\n\nThe generation API endpoint creates an image based on a text prompt. There’s a couple new parameters that we've added to enhance what you can create with our models. Here’s a quick overview of the options:\n\n\nmodel** (‘dall-e-2’ or ‘dall-e-3’): This is the model you’re generating with. Be careful to set it to ‘dall-e-3’ as it defaults to ‘dall-e-2’ if empty.\nstyle** (‘natural’ or ‘vivid’): The style of the generated images. Must be one of vivid or natural. Vivid causes the model to lean towards generating hyper-real and dramatic images. Natural causes the model to produce more natural, less hyper-real looking images. Defaults to ‘vivid’.\nquality** (‘standard’ or ‘hd’): The quality of the image that will be generated. ‘hd’ creates images with finer details and greater consistency across the image. Defaults to ‘standard’.\n\n\nprompt** (str): A text description of the desired image(s). The maximum length is 1000 characters. Required field.\nn** (int): The number of images to generate. Must be between 1 and 10. Defaults to 1. For dall-e-3, only n=1 is supported.\nsize** (...): The size of the generated images. Must be one of 256x256, 512x512, or 1024x1024 for DALL·E-2 models. Must be one of 1024x1024, 1792x1024, or 1024x1792 for DALL·E-3 models.\nresponse_format** ('url' or 'b64_json'): The format in which the generated images are returned. Must be one of \"url\" or \"b64_json\". Defaults to \"url\".\nuser** (str): A unique identifier representing your end-user, which will help OpenAI to monitor and detect abuse. Learn more.\n\n\nOur launch of DALL·E-3 comes with lots of new features and capabilities to help you generate the images you want. Here’s a quick overview of what’s new:\n\n\nA new feature in the latest DALL·E-3 API is prompt rewriting, where we use GPT-4 to optimize all of your prompts before they’re passed to DALL-E. In our research, we’ve seen that using very detailed prompts give significantly better results. You can read more about our captioning, prompting, and safety mitigations in the DALL·E-3 research paper.\n\nKeep in mind that this feature isn’t able to be disabled at the moment, though you can achieve a high level of fidelity by simply giving instructions to the relabeler in your prompt, as I'll show below with examples.\n\nPrompt Rewriting\n\n\nDALL·E-3 introduces a new 'quality' parameter that allows you to adjust the level of detail and organization in all of your generations. The 'standard' quality generations are the DALL·E-3 you're familiar with, with 'hd' generations bringing a new level of attention to detail and adherence to your prompt. Keep in mind that setting your generation quality to ‘hd’ does increase the cost per image, as well as often increasing the time it takes to generate by ~10 seconds or so.\n\nFor example, here we have two different icons in 'hd' and 'standard' quality. Often the choice between either quality is up to taste, but 'hd' often wins when the task requires more ability to capture details and textures or better composition of a scene.\n\nIcons\n\nHere's another example, this time with a prompt of 'An infinite, uniform grid of tessellated cubes.', which DALL·E conveniently rewrites as \"An infinite, uniform grid of tessellated cubes painted carefully in an isometric perspective. The cubes are meticulously arranged in such a way that they seem to stretch endlessly into the distance. Each cube is identical to the next, with light reflecting consistently across all surfaces, underscoring their uniformity. This is a digitally rendered image.\":\n\nCubes\n\n\nDALL·E-3 accepts three different image sizes: 1024px by 1024px, 1792px by 1024px, and 1024px by 1792px. Beyond giving more flexibility in terms of aspect ratio, these sizes can have significant effects on the style and context of your generated image. For example, vertical images might work better when you’re looking for an image that looks like it was taken by a cellphone camera, or horizontal images may work better for landscape paintings or digital designs.\n\nTo demonstrate this difference, here’s multiple variations on the same input prompt with a different aspect ratio. In this case, my prompt was: “Professional photoshoot of a Chemex brewer in the process of brewing coffee.” (For reference, this is a photo of a real Chemex brewer).\n\nHere is the generation in square form (in both HD and standard qualities):\n\nsquare_coffee\n\nYou can see how these images are framed closely to the item and seem to be taken in a more closed space with various surrounding items nearby.\n\nHere are the results on the same prompts with a wider aspect ratio:\n\nwide_coffee\n\nCompared to the previous generations, these come in the form of close-ups. The background is blurred, with greater focus on the item itself, more like professionally organized photoshoots rather than quick snaps.\n\nLastly, we have the vertical aspect ratio:\n\ntall_coffee\n\nThese feel more akin to cellphone images, with a more candid appearance. There’s more action involved: the slowly dripping coffee or the active pour from the pot.\n\n\nDALL·E-3 introduces two new styles: natural and vivid. The natural style is more similar to the DALL·E-2 style in its 'blander' realism, while the vivid style is a new style that leans towards generating hyper-real and cinematic images. For reference, all DALL·E generations in ChatGPT are generated in the 'vivid' style.\n\nThe natural style is specifically useful in cases where DALL·E-3 over-exaggerates or confuses a subject that's supposed to be more simple, subdued, or realistic. I've often used it for logo generation, stock photos, or other cases where I'm trying to match a real-world object.\n\nHere's an example of the same prompt as above in the vivid style. The vivid is far more cinematic (and looks great), but might pop too much if you're not looking for that.\n\nvivid_coffee\n\nThere's many cases in which I prefer the natural style, such as this example of a painting in the style of Thomas Cole's 'Desolation':\n\nthomas_cole\n\n\nTo help you get started building with DALL·E-3, I've come up with a few examples of products you could build with the API, as well as collected some styles and capabilities that seem to be unique to DALL·E-3 at the moment. I've also listed some subjects that I'm struggling to prompt DALL·E-3 to generate in case you want to try your hand at it.\n\n\nHave you ever struggled to find the perfect icon for your website or app? It would be awesome to see a custom icon generator app that lets you pick the style, size, and subject of your icon, and then generates a custom SVG from the DALL·E generation. Here's some examples of helpful website icons I generated with DALL·E-3:\n\nicon_set\n\nIn this case, I used Potrace to convert the images to SVGs, which you can download here. This is what I used to convert the images:\n\npotrace -s cat.jpg -o cat.svg\n\nYou might need to boost the brightness and contrast of the image before converting it to an SVG. I used the following command to do so:\n\nconvert cat.jpg -brightness-contrast 50x50 cat.jpg\n\n\nDALL·E-3 is great at jumpstarting the logo creation process for your company or product. By prompting DALL·E to create 'Vector logo design of a Greek statue, minimalistic, with a white background' I achieved the following:\n\nlogo_greece\n\nHere's another logo I created, this time for an Arabian coffee shop:\n\nlogo_arabia\n\nIn the case of iterating on an existing logo, I took OpenAI's logo, asked GPT-4V to describe it, and then asked DALL·E to generate variations on the logo:\n\niteration\n\n\nDALL·E-3 is great at generating line art, which might be useful for generating custom tattoos. Here's some line art I generated with DALL·E-3:\n\ntattoos\n\n\nWhat if you could generate custom die-cut stickers and t-shirts with DALL·E-3, integrating with a print-on-demand service like Printful or Stickermule? You could have a custom sticker or t-shirt in minutes, with no design experience required. Here's some examples of stickers I generated with DALL·E-3:\n\nstickers\n\n\nWith some difficulty, I managed to prompt DALL·E-3 to generate Minecraft skins. I'm sure with some clever prompting you could get DALL·E-3 to reliably generate incredible Minecraft skins. It might be hard to use the words 'Minecraft' since DALL·E might think you are trying to generate content from the game itself, instead, you can communicate the idea differently: \"Flat player skin texture of a ninja skin, compatible with Minecraftskins.com or Planet Minecraft.\"\n\nHere's what I managed to create. They might need some work, but I think they're a good start:\n\nminecraft\n\n\nHere's some ideas I've had that I haven't had time to try yet:\n\nCustom emojis or Twitch emotes?\nVector illustrations?\nPersonalized Bitmoji-style avatars?\nAlbum art?\nCustom greeting cards?\nPoster/flyer 'pair-programming' with DALL·E?\n\n\nWe're really just starting to figure out what DALL·E-3 is capable of. Here's some of the best styles, generations, and prompts I've seen so far. I've been unable to locate the original authors of some of these images, so if you know who created them, please let me know!\n\ncollage\n\nSources:\n\n@scharan79 on Reddit\n@TalentedJuli on Reddit\n@Wild-Culture-5068 on Reddit\n@popsicle_pope on Reddit\n@gopatrik on Twitter\n@ARTiV3RSE on Twitter\n@willdepue on Twitter\nVarious OpenAI employees\n\n\nDALL·E-3 is still very new and there's still a lot of things it struggles with (or maybe I just haven't figured out how to prompt it correctly yet). Here's some challenges which you might want to try your hand at:\n\n\nDALL·E really struggles at generating real looking websites, apps, etc. and often generates what looks like a portfolio page of a web designer. Here's the best I've gotten so far:\n\nwebsites\n\n\nIt feels like DALL·E-3 is so close to being able to generate seamless textures. Often they come out great, just slightly cutoff or with a few artifacts. See examples below:\n\nseamless\n\n\nUsing DALL·E to generate custom fonts or iterate on letter designs could be really cool, but I haven't been able to get it to work yet. Here's the best I've gotten so far:\n\nfonts\n\n\nThanks for reading! If you're looking for more resources on DALL·E-3, here are some related links:\n\nDALL·E-3 Blog Post\nDALL·E-3 Research Paper\nImage API Documentation\nImage API Cookbook"])</script><script>self.__next_f.push([1,"be:T1082,"])</script><script>self.__next_f.push([1,"TLDR: Developers can now specify seed parameter in the Chat Completion request to receive (mostly) consistent outputs. To help you keep track of these changes, we expose the system_fingerprint field. If this value is different, you may see different outputs due to changes we've made on our systems. Please note that this feature is in beta and only currently supported for gpt-4-1106-preview and gpt-3.5-turbo-1106.\n\n\nReproducibility has always been a big request from user communities when using our APIs. For instance, when granted the capability of getting reproducible numerical result, users can unlock quite a bit of use cases that’s sensitive to numerical changes.\n\n\nThe Chat Completions and Completions APIs are non-deterministic by default (which means model outputs may differ from request to request), but now offer some control towards deterministic outputs using a few model level controls.\n\nThis can unlock consistent completions which enables full control on the model behaviors for anything built on top of the APIs, and quite useful for reproducing results and testing so you know get peace of mind from knowing exactly what you’d get.\n\n\nTo receive mostly deterministic outputs across API calls:\n\nSet the seed parameter to any integer of your choice, but use the same value across requests. For example, 12345.\nSet all other parameters (prompt, temperature, top_p, etc.) to the same values across requests.\nIn the response, check the system_fingerprint field. The system fingerprint is an identifier for the current combination of model weights, infrastructure, and other configuration options used by OpenAI servers to generate the completion. It changes whenever you change request parameters, or OpenAI updates numerical configuration of the infrastructure serving our models (which may happen a few times a year).\n\nIf the seed, request parameters, and system_fingerprint all match across your requests, then model outputs will mostly be identical. There is a small chance that responses differ even when request parameters and system_fingerprint match, due to the inherent non-determinism of our models.\n\n\n\nIf specified, our system will make a best effort to sample deterministically, such that repeated requests with the same seed and parameters should return the same result. Determinism is not guaranteed, and you should refer to the system_fingerprint response parameter to monitor changes in the backend.\n\n\nThis fingerprint represents the backend configuration that the model runs with. It can be used in conjunction with the seed request parameter to understand when backend changes have been made that might impact determinism.This is the indicator on whether users should expect \"almost always the same result\".\n\n\nIn this example, we will demonstrate how to generate a short excerpt using a fixed seed. This can be particularly useful in scenarios where you need to generate consistent results for testing, debugging, or for applications that require consistent outputs.\nNote\nSwitch to latest version of the SDK (1.3.3 at time of writing).\nFirst, let's try generating few different versions of a short excerpt about \"a journey to Mars\" without the seed parameter. This is the default behavior:\nNow, let's try to tun the same code with a constant seed of 123 and temperature of 0 and compare the responses and system_fingerprint.\nAs we can observe, the seed parameter allows us to generate much more consistent results.\n\nWe demonstrated how to use a fixed integer seed to generate consistent outputs from our model. This is particularly useful in scenarios where reproducibility is important. However, it's important to note that while the seed ensures consistency, it does not guarantee the quality of the output. Note that when you want to use reproducible outputs, you need to set the seed to the same integer across Chat Completions calls. You should also match any other parameters like temperature, max_tokens etc. Further extension of reproducible outputs could be to use consistent seed when benchmarking/evaluating the performance of different prompts or models, to ensure that each version is evaluated under the same conditions, making the comparisons fair and the results reliable."])</script><script>self.__next_f.push([1,"bf:T2704,"])</script><script>self.__next_f.push([1,"The new Assistants API is a stateful evolution of our Chat Completions API meant to simplify the creation of assistant-like experiences, and enable developer access to powerful tools like Code Interpreter and File Search.\nAssistants API Diagram\n\nThe primitives of the Chat Completions API are Messages, on which you perform a Completion with a Model (gpt-4o, gpt-4o-mini, etc). It is lightweight and powerful, but inherently stateless, which means you have to manage conversation state, tool definitions, retrieval documents, and code execution manually.\n\nThe primitives of the Assistants API are\n\nAssistants, which encapsulate a base model, instructions, tools, and (context) documents,\nThreads, which represent the state of a conversation, and\nRuns, which power the execution of an Assistant on a Thread, including textual responses and multi-step tool use.\n\nWe'll take a look at how these can be used to create powerful, stateful experiences.\nNote\nWe've updated our Python SDK to add support for the Assistants API, so you'll need to update it to the latest version (1.59.4 at time of writing).\n\nAnd make sure it's up to date by running:\n\n\n\n\nThe easiest way to get started with the Assistants API is through the Assistants Playground.\n\nAssistants Playground\n\nLet's begin by creating an assistant! We'll create a Math Tutor just like in our docs.\n\nCreating New Assistant\n\nYou can also create Assistants directly through the Assistants API, like so:\n\nRegardless of whether you create your Assistant through the Dashboard or with the API, you'll want to keep track of the Assistant ID. This is how you'll refer to your Assistant throughout Threads and Runs.\n\nNext, we'll create a new Thread and add a Message to it. This will hold the state of our conversation, so we don't have re-send the entire message history each time.\n\n\nCreate a new thread:\n\nThen add the Message to the thread:\nNote\nEven though you're no longer sending the entire history each time, you will still be charged for the tokens of the entire conversation history with each Run.\n\n\nNotice how the Thread we created is not associated with the Assistant we created earlier! Threads exist independently from Assistants, which may be different from what you'd expect if you've used ChatGPT (where a thread is tied to a model/GPT).\n\nTo get a completion from an Assistant for a given Thread, we must create a Run. Creating a Run will indicate to an Assistant it should look at the messages in the Thread and take action: either by adding a single response, or using tools.\nNote\nRuns are a key difference between the Assistants API and Chat Completions API. While in Chat Completions the model will only ever respond with a single message, in the Assistants API a Run may result in an Assistant using one or multiple tools, and potentially adding multiple messages to the Thread.\n\nTo get our Assistant to respond to the user, let's create the Run. As mentioned earlier, you must specify both the Assistant and the Thread.\n\nUnlike creating a completion in the Chat Completions API, creating a Run is an asynchronous operation. It will return immediately with the Run's metadata, which includes a status that will initially be set to queued. The status will be updated as the Assistant performs operations (like using tools and adding messages).\n\nTo know when the Assistant has completed processing, we can poll the Run in a loop. (Support for streaming is coming soon!) While here we are only checking for a queued or in_progress status, in practice a Run may undergo a variety of status changes which you can choose to surface to the user. (These are called Steps, and will be covered later.)\n\n\nNow that the Run has completed, we can list the Messages in the Thread to see what got added by the Assistant.\n\nAs you can see, Messages are ordered in reverse-chronological order – this was done so the most recent results are always on the first page (since results can be paginated). Do keep a look out for this, since this is the opposite order to messages in the Chat Completions API.\n\nLet's ask our Assistant to explain the result a bit further!\n\nThis may feel like a lot of steps to get a response back, especially for this simple example. However, you'll soon see how we can add very powerful functionality to our Assistant without changing much code at all!\n\n\nLet's take a look at how we could potentially put all of this together. Below is all the code you need to use an Assistant you've created.\n\nSince we've already created our Math Assistant, I've saved its ID in MATH_ASSISTANT_ID. I then defined two functions:\n\nsubmit_message: create a Message on a Thread, then start (and return) a new Run\nget_response: returns the list of Messages in a Thread\n\nI've also defined a create_thread_and_run function that I can re-use (which is actually almost identical to the client.beta.threads.create_and_run compound function in our API ;) ). Finally, we can submit our mock user requests each to a new Thread.\n\nNotice how all of these API calls are asynchronous operations; this means we actually get async behavior in our code without the use of async libraries! (e.g. asyncio)\n\nOnce all Runs are going, we can wait on each and get the responses.\n\nEt voilà!\n\nYou may have noticed that this code is not actually specific to our math Assistant at all... this code will work for any new Assistant you create simply by changing the Assistant ID! That is the power of the Assistants API.\n\n\nA key feature of the Assistants API is the ability to equip our Assistants with Tools, like Code Interpreter, File Search, and custom Functions. Let's take a look at each.\n\n\nLet's equip our Math Tutor with the Code Interpreter tool, which we can do from the Dashboard...\n\nEnabling code interpreter\n\n...or the API, using the Assistant ID.\n\nNow, let's ask the Assistant to use its new tool.\n\nAnd that's it! The Assistant used Code Interpreter in the background, and gave us a final response.\n\nFor some use cases this may be enough – however, if we want more details on what precisely an Assistant is doing we can take a look at a Run's Steps.\n\n\nA Run is composed of one or more Steps. Like a Run, each Step has a status that you can query. This is useful for surfacing the progress of a Step to a user (e.g. a spinner while the Assistant is writing code or performing retrieval).\n\nLet's take a look at each Step's step_details.\n\nWe can see the step_details for two Steps:\n\ntool_calls (plural, since it could be more than one in a single Step)\nmessage_creation\n\nThe first Step is a tool_calls, specifically using the code_interpreter which contains:\n\ninput, which was the Python code generated before the tool was called, and\noutput, which was the result of running the Code Interpreter.\n\nThe second Step is a message_creation, which contains the message that was added to the Thread to communicate the results to the user.\n\n\nAnother powerful tool in the Assistants API is File search. This allows the uploading of files to the Assistant to be used as a knowledge base when answering questions.\n\nEnabling retrieval\nNote\nThere are more intricacies in File Search, like Annotations, which may be covered in another cookbook.\n\n\nAs a final powerful tool for your Assistant, you can specify custom Functions (much like the Function Calling in the Chat Completions API). During a Run, the Assistant can then indicate it wants to call one or more functions you specified. You are then responsible for calling the Function, and providing the output back to the Assistant.\n\nLet's take a look at an example by defining a display_quiz() Function for our Math Tutor.\n\nThis function will take a title and an array of questions, display the quiz, and get input from the user for each:\n\ntitle\nquestions\n  question_text\n  question_type: [MULTIPLE_CHOICE, FREE_RESPONSE]\n  choices: [\"choice 1\", \"choice 2\", ...]\n\nI'll mocking out responses with get_mock_response.... This is where you'd get the user's actual input.\n\nHere's what a sample quiz would look like:\n\nNow, let's define the interface of this function in JSON format, so our Assistant can call it:\n\nOnce again, let's update our Assistant either through the Dashboard or the API.\n\nEnabling custom function\nNote\nPasting the function JSON into the Dashboard was a bit finicky due to indentation, etc. I just asked ChatGPT to format my function the same as one of the examples on the Dashboard :).\n\nAnd now, we ask for a quiz.\n\nNow, however, when we check the Run's status we see requires_action! Let's take a closer.\n\nThe required_action field indicates a Tool is waiting for us to run it and submit its output back to the Assistant. Specifically, the display_quiz function! Let's start by parsing the name and arguments.\nNote\nWhile in this case we know there is only one Tool call, in practice the Assistant may choose to call multiple tools.\n\nNow let's actually call our display_quiz function with the arguments provided by the Assistant:\n\nGreat! (Remember these responses are the one's we mocked earlier. In reality, we'd be getting input from the back from this function call.)\n\nNow that we have our responses, let's submit them back to the Assistant. We'll need the tool_call ID, found in the tool_call we parsed out earlier. We'll also need to encode our listof responses into a str.\n\nWe can now wait for the Run to complete once again, and check our Thread!\n\nWoohoo 🎉\n\n\nWe covered a lot of ground in this notebook, give yourself a high-five! Hopefully you should now have a strong foundation to build powerful, stateful experiences with tools like Code Interpreter, Retrieval, and Functions!\n\nThere's a few sections we didn't cover for the sake of brevity, so here's a few resources to explore further:\n\nAnnotations: parsing file citations\nFiles: Thread scoped vs Assistant scoped\nParallel Function Calls: calling multiple tools in a single Step\nMulti-Assistant Thread Runs: single Thread with Messages from multiple Assistants\nStreaming: coming soon!\n\nNow go off and build something amazing!"])</script><script>self.__next_f.push([1,"c0:T14ca,"])</script><script>self.__next_f.push([1,"When working with language models, quite often all you need for solid performance is a good prompt and the right tools. However, when dealing with many unique flows, things may get hairy. This cookbook will walk through one way to tackle this.\n\nWe'll introduce the notion of routines and handoffs, then walk through the implementation and show how they can be used to orchestrate multiple agents in a simple, powerful, and controllable way.\n\nFinally, we provide a sample repo, Swarm, that implements these ideas along with examples.\n\nLet's start by setting up our imports.\n\nThe notion of a \"routine\" is not strictly defined, and instead meant to capture the idea of a set of steps. Concretely, let's define a routine to be a list of instructions in natural langauge (which we'll represent with a system prompt), along with the tools necessary to complete them.\n\n\n\nLet's take a look at an example. Below, we've defined a routine for a customer service agent instructing it to triage the user issue, then either suggest a fix or provide a refund. We've also defined the necessary functions execute_refund and look_up_item. We can call this a customer service routine, agent, assistant, etc – however the idea itself is the same: a set of steps and the tools to execute them.\nThe main power of routines is their simplicity and robustness. Notice that these instructions contain conditionals much like a state machine or branching in code. LLMs can actually handle these cases quite robustly for small and medium sized routine, with the added benefit of having \"soft\" adherance – the LLM can naturally steer the conversation without getting stuck in dead-ends.\n\n\n\nTo execute a routine, let's implement a simple loop that:\nGets user input.\nAppends user message to messages.\nCalls the model.\nAppends model response to messages.\n\nAs you can see, this currently ignores function calls, so let's add that.\n\nModels require functions to be formatted as a function schema. For convenience, we can define a helper function that turns python functions into the corresponding function schema.\nFor example:\nNow, we can use this function to pass the tools to the model when we call it.\nFinally, when the model calls a tool we need to execute the corresponding function and provide the result back to the model.\n\nWe can do this by mapping the name of the tool to the python function in a tool_map, then looking it up in execute_tool_call and calling it. Finally we add the result to the conversation.\nIn practice, we'll also want to let the model use the result to produce another response. That response might also contain a tool call, so we can just run this in a loop until there are no more tool calls.\n\nIf we put everything together, it will look something like this:\nNow that we have a routine, let's say we want to add more steps and more tools. We can up to a point, but eventually if we try growing the routine with too many different tasks it may start to struggle. This is where we can leverage the notion of multiple routines – given a user request, we can load the right routine with the appropriate steps and tools to address it.\n\nDynamically swapping system instructions and tools may seem daunting. However, if we view \"routines\" as \"agents\", then this notion of handoffs allow us to represent these swaps simply – as one agent handing off a conversation to another.\n\nLet's define a handoff as an agent (or routine) handing off an active conversation to another agent, much like when you get transfered to someone else on a phone call. Except in this case, the agents have complete knowledge of your prior conversation!\n\nTo see handoffs in action, let's start by defining a basic class for an Agent.\nNow to make our code support it, we can change run_full_turn to take an Agent instead of separate system_message and tools:\nWe can now run multiple agents easily:\nGreat! But we did the handoff manually here – we want the agents themselves to decide when to perform a handoff. A simple, but surprisingly effective way to do this is by giving them a transfer_to_XXX function, where XXX is some agent. The model is smart enough to know to call this function when it makes sense to make a handoff!\n\nNow that agent can express the intent to make a handoff, we must make it actually happen. There's many ways to do this, but there's one particularly clean way.\n\nFor the agent functions we've defined so far, like execute_refund or place_order they return a string, which will be provided to the model. What if instead, we return an Agent object to indicate which agent we want to transfer to? Like so:\nWe can then update our code to check the return type of a function response, and if it's an Agent, update the agent in use! Additionally, now run_full_turn will need to return the latest agent in use in case there are handoffs. (We can do this in a Response class to keep things neat.)\nNow for the updated run_full_turn:\nLet's look at an example with more Agents.\nFinally, we can run this in a loop (this won't run in python notebooks, so you can try this in a separate python file):\n\nAs a proof of concept, we've packaged these ideas into a sample library called Swarm. It is meant as an example only, and should not be directly used in production. However, feel free to take the ideas and code to build your own!"])</script><script>self.__next_f.push([1,"c1:Tf2d,"])</script><script>self.__next_f.push([1,"This notebook demonstrates how to  build a semantic search application  using OpenAI and MongoDB Atlas vector search\n\nThere are 2 pre-requisites for this:\n\nMongoDB Atlas cluster: To create a forever free MongoDB Atlas cluster, first, you need to create a MongoDB Atlas account if you don't already have one. Visit the MongoDB Atlas website and click on “Register.” Visit the MongoDB Atlas dashboard and set up your cluster. In order to take advantage of the $vectorSearch operator in an aggregation pipeline, you need to run MongoDB Atlas 6.0.11 or higher. This tutorial can be built using a free cluster. When you’re setting up your deployment, you’ll be prompted to set up a database user and rules for your network connection. Please ensure you save your username and password somewhere safe and have the correct IP address rules in place so your cluster can connect properly. If you need more help getting started, check out our tutorial on MongoDB Atlas.\n\nOpenAI API key   To create your OpenAI key, you'll need to create an account. Once you have that, visit the OpenAI platform. Click on your profile icon in the top right of the screen to get the dropdown menu and select “View API keys”.\n\nNote: After executing the step above you will be prompted to enter the credentials.\nFor this tutorial, we will be using the\nMongoDB sample dataset. Load the sample dataset using the Atlas UI. We'll be using the “sample_mflix” database, which contains a “movies” collection where each document contains fields like title, plot, genres, cast, directors, etc.\n\n\nEach document in the sample dataset sample_mflix.movies corresponds to a movie; we will execute an operation to create a vector embedding for the data in the \"plot\" field and store it in the database. Creating vector embeddings using OpenAI embeddings endpoint is necessary for performing a similarity search based on intent.\nAfter executing the above, the documents in \"movies\" collection will contain an additional field of \"embedding\", as defined by the EMBEDDDING_FIELD_NAME variable, apart from already existing fields like title, plot, genres, cast, directors, etc.\nNote: We are restricting this to just 500 documents in the interest of time. If you want to do this over the entire dataset of 23,000+ documents in our sample_mflix database, it will take a little while. Alternatively, you can use the sample_mflix.embedded_movies collection which includes a pre-populated plot_embedding field that contains embeddings created using OpenAI's text-embedding-3-small embedding model that you can use with the Atlas Search vector search feature.\n\n\n\n\nWe will create Atlas Vector Search Index on this collection which will allow us to perform the Approximate KNN search, which powers the semantic search.\nWe will cover 2 ways to create this index - Atlas UI and using MongoDB python driver.\n\n(Optional) Documentation: Create a Vector Search Index\nNow head over to Atlas UI and create an Atlas Vector Search index using the steps descibed here.  The 'dimensions' field with value 1536, corresponds to openAI text-embedding-ada002.\n\nUse the definition given below in the JSON editor on the Atlas UI.\n\n{\n  \"mappings\": {\n    \"dynamic\": true,\n    \"fields\": {\n      \"embedding\": {\n        \"dimensions\": 1536,\n        \"similarity\": \"dotProduct\",\n        \"type\": \"knnVector\"\n      }\n    }\n  }\n}\n(Optional) Alternatively, we can use pymongo driver to create these vector search indexes programatically\nThe python command given in the cell below will create the index (this only works for the most recent version of the Python Driver for MongoDB and MongoDB server version 7.0+ Atlas cluster).\n\nThe results for the query here finds movies which have semantically similar plots to the text captured in the query string, rather than being based on the keyword search.\n\n(Optional) Documentation: Run Vector Search Queries"])</script><script>self.__next_f.push([1,"c2:T1e5b,"])</script><script>self.__next_f.push([1,"In this notebook we will look into building an RAG pipeline and evaluating it with LlamaIndex. It has following 3 sections.\n\nUnderstanding Retrieval Augmented Generation (RAG).\nBuilding RAG with LlamaIndex.\nEvaluating RAG with LlamaIndex.\nRetrieval Augmented Generation (RAG)\n\nLLMs are trained on vast datasets, but these will not include your specific data. Retrieval-Augmented Generation (RAG) addresses this by dynamically incorporating your data during the generation process. This is done not by altering the training data of LLMs, but by allowing the model to access and utilize your data in real-time to provide more tailored and contextually relevant responses.\n\nIn RAG, your data is loaded and prepared for queries or “indexed”. User queries act on the index, which filters your data down to the most relevant context. This context and your query then go to the LLM along with a prompt, and the LLM provides a response.\n\nEven if what you’re building is a chatbot or an agent, you’ll want to know RAG techniques for getting data into your application.\nRAG Overview\nStages within RAG\n\nThere are five key stages within RAG, which in turn will be a part of any larger application you build. These are:\n\nLoading: this refers to getting your data from where it lives – whether it’s text files, PDFs, another website, a database, or an API – into your pipeline. LlamaHub provides hundreds of connectors to choose from.\n\nIndexing: this means creating a data structure that allows for querying the data. For LLMs this nearly always means creating vector embeddings, numerical representations of the meaning of your data, as well as numerous other metadata strategies to make it easy to accurately find contextually relevant data.\n\nStoring: Once your data is indexed, you will want to store your index, along with any other metadata, to avoid the need to re-index it.\n\nQuerying: for any given indexing strategy there are many ways you can utilize LLMs and LlamaIndex data structures to query, including sub-queries, multi-step queries and hybrid strategies.\n\nEvaluation: a critical step in any pipeline is checking how effective it is relative to other strategies, or when you make changes. Evaluation provides objective measures of how accurate, faithful and fast your responses to queries are.\n\nNow that we have understood the significance of RAG system, let's build a simple RAG pipeline.\nSet Your OpenAI API Key\nLet's use Paul Graham Essay text for building RAG pipeline.\nBuild a QueryEngine and start querying.\nCheck response.\nBy default it retrieves two similar nodes/ chunks. You can modify that in vector_index.as_query_engine(similarity_top_k=k).\n\nLet's check the text in each of these retrieved nodes.\nWe have built a RAG pipeline and now need to evaluate its performance. We can assess our RAG system/query engine using LlamaIndex's core evaluation modules. Let's examine how to leverage these tools to quantify the quality of our retrieval-augmented generation system.\n\nEvaluation should serve as the primary metric for assessing your RAG application. It determines whether the pipeline will produce accurate responses based on the data sources and a range of queries.\n\nWhile it's beneficial to examine individual queries and responses at the start, this approach may become impractical as the volume of edge cases and failures increases. Instead, it may be more effective to establish a suite of summary metrics or automated evaluations. These tools can provide insights into overall system performance and indicate specific areas that may require closer scrutiny.\n\nIn a RAG system, evaluation focuses on two critical aspects:\n\nRetrieval Evaluation:** This assesses the accuracy and relevance of the information retrieved by the system.\nResponse Evaluation:** This measures the quality and appropriateness of the responses generated by the system based on the retrieved information.\n\nFor the evaluation of a RAG system, it's essential to have queries that can fetch the correct context and subsequently generate an appropriate response. LlamaIndex offers a generate_question_context_pairs module specifically for crafting questions and context pairs which can be used in the assessment of the RAG system of both Retrieval and Response Evaluation. For more details on Question Generation, please refer to the documentation.\n\nWe are now prepared to conduct our retrieval evaluations. We will execute our RetrieverEvaluator using the evaluation dataset we have generated.\n\nWe first create the Retriever and then define two functions: get_eval_results, which operates our retriever on the dataset, and display_results, which presents the outcomes of the evaluation.\nLet's create the retriever.\nDefine RetrieverEvaluator. We use Hit Rate and MRR metrics to evaluate our Retriever.\n\nHit Rate:\n\nHit rate calculates the fraction of queries where the correct answer is found within the top-k retrieved documents. In simpler terms, it’s about how often our system gets it right within the top few guesses.\n\nMean Reciprocal Rank (MRR):\n\nFor each query, MRR evaluates the system’s accuracy by looking at the rank of the highest-placed relevant document. Specifically, it’s the average of the reciprocals of these ranks across all the queries. So, if the first relevant document is the top result, the reciprocal rank is 1; if it’s second, the reciprocal rank is 1/2, and so on.\n\nLet's check these metrics to check the performance of out retriever.\nLet's define a function to display the Retrieval evaluation results in table format.\n\nThe Retriever with OpenAI Embedding  demonstrates a performance with a hit rate of 0.7586, while the MRR, at 0.6206, suggests there's room for improvement in ensuring the most relevant results appear at the top. The observation that MRR is less than the hit rate indicates that the top-ranking results aren't always the most relevant. Enhancing MRR could involve the use of rerankers, which refine the order of retrieved documents. For a deeper understanding of how rerankers can optimize retrieval metrics, refer to the detailed discussion in our blog post.\n\nFaithfulnessEvaluator: Measures if the response from a query engine matches any source nodes which is useful for measuring if the response is hallucinated.\nRelevancy Evaluator: Measures if the response + source nodes match the query.\nLet's start with FaithfulnessEvaluator.\nWe will use gpt-3.5-turbo for generating response for a given query and gpt-4 for evaluation.\n\nLet's create service_context seperately for gpt-3.5-turbo and gpt-4.\nCreate a QueryEngine with gpt-3.5-turbo service_context to generate response for the query.\nCreate a  FaithfulnessEvaluator.\n\n\n\nLet's evaluate on one question.\nGenerate response first and use faithfull evaluator.\nRelevancyEvaluator is useful to measure if the response and source nodes (retrieved context) match the query. Useful to see if response actually answers the query.\nInstantiate RelevancyEvaluator for relevancy evaluation with gpt-4\nLet's do relevancy evaluation for one of the query.\n\nNow that we have done FaithFulness and Relevancy Evaluation independently. LlamaIndex has BatchEvalRunner to compute multiple evaluations in batch wise manner.\n\nFaithfulness score of 1.0 signifies that the generated answers contain no hallucinations and are entirely based on retrieved context.\n\nRelevancy score of 1.0 suggests that the answers generated are consistently aligned with the retrieved context and the queries.\nIn this notebook, we have explored how to build and evaluate a RAG pipeline using LlamaIndex, with a specific focus on evaluating the retrieval system and generated responses within the pipeline.\n\nLlamaIndex offers a variety of other evaluation modules as well, which you can explore further here"])</script><script>self.__next_f.push([1,"c3:T174a,"])</script><script>self.__next_f.push([1,"This notebook shows how to use LLMs in combination with Neo4j, a graph database, to perform Retrieval Augmented Generation (RAG).\n\n\nIf you want to use LLMs to generate answers based on your own content or knowledge base, instead of providing large context when prompting the model, you can fetch the relevant information in a database and use this information to generate a response.\n\nThis allows you to:\nReduce hallucinations\nProvide relevant, up to date information to your users\nLeverage your own content/knowledge base\n\n\nIf you have data where relationships between data points are important and you might want to leverage that, then it might be worth considering graph databases instead of traditional relational databases.\n\nGraph databases are good to address the following:\nNavigating deep hierarchies\nFinding hidden connections between items\nDiscovering relationships between items\n\n\nGraph databases are particularly relevant for recommendation systems, network relationships or analysing correlation between data points.\n\nExample use cases for RAG with graph databases include:\nRecommendation chatbot\nAI-augmented CRM\nTool to analyse customer behavior with natural language\n\nDepending on your use case, you can assess whether using a graph database makes sense.\n\nIn this notebook, we will build a product recommendation chatbot, with a graph database that contains Amazon products data.\n\n\nWe will start by installing and importing the relevant libraries.\n\nMake sure you have your OpenAI account set up and you have your OpenAI API key handy.\n\nWe will use a dataset that was created from a relational database and converted to a json format, creating relationships between entities with the completions API.\n\nWe will then load this data into the graph db to be able to query it.\n\nIn order to efficiently search our database for terms closely related to user queries, we need to use embeddings. To do this, we will create vector indexes on each type of property.\n\nWe will be using the OpenAIEmbeddings Langchain utility. It's important to note that Langchain adds a pre-processing step, so the embeddings will slightly differ from those generated directly with the OpenAI embeddings API.\nUsing GraphCypherQAChain, we can generate queries against the database using Natural Language.\n\nHowever, there is little added value here compared to just writing the Cypher queries ourselves, and it is prone to error.\n\nIndeed, asking an LLM to generate a Cypher query directly might result in the wrong parameters being used, whether it's the entity type or the relationship type, as is the case above.\n\nWe will instead use LLMs to decide what to search for, and then generate the corresponding Cypher queries using templates.\n\nFor this purpose, we will instruct our model to find relevant entities in the user prompt that can be used to query our database.\n\nNow that we know what to look for, we can generate the corresponding Cypher queries to query our database.\n\nHowever, the entities extracted might not be an exact match with the data we have, so we will use the GDS cosine similarity function to return products that have relationships with entities similar to what the user is asking.\n\nWe can then leverage the graph db to find similar products based on common characteristics.\n\nThis is where the use of a graph db really comes into play.\n\nFor example, we can look for products that are the same category and have another characteristic in common, or find products that have relationships to the same entities.\n\nThis criteria is arbitrary and completely depends on what is the most relevant in relation to your use case.\n\nNow that we have all the pieces working, we will stitch everything together.\n\nWe can also add a fallback option to do a product name/title similarity search if we can't find relevant entities in the user prompt.\n\nWe will explore 2 options, one with a Langchain agent for a conversational experience, and one that is more deterministic based on code only.\n\nDepending on your use case, you might choose one or the other option and tailor it to your needs.\n\nWe will create a Langchain agent to handle conversations and probing the user for more context.\n\nWe need to define exactly how the agent should behave, and give it access to our query and similarity search tools.\n\nAs our experiments show, using an agent for this type of task might not be the best option.\n\nIndeed, the agent seems to retrieve results from the tools, but comes up with made-up responses.\n\nFor this specific use case, if the conversational aspect is less relevant, we can actually create a function that will call our previously-defined tasks and provide an answer.\n\n\nWhen the primary objective is to extract specific information from our database, Large Language Models (LLMs) can significantly enhance our querying capabilities.\n\nHowever, it's crucial to base much of this process on robust code logic to ensure a foolproof user experience.\n\nFor crafting a genuinely conversational chatbot, further exploration in prompt engineering is necessary, possibly incorporating few-shot examples. This approach helps mitigate the risk of generating inaccurate or misleading information and ensures more precise responses.\n\nUltimately, the design choice depends on the desired user experience. For instance, if the aim is to create a visual recommendation system, the importance of a conversational interface is less relevant.\n\n\nRetrieving content from a knowledge graph adds complexity but can be useful if you want to leverage connections between items.\n\nThe querying part of this notebook would work on a relational database as well, the knowledge graph comes in handy when we want to couple the results with similar items that the graph is surfacing.\n\nConsidering the added complexity, make sure using a knowledge graph is the best option for your use case.\nIf it is the case, feel free to refine what this cookbook presents to match your needs and perform even better!"])</script><script>self.__next_f.push([1,"c4:T4c6,Supabase is an open-source Firebase alternative built on top of Postgres, a production-grade SQL database.\n\nSupabase Vector is a vector toolkit built on pgvector, a Postgres extension that allows you to store your embeddings inside the same database that holds the rest of your application data. When combined with pgvector's indexing algorithms, vector search remains fast at large scales.\n\nSupabase adds an ecosystem of services and tools on top of Postgres that makes app development as quick as possible, including:\n\nAuto-generated REST APIs\nAuto-generated GraphQL APIs\nRealtime APIs\nAuthentication\nFile storage\nEdge functions\n\nWe can use these services alongside pgvector to store and query embeddings within Postgres.\n\n\nBelow are guides and resources that walk you through how to use OpenAI embedding models with Supabase Vector.\n\n| Guide                                    | Description                                                |\n| ---------------------------------------- | ---------------------------------------------------------- |\n| Semantic search | Store, index, and query embeddings at scale using pgvector |\n\n\nVector columns\nVector indexes\nRAG with permissions\nGoing to production\nDeciding on computec5:T2aa7,"])</script><script>self.__next_f.push([1,"The purpose of this guide is to demonstrate how to store OpenAI embeddings in Supabase Vector (Postgres + pgvector) for the purposes of semantic search.\n\nSupabase is an open-source Firebase alternative built on top of Postgres, a production-grade SQL database. Since Supabase Vector is built on pgvector, you can store your embeddings within the same database that holds the rest of your application data. When combined with pgvector's indexing algorithms, vector search remains fast at large scales.\n\nSupabase adds an ecosystem of services and tools to make app development as quick as possible (such as an auto-generated REST API). We'll use these services to store and query embeddings within Postgres.\n\nThis guide covers:\n\nSetting up your database\nCreating a SQL table that can store vector data\nGenerating OpenAI embeddings using OpenAI's JavaScript client\nStoring the embeddings in your SQL table using the Supabase JavaScript client\nPerforming semantic search over the embeddings using a Postgres function and the Supabase JavaScript client\n\n\nFirst head over to https://database.new to provision your Supabase database. This will create a Postgres database on the Supabase cloud platform. Alternatively, you can follow the local development options if you prefer to run your database locally using Docker.\n\nIn the studio, jump to the SQL editor and execute the following SQL to enable pgvector:\n\n-- Enable the pgvector extension\ncreate extension if not exists vector;\nIn a production application, the best practice is to use database migrations so that all SQL operations are managed within source control. To keep things simple in this guide, we'll execute queries directly in the SQL Editor. If you are building a production app, feel free to move these into a database migration.\n\n\nNext we'll create a table to store documents and embeddings. In the SQL Editor, run:\n\ncreate table documents (\n  id bigint primary key generated always as identity,\n  content text not null,\n  embedding vector (1536) not null\n);\n\nSince Supabase is built on Postgres, we're just using regular SQL here. You can modify this table however you like to better fit your application. If you have existing database tables, you can simply add a new vector column to the appropriate table.\n\nThe important piece to understand is the vector data type, which is a new data type that became available when we enabled the pgvector extension earlier. The size of the vector (1536 here) represents the number of dimensions in the embedding. Since we're using OpenAI's text-embedding-3-small model in this example, we set the vector size to 1536.\n\nLet's go ahead and create a vector index on this table so that future queries remain performant as the table grows:\n\ncreate index on documents using hnsw (embedding vector_ip_ops);\n\nThis index uses the HNSW algorithm to index vectors stored in the embedding column, and specifically when using the inner product operator (``). We'll explain more about this operator later when we implement our match function.\n\nLet's also follow security best practices by enabling row level security on the table:\n\nalter table documents enable row level security;\n\nThis will prevent unauthorized access to this table through the auto-generated REST API (more on this shortly).\n\n\nThis guide uses JavaScript to generate embeddings, but you can easily modify it to use any language supported by OpenAI.\n\nIf you are using JavaScript, feel free to use whichever server-side JavaScript runtime that you prefer (Node.js, Deno, Supabase Edge Functions).\n\nIf you're using Node.js, first install openai as a dependency:\n\nnpm install openai\n\nthen import it:\n\nimport OpenAI from \"openai\";\n\nIf you're using Deno or Supabase Edge Functions, you can import openai directly from a URL:\n\nimport OpenAI from \"https://esm.sh/openai@4\";\nIn this example we import from https://esm.sh which is a CDN that automatically fetches the respective NPM module for you and serves it over HTTP.\n\nNext we'll generate an OpenAI embedding using text-embedding-3-small:\n\nconst openai = new OpenAI();\n\nconst input = \"The cat chases the mouse\";\n\nconst result = await openai.embeddings.create({\n  input,\n  model: \"text-embedding-3-small\",\n});\n\nconst [{ embedding }] = result.data;\n\nRemember that you will need an OpenAI API key to interact with the OpenAI API. You can pass this as an environment variable called OPENAI_API_KEY, or manually set it when you instantiate your OpenAI client:\n\nconst openai = new OpenAI({\n  apiKey: \"\",\n});\n\nRemember:** Never hard-code API keys in your code. Best practice is to either store it in a .env file and load it using a library like dotenv or load it from an external key management system._\n\n\nSupabase comes with an auto-generated REST API that dynamically builds REST endpoints for each of your tables. This means you don't need to establish a direct Postgres connection to your database - instead you can interact with it simply using by the REST API. This is especially useful in serverless environments that run short-lived processes where re-establishing a database connection every time can be expensive.\n\nSupabase comes with a number of client libraries to simplify interaction with the REST API. In this guide we'll use the JavaScript client library, but feel free to adjust this to your preferred language.\n\nIf you're using Node.js, install @supabase/supabase-js as a dependency:\n\nnpm install @supabase/supabase-js\n\nthen import it:\n\nimport { createClient } from \"@supabase/supabase-js\";\n\nIf you're using Deno or Supabase Edge Functions, you can import @supabase/supabase-js directly from a URL:\n\nimport { createClient } from \"https://esm.sh/@supabase/supabase-js@2\";\n\nNext we'll instantiate our Supabase client and configure it so that it points to your Supabase project. In this guide we'll store a reference to your Supabase URL and key in a .env file, but feel free to modify this based on how your application handles configuration.\n\nIf you are using Node.js or Deno, add your Supabase URL and service role key to a .env file. If you are using the cloud platform, you can find these from your Supabase dashboard settings page. If you're running Supabase locally, you can find these by running npx supabase status in a terminal.\n\n.env\n\nSUPABASE_URL=\nSUPABASE_SERVICE_ROLE_KEY=\n\nIf you are using Supabase Edge Functions, these environment variables are automatically injected into your function for you so you can skip the above step.\n\nNext we'll pull these environment variables into our app.\n\nIn Node.js, install the dotenv dependency:\n\nnpm install dotenv\n\nAnd retrieve the environment variables from process.env:\n\nimport { config } from \"dotenv\";\n\n// Load .env file\nconfig();\n\nconst supabaseUrl = process.env[\"SUPABASE_URL\"];\nconst supabaseServiceRoleKey = process.env[\"SUPABASE_SERVICE_ROLE_KEY\"];\n\nIn Deno, load the .env file using the dotenv standard library:\n\nimport { load } from \"https://deno.land/std@0.208.0/dotenv/mod.ts\";\n\n// Load .env file\nconst env = await load();\n\nconst supabaseUrl = env[\"SUPABASE_URL\"];\nconst supabaseServiceRoleKey = env[\"SUPABASE_SERVICE_ROLE_KEY\"];\n\nIn Supabase Edge Functions, simply load the injected environment variables directly:\n\nconst supabaseUrl = Deno.env.get(\"SUPABASE_URL\");\nconst supabaseServiceRoleKey = Deno.env.get(\"SUPABASE_SERVICE_ROLE_KEY\");\n\nNext let's instantiate our supabase client:\n\nconst supabase = createClient(supabaseUrl, supabaseServiceRoleKey, {\n  auth: { persistSession: false },\n});\n\nFrom here we use the supabase client to insert our text and embedding (generated earlier) into the database:\n\nconst { error } = await supabase.from(\"documents\").insert({\n  content: input,\n  embedding,\n});\nIn production, best practice would be to check the response error to see if there were any problems inserting the data and handle it accordingly.\n\n\nFinally let's perform semantic search over the embeddings in our database. At this point we'll assume your documents table has been filled with multiple records that we can search over.\n\nLet's create a match function in Postgres that performs the semantic search query. Execute the following in the SQL Editor:\n\ncreate function match_documents (\n  query_embedding vector (1536),\n  match_threshold float,\n)\nreturns setof documents\nlanguage plpgsql\nas $$\nbegin\n  return query\n  select *\n  from documents\n  where documents.embedding  query_embedding  query_embedding;\nend;\n$$;\n\nThis function accepts a query_embedding which represents the embedding generated from the search query text (more on this shortly). It also accepts a match_threshold which specifies how similar the document embeddings have to be in order for query_embedding to count as a match.\n\nInside the function we implement the query which does two things:\n\nFilters the documents to only include those who's embeddings match within the above match_threshold. Since the ` operator performs the negative inner product (versus positive inner product), we negate the similarity threshold before comparing. This means a match_threshold` of 1 is most similar, and -1 is most dissimilar.\nOrders the documents by negative inner product (``) ascending. This allows us to retrieve documents that match closest first.\nSince OpenAI embeddings are normalized, we opted to use inner product (`) because it is slightly more performant than other operators like cosine distance (`). It is important to note though this only works because the embeddings are normalized - if they weren't, cosine distance should be used.\n\nNow we can call this function from our application using the supabase.rpc() method:\n\nconst query = \"What does the cat chase?\";\n\n// First create an embedding on the query itself\nconst result = await openai.embeddings.create({\n  input: query,\n  model: \"text-embedding-3-small\",\n});\n\nconst [{ embedding }] = result.data;\n\n// Then use this embedding to search for matches\nconst { data: documents, error: matchError } = await supabase\n  .rpc(\"match_documents\", {\n    query_embedding: embedding,\n    match_threshold: 0.8,\n  })\n  .select(\"content\")\n  .limit(5);\n\nIn this example, we set a match threshold to 0.8. Adjust this threshold based on what works best with your data.\n\nNote that since match_documents returns a set of documents, we can treat this rpc() like a regular table query. Specifically this means we can chain additional commands to this query, like select() and limit(). Here we select just the columns we care about from the documents table (content), and we limit the number of documents returned (max 5 in this example).\n\nAt this point you have a list of documents that matched the query based on semantic relationship, ordered by most similar first.\n\n\nYou can use this example as the foundation for other semantic search techniques, like retrieval augmented generation (RAG).\n\nFor more information on OpenAI embeddings, read the Embedding docs.\n\nFor more information on Supabase Vector, read the AI \u0026 Vector docs."])</script><script>self.__next_f.push([1,"c6:T226a,"])</script><script>self.__next_f.push([1,"In this notebook we share examples of how to implement guardrails for your LLM applications. A guardrail is a generic term for detective controls that aim to steer your application. Greater steerability is a common requirement given the inherent randomness of LLMs, and so creating effective guardrails has become one of the most common areas of performance optimization when pushing an LLM from prototype to production.\n\nGuardrails are incredibly diverse and can be deployed to virtually any context you can imagine something going wrong with LLMs. This notebook aims to give simple examples that can be extended to meet your unique use case, as well as outlining the trade-offs to consider when deciding whether to implement a guardrail, and how to do it.\n\nThis notebook will focus on:\nInput guardrails that flag inappropriate content before it gets to your LLM\nOutput guardrails that validate what your LLM has produced before it gets to the customer\n\nNote: This notebook tackles guardrails as a generic term for detective controls around an LLM - for the official libraries that provide distributions of pre-built guardrails frameworks, please check out the following:\nNeMo Guardrails\nGuardrails AI\n\n\nInput guardrails aim to prevent inappropriate content getting to the LLM in the first place - some common use cases are:\nTopical guardrails:** Identify when a user asks an off-topic question and give them advice on what topics the LLM can help them with.\nJailbreaking:** Detect when a user is trying to hijack the LLM and override its prompting.\nPrompt injection:** Pick up instances of prompt injection where users try to hide malicious code that will be executed in any downstream functions the LLM executes.\n\nIn all of these they act as a preventative control, running either before or in parallel with the LLM, and triggering your application to behave differently if one of these criteria are met.\n\n\nWhen designing guardrails it is important to consider the trade-off between accuracy, latency and cost, where you try to achieve maximum accuracy for the least impact to your bottom line and the user's experience.\n\nWe'll begin with a simple topical guardrail which aims to detect off-topic questions and prevent the LLM from answering if triggered. This guardrail consists of a simple prompt and uses gpt-4o-mini, maximising latency/cost holding a good enough accuracy, but if we wanted to optimize further we could consider:\nAccuracy:** You could consider fine-tuning gpt-4o-mini or few-shot examples to increase the accuracy. RAG can also be effective if you have a corpus of information that can help determine whether a piece of content is allowed or not.\nLatency/Cost:** You could try fine-tuning smaller models, such as babbage-002 or open-source offerings like Llama, which can perform quite well when given enough training examples. When using open-source offerings you can also tune the machines you are using for inference to maximize either cost or latency reduction.\n\nThis simple guardrail aims to ensure the LLM only answers to a predefined set of topics, and responds to out-of-bounds queries with a canned message.\n\n\nA common design to minimize latency is to send your guardrails asynchronously along with your main LLM call. If your guardrails get triggered you send back their response, otherwise send back the LLM response.\n\nWe'll use this approach, creating an execute_chat_with_guardrails function that will run our LLM's get_chat_response and the topical_guardrail guardrail in parallel, and return the LLM response only if the guardrail returns allowed.\n\n\nYou should always consider the limitations of guardrails when developing your design. A few of the key ones to be aware of are:\nWhen using LLMs as a guardrail, be aware that they have the same vulnerabilities as your base LLM call itself. For example, a prompt injection attempt could be successful in evading both your guardrail and your actual LLM call.\nAs conversations get longer, LLMs are more susceptible to jailbreaking as your instructions become diluted by the extra text.\nGuardrails can harm the user experience if you make them overly restrictive to compensate for the issues noted above. This manifests as over-refusals, where your guardrails reject innocuous user requests because there are similarities with prompt injection or jailbreaking attempts.\n\n\nIf you can combine guardrails with rules-based or more traditional machine learning models for detection this can mitigate some of these risks. We've also seen customers have guardrails that only ever consider the latest message, to alleviate the risks of the model being confused by a long conversation.\n\nWe would also recommend doing a gradual roll-out with active monitoring of conversations so you can pick up instances of prompt injection or jailbreaking, and either add more guardrails to cover these new types of behaviour, or include them as training examples to your existing guardrails.\nLooks like our guardrail worked - the first question was allowed through, but the second was blocked for being off-topic. Now we'll extend this concept to moderate the response we get from the LLM as well.\n\nOutput guardrails govern what the LLM comes back with. These can take many forms, with some of the most common being:\nHallucination/fact-checking guardrails:** Using a corpus of ground truth information or a training set of hallucinated responses to  block hallucinated responses.\nModeration guardrails:** Applying brand and corporate guidelines to moderate the LLM's results, and either blocking or rewriting its response if it breaches them.\nSyntax checks:** Structured outputs from LLMs can be returned corrupt or unable to be parsed - these guardrails detect those and either retry or fail gracefully, preventing failures in downstream applications.\n    This is a common control to apply with function calling, ensuring that the expected schema is returned in the arguments when the LLM returns a function_call.\n\n\nHere we implement a moderation guardrail that uses a version of the G-Eval evaluation method to score the presence of unwanted content in the LLM's response. This method is demonstrated in more detail in of our other notebooks.\n\nTo accomplish this we will make an extensible framework for moderating content that takes in a domain and applies criteria to a piece of content using a set of steps:\nWe set a domain name, which describes the type of content we're going to moderate.\nWe provide criteria, which outline clearly what the content should and should not contain.\nStep-by-step instructions are provided for the LLM to grade the content.\nThe LLM returns a discrete score from 1-5.\n\n\nOur output guardrail will assess the LLM's response and block anything scoring a 3 or higher. Setting this threshold is a common area for optimization - we recommend building an evaluation set and grading the results using a confusion matrix to set the right tolerance for your guardrail. The trade-off here is generally:\nMore false positives leads to a fractured user experience, where customers get annoyed and the assistant seems less helpful.\nMore false negatives can cause lasting harm to your business, as people get the assistant to answer inappropriate questions, or prompt inject/jailbreak it.\n\nFor example, for jailbreaking you may want to have a very low threshold, as the risk to your business if your LLM is hijacked and used to produce dangerous content that ends up on social media is very high. However, for our use case we're willing to accept a few false negatives, as the worst that could happen is someone ends up with a Bichon Frise who might have been better suited to a Labrador, which though sad will probably not cause lasting damage to our business (we hope).\n\nGuardrails are a vibrant and evolving topic in LLMs, and we hope this notebook has given you an effective introduction to the core concepts around guardrails. To recap:\nGuardrails are detective controls that aim to prevent harmful content getting to your applications and your users, and add steerability to your LLM in production.\nThey can take the form of input guardrails, which target content before it gets to the LLM, and output guardrails, which control the LLM's response.\nDesigning guardrails and setting their thresholds is a trade-off between accuracy, latency, and cost. Your decision should be based on clear evaluations of the performance of your guardrails, and an understanding of what the cost of a false negative and false positive are for your business.\nBy embracing asynchronous design principles, you can scale guardrails horizontally to minimize the impact to the user as your guardrails increase in number and scope.\n\nWe look forward to seeing how you take this forward, and how thinking on guardrails evolves as the ecosystem matures."])</script><script>self.__next_f.push([1,"c7:T318a,"])</script><script>self.__next_f.push([1,"Welcome to the Clothing Matchmaker App Jupyter Notebook! This project demonstrates the power of the GPT-4o mini model in analyzing images of clothing items and extracting key features such as color, style, and type. The core of our app relies on this advanced image analysis model developed by OpenAI, which enables us to accurately identify the characteristics of the input clothing item.\n\nGPT-4o mini is a small model that combines natural language processing with image recognition, allowing it to understand and generate responses based on both text and visual inputs with low latency.\n\nBuilding on the capabilities of the GPT-4o mini model, we employ a custom matching algorithm and the RAG technique to search our knowledge base for items that complement the identified features. This algorithm takes into account factors like color compatibility and style coherence to provide users with suitable recommendations. Through this notebook, we aim to showcase the practical application of these technologies in creating a clothing recommendation system.\n\nUsing the combination of GPT-4o mini + RAG (Retrieval-Augmented Generation) offers several advantages:\n\nContextual Understanding: GPT-4o mini can analyze input images and understand the context, such as the objects, scenes, and activities depicted. This allows for more accurate and relevant suggestions or information across various domains, whether it's interior design, cooking, or education.\nRich Knowledge Base: RAG combines the generative capabilities of GPT-4 with a retrieval component that accesses a large corpus of information across different fields. This means the system can provide suggestions or insights based on a wide range of knowledge, from historical facts to scientific concepts.\nCustomization: The approach allows for easy customization to cater to specific user needs or preferences in various applications. Whether it's tailoring suggestions to a user's taste in art or providing educational content based on a student's learning level, the system can be adapted to deliver personalized experiences.\n\nOverall, the GPT-4o mini + RAG approach offers a fast, powerful, and flexible solution for various fashion-related applications, leveraging the strengths of both generative and retrieval-based AI techniques.\n\nFirst we will install the necessary dependencies, then import the libraries and write some utility functions that we will use later on.\nWe will now set up the knowledge base by choosing a database and generating embeddings for it. I am using the sample_styles.csv file for this in the data folder. This is a sample of a bigger dataset that contains ~44K items. This step can also be replaced by using an out-of-the-box vector database. For example, you can follow one of these cookbooks to set up your vector database.\nNow we will generate embeddings for the entire dataset. We can parallelize the execution of these embeddings to ensure that the script scales up for larger datasets. With this logic, the time to create embeddings for the full 44K entry dataset decreases from 4h to 2-3min.\nThe next line will create the embeddings for the sample clothes dataset. This will take around 0.02s to process and another ~30s to write the results to a local .csv file. The process is using our text_embedding_3_large model which is priced at $0.00013/1K tokens. Given that the dataset has around 1K entries, the following operation will cost approximately $0.001. If you decide to work with the entire dataset of 44K entries, this operation will take 2-3min to process and it will cost approximately $0.07.\n\nIf you would not like to proceed with creating your own embeddings, we will use a dataset of pre-computed embeddings. You can skip this cell and uncomment the code in the following cell to proceed with loading the pre-computed vectors. This operation takes ~1min to load all the data in memory.\n\nIn this section, we'll develop a cosine similarity retrieval algorithm to find similar items in our dataframe. We'll utilize our custom cosine similarity function for this purpose. While the sklearn library offers a built-in cosine similarity function, recent updates to its SDK have led to compatibility issues, prompting us to implement our own standard cosine similarity calculation.\n\nIf you already have a vector database set up, you can skip this step. Most standard databases come with their own search functions, which simplify the subsequent steps outlined in this guide. However, we aim to demonstrate that the matching algorithm can be tailored to meet specific requirements, such as a particular threshold or a specified number of matches returned.\n\nThe find_similar_items function accepts four parameters:\nembedding: The embedding for which we want to find a match.\nembeddings: A list of embeddings to search through for the best matches.\nthreshold (optional): This parameter specifies the minimum similarity score for a match to be considered valid. A higher threshold results in closer (better) matches, while a lower threshold allows for more items to be returned, though they may not be as closely matched to the initial embedding.\ntop_k (optional): This parameter determines the number of items to return that exceed the given threshold. These will be the top-scoring matches for the provided embedding.\n\nIn this module, we leverage gpt-4o-mini to analyze input images and extract important features like detailed descriptions, styles, and types. The analysis is performed through a straightforward API call, where we provide the URL of the image for analysis and request the model to identify relevant features.\n\nTo ensure the model returns accurate results, we use specific techniques in our prompt:\n\nOutput Format Specification: We instruct the model to return a JSON block with a predefined structure, consisting of:\n   items (str[]): A list of strings, each representing a concise title for an item of clothing, including style, color, and gender. These titles closely resemble the productDisplayName property in our original database.\n   category (str): The category that best represents the given item. The model selects from a list of all unique articleTypes present in the original styles dataframe.\n   gender (str): A label indicating the gender the item is intended for. The model chooses from the options [Men, Women, Boys, Girls, Unisex].\n\nClear and Concise Instructions:\n   We provide clear instructions on what the item titles should include and what the output format should be. The output should be in JSON format, but without the json tag that the model response normally contains.\n\nOne Shot Example:\n   To further clarify the expected output, we provide the model with an example input description and a corresponding example output. Although this may increase the number of tokens used (and thus the cost of the call), it helps to guide the model and results in better overall performance.\n\nBy following this structured approach, we aim to obtain precise and useful information from the gpt-4o-mini model for further analysis and integration into our database.\n\nTo evaluate the effectiveness of our prompt, let's load and test it with a selection of images from our dataset. We'll use images from the \"data/sample_clothes/sample_images\" folder, ensuring a variety of styles, genders, and types. Here are the chosen samples:\n\n2133.jpg: Men's shirt\n7143.jpg: Women's shirt\n4226.jpg: Casual men's printed t-shirt\n\nBy testing the prompt with these diverse images, we can assess its ability to accurately analyze and extract relevant features from different types of clothing items and accessories.\nWe need a utility function to encode the .jpg images in base64\nNext, we process the output from the image analysis and use it to filter and display matching items from our dataset. Here's a breakdown of the code:\n\nExtracting Image Analysis Results: We extract the item descriptions, category, and gender from the image_analysis dictionary.\n\nFiltering the Dataset: We filter the styles_df DataFrame to include only items that match the gender from the image analysis (or are unisex) and exclude items of the same category as the analyzed image.\n\nFinding Matching Items: We use the find_matching_items_with_rag function to find items in the filtered dataset that match the descriptions extracted from the analyzed image.\n\nDisplaying Matching Items: We create an HTML string to display images of the matching items. We construct the image paths using the item IDs and append each image to the HTML string. Finally, we use display(HTML(html)) to render the images in the notebook.\n\nThis cell effectively demonstrates how to use the results of image analysis to filter a dataset and visually display items that match the analyzed image's characteristics.\n\nIn the context of using Large Language Models (LLMs) like GPT-4o mini, \"guardrails\" refer to mechanisms or checks put in place to ensure that the model's output remains within desired parameters or boundaries. These guardrails are crucial for maintaining the quality and relevance of the model's responses, especially when dealing with complex or nuanced tasks.\n\nGuardrails are useful for several reasons:\n\nAccuracy: They help ensure that the model's output is accurate and relevant to the input provided.\nConsistency: They maintain consistency in the model's responses, especially when dealing with similar or related inputs.\nSafety: They prevent the model from generating harmful, offensive, or inappropriate content.\nContextual Relevance: They ensure that the model's output is contextually relevant to the specific task or domain it is being used for.\n\nIn our case, we are using GPT-4o mini to analyze fashion images and suggest items that would complement an original outfit. To implement guardrails, we can refine results: After obtaining initial suggestions from GPT-4o mini, we can send the original image and the suggested items back to the model. We can then ask GPT-4o mini to evaluate whether each suggested item would indeed be a good fit for the original outfit.\n\nThis gives the model the ability to self-correct and adjust its own output based on feedback or additional information. By implementing these guardrails and enabling self-correction, we can enhance the reliability and usefulness of the model's output in the context of fashion analysis and recommendation.\n\nTo facilitate this, we write a prompt that asks the LLM for a simple \"yes\" or \"no\" answer to the question of whether the suggested items match the original outfit or not. This binary response helps streamline the refinement process and ensures clear and actionable feedback from the model.\nFinally, let's determine which of the items identified above truly complement the outfit.\nWe can observe that the initial list of potential items has been further refined, resulting in a more curated selection that aligns well with the outfit. Additionally, the model provides explanations for why each item is considered a good match, offering valuable insights into the decision-making process.\n\nIn this Jupyter Notebook, we explored the application of GPT-4o mini and other machine learning techniques to the domain of fashion. We demonstrated how to analyze images of clothing items, extract relevant features, and use this information to find matching items that complement an original outfit. Through the implementation of guardrails and self-correction mechanisms, we refined the model's suggestions to ensure they are accurate and contextually relevant.\n\nThis approach has several practical uses in the real world, including:\n\nPersonalized Shopping Assistants: Retailers can use this technology to offer personalized outfit recommendations to customers, enhancing the shopping experience and increasing customer satisfaction.\nVirtual Wardrobe Applications: Users can upload images of their own clothing items to create a virtual wardrobe and receive suggestions for new items that match their existing pieces.\nFashion Design and Styling: Fashion designers and stylists can use this tool to experiment with different combinations and styles, streamlining the creative process.\n\nHowever, one of the considerations to keep in mind is cost. The use of LLMs and image analysis models can incur costs, especially if used extensively. It's important to consider the cost-effectiveness of implementing these technologies. gpt-4o-mini is priced at $0.01 per 1000 tokens. This adds up to $0.00255 for one 256px x 256px image.\n\nOverall, this notebook serves as a foundation for further exploration and development in the intersection of fashion and AI, opening doors to more personalized and intelligent fashion recommendation systems."])</script><script>self.__next_f.push([1,"c8:Tcf3,"])</script><script>self.__next_f.push([1,"This notebook shows how to leverage GPT-4o to turn rich PDF documents such as slide decks or exports from web pages into usable content for your RAG application.\n\nThis technique can be used if you have a lot of unstructured data containing valuable information that you want to be able to retrieve as part of your RAG pipeline.\n\nFor example, you could build a Knowledge Assistant that could answer user queries about your company or product based on information contained in PDF documents.\n\nThe example documents used in this notebook are located at data/example_pdfs. They are related to OpenAI's APIs and various techniques that can be used as part of LLM projects.\n\nIn this section, we will process our input data to prepare it for retrieval.\n\nWe will do this in 2 ways:\n\nExtracting text with pdfminer\nConverting the PDF pages to images to analyze them with GPT-4o\n\nYou can skip the 1st method if you want to only use the content inferred from the image analysis.\n\nWe need to install a few libraries to convert the PDF to images and extract the text (optional).\n\nNote: You need to install poppler on your machine for the pdf2image library to work. You can follow the instructions to install it here.\n\nAfter converting a PDF file to multiple images, we'll use GPT-4o to analyze the content based on the images.\nWe will list all files in the example folder and process them by\nExtracting the text\nConverting the docs to images\nAnalyzing pages with GPT-4o\n\nNote: This takes about ~2 mins to run. Feel free to skip and load directly the result file (see below).\nBefore embedding the content, we will chunk it logically by page.\nFor real-world scenarios, you could explore more advanced ways to chunk the content:\nCutting it into smaller pieces\nAdding data - such as the slide title, deck title and/or the doc description - at the beginning of each piece of content. That way, each independent chunk can be in context\n\nFor the sake of brevity, we will use a very simple chunking strategy and rely on separators to split the text by page.\n\nThe last step of the process is to generate outputs in response to input queries, after retrieving content as context to reply.\n\nIn this notebook, we have learned how to develop a basic RAG pipeline based on PDF documents. This includes:\n\nHow to parse pdf documents, taking slide decks and an export from an HTML page as examples, using a python library as well as GPT-4o to interpret the visuals\nHow to process the extracted content, clean it and chunk it into several pieces\nHow to embed the processed content using OpenAI embeddings\nHow to retrieve content that is relevant to an input query\nHow to use GPT-4o to generate an answer using the retrieved content as context\n\nIf you want to explore further, consider these optimisations:\n\nPlaying around with the prompts provided as examples\nChunking the content further and adding metadata as context to each chunk\nAdding rule-based filtering on the retrieval results or re-ranking results to surface to most relevant content\n\nYou can apply the techniques covered in this notebook to multiple use cases, such as assistants that can access your proprietary data, customer service or FAQ bots that can read from your internal policies, or anything that requires leveraging rich documents that would be better understood as images."])</script><script>self.__next_f.push([1,"c9:Tef2,"])</script><script>self.__next_f.push([1,"This notebook explores how to leverage the vision capabilities of the GPT-4* models (for example gpt-4o, gpt-4o-mini or gpt-4-turbo) to tag \u0026 caption images.\n\nWe can leverage the multimodal capabilities of these models to provide input images along with additional context on what they represent, and prompt the model to output tags or image descriptions. The image descriptions can then be further refined with a language model (in this notebook, we'll use gpt-4o-mini) to generate captions.\n\nGenerating text content from images can be useful for multiple use cases, especially use cases involving search.\nWe will illustrate a search use case in this notebook by using generated keywords and product captions to search for products - both from a text input and an image input.\n\nAs an example, we will use a dataset of Amazon furniture items, tag them with relevant keywords and generate short, descriptive captions.\n\nIn this section, we'll use GPT-4o mini to generate relevant tags for our products.\n\nWe'll use a simple zero-shot approach to extract keywords, and deduplicate those keywords using embeddings to avoid having multiple keywords that are too similar.\n\nWe will use a combination of an image and the product title to avoid extracting keywords for other items that are depicted in the image - sometimes there are multiple items used in the scene and we want to focus on just the one we want to tag.\n\nUsing embeddings to avoid duplicates (synonyms) and/or match pre-defined keywords\n\nIn this section, we'll use GPT-4o mini to generate an image description and then use a few-shot examples approach with GPT-4-turbo to generate captions from the images.\n\nIf few-shot examples are not enough for your use case, consider fine-tuning a model to get the generated captions to match the style \u0026 tone you are targeting.\nUsing a few-shot examples approach to turn a long description into a short image caption\n\nIn this section, we will use generated keywords and captions to search items that match a given input, either text or image.\n\nWe will leverage our embeddings model to generate embeddings for the keywords and captions and compare them to either input text or the generated caption from an input image.\nProcessing all 312 lines of the dataset will take a while.\nTo test out the idea, we will only run it on the first 50 lines: this takes ~20 mins.\nFeel free to skip this step and load the already processed dataset (see below).\nWe can now use the generated captions and keywords to match relevant content to an input text query or caption.\nTo do this, we will embed a combination of keywords + captions.\nNote: creating the embeddings will take ~3 mins to run. Feel free to load the pre-processed dataset (see below).\n\nWe can compare the input text from a user directly to the embeddings we just created.\n\nIf the input is an image, we can find similar images by first turning images into captions, and embedding those captions to compare them to the already created embeddings.\n\n\nIn this notebook, we explored how to leverage the multimodal capabilities of gpt-4o-mini to tag and caption images. By providing images along with contextual information to the model, we were able to generate tags and descriptions that can be further refined to create captions. This process has practical applications in various scenarios, particularly in enhancing search functionalities.\n\nThe search use case illustrated can be directly applied to applications such as recommendation systems, but the techniques covered in this notebook can be extended beyond items search and used in multiple use cases, for example RAG applications leveraging unstructured image data.\n\nAs a next step, you could explore using a combination of rule-based filtering with keywords and embeddings search with captions to retrieve more relevant results."])</script><script>self.__next_f.push([1,"ca:T2ab5,"])</script><script>self.__next_f.push([1,"Note: This guide is designed to complement our Guardrails Cookbook by providing a more focused look at moderation techniques. While there is some overlap in content and structure, this cookbook delves deeper into the nuances of tailoring moderation criteria to specific needs, offering a more granular level of control. If you're interested in a broader overview of content safety measures, including guardrails and moderation, we recommend starting with the Guardrails Cookbook. Together, these resources offer a comprehensive understanding of how to effectively manage and moderate content within your applications.\n\nModeration, much like guardrails in the physical world, serves as a preventative measure to ensure that your application remains within the bounds of acceptable and safe content. Moderation techniques are incredibly versatile and can be applied to a wide array of scenarios where LLMs might encounter issues. This notebook is designed to offer straightforward examples that can be adapted to suit your specific needs, while also discussing the considerations and trade-offs involved in deciding whether to implement moderation and how to go about it. This notebook will use our Moderation API, a tool you can use to check whether text or an image is potentially harmful.\n\nThis notebook will concentrate on:\n\nInput Moderation:** Identifying and flagging inappropriate or harmful content before it is processed by your LLM.\nOutput Moderation:** Reviewing and validating the content generated by your LLM before it reaches the end user.\nCustom Moderation:** Tailoring moderation criteria and rules to suit the specific needs and context of your application, ensuring a personalized and effective content control mechanism.\n\nInput Moderation focuses on preventing harmful or inappropriate content from reaching the LLM, with common applications including:\nContent Filtering:** Prevent the spread of harmful content such as hate speech, harassment, explicit material, and misinformation on social media, forums, and content creation platforms.\nCommunity Standards Enforcement:** Ensure that user interactions, such as comments, forum posts, and chat messages, adhere to the community guidelines and standards of online platforms, including educational environments, gaming communities, or dating apps.\nSpam and Fraud Prevention:** Filter out spam, fraudulent content, and misleading information in online forums, comment sections, e-commerce platforms, and customer reviews.\n\nThese measures act as preventive controls, operating before or alongside the LLM to alter your application's behavior if specific criteria are met.\nA common design to minimize latency is to send your moderations asynchronously along with your main LLM call. If your moderation gets triggered you send back a placeholder response, otherwise send back the LLM response. This pattern can also be found in our Guardrails Cookbook. It's important to note that while the async mode is effective in minimizing latency, it can also lead to unnecessary costs. Specifically, you could avoid completion costs if the content is flagged before processing. Therefore, it's crucial to balance the benefits of reduced latency with the potential for increased expenses when using async mode.\n\nWe'll use this approach, creating an execute_chat_with_moderation function that will run our LLM's get_chat_response and the check_expression moderation function in parallel, and return the LLM response only if the moderation returns False (not triggered).\n\nWe will create a workflow that incorporates the Moderation API to check user input for any potentially unsafe content before it is sent to the Language Model (LLM). This ensures that only appropriate content is processed further in the application.\n\nReceive an input from the user\nUse the Moderation API to analyze the input for any problematic content.\nConditional Processing:\nIf the input is flagged by the moderation check, handle it accordingly (e.g., reject the input, ask the user to rephrase, etc.).\nIf the input is not flagged, pass it to the LLM for further processing.\n\nWe will demonstrate this workflow with two example prompts. One for text and another for image. Note that you can pass both the text and the image in the same request.\nLooks like our moderation worked - the first question was allowed through, but the second was blocked for inapropriate content. Here is a similar example that works with images.\nThe function above can be used to check if an image is appropriate or not. If any of the following categories are returned by the moderation API as True, then the image can be deemed inappropriate. You can also check for one or more categories to tailor this to a specific use case:\n\nsexual\nsexual/minors\nharassment\nharassment/threatening\nhate\nhate/threatening\nillicit\nillicit/violent\nself-harm\nself-harm/intent\nself-harm/instructions\nviolence\nviolence/graphic\nNow we'll extend this concept to moderate the response we get from the LLM as well.\n\nOutput moderation is crucial for controlling the content generated by the Language Model (LLM). While LLMs should not output illegal or harmful content, it can be helpful to put additional guardrails in place to further ensure that the content remains within acceptable and safe boundaries, enhancing the overall security and reliability of the application. Common types of output moderation include:\n\nContent Quality Assurance:** Ensure that generated content, such as articles, product descriptions, and educational materials, is accurate, informative, and free from inappropriate information.\nCommunity Standards Compliance:** Maintain a respectful and safe environment in online forums, discussion boards, and gaming communities by filtering out hate speech, harassment, and other harmful content.\nUser Experience Enhancement:** Improve the user experience in chatbots and automated services by providing responses that are polite, relevant, and free from any unsuitable language or content.\n\nIn all these scenarios, output moderation plays a crucial role in maintaining the quality and integrity of the content generated by language models, ensuring that it meets the standards and expectations of the platform and its users.\nOpenAI has selected thresholds for moderation categories that balance precision and recall for our use cases, but your use case or tolerance for moderation may be different. Setting this threshold is a common area for optimization - we recommend building an evaluation set and grading the results using a confusion matrix to set the right tolerance for your moderation. The trade-off here is generally:\n\nMore false positives leads to a fractured user experience, where customers get annoyed and the assistant seems less helpful.\nMore false negatives can cause lasting harm to your business, as people get the assistant to answer inappropriate questions, or provide inappropriate responses.\n\nFor example, on a platform dedicated to creative writing, the moderation threshold for certain sensitive topics might be set higher to allow for greater creative freedom while still providing a safety net to catch content that is clearly beyond the bounds of acceptable expression. The trade-off is that some content that might be considered inappropriate in other contexts is allowed, but this is deemed acceptable given the platform's purpose and audience expectations.\n\nWe will create a workflow that incorporates the Moderation API to check the LLM response for any potentially unsafe content before it is sent to the Language Model (LLM). This ensures that only appropriate content is displayed to the user.\n\nReceive an input from the user\nSend prompt to LLM and generate a response\nUse the Moderation API to analyze the LLM's response for any problematic content.\nConditional Processing:\nIf the response is flagged by the moderation check, handle it accordingly (e.g., reject the response, show a placeholder message, etc.).\nIf the response is not flagged, display it to the user.\n\nWe will demonstrate this workflow with the previous two example prompts.\nAs observed, the first two examples behaved as expected. However, the \"interesting example\" did not perform as anticipated. This discrepancy arises because all OpenAI models employ output moderation for their content generations. Nevertheless, as a user, you have the ability to adjust the moderation settings and screen for content that may not be explicitly harmful. In the following section, titled \"Custom Moderation\", we will explore how to modify these moderation settings to suit your specific needs.\n\nNote: This section does not use the Moderation API.\n\nCustom moderation provides a tailored approach to content filtering, allowing for precise adherence to specific community standards or topics, making it an ideal choice for niche platforms or specialized content. Unlike the general categories covered by the moderation API, custom moderation offers a higher degree of control and requires more effort to set up and maintain. It shares the common goal of ensuring content safety with guardrails, focusing on setting criteria to filter and manage content, whether it's user input or output from language models. Custom moderation can be an alternative or an extension to the moderation API, that uses our completions endpoint. For those interested in exploring guardrails further, a cookbook with examples and guidance is available here.\n\nWe will implement a small example to showcase custom moderation. We will use an extra call to gpt-4o mini to assess messages and decide if they should be moderated or not.\n\nIn conclusion, this notebook has explored the essential role of moderation in applications powered by language models (LLMs). We've delved into both input and output moderation strategies, highlighting their significance in maintaining a safe and respectful environment for user interactions. Through practical examples, we've demonstrated the use of OpenAI's Moderation API to preemptively filter user inputs and to scrutinize LLM-generated responses for appropriateness. The implementation of these moderation techniques is crucial for upholding the integrity of your application and ensuring a positive experience for your users.\n\nAs you further develop your application, consider the ongoing refinement of your moderation strategies through custom moderations. This may involve tailoring moderation criteria to your specific use case or integrating a combination of machine learning models and rule-based systems for a more nuanced analysis of content. Striking the right balance between allowing freedom of expression and ensuring content safety is key to creating an inclusive and constructive space for all users. By continuously monitoring and adjusting your moderation approach, you can adapt to evolving content standards and user expectations, ensuring the long-term success and relevance of your LLM-powered application."])</script><script>self.__next_f.push([1,"cb:T928,"])</script><script>self.__next_f.push([1,"The objective of this notebook is to demonstrate how to summarize large documents with a controllable level of detail.\n\nIf you give a GPT model the task of summarizing a long document (e.g. 10k or more tokens), you'll tend to get back a relatively short summary that isn't proportional to the length of the document. For instance, a summary of a 20k token document will not be twice as long as a summary of a 10k token document. One way we can fix this is to split our document up into pieces, and produce a summary piecewise. After many queries to a GPT model, the full summary can be reconstructed. By controlling the number of text chunks and their sizes, we can ultimately control the level of detail in the output.\nWe'll define a simple utility to wrap calls to the OpenAI API.\nNext we'll define some utilities to chunk a large document into smaller pieces.\nNow we can define a utility to summarize text with a controllable level of detail (note the detail parameter).\n\nThe function first determines the number of chunks by interpolating between a minimum and a maximum chunk count based on a controllable detail parameter. It then splits the text into chunks and summarizes each chunk.\nNow we can use this utility to produce summaries with varying levels of detail. By increasing detail from 0 to 1 we get progressively longer summaries of the underlying document. A higher value for the detail parameter results in a more detailed summary because the utility first splits the document into a greater number of chunks. Each chunk is then summarized, and the final summary is a concatenation of all the chunk summaries.\nThe original document is nearly 15k tokens long. Notice how large the gap is between the length of summary_with_detail_0 and summary_with_detail_1. It's nearly 25 times longer!\nLet's inspect the summaries to see how the level of detail changes when the detail parameter is increased from 0 to 1.\nNote that this utility also allows passing additional instructions.\nFinally, note that the utility allows for recursive summarization, where each summary is based on the previous summaries, adding more context to the summarization process. This can be enabled by setting the summarize_recursively parameter to True. This is more computationally expensive, but can increase consistency and coherence of the combined summary."])</script><script>self.__next_f.push([1,"cc:Tf68,"])</script><script>self.__next_f.push([1,"The GPT-4o, available as gpt-4o-2024-11-20 as of Novemeber 2024, now enables function calling with vision capabilities, better reasoning and a knowledge cutoff date of Oct 2023. Using images with function calling will unlock multimodal use cases and the ability to use reasoning, allowing you to go beyond OCR and image descriptions.\n\nWe will go through two examples to demonstrate the use of function calling with GPT-4o with Vision:\n\nSimulating a customer service assistant for delivery exception support\nAnalyzing an organizational chart to extract employee information\nWe will simulate a customer service assistant for a delivery service that is equipped to analyze images of packages. The assistant will perform the following actions based on the image analysis:\nIf a package appears damaged in the image, automatically process a refund according to policy.\nIf the package looks wet, initiate a replacement.\nIf the package appears normal and not damaged, escalate to an agent.\nLet's look at the sample images of packages that the customer service assistant will analyze to determine the appropriate action. We will encode the images as base64 strings for processing by the model.\nWe have successfully encoded the sample images as base64 strings and displayed them. The customer service assistant will analyze these images to determine the appropriate action based on the package condition.\n\nLet's now define the functions/tools for order processing, such as escalating an order to an agent, refunding an order, and replacing an order. We will create placeholder functions to simulate the processing of these actions based on the identified tools. We will be using Pydantic models to define the structure of the data for order actions.\n\n\nWe will simulate user messages containing the package images and process the images using the GPT-4o with Vision model. The model will identify the appropriate tool call based on the image analysis and the predefined actions for damaged, wet, or normal packages. We will then process the identified action based on the order ID and display the results.\n\nFor the second example, we will analyze an organizational chart image to extract employee information, such as employee names, roles, managers, and manager roles. We will use GPT-4o with Vision to process the organizational chart image and extract structured data about the employees in the organization. Indeed, function calling lets us go beyond OCR to actually deduce and translate hierarchical relationships within the chart.\n\nWe will start with a sample organizational chart in PDF format that we want to analyze and convert the first page of the PDF to a JPEG image for analysis.\nThe organizational chart image has been successfully extracted from the PDF file and displayed. Let's now define a function to analyze the organizational chart image using the new GPT4o with Vision. The function will extract information about the employees, their roles, and their managers from the image. We will use function/tool calling to specify the input parameters for the organizational structure, such as the employee name, role, and manager's name and role. We will use Pydantic models to define the structure of the data.\n\nNow, we will define a function to parse the response from GPT-4o with vision and extract the employee data. We will tabulate the extracted data for easy visualization. Please note that the accuracy of the extracted data may vary based on the complexity and clarity of the input image.\nThe extracted data from the organizational chart has been successfully parsed and displayed in a DataFrame. This approach allows us to leverage GPT-4o with Vision capabilities to extract structured information from images, such as organizational charts and diagrams, and process the data for further analysis. By using function calling, we can extend the functionality of multimodal models to perform specific tasks or call external functions."])</script><script>self.__next_f.push([1,"cd:T294e,"])</script><script>self.__next_f.push([1,"Synthetic data generation using large language models (LLMs) offers a powerful solution to a commonly faced problem: the availability of high-quality, diverse, and privacy-compliant data. This could be used in a number of scenarios such as training a data science  machine learning model (SVMs, decision trees, KNN's), finetuning a different GPT model on the data, as a solution to the coldstart problem, helping build compelling demos/apps with realistic data, scenario testing etc.\n\nThere are a number of key drivers which may see you wanting to leverage synthetic data.\nHuman data may have privacy restrictions and/or identifiable data within it which we do not want to be used.\nSynthetic data can be much more structured and therefore easier to manipulate than real data.\nIn domains where data is sparse or data of certain categories is sparse we may want to augment the data.\nWhen dealing with imbalanced datasets or datasets which lack diversity, we may want to create data to improve the richness of our datasets.\n\nUnlike traditional data augmentation or manual data creation methods, using LLMs allows for the generation of rich, nuanced, and contextually relevant datasets that can significantly enhance it's usefulness to enterprises and developers.\n\nWe split this tutorial into 2 parts. In this cookbook, we will have the following agenda:\nCSV with a structured prompt\nCSV with a Python program\nMultitable CSV with a python program\nSimply creating textual data\nDealing with imbalanced or non-diverse textual data\nwhile in part 2, we will look at prompting strategies for getting better textual data.\n\nThe last two in particular are useful for creating synthetic data to finetune another GPT model. For example using higher quality data produced by gpt-4o to finetune the cheaper and quicker gpt-3.5-turbo for improved performance while reducing costs.\n\nHere we create data in the simplest way. You can quickly generate data by addressing 3 key points: telling it the format of the data (CSV), the schema, and useful information regarding how columns relate (the LLM will be able to deduce this from the column names but a helping hand will improve performance).\nThe issue with generating data directly is we are limited in the amount of data we can generate because of the context. Instead what we can do is ask the LLM to generate a python program to generate the synthetic data. This allows us to scale to much more data while also providing us a view into how the data was generated by inspecting the python program.\n\nThis would then let us edit the python program as we desire while giving us a good basis to start from.\n\nWe need to make sure to parse the output of this appropriately as often there may be surrounding text to the python code. We can also explicitly ask it to state all assumptions it made about the data it's generating, however in this circumstance it told us that automatically.\nFor more complex relationships however we need to make sure to specify a few more characteristics.\n\nTo create multiple different datasets which relate to each other (for example housing, location, house type), as before we would need to specify the format, schema and useful information. However, the useful information required to get good performance is higher now. It's case-specific but a good amount of things to describe would be how the datasets relate to each other, addressing the size of the datasets in relation to one another, making sure foreign and primary keys are made appropriately and ideally using previously generated datasets to populate new ones so the actual data values match where necessary.\nHere we take a first look at creating textual data. This can be used to finetune another GPT model for example. In this case we imagine ourselves a retailer trying to streamline the process of creating descriptions for items they are selling. We again need to specify the format of the data, in particular in this case we want one which is easy to parse as an output.\nThe example we consider below is one in which we want to create input output training pairs for GPT model to finetune on. We will have the products' name and the category it belongs to as input and the output will be a description.\n\nSpecifying the structure of the output explicitly and giving commands to not deviate from this help enforce the output structure. You can run this in a loop and append the data to generate more synthetic data. Again, as before we will need to parse the data well so that our code further downstream does not break.\nNote: the above output is truncated. And now we can parse it as below to get a list of products, categories and their descriptions. For example, let's take a look at the products it's generated.\n\nSome of the most important aspects of generating high-quality synthetic data are accuracy (does the data make sense), consistency (are two separate data points for the same input roughly the same) and diversity (making sure our data distribution matches as much of the distribution that exists in production).\n\n\nTo increase the diversity of our data, we start first by clustering the data. This will provide us information about which clusters are underrepresented (imbalanced dataset) or which data is not addressed at all (widening the data distribution). Then, we will either suggest new clusters (using self-reflection type call from GPT) or ask the next iteration of our synthetic generation calls to explicitly target the underrepresented clusters.\n\nWe can then recursively run this generation and analysis of cluster loop to automate generating diverse synthetic data.\nFor demonstrative purposes, we explicitly prompt the LLM to generate information about 4 different topical areas: vehicle, clothing, toiletries, food. We will then cluster the data and see if it managed to find these 4 topic areas.\nNote: The above output is truncated. In the example above, we would explicitly include the topic area as part of the response per example as it helps condition the proceeding output and tends to give better performance. We can also give it an actual example of what the output should look like so it gets the right idea of style of output but also to help enforce structure.\nWe will now cluster the data to analyze it. We will use K-means clustering to segregate the data. An important parameter of K-means to set is K, the number of clusters.\n\nWe know that there should be 4 cluster (4 topics) since we specified this in prompt: vehicle, electronics, clothing, food. However in general for our data, we do not know the number of clusters that exist. Therefore we will use the elbow method to find the optimal number of clusters.\n\nIn the elbow method, we iterate through a range of different K's, each time storing the inertia. The inertia measures the sum of the squared distances between each point in a cluster and the centroid of that cluster thus telling us how well-separated and dense each cluster is. If we plot K against the inertia, we are able to see how the inertia drops and where the drop in inertia is least rapid (often making an elbow shape) we can set our optimal number of clusters. You can read into more depth about the elbow method here).\nFirst let's store our data into a pandas dataframe for ease of analysis\n\n\nNext let us embed our data as the embeddings is what we will cluster since they should be close to each other in vector space if they are similar.\nNow we perform the elbow method.\nThis will output a chart for us in which we have to visually tell where the optimal cluster point is. We can see below that we see a gradual decrease of inertia rather than a sharp elbow but the point of steepest decrease appears to occur around 3, 4 or 5 clusters which lines up with our expectations given our prompt.\nelbow_chart\nFor demonstration purposes we will pick 5 as the optimal cluster number to show it doesn't matter exactly where we pick it as long as we are approximately right. There are numerous correct ways to categorize data. We also store which cluster each data point belongs to.\nWe will analyze the cluster data now. There are two separate things we will look to address. 1. imbalanced data, 2. Expanding the data distribution.\nFirst for imbalanced data we count the number of examples in each cluster. Then we select a few examples from each cluster at random and ask the LLM what topics these map to.\nWe can see the topics found here:\nEco-friendly Transportation, Luxury and Leisure Items, Personal Care Products, Electronic Toothbrushes and Clothing and Apparel\nmatch well enough but not exactly to our initial prompt of:\nvehicle, clothing, toiletries, food.\n\nAs we chose 5 clusters, it split up toiletries into Skincare and Personal Care which doesn't affect us too much further downstream.\nWe now have the clusters and their counts so we could prompt the LLM to generate more examples within the topics we want. However for this example we won't take that further as they are well-split and you would just follow the procedure above for prompting the model to generate data while passing in the underrepresented topics.\nNext, we will try and deal with increasing the diversity of our data distribution.\n\nFirst we start in a similar way by finding a few examples from each cluster at random and ask the LLM what topics these map to. In addition to this in the same LLM call, we will ask it to generate more topics to increase the diversity of our data. We do this in one call to save time/cost.\nWe can see here again that we explicitly prompt the output structure it should follow. I also tell it the purpose of generating topics (to promote diversity) so the model has full context.\nWe then parse the data into a list of cluster-mapping jsons and a list of topics\nAnd finally we can use this information to further prompt a model to keep generating synthetic data. We do this by passing all the topics in the list of jsons to the prompt below.\nYou can run this in a loop to append to your previous data and in this way you can keep generating more textual synthetic data to train another GPT model while making sure that we cater to imbalanced datasets and generating a diversity of data.\nYou have now completed part 1 of the synthetic data generation tutorial where we have gone through:\nCSV with a structured prompt\nCSV with a Python program\nMultitable CSV with a python program\nSimply creating textual data\nDealing with imbalanced or non-diverse textual data\n\nIn part 2 you will find find out techniques for better prompting an LLM to enhance textual synthetic data generation."])</script><script>self.__next_f.push([1,"ce:T1443,"])</script><script>self.__next_f.push([1,"Multimodal RAG integrates additional modalities into traditional text-based RAG, enhancing LLMs' question-answering by providing extra context and grounding textual data for improved understanding.\n\nAdopting the approach from the clothing matchmaker cookbook, we directly embed images for similarity search, bypassing the lossy process of text captioning, to boost retrieval accuracy.\n\nUsing CLIP-based embeddings further allows fine-tuning with specific data or updating with unseen images.\n\nThis technique is showcased through searching an enterprise knowledge base with user-provided tech images to deliver pertinent information.\nFirst let's install the relevant packages.\nThen let's import all the needed packages.\n\nNow let's load the CLIP model.\n\nWe will now:\nCreate the image embedding database\nSet up a query to the vision model\nPerform the semantic search\nPass a user query to the image\n\n\nNext we will create our image embeddings knowledge base from a directory of images. This will be the knowledge base of technology that we search through to provide information to the user for an image they upload.\n\nWe pass in the directory in which we store our images (as JPEGs) and loop through each to create our embeddings.\n\nWe also have a description.json. This has an entry for every single image in our knowledge base. It has two keys: 'image_path' and 'description'. It maps each image to a useful description of this image to aid in answering the user question.\nFirst let's write a function to get all the image paths in a given directory. We will then get all the jpeg's from a directory called 'image_database'\nNext we will write a function to get the image embeddings from the CLIP model given a series of paths.\n\nWe first preprocess the image using the preprocess function we got earlier. This performs a few things to ensure the input to the CLIP model is of the right format and dimensionality including resizing, normalization, colour channel adjustment etc.\n\nWe then stack these preprocessed images together so we can pass them into the model at once rather than in a loop. And finally return the model output which is an array of embeddings.\nWe can now create our vector database.\nAnd also ingest our json for image-description mapping and create a list of jsons. We also create a helper function to search through this list for a given image we want, so we can obtain the description of that image\nLet us display an example image, this will be the user uploaded image. This is a piece of tech that was unveiled at the 2024 CES. It is the DELTA Pro Ultra Whole House Battery Generator.\nDelta Pro\nNow let's have a look at what GPT-4 Vision (which wouldn't have seen this technology before) will label it as.\n\n\nFirst we will need to write a function to encode our image in base64 as this is the format we will pass into the vision model. Then we will create a generic image_query function to allow us to query the LLM with an image input.\nAs we can see, it tries its best from the information it's been trained on but it makes a mistake due to it not having seen anything similar in its training data. This is because it is an ambiguous image making it difficult to extrapolate and deduce.\nNow let's perform similarity search to find the two most similar images in our knowledge base. We do this by getting the embeddings of a user inputted image_path, retrieving the indexes and distances of the similar iamges in our database. Distance will be our proxy metric for similarity and a smaller distance means more similar. We then sort based on distance in descending order.\nWe require the indices as we will use this to search through our image_directory and selecting the image at the location of the index to feed into the vision model for RAG.\nAnd let's see what it brought back (we display these in order of similarity):\nDelta Pro2\n\nDelta Pro3\nWe can see here it brought back two images which contain the DELTA Pro Ultra Whole House Battery Generator. In one of the images it also has some background which could be distracting but manages to find the right image.\nNow for our most similar image, we want to pass it and the description of it to gpt-v with a user query so they can inquire about the technology that they may have bought. This is where the power of the vision model comes in, where you can ask general queries for which the model hasn't been explicitly trained on to the model and it responds with high accuracy.\nIn our example below, we will inquire as to the capacity of the item in question.\nAnd we see it is able to answer the question. This was only possible by matching images directly and from there gathering the relevant description as context.\nIn this notebook, we have gone through how to use the CLIP model, an example of creating an image embedding database using the CLIP model, performing semantic search and finally providing a user query to answer the question.\nThe applications of this pattern of usage spread across many different application domains and this is easily improved to further enhance the technique. For example you may finetune CLIP, you may improve the retrieval process just like in RAG and you can prompt engineer GPT-V."])</script><script>self.__next_f.push([1,"cf:Tdd3,"])</script><script>self.__next_f.push([1,"The new Batch API allows to create async batch jobs for a lower price and with higher rate limits.\n\nBatches will be completed within 24h, but may be processed sooner depending on global usage.\n\nIdeal use cases for the Batch API include:\n\nTagging, captioning, or enriching content on a marketplace or blog\nCategorizing and suggesting answers for support tickets\nPerforming sentiment analysis on large datasets of customer feedback\nGenerating summaries or translations for collections of documents or articles\n\nand much more!\n\nThis cookbook will walk you through how to use the Batch API with a couple of practical examples.\n\nWe will start with an example to categorize movies using gpt-4o-mini, and then cover how we can use the vision capabilities of this model to caption images.\n\nPlease note that multiple models are available through the Batch API, and that you can use the same parameters in your Batch API calls as with the Chat Completions endpoint.\n\nIn this example, we will use gpt-4o-mini to extract movie categories from a description of the movie. We will also extract a 1-sentence summary from this description.\n\nWe will use JSON mode to extract categories as an array of strings and the 1-sentence summary in a structured format.\n\nFor each movie, we want to get a result that looks like this:\n\n{\n    categories: ['category1', 'category2', 'category3'],\n    summary: '1-sentence summary'\n}\n\nWe will use the IMDB top 1000 movies dataset for this example.\n\nHere, we will prepare our requests by first trying them out with the Chat Completions endpoint.\n\nOnce we're happy with the results, we can move on to creating the batch file.\n\nThe batch file, in the jsonl format, should contain one line (json object) per request.\nEach request is defined as such:\n\n{\n    \"custom_id\": ,\n    \"method\": \"POST\",\n    \"url\": \"/v1/chat/completions\",\n    \"body\": {\n        \"model\": ,\n        \"messages\": ,\n        // other parameters\n    }\n}\n\nNote: the request ID should be unique per batch. This is what you can use to match results to the initial input files, as requests will not be returned in the same order.\n\nNote: this can take up to 24h, but it will usually be completed faster.\n\nYou can continue checking until the status is 'completed'.\nReminder: the results are not in the same order as in the input file.\nMake sure to check the custom_id to match the results against the input requests\n\nIn this example, we will use gpt-4-turbo to caption images of furniture items.\n\nWe will use the vision capabilities of the model to analyze the images and generate the captions.\n\nWe will use the Amazon furniture dataset for this example.\n\nAgain, we will first prepare our requests with the Chat Completions endpoint, and create the batch file afterwards.\n\nAs with the first example, we will create an array of json tasks to generate a jsonl file and use it to create the batch job.\n\nAs with the first example, we can retrieve results once the batch job is done.\n\nReminder: the results are not in the same order as in the input file.\nMake sure to check the custom_id to match the results against the input requests\n\nIn this cookbook, we have seen two examples of how to use the new Batch API, but keep in mind that the Batch API works the same way as the Chat Completions endpoint, supporting the same parameters and most of the recent models (gpt-4o, gpt-4o-mini, gpt-4-turbo, gpt-3.5-turbo...).\n\nBy using this API, you can significantly reduce costs, so we recommend switching every workload that can happen async to a batch job with this new API."])</script><script>self.__next_f.push([1,"d0:T6b5,The ChatCompletion endpoint now includes the ability to specify whether a tool must be called every time, by adding tool_choice='required' as a parameter.\n\nThis adds an element of determinism to how you build your wrapping application, as you can count on a tool being provided with every call. We'll demonstrate here how this can be useful for a contained flow like customer service, where having the ability to define specific exit points gives more control.\n\nThe notebook concludes with a multi-turn evaluation, where we spin up a customer GPT to imitate our customer and test the LLM customer service agent we've set up.\n\nWe will define tools and instructions which our LLM customer service agent will use. It will source the right instructions for the problem the customer is facing, and use those to answer the customer's query.\n\nAs this is a demo example, we'll ask the model to make up values where it doesn't have external systems to source info.\n\nTo test this we will run an example for a customer who has experienced fraud, and see how the model handles it.\n\nPlay the role of the user and provide plausible next steps to keep the conversation going.\n\nNow we'll do a simple evaluation where a GPT will pretend to be our customer. The two will go back and forth until a resolution is reached.\n\nWe'll reuse the functions above, adding an execute_conversation function where the customer GPT will continue answering.\n\nYou can now control your LLM's behaviour explicitly by making tool use mandatory, as well as spin up GPT testers to challenge your LLM and to act as automated test cases.\n\nWe hope this has given you an appreciation for a great use case for tool use, and look forward to seeing what you build!d1:T151e,"])</script><script>self.__next_f.push([1,"GPT-4o (\"o\" for \"omni\") and GPT-4o mini are natively multimodal models designed to handle a combination of text, audio, and video inputs, and can generate outputs in text, audio, and image formats. GPT-4o mini is the lightweight version of GPT-4o.\n\n\nBefore GPT-4o, users could interact with ChatGPT using Voice Mode, which operated with three separate models. GPT-4o integrates these capabilities into a single model that's trained across text, vision, and audio. This unified approach ensures that all inputs — whether text, visual, or auditory — are processed cohesively by the same neural network.\n\nGPT-4o mini is the next iteration of this omni model family, available in a smaller and cheaper version. This model offers higher accuracy than GPT-3.5 Turbo while being just as fast and supporting multimodal inputs and outputs.\n\n\nCurrently, the gpt-4o-mini model supports {text, image}, with {text} outputs, the same modalities as gpt-4-turbo.  As a preview, we will also be using the gpt-4o-audio-preview model to showcase transcription though the GPT4o model.\n\n\nTo setup the client for our use, we need to create an API key to use with our request. Skip these steps if you already have an API key for usage.\n\nYou can get an API key by following these steps:\nCreate a new project\nGenerate an API key in your project\n(RECOMMENDED, BUT NOT REQUIRED) Setup your API key for all projects as an env var\n\nOnce we have this setup, let's start with a simple {text} input to the model for our first request. We'll use both system and user messages for our first request, and we'll receive a response from the assistant role.\nGPT-4o mini can directly process images and take intelligent actions based on the image. We can provide images in two formats:\nBase64 Encoded\nURL\n\nLet's first view the image we'll use, then try sending this image as both Base64 and as a URL link to the API\nWhile it's not possible to directly send a video to the API, GPT-4o can understand videos if you sample frames and then provide them as images.\n\nSince GPT-4o mini in the API does not yet support audio-in (as of July 2024), we'll use a combination of GPT-4o mini and Whisper to process both the audio and visual for a provided video, and showcase two usecases:\nSummarization\nQuestion and Answering\n\n\nWe'll use two python packages for video processing - opencv-python and moviepy.\n\nThese require ffmpeg, so make sure to install this beforehand. Depending on your OS, you may need to run brew install ffmpeg or sudo apt install ffmpeg\nNow that we have both the video frames and the audio, let's run a few different tests to generate a video summary to compare the results of using the models with different modalities. We should expect to see that the summary generated with context from both visual and audio inputs will be the most accurate, as the model is able to use the entire context from the video.\n\nVisual Summary\nAudio Summary\nVisual + Audio Summary\n\nThe visual summary is generated by sending the model only the frames from the video. With just the frames, the model is likely to capture the visual aspects, but will miss any details discussed by the speaker.\nThe results are as expected - the model is able to capture the high level aspects of the video visuals, but misses the details provided in the speech.\n\nThe audio summary is generated by sending the model the audio transcript. With just the audio, the model is likely to bias towards the audio content, and will miss the context provided by the presentations and visuals.\n\n{audio} input for GPT-4o is currently in preview, but will be incorporated into the base model in the near future.  Because of this, we will use the gpt-4o-audio-preview model to process the audio.\nLooking good.  Now let's summarize this and format in markdown.\nThe audio summary is biased towards the content discussed during the speech, but comes out with much less structure than the video summary.\n\nThe Audio + Visual summary is generated by sending the model both the visual and the audio from the video at once. When sending both of these, the model is expected to better summarize since it can perceive the entire video at once.\nAfter combining both the video and audio, we're able to get a much more detailed and comprehensive summary for the event which uses information from both the visual and audio elements from the video.\n\nFor the Q\u0026A, we'll use the same concept as before to ask questions of our processed video while running the same 3 tests to demonstrate the benefit of combining input modalities:\nVisual Q\u0026A\nAudio Q\u0026A\nVisual + Audio Q\u0026A\nComparing the three answers, the most accurate answer is generated by using both the audio and visual from the video. Sam Altman did not discuss the raising windows or radio on during the Keynote, but referenced an improved capability for the model to execute multiple functions in a single request while the examples were shown behind him.\n\n\nIntegrating many input modalities such as audio, visual, and textual, significantly enhances the performance of the model on a diverse range of tasks. This multimodal approach allows for more comprehensive understanding and interaction, mirroring more closely how humans perceive and process information.\n\nCurrently, GPT-4o and GPT-4o mini in the API support text and image inputs, with audio capabilities coming soon.  For the time being, use the gpt-4o-audio-preview for audio inputs."])</script><script>self.__next_f.push([1,"d2:T237f,"])</script><script>self.__next_f.push([1,"This notebook provides step by step instuctions on using Azure AI Search (f.k.a Azure Cognitive Search) as a vector database with OpenAI embeddings, then creating an Azure Function on top to plug into a Custom GPT in ChatGPT.\n\nThis can be a solution for customers looking to set up RAG infrastructure contained within Azure, and exposing it as an endpoint to integrate that with other platforms such as ChatGPT.\n\nAzure AI Search is a cloud search service that gives developers infrastructure, APIs, and tools for building a rich search experience over private, heterogeneous content in web, mobile, and enterprise applications.\n\nAzure Functions is a serverless compute service that runs event-driven code, automatically managing infrastructure, scaling, and integrating with other Azure services.\nFor the purposes of this exercise you must have the following:\nAzure user with permission to create Azure AI Search Service and Azure Function Apps\nAzure subscription ID and a resource group.\nOpenAI Key\nBelow is a diagram of the architecture of this solution, which we'll walk through step-by-step.\n\nazure-rag-architecture.png\nNote: This architecture pattern of vector data store + serverless functions can be extrapolated to other vector data stores. For example, if you would want to use something like Postgres within Azure, you'd change the Configure Azure AI Search Settings step to set-up the requirements for Postgres, you'd modify the Create Azure AI Vector Search to create the database and table in Postgres instead, and you'd update the function_app.py code in this repository to query Postgres instead of Azure AI Search. The data preparation and creation of the Azure Function would stay consistent.\n\nSetup of Environment\n    Setup environment by installing and importing the required libraries and configuring our Azure settings. Includes:\n     Install and Import Required Libraries\n     Configure OpenAI Settings\n     Configure Azure AI Search Settings\n\n\nPrepare Data Prepare the data for uploading by embedding the documents, as well as capturing additional metadata. We will use a subset of OpenAI's docs as example data for this.\n\nCreate Azure AI Vector Search Create an Azure AI Vector Search and upload the data we've prepared. Includes:\n     Create Index: Steps to create an index in Azure AI Search.\n     Upload Data: Instructions to upload data to Azure AI Search.\n     Test Search: Steps to test the search functionality.\n\nCreate Azure Function Create an Azure Function to interact with the Azure AI Vector Search. Includes:\n     Create Storage Account: Steps to create a storage account for the Azure Function.\n     Create Function App: Instructions to create a function app in Azure.\n\nInput in a Custom GPT in ChatGPT Integrate the Azure Function with a Custom GPT in ChatGPT. Includes:\n     Create OpenAPI Spec: Steps to create an OpenAPI specification for the Azure Function.\n     Create GPT Instructions: Instructions to create GPT-specific instructions for the integration.\n\n\n\nWe'll set up our environment by importing the required libraries and configuring our Azure settings.\nWe categorize these libraries into standard Python libraries, third-party libraries, and Azure-related libraries for readability.\n\nBefore going through this section, make sure you have your OpenAI API key.\n\nYou can locate your Azure AI Search service details in the Azure Portal or programmatically via the Search Management SDK.\n\nSubscription ID from Azure\nResource Group name from Azure\nRegion in Azure\nBelow we'll generate a unique name for the search service, set up the service properties, and create the search service.\nNow that we have the search service up and running, we need the Search Service API Key, which we'll use to initiate the index creation, and later to execute the search.\nWe're going to embed and store a few pages of the OpenAI docs in the oai_docs folder. We'll first embed each, add it to a CSV, and then use that CSV to upload to the index.\n\nIn order to handle longer text files beyond the context of 8191 tokens, we can either use the chunk embeddings separately, or combine them in some way, such as averaging (weighted by the size of each chunk).\n\nWe will take a function from Python's own cookbook that breaks up a sequence into chunks.\nNow we define a function that encodes a string into tokens and then breaks it up into chunks. We'll use tiktoken, a fast open-source tokenizer by OpenAI.\n\nTo read more about counting tokens with Tiktoken, check out this cookbook.\n\nFinally, we can write a function that safely handles embedding requests, even when the input text is longer than the maximum context length, by chunking the input tokens and embedding each chunk individually. The average flag can be set to True to return the weighted average of the chunk embeddings, or False to simply return the unmodified list of chunk embeddings.\nNote: there are other, more sophisticated techniques you can take here, including:\n- using GPT-4o to capture images/chart descriptions for embedding.\n- keeping text overlap between the chunks to minimize cutting off important context.\n- chunking based on paragraphs or sections.\n- adding more descriptive metadata about each article.\nNext, we can define a helper function that will capture additional metadata about the documents. This is useful to use as a metadata filter for search queries, and capturing richer data for search.\n\nIn this example, I'll choose from a list of categories to use later on in a metadata filter.\nNow, we can define some helper functions to process the .txt files in the oai_docs folder within the data folder. You can use this with your own data as well and supports both .txt and .pdf files.\nWe'll now use this helper function to process our OpenAI documentation. Feel free to update this to use your own data by changing the folder in process_files below.\n\nNote that this will process the documents in chosen folder concurrently, so this should take  Note that this Azure Function does not have any authentication. However, you can set authentication on it following docs here\nWe can create a new storage account using the code below, but feel free to skip that block and modify the subsequent steps to use an existing storage account. This may take up to 30 seconds.\nThis Function App is where the python code will execute once it is triggered via a GPT Action. To read more about Function Apps, see the docs here.\nTo deploy Function Apps, we'll need to use the Azure CLI and Azure Functions Core Tools.\nThe below will attempt to install it and run it based on your platform type in your virtual environment, but if that does not work, read the Azure documentation to figure out how to install Azure Function Core Tools and Azure CLI. After doing that, run the below subprocess.run commands in your terminal after navigating to this folder.\nFirst we'll make sure we have the relevant tools in the environment in order to run the Azure commands necessary. This may take a few minutes to install.\nNow, we need to create a local.settings.json file with our key environment variables for Azure\nCheck the local.settings.json file and make sure that the environment variables match what you expect.\n\nNow, give your app a name below, and you are ready to create your Function App and then publish your function.\nOnce we've created the Function App, we now want to add the configuration variables to the function app to use in the function. Specifically, we need the OPENAI_API_KEY, the SEARCH_SERVICE_API_KEY, and the EMBEDDINGS_MODEL as these are all used in the function_app.py code.\nWe are now ready to publish your function code function_app.py to the Azure Function. This may take up to 10 minutes to deploy. Once this is finished, we now have an API endpoint using an Azure Function on top of Azure AI Search.\nNow that we have an Azure Function that queries this Vector Search Index, let's put it as a GPT Action!\n\nSee documentation here on GPTs and here on GPT Actions. Use the below as the instructions for the GPT and as the OpenAPI spec for the GPT Action.\n\nBelow is a sample OpenAPI spec. When we run the block below, a functional spec should be copied to the clipboard to paste in the GPT Action.\n\nNote that this does not have any authentication by default, but you can set up Azure Functions with OAuth by following the pattern in this cookbook in the Authentication section or looking at the documentation here.\n\nFeel free to modify instructions as you see fit. Check out our docs here for some tips on prompt engineering.\nWe now have a GPT that queries a vector database!\nWe've now successfully integrated Azure AI Search with GPT Actions in ChatGPT by doing the following:\nembedded them using OpenAI's embeddings, while adding some additional metadata using gpt-4o.\nuploaded that data to Azure AI Search.\ncreated an endpoint to query it using Azure Functions.\nincorporated it into a Custom GPT.\n\nOur GPT can now retrieve information to help answer user queries, making it much more accurate and customized to our data. Here's the GPT in action:\nazure-rag-quickstart-gpt.png"])</script><script>self.__next_f.push([1,"d3:T6a3,This page provides an instruction \u0026 guide for developers building a GPT Action for a specific application. Before you proceed, make sure to first familiarize yourself with the following information:\nIntroduction to GPT Actions\nIntroduction to GPT Actions Library\nExample of Buliding a GPT Action from Scratch\nThis particular GPT Action provides an overview of how to connect to a Weather.gov weather forecast. This Action takes a user’s question about a location, converts the lat-long into a weather forecast office (WFO), x, and y coordinates, then converts those 3 values into a weather forecast.\n\nNote: When setting up the GPT Action, for authentication, leave it with \"None\". This is a public API and does not require any Authentication\nValue: Users can now leverage ChatGPT's natural language capability to forecast the weather\n\nExample Use Cases:\nUsers can plan out their day based on weather patterns\nUsers can quickly visualize (including graphs) what the weather is forecasted to look like\nCheck out these links from the application before you get started:\nApplication Website: https://www.weather.gov/\nApplication API Documentation: https://www.weather.gov/documentation/services-web-api\nOnce you've created a Custom GPT, copy the text below in the Instructions panel. Have questions? Check out Getting Started Example to see how this step works in more detail.\nOnce you've created a Custom GPT, copy the text below in the Actions panel. Have questions? Check out Getting Started Example to see how this step works in more detail.\nAre there integrations that you’d like us to prioritize? Are there errors in our integrations? File a PR or issue in our github, and we’ll take a look.d4:Te9e,"])</script><script>self.__next_f.push([1,"This page provides an instruction \u0026 guide for developers building a GPT Action for a specific application. Before you proceed, make sure to first familiarize yourself with the following information:\nIntroduction to GPT Actions\nIntroduction to GPT Actions Library\nExample of Building a GPT Action from Scratch\nThis particular GPT Action provides an overview of how to connect to Google BigQuery, Google Cloud's Analytical Data Warehouse. This Action takes a user’s question, scans the relevant tables to gather the data schema, then writes a SQL query to answer the user’s question.\n\nNote: these instructions return back a functioning SQL statement, rather than the result itself. Currently middleware is required to return back a CSV file – we’ll be posting instructions on an example of that soon\nValue: Users can now leverage ChatGPT's natural language capability to connect directly to BigQuery's DWH.\n\nExample Use Cases:\nData scientists can connect to tables and run data analyses using ChatGPT's Data Analysis\nCitizen data users can ask basic questions of their transactional data\nUsers gain more visibility into their data \u0026 potential anomalies\nCheck out these links from the application before you get started:\nApplication Website: https://cloud.google.com/bigquery\nApplication API Documentation: https://cloud.google.com/bigquery/docs/reference/rest\nBefore you get started, make sure you go through the following steps in your application environment:\nSet up a GCP project\nSet up a BQ dataset in that GCP project\nEnsure that the user authenticating into BigQuery via ChatGPT has access to that BQ dataset\nOnce you've created a Custom GPT, copy the text below in the Instructions panel. Have questions? Check out Getting Started Example to see how this step works in more detail.\nOnce you've created a Custom GPT, copy the text below in the Actions panel. Have questions? Check out Getting Started Example to see how this step works in more detail.\nBelow are instructions on setting up authentication with this 3rd party application. Have questions? Check out Getting Started Example to see how this step works in more detail.\nBefore you set up authentication in ChatGPT, please take the following steps in the application.\nGo to the Google Cloud Console\nNavigate to API \u0026 Services \u003e Credentials\nCreate new OAuth credentials (or use an existing one)\nLocate your OAuth Client ID \u0026 Client Secret and store both values securely (see screenshot below)\ngptactions_BigQuery_auth.png\nIn ChatGPT, click on \"Authentication\" and choose \"OAuth\". Enter in the information below.\nClient ID**: use Client ID from steps above\nClient Secret**: use Client Secret from steps above\nAuthorization URL**: https://accounts.google.com/o/oauth2/auth\nToken URL**: https://oauth2.googleapis.com/token\nScope**: https://www.googleapis.com/auth/bigquery\nToken**: Default (POST)\nOnce you've set up authentication in ChatGPT, follow the steps below in the application to finalize the Action.\nCopy the callback URL from the GPT Action\nIn the “Authorized redirect URIs” (see screenshot above), add your callback URL\n\nCallback URL Error: If you get a callback URL error in ChatGPT, pay close attention to the screenshot above. You need to add the callback URL directly into GCP for the action to authenticate correctly\nSchema calls the wrong project or dataset: If ChatGPT calls the wrong project or dataset, consider updating your instructions to make it more explicit either (a) which project / dataset should be called or (b) to require the user provide those exact details before it runs the query\nAre there integrations that you’d like us to prioritize? Are there errors in our integrations? File a PR or issue in our github, and we’ll take a look."])</script><script>self.__next_f.push([1,"d5:T16dc,"])</script><script>self.__next_f.push([1,"A lot of enterprise data is unstructured and locked up in difficult-to-use formats, e.g. PDFs, PPT, PNG, that are not optimized for use with LLMs or databases. As a result this type of data tends to be underutilized for analysis and product development, despite it being so valuable. The traditional way of extracting information from unstructured or non-ideal formats has been to use OCR, but OCR struggles with complex layouts and can have limited multilingual support. Moreover, manually applying transforms to data can be cumbersome and timeconsuming.\n\nThe multi-modal capabilities of GPT-4o enable new ways to extract and transform data because of GPT-4o's ability to adapt to different types of documents and to use reasoning for interpreting the content of documents. Here are some reasons why you would choose GPT-4o for your extraction and transformation workflows over traditional methods.\n\n| Extraction                                               | Transformation                                              |\n|---------------------------------------------------------------|------------------------------------------------------------------|\n| Adaptable: Handles complex document layouts better, reducing errors | Schema Adaptability: Easily transforms data to fit specific schemas for database ingestion |\n| Multilingual Support: Seamlessly processes documents in multiple languages | Dynamic Data Mapping: Adapts to different data structures and formats, providing flexible transformation rules |\n| Contextual Understanding: Extracts meaningful relationships and context, not just text | Enhanced Insight Generation: Applies reasoning to create more insightful transformations, enriching the dataset with derived metrics, metadata and relationships |\n| Multimodality: Processes various document elements, including images and tables |  |\n\nThis cookbook has three parts:\nHow to extract data from multilingual PDFs\nHow to transform data according to a schema for loading into a database\nHow to load transformed data into a database for downstream analysis\n\nWe're going to mimic a simple ELT workflow where data is first extracted from PDFs into JSON using GPT-4o, stored in an unstructured format somewhere like a data lake, transformed to fit a schema using GPT-4o, and then finally ingested into a relational database for querying. It's worth noting that you can do all of this with the BatchAPI if you're interested in lowering the cost of this workflow.\n\nThe data we'll be using is a set of publicly available 2019 hotel invoices from Germany available on Jens Walter's GitHub, (thank you Jens!). Though hotel invoices generally contain similar information (reservation details, charges, taxes etc.), you'll notice that the invoices present itemized information in different ways and are multilingual containing both German and English. Fortunately GPT-4o can adapt to a variety of different document styles without us having to specify formats and it can seamlessly handle a variety of languages, even in the same document.\nHere is what one of the invoices looks like:\n\nGPT-4o doesn't natively handle PDFs so before we extract any data we'll first need to convert each page into an image and then encode the images as base64.\nWe can then pass each base64 encoded image in a GPT-4o LLM call, specifying a high level of detail and JSON as the response format. We're not concerned about enforcing a schema at this step, we just want all of the data to be extracted regardless of type.\nBecause invoice data can span multiple pages in a PDF, we're going to produce JSON objects for each page in the invoice and then append them together. The final invoice extraction will be a single JSON file.\nEach invoice JSON will have different keys depending on what data the original invoice contained, so at this point you can store the unschematized JSON files in a data lake that can handle unstructured data. For simplicity though, we're going to store the files in a folder. Here is what one of the extracted JSON files looks like, you'll notice that even though we didn't specify a schema, GPT-4o was able to understand German and group similar information together. Moreover, if there was a blank field in the invoice GPT-4o transcribed that as \"null\".\n\nYou've extracted data from PDFs and have likely loaded the unstructured extractions as JSON objects in a data lake. The next step in our ELT workflow is to use GPT-4o to transform the extractions according to our desired schema. This will enable us to ingest any resulting tables into a database. We've decided upon the following schema that broadly covers most of the information we would have seen across the different invoices. This schema will be used to process each raw JSON extraction into our desired schematized JSON and can specify particular formats such as \"date\": \"YYYY-MM-DD\". We're also going to translate the data into English at this step.\n\nNow that we've schematized all of our data, we can segment it into tables for ingesting into a relational database. In particular, we're going to create four tables: Hotels, Invoices, Charges and Taxes. All of the invoices pertained to one guest, so we won't create a guest table.\nNow let's check that we've correctly ingested the data by running a sample SQL query to determine the most expensive hotel stay and the same of the hotel!\nYou can even automate the generation of SQL queries at this step by using function calling, check out our cookbook on function calling with model generated arguments to learn how to do that.\nTo recap in this cookbook we showed you how to use GPT-4o for extracting and transforming data that would otherwise be inaccessible for data analysis. If you don't need these workflows to happen in real-time, you can take advantage of OpenAI's BatchAPI to run jobs asynchronously at a much lower cost!"])</script><script>self.__next_f.push([1,"d6:T11fd,"])</script><script>self.__next_f.push([1,"This page provides an instruction \u0026 guide for developers building a GPT Action for a specific application. Before you proceed, make sure to first familiarize yourself with the following information:\nIntroduction to GPT Actions\nIntroduction to GPT Actions Library\nExample of Buliding a GPT Action from Scratch\nThis particular GPT Action provides an overview of how to connect to Outlook, Microsoft's web service for emailing and calendar events. This action assumes a user’s context and allows them to send and retrieve emails and calendar events from Outlook.\nValue: Users can now leverage ChatGPT's natural language capability to connect directly to Outlook\n\nExample Use Cases:\nA user can look up all of their meetings for the day and have ChatGPT summarize the day\nA user can email a ChatGPT output to someone directly\nCheck out these links from the application before you get started:\nApplication Website: https://portal.azure.com/\nApplication API Documentation: https://learn.microsoft.com/en-us/graph/api/overview?view=graph-rest-1.0\nBefore you get started, make sure you go through the following steps in your application environment:\nEnsure you have the access and permissions to Set up an App Registration in Azure\nOnce you've created a Custom GPT, copy the text below in the Instructions panel. Have questions? Check out Getting Started Example to see how this step works in more detail.\nOnce you've created a Custom GPT, copy the text below in the Actions panel. Have questions? Check out Getting Started Example to see how this step works in more detail.\nBelow are instructions on setting up authentication with Outlook. Have questions? Check out Getting Started Example to see how this step works in more detail.\n\nApp Registration: The first step is to register a new App registration in the Azure Portal which will be used to integrate OAuth between our application and Azure Active Directory/Entra ID. Simply provide the application with a relevant name, leaving the Redirect URI blank for now as we will return to this, and save.\ngptactions_outlook_registerapplication.png\nCertificate \u0026 Secrets: We next need to generate a client secret to provide secure communication between the GPT and Azure. Within the App registration, navigate to Certificate \u0026 secrets in the sidebar\ngptactions_outlook_secrets.png\nClick New client secret and create a new client secret with desired name and expiry date. Clicking save will provide us a Secret to use in our GPT creation. Make sure to save the Value field as it’ll only be visible at creation, and we will need it later!\ngptactions_outlook_secretvalue.png\nAPI Permissions: The next step is to provide the integration with the scope it needs to perform our specific required actions.\nWithin the App registration, navigate to Manage \u003e API permissions in the sidebar.\ngptactions_outlook_permissions.png\nClick Add a permission and Microsoft graph \u003e Delegated Permissions as options in the opened side menu. Use the search bar to add the following permissions:\nCalendars.ReadWrite\nMail.Read\nMail.Send\nUser.Read\n\ngptactions_outlook_permissionadd.png\nIn ChatGPT, click on \"Authentication\" and choose \"OAuth\". Enter in the information below.\nClient ID: The value listed on the Azure Registered App’s Overview page under **Application (client) ID\nClient Secret: the secret **Value saved from step 2 of Azure Steps\nFor the following two inputs, replace  with the value listed on the Registered App’s Overview page under Directory (tenant) ID\nAuthorization URL**: https://login.microsoftonline.com//oauth2/v2.0/authorize\nToken URL**: https://login.microsoftonline.com//oauth2/v2.0/token\nScope**: https://graph.microsoft.com/User.Read https://graph.microsoft.com/Mail.Send https://graph.microsoft.com/Mail.Read https://graph.microsoft.com/Calendars.ReadWrite\nToken Exchange Method**: Default (POST Request)\nOnce you've set up authentication in ChatGPT, follow the steps below in the application to finalize the Action.\nCopy the callback URL from the GPT Action\ngptactions_outlook_callback.png\nIn the Azure app, navigate to the Manage \u003e Authentication tab, click Add a platform, select Web and add your callback URL under Redirect URI\n\ngptactions_outlook_redirectconfig.png\ngptactions_outlook_redirectinput.png\nCallback URL Error**: If you get a callback URL error in ChatGPT, double check the Callback URL value as it can occasionally change depending on any alterations made to the authentication\n\nAre there integrations that you’d like us to prioritize? Are there errors in our integrations? File a PR or issue in our github, and we’ll take a look."])</script><script>self.__next_f.push([1,"d7:T3a92,"])</script><script>self.__next_f.push([1,"This page provides an instruction \u0026 guide for developers building a GPT Action for a specific application. Before you proceed, make sure to first familiarize yourself with the following information:\nIntroduction to GPT Actions\nIntroduction to GPT Actions Library\nExample of Building a GPT Action from Scratch\nThis solution enables a GPT action to answer a user’s question with the context of files the user can access in SharePoint or Office365, using Microsoft’s Graph API search capabilities and the ability to retrieve files. It uses Azure Functions to process the Graph API response and convert it to a human readable format or structure it in a way ChatGPT understands. This code is meant to be directional, and you should modify it to your requirements.\n\nThis solution uses the ability to retrieve files in Actions and use them as if you had uploaded them directly to a conversation. The Azure Function returns a base64 string that ChatGPT converts into a file. This solution can handle both structured and unstructured data, but does have size volume limitations (see docs here)\nValue: Users can now leverage ChatGPT's natural language capability to connect directly to files in Sharpeoint\n\nExample Use Cases:\nA user needs to look up which files relate to a certain topic\nA user needs an answer to a critical question, buried deep in documents\n\n\nThis solution uses a Node.js Azure Function to, based on the logged in user:\n\nSearch for a relevant file that the user has access to, based on the user’s initial question. \n\nFor each file that is found, convert it to a base64 string.\n\nFormat the data in the structure ChatGPT is expecting here.\n\nReturn that to ChatGPT. The GPT then can use those files as if you had uploaded it to the conversation.\n\nCheck out these links from the application before you get started:\nApplication Website: https://www.microsoft.com/en-us/microsoft-365/sharepoint/collaboration\nApplication API Documentation: https://learn.microsoft.com/en-us/previous-versions/office/developer/sharepoint-rest-reference/\nBefore you get started, make sure you go through the following steps in your application environment:\nAccess to a Sharepoint environment\nPostman (and knowledge of APIs and OAuth)\n\nIf you follow the search concept files guide, the Microsoft Graph Search API returns references to files that fit the criteria, but not the file contents themselves. Therefore, middleware is required, rather than hitting the MSFT endpoints directly.\n\nWe need to restructure the response from that API so that it matches the expected structure in openaiFileResponse outlined here.\nSet up an Azure Function using the steps in the Azure Function cookbook\nNow that you have an authenticated Azure Function, we can update the function to search SharePoint / O365\n\nGo to your test function and paste in the code from this file. Save the function.\nThis code is meant to be directional - while it should work out of the box, it is designed to be customized to your needs (see examples towards the end of this document).\n\nSet up the following env variables by going to the Configuration tab on the left under Settings. Note that this may be listed directly in Environment Variables depending on your Azure UI.\n\n    TENANT_ID: copied from previous section\n\n    CLIENT_ID: copied from previous section\n\nGo to the Console tab under the Development Tools\n\n    Install the following packages in console\n\n       npm install @microsoft/microsoft-graph-client\n\n       npm install axios\n\nOnce this is complete, try calling the function (POST call) from Postman again, putting the below into body (using a query and search term you think will generate responses).\n\n         {\n        \"searchTerm\": \"\"\n    }\n\nIf you get a response, you are ready to set this up with a Custom GPT! See the ChatGPT Section of the Azure Function page for more details on setting this up\n\n\nThe below walks through setup instructions and walkthrough unique to this solution. You can find the entire code here.\n\n\nThe below walks through the different parts of the function. Before you begin, ensure you have the required packages installed and environment variables set up (see the Installation Steps section).\n\n\n\nBelow we have a few helper functions that we’ll use in the function.\n\n\n\nCreate a function to initialize the Graph client with an access token. This will be used to search through Office 365 and SharePoint.\n\nconst { Client } = require('@microsoft/microsoft-graph-client');\n\nfunction initGraphClient(accessToken) {\n    return Client.init({\n        authProvider: (done) =\u003e {\n            done(null, accessToken);\n        }\n    });\n}\n\n\nThis function uses an existing bearer token to request an OBO token from Microsoft's identity platform. This enables passing through the credentials to ensure the search only returns files the logged-in user can access.\n\nconst axios = require('axios');\nconst qs = require('querystring');\n\nasync function getOboToken(userAccessToken) {\n    const { TENANT_ID, CLIENT_ID, MICROSOFT_PROVIDER_AUTHENTICATION_SECRET } = process.env;\n    const params = {\n        client_id: CLIENT_ID,\n        client_secret: MICROSOFT_PROVIDER_AUTHENTICATION_SECRET,\n        grant_type: 'urn:ietf:params:oauth:grant-type:jwt-bearer',\n        assertion: userAccessToken,\n        requested_token_use: 'on_behalf_of',\n        scope: 'https://graph.microsoft.com/.default'\n    };\n\n    const url = https\\://login.microsoftonline.com/${TENANT_ID}/oauth2/v2.0/token;\n    try {\n        const response = await axios.post(url, qs.stringify(params), {\n            headers: { 'Content-Type': 'application/x-www-form-urlencoded' }\n        });\n        return response.data.access\\_token;\n    } catch (error) {\n        console.error('Error obtaining OBO token:', error.response?.data || error.message);\n        throw error;\n    }\n}\n\n\nThis function fetches the content of drive items, converts it to a base64 string, and restructures to match the openaiFileResponse format.\nconst getDriveItemContent = async (client, driveId, itemId, name) =\u003e {\n   try\n       const filePath = /drives/${driveId}/items/${itemId};\n       const downloadPath = filePath + /content\n       // this is where we get the contents and convert to base64\n       const fileStream = await client.api(downloadPath).getStream();\n       let chunks = [];\n           for await (let chunk of fileStream) {\n               chunks.push(chunk);\n           }\n       const base64String = Buffer.concat(chunks).toString('base64');\n       // this is where we get the other metadata to include in response\n       const file = await client.api(filePath).get();\n       const mime_type = file.file.mimeType;\n       const name = file.name;\n       return {\"name\":name, \"mime_type\":mime_type, \"content\":base64String}\n   } catch (error) {\n       console.error('Error fetching drive content:', error);\n       throw new Error(Failed to fetch content for ${name}: ${error.message});\n   }\n\n\nNow that we have all these helper functions, the Azure Function will orchestrate the flow, by authenticating the user, performing the search, and iterating through the search results to extract the text and retrieve the relevant parts of the text to the GPT.\n\nHandling HTTP Requests: The function starts by extracting the query and searchTerm from the HTTP request. It checks if the Authorization header is present and extracts the bearer token.\n\nAuthentication: Using the bearer token, it obtains an OBO token from Microsoft's identity platform using getOboToken defined above.\n\nInitializing the Graph Client: With the OBO token, it initializes the Microsoft Graph client using initGraphClient defined above.\n\nDocument Search: It constructs a search query and sends it to the Microsoft Graph API to find documents based on the searchTerm.\n\nDocument Processing: For each document returned by the search:\n\nIt retrieves the document content using getDriveItemContent.\n\nIt converts the document to base64 string and restructures it to match the openaiFileResponse structure.\n\nResponse: The function sends them back in the HTTP response.\nmodule.exports = async function (context, req) {\n   // const query = req.query.query || (req.body \u0026\u0026 req.body.query);\n   const searchTerm = req.query.searchTerm || (req.body \u0026\u0026 req.body.searchTerm);\n   if (!req.headers.authorization) {\n       context.res = {\n           status: 400,\n           body: 'Authorization header is missing'\n       };\n       return;\n   }\n   /// The below takes the token passed to the function, to use to get an OBO token.\n   const bearerToken = req.headers.authorization.split(' ')[1];\n   let accessToken;\n   try {\n       accessToken = await getOboToken(bearerToken);\n   } catch (error) {\n       context.res = {\n           status: 500,\n           body: Failed to obtain OBO token: ${error.message}\n       };\n       return;\n   }\n   // Initialize the Graph Client using the initGraphClient function defined above\n   let client = initGraphClient(accessToken);\n   // this is the search body to be used in the Microsft Graph Search API: https://learn.microsoft.com/en-us/graph/search-concept-files\n   const requestBody = {\n       requests: [\n           {\n               entityTypes: ['driveItem'],\n               query: {\n                   queryString: searchTerm\n               },\n               from: 0,\n               // the below is set to summarize the top 10 search results from the Graph API, but can configure based on your documents.\n               size: 10\n           }\n       ]\n   };\n\n\n   try {\n       // This is where we are doing the search\n       const list = await client.api('/search/query').post(requestBody);\n       const processList = async () =\u003e {\n           // This will go through and for each search response, grab the contents of the file and summarize with gpt-3.5-turbo\n           const results = [];\n           await Promise.all(list.value[0].hitsContainers.map(async (container) =\u003e {\n               for (const hit of container.hits) {\n                   if (hit.resource[\"@odata.type\"] === \"#microsoft.graph.driveItem\") {\n                       const { name, id } = hit.resource;\n                       // The below is where the file lives\n                       const driveId = hit.resource.parentReference.driveId;\n                       // we use the helper function we defined above to get the contents, convert to base64, and restructure it\n                       const contents = await getDriveItemContent(client, driveId, id, name);\n                       results.push(contents)\n               }\n           }));\n           return results;\n       };\n       let results;\n       if (list.value[0].hitsContainers[0].total == 0) {\n           // Return no results found to the API if the Microsoft Graph API returns no results\n           results = 'No results found';\n       } else {\n           // If the Microsoft Graph API does return results, then run processList to iterate through.\n           results = await processList();\n           // this is where we structure the response so ChatGPT knows they are files\n           results = {'openaiFileResponse': results}\n       }\n       context.res = {\n           status: 200,\n           body: results\n       };\n   } catch (error) {\n       context.res = {\n           status: 500,\n           body: Error performing search or processing results: ${error.message},\n       };\n   }\n};\n\nBelow are some potential areas to customize. \n\nYou can customize the GPT prompt to search again a certain amount of times if nothing is found.\n\nYou can customize the code to only search through specific SharePoint sites or O365 Drives by customizing the search query. This will help focus the search and improve the retrieval. The function as setup now looks through all files the logged-in user can access.\n\nYou can update the code to only return certain types of files. For example, only return structured data / CSVs. \n\nYou can customize the amount of files it searches through within the call to Microsoft Graph. Note that you should only put a maximum of 10 files based on the documentation here. \n\n\nNote that all the same limitations of Actions apply here, with regards to returning 100K characters or less and the 45 second timeout.\n\nMake sure you read the documentation here around returning files and file uploads, as those limitations apply here.\nOnce you've created a Custom GPT, copy the text below in the Instructions panel. Have questions? Check out Getting Started Example to see how this step works in more detail.\nOnce you've created a Custom GPT, copy the text below in the Actions panel. Have questions? Check out Getting Started Example to see how this step works in more detail.\nThis expects a response that matches the file retrieval structure in our doc here and passes in a searchTerm parameter to inform the search.\nMake sure to switch the function app name, function name and code based on link copied in screenshot above\nBelow are instructions on setting up authentication with this 3rd party application. Have questions? Check out Getting Started Example to see how this step works in more detail.\nSee above and on the Azure Function cookbook for more detailed instructions on authentication.\nWhy are you using the Microsoft Graph API in your code instead of the SharePoint API?\n\n  The SharePoint API is legacy - per the Microsoft documentation here, “For SharePoint Online, innovation using a REST API against SharePoint is driven via the Microsoft Graph REST API's.” The Graph API gives us more flexibility, and the SharePoint API still runs into the same file issues listed in the Why is this necessary instead of interacting with the Microsoft Graph API directly? section.\n\nWhat types of files does this support?\n\n  It follows the same guidelines as the documentation here about file uploads. \n\nWhy do I need to request an OBO token?\n\n  When you try to use the same token to authenticate to the Graph API as the one you use to authenticate into the Azure Function, you get an “invalid audience” token. This is because the audience for the token can only be user\\_impersonation.\n\n  To address this, the function requests a new token scoped to Files.Read.All within the app using the On Behalf Of flow. This will inherit the permissions of the logged in user, meaning this function will only search through files the logged-in user has access to. \n\n  We are purposefully requesting a new On Behalf Of token with each request, because Azure Function Apps are meant to be stateless. You could potentially integrate this with Azure Key Vault to store the secret and retrieve programmatically. \nAre there integrations that you’d like us to prioritize? Are there errors in our integrations? File a PR or issue in our github, and we’ll take a look."])</script><script>self.__next_f.push([1,"d8:T505c,"])</script><script>self.__next_f.push([1,"This page provides an instruction \u0026 guide for developers building a GPT Action for a specific application. Before you proceed, make sure to first familiarize yourself with the following information:\nIntroduction to GPT Actions\nIntroduction to GPT Actions Library\nExample of Building a GPT Action from Scratch\nThis solution enables a GPT action to answer a user’s question with the context of files the user can access in SharePoint or Office365, using Microsoft’s Graph API search capabilities and the ability to retrieve files. It uses Azure Functions to process the Graph API response and convert it to a human readable format or structure it in a way ChatGPT understands. This code is meant to be directional, and you should modify it to your requirements.\n\nThis solution pre-processes the file within the Azure Function. The Azure Function returns text, instead of the base64 encoded file. Due to the pre-processing and the conversion to text, this solution is best used for large, unstructured documents, and for when you want to analyze more than the amount of files supported in the first solution (see documentation here).\nValue: Users can now leverage ChatGPT's natural language capability to connect directly to files in Sharpeoint\n\nExample Use Cases:\nA user needs to look up which files relate to a certain topic\nA user needs an answer to a critical question, buried deep in documents\n\nThis solution uses a Node.js Azure Function to, based on the logged in user:\n\nSearch for a relevant file that the user has access to, based on the user’s initial question.\n\nFor each file that is found, convert it to a consistent readable format and retrieve all the text.\n\nUse GPT 4o mini (gpt-4o-mini) to extract the relevant text from the files based on the initial user’s question. Note the pricing of GPT 4o mini here - since we are dealing with small token chunks, the cost of this step is nominal.  \n\nReturns that data to ChatGPT. The GPT then uses that information to respond to the user's initial question.\n\nAs you can see from the below architecture diagram, the first three steps are the same as Solution 1. The main difference is that this solution converts the file to text instead of a base64 string, and then summarizes that text using GPT 4o mini.\n\nCheck out these links from the application before you get started:\nApplication Website: https://www.microsoft.com/en-us/microsoft-365/sharepoint/collaboration\nApplication API Documentation: https://learn.microsoft.com/en-us/previous-versions/office/developer/sharepoint-rest-reference/\nBefore you get started, make sure you go through the following steps in your application environment:\nAccess to a Sharepoint environment\nPostman (and knowledge of APIs and OAuth)\nAn OpenAI API Key from platform.openai.com\nIf you follow the search concept files guide, the Microsoft Graph Search API returns references to files that fit the criteria, but not the file contents themselves. Therefore, middleware is required, rather than hitting the MSFT endpoints directly.\n\nSteps:\n\nloop through the returned files and download the files using the Download File endpoint or Convert File endpoint\n\nconvert that Binary stream to human readable text using pdf-parse\n\nThen, we can optimize further by summarizing using gpt-4o-mini in the function to help with the 100,000 character limit we impose on Actions today. \nSet up an Azure Function using the steps in the Azure Function cookbook\nNow that you have an authenticated Azure Function, we can update the function to search SharePoint / O365\n\nGo to your test function and paste in the code from this file. Save the function.\nThis code is meant to be directional - while it should work out of the box, it is designed to be customized to your needs (see examples towards the end of this document).\n\nSet up the following env variables by going to the Configuration tab on the left under Settings. Note that this may be listed directly in Environment Variables depending on your Azure UI.\n\n    TENANT_ID: copied from previous section\n\n    CLIENT_ID: copied from previous section\n\n    OPENAI_API_KEY: spin up an OpenAI API key on platform.openai.com.\n\nGo to the Console tab under the Development Tools\n\n    Install the following packages in console\n\n       npm install @microsoft/microsoft-graph-client\n\n       npm install axios\n\n       npm install pdf-parse\n\n       npm install openai\n\nOnce this is complete, try calling the function (POST call) from Postman again, putting the below into body (using a query and search term you think will generate responses).\n\n        {\n        \"query\": \"\",\n        \"searchTerm\": \"\"\n    }\n\nIf you get a response, you are ready to set this up with a Custom GPT!\n\nThe below walks through setup instructions and walkthrough unique to this solution of pre-processing the files and extracting summaries in the Azure Function. You can find the entire code here.\n\n\n\nBelow we have a few helper functions that we’ll use in the function.\n\nCreate a function to initialize the Graph client with an access token. This will be used to search through Office 365 and SharePoint.\n\nconst { Client } = require('@microsoft/microsoft-graph-client');\n\nfunction initGraphClient(accessToken) {\n    return Client.init({\n        authProvider: (done) =\u003e {\n            done(null, accessToken);\n        }\n    });\n}\n\nThis function uses an existing bearer token to request an OBO token from Microsoft's identity platform. This enables passing through the credentials to ensure the search only returns files the logged-in user can access.\n\nconst axios = require('axios');\nconst qs = require('querystring');\n\nasync function getOboToken(userAccessToken) {\n    const { TENANT_ID, CLIENT_ID, MICROSOFT_PROVIDER_AUTHENTICATION_SECRET } = process.env;\n    const params = {\n        client_id: CLIENT_ID,\n        client_secret: MICROSOFT_PROVIDER_AUTHENTICATION_SECRET,\n        grant_type: 'urn:ietf:params:oauth:grant-type:jwt-bearer',\n        assertion: userAccessToken,\n        requested_token_use: 'on_behalf_of',\n        scope: 'https://graph.microsoft.com/.default'\n    };\n\n    const url = https\\://login.microsoftonline.com/${TENANT_ID}/oauth2/v2.0/token;\n    try {\n        const response = await axios.post(url, qs.stringify(params), {\n            headers: { 'Content-Type': 'application/x-www-form-urlencoded' }\n        });\n        return response.data.access\\_token;\n    } catch (error) {\n        console.error('Error obtaining OBO token:', error.response?.data || error.message);\n        throw error;\n    }\n}\n\n\nThis function fetches the content of drive items, handling different file types and converting files to PDF when necessary for text extraction. This uses the download endpoint for PDFs and the convert endpoint for other supported file types.\nconst getDriveItemContent = async (client, driveId, itemId, name) =\u003e {\n    try {\n        const fileType = path.extname(name).toLowerCase();\n        // the below files types are the ones that are able to be converted to PDF to extract the text. See https://learn.microsoft.com/en-us/graph/api/driveitem-get-content-format?view=graph-rest-1.0\u0026tabs=http\n        const allowedFileTypes = ['.pdf', '.doc', '.docx', '.odp', '.ods', '.odt', '.pot', '.potm', '.potx', '.pps', '.ppsx', '.ppsxm', '.ppt', '.pptm', '.pptx', '.rtf'];\n        // filePath changes based on file type, adding ?format=pdf to convert non-pdf types to pdf for text extraction, so all files in allowedFileTypes above are converted to pdf\n        const filePath = /drives/${driveId}/items/${itemId}/content + ((fileType === '.pdf' || fileType === '.txt' || fileType === '.csv') ? '' : '?format=pdf');\n        if (allowedFileTypes.includes(fileType)) {\n            response = await client.api(filePath).getStream();\n            // The below takes the chunks in response and combines\n            let chunks = [];\n            for await (let chunk of response) {\n                chunks.push(chunk);\n            }\n            let buffer = Buffer.concat(chunks);\n            // the below extracts the text from the PDF.\n            const pdfContents = await pdfParse(buffer);\n            return pdfContents.text;\n        } else if (fileType === '.txt') {\n            // If the type is txt, it does not need to create a stream and instead just grabs the content\n            response = await client.api(filePath).get();\n            return response;\n        }  else if (fileType === '.csv') {\n            response = await client.api(filePath).getStream();\n            let chunks = [];\n            for await (let chunk of response) {\n                chunks.push(chunk);\n            }\n            let buffer = Buffer.concat(chunks);\n            let dataString = buffer.toString('utf-8');\n            return dataString\n\n    } else {\n        return 'Unsupported File Type';\n    }\n\n    } catch (error) {\n        console.error('Error fetching drive content:', error);\n        throw new Error(Failed to fetch content for ${name}: ${error.message});\n    }\n};\n\n\nThis function utilizes the OpenAI SDK to analyze text extracted from documents and find relevant information based on a user query. This helps to ensure only relevant text to the user’s question is returned to the GPT. \n\nconst getRelevantParts = async (text, query) =\u003e {\n    try {\n        // We use your OpenAI key to initialize the OpenAI client\n        const openAIKey = process.env[\"OPENAI_API_KEY\"];\n        const openai = new OpenAI({\n            apiKey: openAIKey,\n        });\n        const response = await openai.chat.completions.create({\n            // Using gpt-4o-mini due to speed to prevent timeouts. You can tweak this prompt as needed\n            model: \"gpt-4o-mini\",\n            messages: [\n                {\"role\": \"system\", \"content\": \"You are a helpful assistant that finds relevant content in text based on a query. You only return the relevant sentences, and you return a maximum of 10 sentences\"},\n                {\"role\": \"user\", \"content\": Based on this question: \"${query}\", get the relevant parts from the following text:\\n\\n${text}. If you cannot answer the question based on the text, respond with 'No information provided'}\n            ],\n            // using temperature of 0 since we want to just extract the relevant content\n            temperature: 0,\n            // using max_tokens of 1000, but you can customize this based on the number of documents you are searching.\n            max_tokens: 1000\n        });\n        return response.choices[0].message.content;\n    } catch (error) {\n        console.error('Error with OpenAI:', error);\n        return 'Error processing text with OpenAI' + error;\n    }\n};\n\n\nNow that we have all these helper functions, the Azure Function will orchestrate the flow, by authenticating the user, performing the search, and iterating through the search results to extract the text and retrieve the relevant parts of the text to the GPT.\n\nHandling HTTP Requests: The function starts by extracting the query and searchTerm from the HTTP request. It checks if the Authorization header is present and extracts the bearer token.\n\nAuthentication: Using the bearer token, it obtains an OBO token from Microsoft's identity platform using getOboToken defined above.\n\nInitializing the Graph Client: With the OBO token, it initializes the Microsoft Graph client using initGraphClient defined above.\n\nDocument Search: It constructs a search query and sends it to the Microsoft Graph API to find documents based on the searchTerm.\n\nDocument Processing: For each document returned by the search:\n\nIt retrieves the document content using getDriveItemContent.\n\nIf the file type is supported, it analyzes the content using getRelevantParts, which sends the text to OpenAI's model for extracting relevant information based on the query.\n\nIt collects the analysis results and includes metadata like the document name and URL.\n\nResponse: The function sorts the results by relevance and sends them back in the HTTP response.\n\nmodule.exports = async function (context, req) {\n    const query = req.query.query || (req.body \u0026\u0026 req.body.query);\n    const searchTerm = req.query.searchTerm || (req.body \u0026\u0026 req.body.searchTerm);\n    if (!req.headers.authorization) {\n        context.res = {\n            status: 400,\n            body: 'Authorization header is missing'\n        };\n        return;\n    }\n    /// The below takes the token passed to the function, to use to get an OBO token.\n    const bearerToken = req.headers.authorization.split(' ')[1];\n    let accessToken;\n    try {\n        accessToken = await getOboToken(bearerToken);\n    } catch (error) {\n        context.res = {\n            status: 500,\n            body: Failed to obtain OBO token: ${error.message}\n        };\n        return;\n    }\n    // Initialize the Graph Client using the initGraphClient function defined above\n    let client = initGraphClient(accessToken);\n    // this is the search body to be used in the Microsft Graph Search API: https://learn.microsoft.com/en-us/graph/search-concept-files\n    const requestBody = {\n        requests: [\n            {\n                entityTypes: ['driveItem'],\n                query: {\n                    queryString: searchTerm\n                },\n                from: 0,\n                // the below is set to summarize the top 10 search results from the Graph API, but can configure based on your documents.\n                size: 10\n            }\n        ]\n    };\n\n    try {\n        // Function to tokenize content (e.g., based on words).\n        const tokenizeContent = (content) =\u003e {\n            return content.split(/\\s+/);\n        };\n\n        // Function to break tokens into 10k token windows for gpt-4o-mini\n        const breakIntoTokenWindows = (tokens) =\u003e {\n            const tokenWindows = []\n            const maxWindowTokens = 10000; // 10k tokens\n            let startIndex = 0;\n\n            while (startIndex  {\n            // This will go through and for each search response, grab the contents of the file and summarize with gpt-4o-mini\n            const results = [];\n\n            await Promise.all(list.value[0].hitsContainers.map(async (container) =\u003e {\n                for (const hit of container.hits) {\n                    if (hit.resource[\"@odata.type\"] === \"#microsoft.graph.driveItem\") {\n                        const { name, id } = hit.resource;\n                        // We use the below to grab the URL of the file to include in the response\n                        const webUrl = hit.resource.webUrl.replace(/\\s/g, \"%20\");\n                        // The Microsoft Graph API ranks the reponses, so we use this to order it\n                        const rank = hit.rank;\n                        // The below is where the file lives\n                        const driveId = hit.resource.parentReference.driveId;\n                        const contents = await getDriveItemContent(client, driveId, id, name);\n                        if (contents !== 'Unsupported File Type') {\n                            // Tokenize content using function defined previously\n                            const tokens = tokenizeContent(contents);\n\n                            // Break tokens into 10k token windows\n                            const tokenWindows = breakIntoTokenWindows(tokens);\n\n                            // Process each token window and combine results\n                            const relevantPartsPromises = tokenWindows.map(window =\u003e getRelevantParts(window.join(' '), query));\n                            const relevantParts = await Promise.all(relevantPartsPromises);\n                            const combinedResults = relevantParts.join('\\n'); // Combine results\n\n                            results.push({ name, webUrl, rank, contents: combinedResults });\n                        }\n                        else {\n                            results.push({ name, webUrl, rank, contents: 'Unsupported File Type' });\n                        }\n                    }\n                }\n            }));\n\n            return results;\n        };\n        let results;\n        if (list.value[0].hitsContainers[0].total == 0) {\n            // Return no results found to the API if the Microsoft Graph API returns no results\n            results = 'No results found';\n        } else {\n            // If the Microsoft Graph API does return results, then run processList to iterate through.\n            results = await processList();\n            results.sort((a, b) =\u003e a.rank - b.rank);\n        }\n        context.res = {\n            status: 200,\n            body: results\n        };\n    } catch (error) {\n        context.res = {\n            status: 500,\n            body: Error performing search or processing results: ${error.message},\n        };\n    }\n};\n\n\nBelow are some potential areas to customize. \n\nYou can customize the GPT prompt to search again a certain amount of times if nothing is found.\n\nYou can customize the code to only search through specific SharePoint sites or O365 Drives by customizing the search query. This will help focus the search and improve the retrieval. The function as setup now looks through all files the logged-in user can access.\n\nYou could use gpt-4o instead of gpt-4o-mini. This would slightly increase the cost and latency, but you may get higher quality summarizations.\n\nYou can customize the amount of files it searches through within the call to Microsoft Graph.\n\n\n\nNote that all the same limitations of Actions apply here, with regards to returning 100K characters or less and the 45 second timeout.\n\n\nThis only works for text, not for images. With some additional code in the Azure Function, you could customize this by using GPT-4o to extract summarizations of images.\n\nThis does not work for structured data. We recommend Solution 1 if structured data is a major part of your use case.\nOnce you've created a Custom GPT, copy the text below in the Instructions panel. Have questions? Check out Getting Started Example to see how this step works in more detail.\nOnce you've created a Custom GPT, copy the text below in the Actions panel. Have questions? Check out Getting Started Example to see how this step works in more detail.\nThe below spec passes in the query parameter to inform the pre-processing and a searchTerm to find the right files in Microsoft Graph.\nMake sure to switch the function app name, function name and code based on link copied in screenshot above\nBelow are instructions on setting up authentication with this 3rd party application. Have questions? Check out Getting Started Example to see how this step works in more detail.\nSee above and on the Azure Function cookbook for more detailed instructions on authentication.\nWhy are you using the Microsoft Graph API in your code instead of the SharePoint API?\n\n  The SharePoint API is legacy - per the Microsoft documentation here, “For SharePoint Online, innovation using a REST API against SharePoint is driven via the Microsoft Graph REST API's.” The Graph API gives us more flexibility, and the SharePoint API still runs into the same file issues listed in the Why is this necessary instead of interacting with the Microsoft Graph API directly? section.\n\nWhat types of files does this support?\n    This supports all files listed in the documentation for the Convert File endpoint here. Specifically, it supports pdf, doc, docx, odp, ods, odt, pot, potm, potx, pps, ppsx, ppsxm, ppt, pptm, pptx, rtf.\n\n    When a search result returns XLS, XLSX, or CSV, this prompts the user to download the file and re-upload to ask questions using Advanced Data Analysis. As stated above, we recommend solution 1 if structured data is part of your use case.\n\nWhy do I need to request an OBO token?\n\n  When you try to use the same token to authenticate to the Graph API as the one you use to authenticate into the Azure Function, you get an “invalid audience” token. This is because the audience for the token can only be user\\_impersonation.\n\n  To address this, the function requests a new token scoped to Files.Read.All within the app using the On Behalf Of flow. This will inherit the permissions of the logged in user, meaning this function will only search through files the logged-in user has access to. \n\n  We are purposefully requesting a new On Behalf Of token with each request, because Azure Function Apps are meant to be stateless. You could potentially integrate this with Azure Key Vault to store the secret and retrieve programmatically. \nAre there integrations that you’d like us to prioritize? Are there errors in our integrations? File a PR or issue in our github, and we’ll take a look."])</script><script>self.__next_f.push([1,"d9:T2497,"])</script><script>self.__next_f.push([1,"This page provides an instruction \u0026 guide for developers building middleware to connect a GPT Action to a specific application. Before you proceed, make sure to first familiarize yourself with the following information:\nIntroduction to GPT Actions\nIntroduction to GPT Actions Library\nExample of Building a GPT Action from Scratch\nThis particular GPT Action provides an overview of how to build an Azure Function, MSFT's cloud-based function builder. This documentation helps a user set up an OAuth-protected Azure Function to connect to a GPT Action, and to a sample application.\nValue: Users can now leverage ChatGPT's natural language capability to connect directly to Azure Function. This can in a few ways:\n\n100k character limit in GPT Actions: users can use the middleware to pre-process the text response from an API. For example, you can use OpenAI’s API in the middleware to summarize the text before sending it back to ChatGPT.\nTypically for actions, users are relying on the SaaS API to return text. You can convert the response for the vendor API into easily digestible text, and it can handle different data types such as structured and unstructured data.\nIt can return files instead of just text. This can be useful to surface CSV files for Data Analysis, or bring back an PDF file and ChatGPT will treat it like an upload.\n\nExample Use Cases:\nA user needs to look up files in Sharepoint, but needs a middleware app between ChatGPT and Sharepoint\nA user has built several steps in a row in an Azure function, and needs to be able to kick off that process using ChatGPT\nCheck out these links from the application before you get started:\nApplication Website: https://learn.microsoft.com/en-us/azure/azure-functions/\nApplication API Documentation: https://learn.microsoft.com/en-us/azure/azure-functions/functions-reference/\nBefore you get started, make sure you go through the following steps in your application environment:\nAzure Portal with access to create Azure Function Apps and Azure Entra App Registrations\nYou can read more about languages and deployment options for Azure Functions on the left hand side of the documentation here. \n\nSee Microsoft’s documentation here for how to deploy using VSCode. If you have familiarity with this approach, feel free to use it. \n\n\n\nSee the documentation here for how to deploy using the Azure portal. We’ll walk through an example here step by step.\n\n\nCreate an Azure Function app. I used the following settings but you can use anything you are comfortable with. Note that not every language / operating system allows for editing the functions in the console directly - the combination I chose below does. For my walkthrough, I left everything as default and made the selections below. The below settings work out of the box for the SharePoint Node.js solutions here and here.\n\n   Basics\n\n      Do you want to deploy code or container image?:  Code\n\n      Runtime stack: Node.js\n\n      Operating system: Windows\n\n   Networking\n\n      Enable public access: on (need this on to connect to the GPT)\n\nAfter completing the above, you’ll land on the “Deployments” page. Once the deployment completes (which should only take a few minutes) click on “Go to Resource” to go back to the Function App\nYou may get an error the first time you attempt this, click create again and it will likely work.\nOn the left-hand side menu of the Azure Function App, click on Authentication under the Settings menu. \n\n   Add identity provider\n\n   Select Microsoft as identity provider. \n\n   Workforce as tenant type\n\n   Create a new application. The instructions are fairly similar if you are using an existing application, but it is easier to create a new application as it will have the callback URLs and the API exposed automatically using “Easy Auth”. You can read more about that here.\n\n   Leave all the other settings on this page as the default, but feel free to change based on your internal guidelines.\n\n   On the permissions tab, click Add Permission and add Files.Read.All and Sites.ReadAll, then Add. This allows this application to read files which is important in order to use the Microsoft Graph Search API. If you are not using this for the SharePoint solution here and here you can skip this.\n\nOnce it is created, click on the enterprise application you just created (so, leave the Function App page and land on the Enterprise Application that you just spun up). We are now going to give it one more permission, to execute the Azure Function by impersonating the user logging into the application. See here for more details.\n\n   On the main page, click “View API Permissions”\n\n   Search for Microsoft Azure App Service in the APIs my organization uses and find user\\_impersonation \n\n   Add it, then you’ll need an Admin on Azure Portal to Grant Admin Consent.\n\n5) Within that enterprise application, Click on “Expose an API” on the left hand menu under Manage, then copy the scope that was created using the Copy to Clipboard button. The scope should look like “api://\\/user\\_impersonation”. Save this for later as SCOPE.\n\n6) Click on “Authentication” on the left hand menu under Manage\n\n   Under the Web section, you’ll notice one callback URI was added automatically. Add the Postman redirect URI () for testing.\n\n7) On the left-hand side, go to Overview. Copy the application (client) ID and and the directory (tenant) ID and save for later as CLIENT_ID and TENANT_ID.\nLeave the page by going home and then back to your Function App.\n\nClick on Create Function. For this example, I’m going to develop it in the portal, but you can also use VSCode or another IDE.\n\n   Choose HTTP trigger\n\n   For Authorization Level, you can choose any key type you want.\n\n      Note this may error out the first time, but it is likely the Function did create, do a refresh of the page to check.\n\nClick on the function you just created (You may need to click refresh to see it). Click on Get Function URL and save it to test in Postman. You will also use this when creating the OpenAPI spec later when you put it into the GPT. \n\nGo back to the function app and click on Configuration. Show the value for the MICROSOFT_PROVIDER_AUTHENTICATION_SECRET variable, copy it (click advanced edit to copy it), and save it for later.  \n\nAt this point, you should have a test function created, and you should have saved a client id, tenant id, secret, scope, and function URL. You are now ready to test out the authentication in Postman\nTry to hit endpoint you created in Postman using those OAuth settings:\n\n    Grant Type: Authorization Code\n\n    Auth URL: https://login.microsoftonline.com/TENANT_ID/oauth2/v2.0/authorize\n\n    Auth Token URL: https://login.microsoftonline.com/TENANT_ID/oauth2/v2.0/token\n\n    Client ID: CLIENT_ID from step 7 above\n\n    Client secret: MICROSOFT_PROVIDER_AUTHENTICATION_SECRET from step 11 above\n\n    Scope: SCOPE from step 5 above\n\n    Client credentials: Send client credentials in body\n\nYou will need to click Get New Access Token, and then hit the endpoint you saved in step 10 above. If it was successful, you should get this response: ”This HTTP triggered function executed successfully. Pass a name in the query string or in the request body for a personalized response.”\nThis should be done separately and is specific to your app. See the Sharepoint Cookbook) for an example of that.\nGenerate an OpenAPI spec for your endpoint. \n\nPaste that into the Actions section of a GPT, and choose OAuth as the authentication type. Fill out the OAuth settings the same way you did for Postman above. \n\nOnce you save the action, you will see a callback URI at the bottom of the GPT configuration. Copy that URL, then go back to your Function App in the Azure Portal.\n\nClick on Authentication under Settings, then click on your Entra application.\n\nOnce you are there, then click Authentication under the Manage section.\n\nAdd a new Redirect URI under the Web section of that page, and paste in the Callback URI you got from step 16, then click Save. \n\nTest out the GPT and it should work as expected.\nThis is application specific. See Sharepoint Cookbook) for an example\nOnce you've created a Custom GPT, copy the text below in the Actions panel. Have questions? Check out Getting Started Example to see how this step works in more detail.\nBelow is an example of what connecting to this Middlware might look like. You'll need to insert your application's \u0026 function's information in this section.\nBelow are instructions on setting up authentication with this 3rd party application. Have questions? Check out Getting Started Example to see how this step works in more detail.\nBefore you set up authentication in ChatGPT, please take the following steps in the application.\nFollow steps 2 \u0026 4 above to setting up authentication\nIn ChatGPT, click on \"Authentication\" and choose \"OAuth\". Enter in the information below.\nClient ID*: *see step 12 above\nClient Secret*: *ditto\nAuthorization URL*: *ditto\nToken URL*: *ditto\nScope*: *ditto\nToken*: *ditto\nOnce you've set up authentication in ChatGPT, follow the steps below in the application to finalize the Action.\nSee above for testing out this application\nAre there integrations that you’d like us to prioritize? Are there errors in our integrations? File a PR or issue in our github, and we’ll take a look."])</script><script>self.__next_f.push([1,"da:T5ea1,"])</script><script>self.__next_f.push([1,"General App Information - Overview of Canvas LMS, its functionality, and the role of ChatGPT's Custom Actions to enhance educational experiences through AI integration.\n\nAuthentication from ChatGPT to Canvas - Explanation of authentication methods (OAuth and User Generated Access Tokens) for connecting ChatGPT to Canvas, with detailed instructions for setting up each option.\n\nSample Use Case: Student Course Assistant - Detailed example of using ChatGPT to assist students with course navigation, exam preparation, and personalized feedback, including specific API calls and workflows.\n\nOther Use Cases for Consideration - Additional potential integrations using the Canvas API, such as classroom analytics and report generation.\n\nCongratulations\n\nCanvas is a widely-used Learning Management System (LMS) designed to support online learning and teaching. It offers a robust set of tools for course management, content delivery, assessments, and student collaboration. Through the Canvas REST API, Canvas allows for extensive customization and integration with third-party applications, including AI-powered tools like ChatGPT.\n\nChatGPT’s Custom Actions with Canvas enable educators to leverage AI to enhance course content, automate tasks, and provide personalized learning journeys for students. Examples include virtual teaching assistants based on active courses, as the capabilities are well-suited for pulling information in from Canvas to create an educational dialogue. ChatGPT with Custom Actions is not meant for automating the entire Canvas experience nor act as a replacement to many of its capabilities better suited for completion in the Canvas app.\n\nFor a general overview on Authentication in Custom Actions, see the Action authentication documentation.\n\nThere are two options for authentication in Canvas: 1) OAuth and 2) User Generated Access Tokens.\nFor large-scale deployments, it is required to use OAuth for Action Authentication.\nIf the user is considering a single-user deployment or does not have access to Admin Settings, they may consider User Generated Access Tokens. Be aware that any request made by the action will be made using the token the user generated, so Canvas will register all requests as the user's activity and use the user's permissions to complete them.\n\n\nWhile this Canvas Cookbook does not use OAuth, any deployment with more than one user must use it. See OAuth for Canvas Documentation for a detailed walkthrough.\n\nHere are some things to keep in mind while implementing OAuth in a Canvas Custom Action:\n\nAccess to Canvas’ Admin settings is required for OAuth in order to retrieve a Client ID and Client Secret.\nThe Authorization URL will look like (make sure to update the Canvas Install URL): https:///login/oauth2/auth\nThe Token URL will look like (make sure to update the Canvas Install URL): ttps:///login/oauth2/token\nScopes may not need to be defined in the Custom Action. If the developer key does not require scopes and no scope parameter is specified, the access token will have access to all scopes. If the developer key does require scopes and no scope parameter is specified, Canvas will respond with \"invalid_scope.\" More information on developer keys here and endpoints here.\nToken Exchange Method is Default (POST Request)\nCanvas uses the term redirect_uri where ChatGPT uses the term Callback URL for URL to complete the redirect process after successful authentication.\n\n\nIn some cases, it may be appropriate to use User Generated Access Tokens for Custom Action authentication with Canvas. Here are the steps to follow to do so:\n\n  Proceed to Canvas Account Settings shown here:\n  canvas_lms_settings_link.png\n  Scroll down to the List of Tokens shown here:\n  canvas_lms_list_of_tokens.png\n  Generate a New Token, and store this token. It will not be accessible later.\n  canvas_lms_new_token.png\n\n\n\nAssists students in navigating and understanding their courses by providing detailed information, generating personalized practice exams, and offering constructive feedback to enhance learning.\n\n\nSome information like the Syllabus is returned as an HTML page when requested by the API. This renders it impossible to show in ChatGPT. Instead, reference course description, modules, and the assignments to guide the user.\nRequests can be modified to retrieve specific pieces of information using the include[] query parameter. If you need to request specific information about a course, provide an example in the GPT instructions.\n\n\nThere can be multiple ways to write these instructions. See here for guidance on Prompt Engineering strategies and best practices.\n\n\n\n\nAsk the user to specify the course they want assistance with and the particular area of focus (e.g., overall course overview, specific module).\nIf you do not know the Course ID for the course requested, use the listYourCourses to find the right course and corresponding ID in Canvas. If none of the courses listed returned courses that seem to match the course request, use the searchCourses to see if there are any similarly named course.\nRetrieve the course information from Canvas using the getSingleCourse API call and the listModules API call.\nAsk the user which module(s) they would like to focus on and use the listModuleItems to retrieve the requested module items. For any assignments, share links to them.\nAsk if the user needs more information or if they need to prepare for an exam.\n\nAsk how many questions\nAsk which chapters or topics they want to be tested on, provide a couple examples from the course modules in Canvas.\nAsk 1 question at a time, be sure the questions are multiple choice (do not generate the next question until the question is answered)\nWhen the user answers, tell them if its right or wrong and give a description for the correct answer\nAsk the user if they want to export the test results and write the code to create the PDF\nOffer additional resources and study tips tailored to the user's needs and progress, and inquire if they require further assistance with other courses or topics.\n\nFormat the generated study guide in a table\n\n\nAPI Calls Featured\n  [GET] listYourCourses\n  [GET] getSingleCourse\n  [GET] listModules\n  [GET] listModuleItems\n  [GET] searchCourses\n\nBelow was generated with a combination of Canvas API Reference and the ActionsGPT.\n\nopenapi: 3.1.0\ninfo:\n  title: Canvas API\n  description: API for interacting with Canvas LMS, including courses, modules, module items, and search functionalities.\n  version: 1.0.0\nservers:\n  url: https://canvas.instructure.com/api/v1\n    description: Canvas LMS API server\n    variables:\n      domain:\n        default: canvas.instructure.com\n        description: The domain of your Canvas instance\npaths:\n  /courses:\n    get:\n      operationId: listYourCourses\n      summary: List your courses\n      description: Retrieves a paginated list of active courses for the current user.\n      parameters:\n        name: enrollment_type\n          in: query\n          description: Filter by enrollment type (e.g., \"teacher\", \"student\").\n          schema:\n            type: string\n        name: enrollment_role\n          in: query\n          description: Filter by role type. Requires admin permissions.\n          schema:\n            type: string\n        name: enrollment_state\n          in: query\n          description: Filter by enrollment state (e.g., \"active\", \"invited\").\n          schema:\n            type: string\n        name: exclude_blueprint_courses\n          in: query\n          description: Exclude Blueprint courses if true.\n          schema:\n            type: boolean\n        name: include\n          in: query\n          description: Array of additional information to include (e.g., \"term\", \"teachers\").\n          schema:\n            type: array\n            items:\n              type: string\n        name: per_page\n          in: query\n          description: The number of results to return per page.\n          schema:\n            type: integer\n          example: 10\n        name: page\n          in: query\n          description: The page number to return.\n          schema:\n            type: integer\n          example: 1\n      responses:\n        '200':\n          description: A list of courses.\n          content:\n            application/json:\n              schema:\n                type: array\n                items:\n                  type: object\n                  properties:\n                    id:\n                      type: integer\n                      description: The ID of the course.\n                    name:\n                      type: string\n                      description: The name of the course.\n                    account_id:\n                      type: integer\n                      description: The ID of the account associated with the course.\n                    enrollment_term_id:\n                      type: integer\n                      description: The ID of the term associated with the course.\n                    start_at:\n                      type: string\n                      format: date-time\n                      description: The start date of the course.\n                    end_at:\n                      type: string\n                      format: date-time\n                      description: The end date of the course.\n                    course_code:\n                      type: string\n                      description: The course code.\n                    state:\n                      type: string\n                      description: The current state of the course (e.g., \"unpublished\", \"available\").\n        '400':\n          description: Bad request, possibly due to invalid query parameters.\n        '401':\n          description: Unauthorized, likely due to invalid authentication credentials.\n\n  /courses/{course_id}:\n    get:\n      operationId: getSingleCourse\n      summary: Get a single course\n      description: Retrieves the details of a specific course by its ID.\n      parameters:\n        name: course_id\n          in: path\n          required: true\n          description: The ID of the course.\n          schema:\n            type: integer\n        name: include\n          in: query\n          description: Array of additional information to include (e.g., \"term\", \"teachers\").\n          schema:\n            type: array\n            items:\n              type: string\n      responses:\n        '200':\n          description: A single course object.\n          content:\n            application/json:\n              schema:\n                type: object\n                properties:\n                  id:\n                    type: integer\n                    description: The ID of the course.\n                  name:\n                    type: string\n                    description: The name of the course.\n                  account_id:\n                    type: integer\n                    description: The ID of the account associated with the course.\n                  enrollment_term_id:\n                    type: integer\n                    description: The ID of the term associated with the course.\n                  start_at:\n                    type: string\n                    format: date-time\n                    description: The start date of the course.\n                  end_at:\n                    type: string\n                    format: date-time\n                    description: The end date of the course.\n                  course_code:\n                    type: string\n                    description: The course code.\n                  state:\n                    type: string\n                    description: The current state of the course (e.g., \"unpublished\", \"available\").\n                  is_public:\n                    type: boolean\n                    description: Whether the course is public.\n                  syllabus_body:\n                    type: string\n                    description: The syllabus content of the course.\n                  term:\n                    type: object\n                    description: The term associated with the course.\n                    properties:\n                      id:\n                        type: integer\n                      name:\n                        type: string\n                      start_at:\n                        type: string\n                        format: date-time\n                      end_at:\n                        type: string\n                        format: date-time\n        '400':\n          description: Bad request, possibly due to an invalid course ID or query parameters.\n        '401':\n          description: Unauthorized, likely due to invalid authentication credentials.\n        '404':\n          description: Course not found, possibly due to an invalid course ID.\n\n  /courses/{course_id}/modules:\n    get:\n      operationId: listModules\n      summary: List modules in a course\n      description: Retrieves the list of modules for a given course in Canvas.\n      parameters:\n        name: course_id\n          in: path\n          required: true\n          description: The ID of the course.\n          schema:\n            type: integer\n        name: include\n          in: query\n          description: Include additional information such as items in the response.\n          schema:\n            type: array\n            items:\n              type: string\n            example: [\"items\"]\n        name: search_term\n          in: query\n          description: The partial title of the module to match and return.\n          schema:\n            type: string\n        name: student_id\n          in: query\n          description: Return module completion information for the student with this ID.\n          schema:\n            type: integer\n        name: per_page\n          in: query\n          description: The number of results to return per page.\n          schema:\n            type: integer\n          example: 10\n        name: page\n          in: query\n          description: The page number to return.\n          schema:\n            type: integer\n          example: 1\n      responses:\n        '200':\n          description: A list of modules in the course.\n          content:\n            application/json:\n              schema:\n                type: array\n                items:\n                  type: object\n                  properties:\n                    id:\n                      type: integer\n                      description: The ID of the module.\n                    name:\n                      type: string\n                      description: The name of the module.\n                    items_count:\n                      type: integer\n                      description: The number of items in the module.\n                    state:\n                      type: string\n                      description: The state of the module (e.g., \"active\", \"locked\").\n        '400':\n          description: Bad request, possibly due to an invalid course ID or query parameters.\n        '401':\n          description: Unauthorized, likely due to invalid authentication credentials.\n        '404':\n          description: Course not found, possibly due to an invalid course ID.\n\n  /courses/{course_id}/modules/{module_id}/items:\n    get:\n      operationId: listModuleItems\n      summary: List items in a module\n      description: Retrieves the list of items within a specific module in a Canvas course.\n      parameters:\n        name: course_id\n          in: path\n          required: true\n          description: The ID of the course.\n          schema:\n            type: integer\n        name: module_id\n          in: path\n          required: true\n          description: The ID of the module.\n          schema:\n            type: integer\n        name: include\n          in: query\n          description: Include additional information in the response, such as content details.\n          schema:\n            type: array\n            items:\n              type: string\n            example: [\"content_details\"]\n        name: student_id\n          in: query\n          description: Return completion information for the student with this ID.\n          schema:\n            type: integer\n        name: per_page\n          in: query\n          description: The number of results to return per page.\n          schema:\n            type: integer\n          example: 10\n        name: page\n          in: query\n          description: The page number to return.\n          schema:\n            type: integer\n          example: 1\n      responses:\n        '200':\n          description: A list of items in the module.\n          content:\n            application/json:\n              schema:\n                type: array\n                items:\n                  type: object\n                  properties:\n                    id:\n                      type: integer\n                      description: The ID of the module item.\n                    title:\n                      type: string\n                      description: The title of the module item.\n                    type:\n                      type: string\n                      description: The type of the module item (e.g., \"Assignment\", \"File\").\n                    position:\n                      type: integer\n                      description: The position of the item within the module.\n                    indent:\n                      type: integer\n                      description: The level of indentation of the item in the module.\n                    completion_requirement:\n                      type: object\n                      description: The completion requirement for the item.\n                      properties:\n                        type:\n                          type: string\n                        min_score:\n                          type: integer\n                    content_id:\n                      type: integer\n                      description: The ID of the associated content item (e.g., assignment, file).\n                    state:\n                      type: string\n                      description: The state of the item (e.g., \"active\", \"locked\").\n        '400':\n          description: Bad request, possibly due to an invalid module ID or query parameters.\n        '401':\n          description: Unauthorized, likely due to invalid authentication credentials.\n        '404':\n          description: Module or course not found, possibly due to an invalid module or course ID.\n\n  /search/all_courses:\n    get:\n      operationId: searchCourses\n      summary: Search for courses\n      description: Searches for public courses in Canvas.\n      parameters:\n        name: search\n          in: query\n          description: The search term to filter courses.\n          schema:\n            type: string\n        name: public_only\n          in: query\n          description: If true, only returns public courses.\n          schema:\n            type: boolean\n        name: open_enrollment_only\n          in: query\n          description: If true, only returns courses with open enrollment.\n          schema:\n            type: boolean\n        name: enrollment_type\n          in: query\n          description: Filter by enrollment type (e.g., \"teacher\", \"student\").\n          schema:\n            type: string\n        name: sort\n          in: query\n          description: Sort the results by \"asc\" or \"desc\" order.\n          schema:\n            type: string\n          enum:\n            asc\n            desc\n        name: per_page\n          in: query\n          description: The number of results to return per page.\n          schema:\n            type: integer\n          example: 10\n        name: page\n          in: query\n          description: The page number to return.\n          schema:\n            type: integer\n          example: 1\n      responses:\n        '200':\n          description: A list of courses matching the search criteria.\n          content:\n            application/json:\n              schema:\n                type: array\n                items:\n                  type: object\n                  properties:\n                    id:\n                      type: integer\n                      description: The ID of the course.\n                    name:\n                      type: string\n                      description: The name of the course.\n                    account_id:\n                      type: integer\n                      description: The ID of the account associated with the course.\n                    enrollment_term_id:\n                      type: integer\n                      description: The ID of the term associated with the course.\n                    start_at:\n                      type: string\n                      format: date-time\n                      description: The start date of the course.\n                    end_at:\n                      type: string\n                      format: date-time\n                      description: The end date of the course.\n                    course_code:\n                      type: string\n                      description: The course code.\n                    state:\n                      type: string\n                      description: The current state of the course (e.g., \"unpublished\", \"available\").\n                    is_public:\n                      type: boolean\n                      description: Whether the course is public.\n                    term:\n                      type: object\n                      description: The term associated with the course.\n                      properties:\n                        id:\n                          type: integer\n                        name:\n                          type: string\n                        start_at:\n                          type: string\n                          format: date-time\n                        end_at:\n                          type: string\n                          format: date-time\n        '400':\n          description: Bad request, possibly due to invalid query parameters.\n        '401':\n          description: Unauthorized, likely due to invalid authentication credentials.\n        '404':\n          description: No courses found matching the criteria.\n\n\nHelp me take a practice exam.\nGive an overview of one of my courses.\nList all of my courses.\n\n\n[On] Web Browsing\n[On] DALL·E Image Generation\n[On] Code Interpreter \u0026 Data Analysis\n\n\nBelow is a non-exhaustive list of additional use cases that could be explored using the Canvas API. The basic outline for each is provided, but the GPT Instructions and specific API calls referenced are intentionally left to you as the user to decide what works best for your needs.\n\nUse Case: Empowers teachers with comprehensive analytics and performance reports on student engagement, grades, and participation. By leveraging this data, teachers can make informed decisions to tailor their course delivery, identify at-risk students, and enhance overall classroom effectiveness.\n\nAPI Resources:\n\nAnalytics and Quiz Statistics: Retrieve detailed data on student participation, grades, and course-level statistics.\nQuiz Reports: Generate and view various reports to analyze overall class performance and track progress over time.\n\n\nUse Case: Provide students with a tool to review their graded assignments, analyze their performance, and receive targeted guidance on how to improve in areas where they have knowledge gaps. The tool can highlight specific questions or sections where the student struggled and suggest additional resources or practice materials to help them improve.\n\nAPI Resources:\n\nSubmissions and Quiz Submissions: Retrieve the student’s submissions and associated grades.\nAssignments: Retrieve detailed information about the assignment, including rubrics and grading criteria.\nRubric Assessments: Access detailed feedback and rubric assessments\nModules: Suggest additional learning modules that target the student’s weak areas using the List modules API.\nQuizzes: Recommend practice quizzes to help the student improve on specific knowledge gaps\n\n\nYou’ve successfully created a Custom GPT with a working Custom Action using Canvas LMS. You should be able to have a conversation that looks similar to the screenshot below. Great job and keep going!\n\ncanvas_lms_sample_conversation.png"])</script><script>self.__next_f.push([1,"db:T11bf,"])</script><script>self.__next_f.push([1,"This page provides an instruction \u0026 guide for developers building a GPT Action for a specific application. Before you proceed, make sure to first familiarize yourself with the following information:\nIntroduction to GPT Actions\nIntroduction to GPT Actions Library\nExample of Buliding a GPT Action from Scratch\nThis particular GPT Action provides an overview of how to connect to Salesforce, specifically, Salesforce Service Cloud. This schema detailed in this Action allows the user to pull case data and update cases directly from ChatGPT. The setup process to create Actions for other Salesforce Cloud solutions uses the same Connected App and authentication setup, but will require a different API schema.\nValue: Users can now leverage ChatGPT's natural language capability to connect directly to Salesforce\n\nExample Use Cases:\nReduce average response time to customers\nReduce time to troubleshoot cases or issues\nEnsure more consistent brand voice in reponse to customers when combined with knowledge and instructions in the GPT\nCheck out these links from the application before you get started:\nCreate Lightning Apps in Salesforce\nOAuth Tokens and Scopes\nSalesforce API Docs\nBefore you get started, make sure you go through the following steps in your application environment:\nEnsure you have permissions to create an App in Salesforce\nOnce you've created a Custom GPT, copy the text below in the Instructions panel. Have questions? Check out Getting Started Example to see how this step works in more detail.\nOnce you've created a Custom GPT, copy the text below in the Actions panel. Have questions? Check out Getting Started Example to see how this step works in more detail.\nBelow are instructions on setting up authentication with this 3rd party application. Have questions? Check out Getting Started Example to see how this step works in more detail.\nBefore you set up authentication in ChatGPT, please take the following steps in the application.\nBefore you set up authentication in ChatGPT, please take the following steps in the application.\nNavigate to Salesforce Setup\ngptactions_salesforce.png\nSearch for “App Manager”\n\ngptactions_salesforce.png\nClick “New Connected App”\nEnter a Connected App Name\nEnter contact email (your email)\nCheck the box to enable OAuth settings\nInsert a callback URL (use a placeholder like https://chat.openai.com/aip//oauth/callback for now, you’ll update this later when you create the Action in ChatGPT)\n\ngptactions_salesforce.png\nSelect “Selected OAuth Scopes” and grant the appropriate permissions. Scope these based on your internal security policies.\n\ngptactions_salesforce.png\nEnsure the following boxes are checked:\nEnable Client Credentials Flow\nEnable Authorization Code and Credentials FLow\nEnable Token Exchange Flow\nEnsure the following box is unchecked:\nRequire Proof Key for Code Exchange (PKCE) Extension for Supported Authorization Flows\n\ngptactions_salesforce.png\nSave your New Connected App\nUnder “Consumer Key and Secret” click “Manage Consumer Details”. Verify your access using the code emailed to your account, and then copy the key and secret.\nSalesforce Consumer Key = ChatGPT Client ID\nSalesforce Consumer Secret = ChatGPT Client Secret\n\ngptactions_salesforce.png\nReturn to App page\nClick “Manage”\nClick “Edit Policies”\nUnder OAuth Policies, check the “Enable Token Exchange Flow” box\n\ngptactions_salesforce.png\nClick save!\nIn ChatGPT, click on \"Authentication\" and choose \"OAuth\". Enter in the information below.\nClient ID**: use Client ID from steps above\nClient Secret**: use Client Secret from steps above\nAuthorization URL**: https://[inserturlhere].my.salesforce.com/services/oauth2/authorize\nToken URL**: https://[inserturlhere].my.salesforce.com/services/oauth2/token\nScope**: full\nToken**: Default (POST)\n\nOnce you've set up authentication in ChatGPT, follow the steps below in the application to finalize the Action.\nCopy the callback URL from the GPT Action\nNavigate back to your Connected App in Salesforce, and add your callback URL.\n\nCallback URL Error:  If you get a callback URL error in ChatGPT, pay close attention to the screenshot above. You need to add the callback URL directly into Salesforce for the action to authenticate correctly\nInternal Server Error: Ensure all the correct boxes are checked and/or unchecked in the OAuth settings for your connected app.\nAre there integrations that you’d like us to prioritize? Are there errors in our integrations? File a PR or issue in our github, and we’ll take a look."])</script><script>self.__next_f.push([1,"dc:Ted7,"])</script><script>self.__next_f.push([1,"This page provides an instruction \u0026 guide for developers building a GPT Action for a specific application. Before you proceed, make sure to first familiarize yourself with the following information:\nIntroduction to GPT Actions\nIntroduction to GPT Actions Library\nExample of Building a GPT Action from Scratch\nThis GPT Action provides an overview of how to connect to Google Gmail, Google’s Private \u0026 Secure Email for Personal or Business. This Action is connected to the Google Gmail APIs that can read, send, list, and draft emails in the authorized account.\nValue: The Gmail GPT will serve as a powerful tool to streamline communication processes, improve customer engagement, and optimize resource allocation.\n\nExample Use Cases:\nManage internal communications by summarizing lengthy emails and drafting responses based on previous email threads.\nSupport agents can provide customers with instant responses adhering to a company’s communication guidelines, tone, and style.\nReference other GPTs , such as a data analsys GPT, and then ask for a draft/send of the consolidated analysis through email communication.\nCheck out these links from the application before you get started:\nApplication Website: https://mail.google.com/mail/u/0/#inbox\nApplication API Documentation: https://developers.google.com/gmail/api/guides\nBefore you get started, make sure you’ve a Google Cloud account and that the Gmail API is enabled:\nSet up a Google Cloud project\nEnable Gmail API from Google API Library\nIf application’s  “Publishing Status” is “Testing”, ensure users are added to your application\nOnce you've created a Custom GPT, copy the text below in the Instructions panel. Have questions? Check out Getting Started Example to see how this step works in more detail.\nOnce you've created a Custom GPT, copy the text below in the Actions panel. Have questions? Check out Getting Started Example to see how this step works in more detail.\nBelow are instructions on setting up authentication with this 3rd party application. Have questions? Check out Getting Started Example to see how this step works in more detail.\nBefore you set up authentication in ChatGPT, please take the following steps in the application.\n\nGo to the Google Cloud Console\nNavigate to API \u0026 Services \u003e Credentials\ngptactions_BigQuery_auth.png\ngptactions_BigQuery_auth.png\nCreate new OAuth credentials (or use an existing one)\n\ngptactions_BigQuery_auth.png\n\nLocate your OAuth Client ID \u0026 Client Secret and store both values securely (see screenshot below)\n\ngptactions_BigQuery_auth.png\nIn ChatGPT, click on \"Authentication\" and choose \"OAuth\". Enter in the information below.\nClient ID**: use Client ID from steps above\nClient Secret**: use Client Secret from steps above\nAuthorization URL**: https://accounts.google.com/o/oauth2/auth\nToken URL**: https://oauth2.googleapis.com/token\nScope**: https://mail.google.com/\nToken**: Default (POST)\nOnce you've set up authentication in ChatGPT, follow the steps below in the application to finalize the Action.\nCopy the callback URL from the GPT Action\nIn the “Authorized redirect URIs” (see screenshot above), add your callback URL\n\nCallback URL Error: If you get a callback URL error in ChatGPT, pay close attention to the screenshot above. You need to add the callback URL directly into GCP for the action to authenticate correctly\nSchema calls the wrong project or dataset: If ChatGPT calls the wrong project or dataset, consider updating your instructions to make it more explicit either (a) which project / dataset should be called or (b) to require the user provide those exact details before it runs the query\nAre there integrations that you’d like us to prioritize? Are there errors in our integrations? File a PR or issue in our github, and we’ll take a look."])</script><script>self.__next_f.push([1,"dd:T1357,"])</script><script>self.__next_f.push([1,"This page provides an instruction \u0026 guide for developers building a GPT Action for a specific application. Before you proceed, make sure to first familiarize yourself with the following information:\nIntroduction to GPT Actions\nIntroduction to GPT Actions Library\nExample of Buliding a GPT Action from Scratch\nThis particular GPT Action provides an overview of how to connect to Jira, Atlassian's tool for project and ticket management. This action assumes a user’s context and allows them to read and write to issues in a given project.\nValue: Users can now leverage ChatGPT's natural language capability to connect directly to Jira Cloud\n\nExample Use Cases:\nA user can load up recent issues for a particular project and use ChatGPT to provide solutions\nA user can create and alter issues and sub-tasks and assign to specific users by instructing ChatGPT\nCheck out these links from the application before you get started:\nApplication Website: https://.atlassian.net/jira\nApplication API Documentation: https://developer.atlassian.com/cloud/jira/platform/rest/v3/intro/\nApplication OAuth 2.0 Documentation: https://developer.atlassian.com/cloud/jira/platform/oauth-2-3lo-apps/\nBefore you get started, make sure you go through the following steps in your application environment:\nEnsure you have the access and permissions to create an application in the Atlassian Cloud Developer Console\nOnce you've created a Custom GPT, copy the text below in the Instructions panel. Have questions? Check out Getting Started Example to see how this step works in more detail.\nOnce you've created a Custom GPT, copy the text below in the Actions panel. Have questions? Check out Getting Started Example to see how this step works in more detail.\nNOTE: Replace the placeholder  in url with your cloud environment's unique ID. You can find this value by visiting https://.atlassian.net/_edge/tenant_info\n\nBelow are instructions on setting up authentication with Jira. Have questions? Check out Getting Started Example to see how this step works in more detail.\n\nCreate an Application: The first step is to create a new application in Jira for the integration with ChatGPT. This can be done by visiting the Atlassian Developer Console, Clicking Create and selecting OAuth 2.0 Integration.\ngptactions_jira_devconsole.png\nFrom here, simply enter the name of your integration and click Create.\ngptactions_jira_newapplication.png\nDefine Permissions: Next we need to provide the required permissions to our application. Within the new application, open the Permissions menu from the sidebar, locate Jira API and click Add and then Configure.\ngptactions_jira_permissions.png\nRequired permissions will vary depending on the intended functionality of the GPT. In this scenario we wish to read and write to Jira issues, so select the following scopes under Jira platform REST API by clicking Edit Scopes:\n\nread:jira-work\nwrite:jira-work\nread:jira-user\n\nOnce selected, click Save\ngptactions_jira_scopes.png\nConfigure Placeholder Callback URL: In order to complete the following step and obtain a Client ID and Secret for enabling secure authentication between ChatGPT and Jira, we first need to add a placeholder callback URL. We can achieve this by clicking on Authorization in the sidebar, and Configure next to OAuth 2.0 (3LO). From here simply enter a placeholder URL and click Save Changes.\n\ngptactions_jira_placeholder.png\nApplication Client ID/Secret: The next step is to locate the Client ID and Secret for enabling secure authentication between ChatGPT and Jira. We can find these values by clicking on Settings in the sidebar and scrolling down to Authentication Details.\n\n      Keep this page open as we will require these values in the next stage of configuration!\ngptactions_jira_clientsecret.png\nIn ChatGPT, click on \"Authentication\" and choose \"OAuth\". Enter in the information below.\nClient ID: The **Client ID from Step 3 of Jira Configuration\nClient Secret: The **Secret from Step 3 of Jira Configuration\nAuthorization URL**: https://auth.atlassian.com/authorize\nToken URL**: https://auth.atlassian.com/oauth/token\nScope**: read:jira-work write:jira-work read:jira-user\nToken Exchange Method**: Default (POST Request)\nOnce you've set up authentication in ChatGPT, follow the steps below in the application to finalize the Action.\nCopy the callback URL from the GPT Action\ngptactions_jira_redirect.png\nIn your application in the Atlassian Developer Console, navigate to the Authorization sidebar tab, next to OAuth 2.0 (3L0) click Configure, and add your callback URL under Callback URL\n\ngptactions_jira_callback.png\nCallback URL Error**: If you get a callback URL error in ChatGPT, double check the Callback URL value as it can occasionally change depending on any alterations made to the authentication\n\nAre there integrations that you’d like us to prioritize? Are there errors in our integrations? File a PR or issue in our github, and we’ll take a look."])</script><script>self.__next_f.push([1,"de:Tdc1,"])</script><script>self.__next_f.push([1,"This page provides an instruction \u0026 guide for developers building a GPT Action for a specific application. Before you proceed, make sure to first familiarize yourself with the following information:\nIntroduction to GPT Actions\nIntroduction to GPT Actions Library\nExample of Buliding a GPT Action from Scratch\nThis particular GPT Action provides an overview of how to connect to Notion. This Action takes a user’s question, scans the relevant Notion pages using Notions search functionality, and then returns information on the matching pages.\nValue: Users can now harness ChatGPT’s natural language capabilities to directly connect to, query, and synthesize their knowledge within Notion. Administrators can explicitly share pages with the integration to manage access.\n\nExample Use Cases:\nA new employee seeks quick how-to information on setting up a new system\nA support agent needs to quickly retrieve information from Notion without reading the entire document\nUsers want to synthesize information and create summaries or transformations for use in other aspects of their work\nCheck out these links from the application before you get started:\nApplication Website: https://www.notion.so/\nApplication API Documentation: https://developers.notion.com/reference/intro\nNotion Authorization Approach: https://developers.notion.com/docs/authorization\n    NOTE:  Notion only allows OAuth with \"Public Integrations.\"  Refer to the linked documentation to determine what is best suited for your needs\nBefore you get started, make sure you go through the following steps in your application environment:\nSet up a notion workspace with populated pages\nSharing pages through notion works best with specific Wikis.  Consider organizing your knowledge base into a wiki or set of wikis\nOnce you've created a Custom GPT, copy the text below in the Instructions panel. Have questions? Check out Getting Started Example to see how this step works in more detail.\nOnce you've created a Custom GPT, copy the text below in the Actions panel. Have questions? Check out Getting Started Example to see how this step works in more detail.\nBelow are instructions on setting up authentication with this 3rd party application.\nBefore you set up authentication in ChatGPT, please take the following steps in the Notion.\nGo to the Notion Settings Page for your workspace\nNavigate to My Connections \u003e Develop or Manage Integrations\nCreate new Integration marked as Internal\nLocate your integration and find the API Key labeled: Internal Integration Secret.  This is the bearer token for this integration.\n\nNOTE! You need to share specific pages, databases, or wikis with the integration in order to access them in ChatGPT.  Do this by selecting the ... button on the upper right of a page and select the appropriate connection.\n\nNOTE! Notion allows integrations to leverage OAuth if they are marked as \"Public.\"  Review Notion's Auth Documentation to determine what integration path is best for your needs.\nnotion_connections.png\nsharing_notion_pages.png\nIn ChatGPT, click on \"Authentication\" and choose \"API Key\". Enter in the information below.\nAPI Key**: Use Internal Integration Secret from steps above\nAuth Type**: Bearer\nSearch returns nothing If you don't see any pages returned when running a search, double check that you've shared relevant pages with the application from Notion\nAre there integrations that you’d like us to prioritize? Are there errors in our integrations? File a PR or issue in our github, and we’ll take a look."])</script><script>self.__next_f.push([1,"df:T138f,"])</script><script>self.__next_f.push([1,"This page provides an instruction \u0026 guide for developers building a GPT Action for a specific application. Before you proceed, make sure to first familiarize yourself with the following information:\nIntroduction to GPT Actions\nIntroduction to GPT Actions Library\nExample of Building a GPT Action from Scratch\nThis particular GPT Action provides an overview of how to connect to Confluence, Atlassian's collaboration and documentation platform. This Action takes a user’s question, scans the relevant Confluence spaces and pages to gather the necessary information, then formulates a response to answer the user’s question. This cookbook does not address updating content in Confluence directly from ChatGPT, but it is technically feasible to accomplish with additional Actions and scopes.\nValue\n\nUsers can now leverage ChatGPT's natural language capability to connect directly to Confluence, enabling seamless interaction with their organization's knowledge base.\n\nExample Use Cases\nKnowledge Workers**: Easily retrieve information from Confluence pages and spaces to answer questions or gather details for reports and presentations.\nProject Managers**: Quickly access project documentation and updates stored in Confluence without manually searching through pages.\nCustomer Support Teams**: Provide accurate and timely responses to customer inquiries by pulling relevant information from the Confluence knowledge base.\nAll Users**: Gain more visibility into company-wide documentation, policies, and procedures, enhancing collaboration and knowledge sharing.\nCheck out these links from the application before you get started:\nApplication Website: https://developer.atlassian.com/console/myapps/\nApplication API Documentation: https://developer.atlassian.com/cloud/confluence/rest/v2/intro/#about\nBefore you get started, make sure you go through the following steps in your application environment:\nEnsure you have permissions to create an App in the Atlassian Developer Portal\nDetermine what interactions you would like your GPT to take (search, read, edit, etc.)\nOnce you've created a Custom GPT, copy the text below in the Instructions panel. Have questions? Check out Getting Started Example to see how this step works in more detail.\nOnce you've created a Custom GPT, copy the text below in the Actions panel. Have questions? Check out Getting Started Example to see how this step works in more detail.\nBelow are instructions on setting up authentication with this 3rd party application. Have questions? Check out Getting Started Example to see how this step works in more detail.\nBefore you set up authentication in ChatGPT, make sure you go through the following steps within the Atlassian Developer portal to create your Confluence app:\nSelect the Create drop-down\nChoose OAuth 2.0 integration\nGive a name, agree to terms, and click Create\nSelect \"Distribution\" on the left-hand menu and click “Edit”\nChange radio button to \"Sharing\"\nFill out required fields and Save Changes\nSelect \"Permissions\" on the left-hand menu\nAdd in the scopes you would like to include (e.g., User identity API and Confluence API so that the app can know what a user has access to and fetch from Confluence)\nSelect \"Authorization\" on the left-hand menu\nClick \"Add\" under Action in the row for OAuth 2.0\nEnter the callback URL from your GPT (note: you may need to add a placeholder for now and revisit this once you have created the Action and OAuth in your GPT so that you have the final callback URL)\nSelect \"Settings\" under the left-hand menu\nCopy your Client ID and Secret for us in OAuth setup in GPT\n\nconfluence_gpt.png\nIn ChatGPT, click on \"Authentication\" and choose \"OAuth\". Enter in the information below.\nClient ID**: use Client ID from steps above\nClient Secret**: use Client Secret from steps above\nAuthorization URL**: https://auth.atlassian.com/authorize\nToken URL**: https://auth.atlassian.com/oauth/token\nScope**: read:confluence-content.all search:confluence\nToken**: Default (POST)\nOnce you've set up authentication in ChatGPT, follow the steps below in the application to finalize the Action.\nCopy the callback URL from the GPT Action\nIn the “Authorized redirect URIs” (see screenshot above), add your callback URL\n\nCallback URL Error: If you get a callback URL error in ChatGPT, pay close attention to the screenshot above. You need to add the callback URL directly into your Confluence app for the action to authenticate correctly\nSchema calls the wrong project or dataset: If ChatGPT calls the wrong project or dataset, consider updating your instructions to make it more explicit either (a) which project / dataset should be called or (b) to require the user provide those exact details before it runs the query\nLooping Actions: You may not have given the necessary scopes/permissions to your app to accomplish its intended purpose\nAre there integrations that you’d like us to prioritize? Are there errors in our integrations? File a PR or issue in our github, and we’ll take a look."])</script><script>self.__next_f.push([1,"e0:T22ab,"])</script><script>self.__next_f.push([1,"This is a guide for developers seeking to give ChatGPT the ability to query a SQL database using a GPT Action. Before reading this guide, please familiarize yourself with the following content:\n\n\n\nIntroduction to GPT Actions\nIntroduction to GPT Actions Library\nExample of Building a GPT Action from Scratch\n\nThis guide outlines the workflow required to connect ChatGPT to a SQL Database via a middleware application. We’ll use a PostgreSQL database for this example, but the process should be similar for all SQL databases (MySQL, MS SQL Server, Amazon Aurora, SQL Server on Google Cloud, etc.). This documentation outlines the steps required to create GPT Action which can:\n\n\n\nExecute read queries against a SQL Database\nReturn records via a text response\nReturn records via a CSV file\n\n\n\nValue: Users can now leverage ChatGPT's natural language capability to answer questions about data in a SQL database:\n\n\n\nBusiness users can access information contained in a SQL database without writing SQL or submitting a request to an analyst\nData analysts can perform complex analysis beyond what is possible with a SQL query by extracting data and analyzing it with ChatGPT\n\nExample Use Cases:\n\n\n\nA business user needs to answer questions about their sales funnel\nA data analyst needs to perform a regression analysis on a large dataset\n\n\n\nGiven that most managed SQL databases do not provide REST APIs for submitting queries, you will need a middleware application to perform the following functions:\n\n\n\nAccept database queries via REST API requests\nForward queries to the integrated SQL database\nConvert database responses in to CSV files\nReturn CSV files to the requestor\n\nThere are two main approaches to designing the first function:\n\n\n\nThe middleware supports a single method for receiving arbitrary SQL queries generated by the GPT and forwards them to the database. The benefits of this approach include:\n    Ease of development\n    Flexibility (doesn’t require you to anticipate the types of queries users will make)\n    Low maintenance (doesn’t require you to update the API schema in response to database changes)\nThe middleware supports a number of methods corresponding to specific allowed queries. The benefits of this approach include:\n    More control\n    Less opportunity for model error when generating SQL\n\nThis guide will focus on option 1. For those interested in option 2, consider implementing a service like PostgREST or Hasura to streamline the process.\n\nAn application architecture diagram depicting the interaction between the user, GPT, middleware, and database\nApplication architecture diagram\n\n\nDevelopers can either build custom middleware (commonly deployed as serverless functions with CSPs like AWS, GCP, or MS Azure) or use third-party solutions (like Mulesoft Anypoint or Retool Workflows). Using third-party middleware can accelerate your development process, but is less flexible than building it yourself.\n\nBuilding your own middleware gives you more control over the application’s behavior. For an example of custom middleware, see our Azure Functions cookbook.\n\nRather than focusing on the specifics of middleware setup, this guide will focus on the middleware’s interface with the GPT and SQL database.\n\n\n\n\n\nGPTs are very good at writing SQL queries based on a user’s natural language prompt. You can improve the GPT’s query generation capabilities by giving it access to the database schema in one of the following ways:\n\n\n\nInstruct the GPT to start by querying the database to retrieve the schema (this approach is demonstrated in more detail in our BigQuery cookbook).\nProvide the schema in the GPT instructions (works best for small, static schemata)\n\nHere are sample GPT instructions which include information about a simple database schema:\n\n\nIn order for our GPT to communicate with our middleware, we’ll configure a GPT Action. The middleware needs to present a REST API endpoint which accepts a SQL query string. You can design this interface in several ways. Here is an example of an OpenAPI schema for a simple endpoint which accepts a “q” parameter in a POST operation:\nA note on authentication: The API interface in the above example accepts a single system-level API key which is stored along with the GPT’s configuration and used to authenticate requests for all GPT users. GPT Actions also support OAuth authentication, which enables user-level authentication and authorization. Learn more about GPT Action authentication options.\n\nBecause the user is authenticating with middleware and not directly with the underlying database, enforcing user-level access (table or row-level permissions) requires more effort. However, it may be required for GPTs where users have different levels of access to the underlying database.\n\n In order to enforce user-level permissions, your middleware should:\n\n\n\nReceive the user’s metadata provided by the IdP during the OAuth flow and extract their identifying information\nQuery the database to retrieve the user’s database permissions\nIssue a command to the database to enforce the relevant permissions for the remainder of the session\n\nIn order to maintain a good user experience, you’ll want to dynamically retrieve the available database schema for each user as opposed to including the schema data in the GPT instructions directly. This ensures that the GPT only has access to tables which it can query on behalf of the current user.\n\n\n\nYour middleware will implement a database driver or client library to enable it to query the PostgreSQL database directly. If you are using third-party middleware, the middleware vendor should provide native connectors for SQL databases. If you are building your own middleware, you may need to implement a client library provided by the database vendor or a third-party. For example, here is a list of community-maintained client libraries for PostgreSQL: https://wiki.postgresql.org/wiki/List_of_drivers\n\nDuring this workflow step, the middleware application needs to extract the SQL string from the request it received from the GPT and forward it to the database using the methods provided by the client library.\n\nA note on read-only permissions: Given that this design pattern results in your database processing arbitrary AI-generated SQL queries, you should ensure that the middleware application has read-only permissions on the database. This ensures that the AI-generated queries cannot insert new data or modify existing data. If write access is required for your use-case, consider deploying operation-specific endpoints rather than accepting arbitrary SQL.\n\n\n\nDepending on the client library you have implemented, your middleware may receive records in a variety of formats. One common pattern is for your middleware to receive an array of JSON objects, each object representing a database record matching the query:\n\n\nIn order for ChatGPT to analyze large numbers of records, it needs access to data in a CSV format. The GPT Actions interface allows GPTs to receive base64-encoded files of up to 10mb in size.\n\nYour middleware needs to perform two actions:\n\n\n\nMany programming languages include a native library for working with CSV files (the Python csv library, for example).\n\nHere’s an example of how your middleware could convert an array of JSON objects into a CSV file:\n\nMany programming languages include a native library for working with base64 encodings (the Python base64 library, for example).\n\nHere’s an example of how your middleware could base64-encode the CSV file generated in the previous step:\n\nIn order for the GPT Actions interface to process the base-64 encoded CSV file, the response returned by your middleware must contain an openaiFileResponse parameter. The value provided must be an array of file objects or links to files (see the Actions documentation for more details). For the purposes of this example, we will work with an array of file objects.\n\nHere is an example of what a valid response body looks like:\n\nOnce your GPT receives the base64-encoded CSV file, it will automatically decode the file and process it to answer the user’s question. This may involve using code interpreter to perform additional analysis against the CSV file, which happens the same way as if a user had uploaded the CSV file via the prompt.\n\nNote: You must enable the Code Interpreter \u0026 Data Analysis capability in your GPT if you want to be able to perform additional analysis on the returned file.\n\n\n\nGPT Actions provide a flexible framework for retrieving data from external sources like SQL databases. Giving ChatGPT the ability to query a database can substantially expand its capabilities as a knowledge assistant and analyst.\n\nAre there integrations that you’d like us to prioritize? Are there errors in our integrations? File a PR or issue in our github, and we’ll take a look."])</script><script>self.__next_f.push([1,"e1:T17fd,"])</script><script>self.__next_f.push([1,"This page provides an instruction \u0026 guide for developers building a GPT Action for a specific application. Before you proceed, make sure to first familiarize yourself with the following information:\nIntroduction to GPT Actions\nIntroduction to GPT Actions Library\nExample of Buliding a GPT Action from Scratch\nThis guide provides details on how to connect chatGPT with a Box.com account, the GPT requires two actions to pull data from Box. The GPT will interact with the Box API directly but requires middleware (ie Azure function) to properly format the response from Box to download and read the file contents. The azure function action is transparent to the end user, meaning the user will not need to explicity call the action.\n\nAction 1 : Box API Action - Leverages the Box API to query data from Box\nAction 2 : Azure function - Formats response from Box enabling chatGPT to download the file directly from Box\n\n\nExisting Box customers can leverage these guidelines to query details about files, contents of files and any metadata related. This enables a OpenAI powered analysis of any content stored in Box such as visualizing data sets and creating summaries across multiple folders and files. This GPT can access folders, files and business process data such as metadata in Box. Additionally Box admins can use this GPT action for visibility into audit trails and health checks.\nCheck out these links from Box and Azure before you get started:\n\nBox Action\nApplication Website: https://app.box.com\nApplication API Documentation: https://developer.box.com/reference/\n\n\n\nAzure Function\nApplication Website: https://learn.microsoft.com/en-us/azure/azure-functions/\nApplication API Documentation: https://learn.microsoft.com/en-us/azure/azure-functions/functions-reference/\n\nBefore you get started, make sure you go through the following steps in your Box environment:\nThis requires a Box developer account to get started : https://developer.box.com/\nFollow the Box Developer site to create a custom app with OAuth 2.0 authentication type  : https://developer.box.com/guides/getting-started/first-application/\nNavigate to Configuration tab for the following values\n    OAuth 2.0 Credentials (Client ID / Client Secret) You will need both of these values for the chatGPT configuration\n    OAuth 2.0 Redirect URIs : You will fill this value in from chatGPT action configuration below\n    Application scopes (Read all files and folders in Box, Manage Enterprise properties)\n\nYou will want to keep this window open, the Redirct URIs needs to be filled in from the gpt configuration.\n\n\n\ngpt_actions_box_boxconfig1.png.png\n\n\n\n\n\nMake sure you go through the following steps in your Azure environment:\nAzure Portal with access to create Azure Function Apps and Azure Entra App Registrations\nThere is a detailed section in this guide related to deploying and designing the function required to wrap the response from Box in order to view the contents of the file. Without the function the GPT will only be able to query data about the file and not the contents. Be sure to read this section after creating the first action.\n\nOnce you've created a Custom GPT, copy the text below in the Instructions panel. Have questions? Check out Getting Started Example to see how this step works in more detail.\nOnce you've created a Custom GPT, you will need to create 2 actions. Copy the text below in the 1st Actions panel, this will be for the Box action. Have questions? Check out Getting Started Example to see how this step works in more detail.\nNote : this schema above does not contain all possible API endpoints, be sure to edit the schema to produce the appropriate actions from Box Developer documentation\nBelow are instructions on setting up authentication with this 3rd party application. Have questions? Check out Getting Started Example to see how this step works in more detail.\nIn ChatGPT, click on \"Authentication\" and choose OAuth\n\n gptactions_box_gptauth.png\nOAuth Connection\n\nClient ID - value from Box custom app you created earlier\nClient Secret - value from Box custom app you created earlier\nAuthorization URL - : https://account.box.com/api/oauth2/authorize?response_type=code\u0026client_id=[client ID from above]\u0026redirect_uri=[use a placeholder like chat.openai.com/aip//oauth/callback for now, you’ll update this later when you create the Action in ChatGPT]\nToken URL : https:api.box.com/oauth2/token\n\n\nYou need to save the configuration and navigate back to the gpt Configuration tab to copy the Callback URL, edit the configuration for the Box action Authorization URL and format the URL as https://account.box.com/api/oauth2/authorize?response_type=code\u0026client_id=[client_ID]\u0026redirect_uri=[callBack URL]\nUpdate the Box.com custom application\n\nCopy the CallBack URL from the gpt and add a OAuth 2.0 Redirect URIs in Box.com\n\n\ngpt_actions_box_boxconfig1.png.png\n\n\n\nNow that we have the GPT created and authenticating against Box.com, we can create the azure function to handle the response formatting enabling the GPT to download the files from Box.\n\nFollow this Azure Cookbook Guide for further details deploying an Azure function. Below you will find sample code to add to the function.\n\nThis code is meant to be directional - while it should work out of the box, it is designed to be customized to your need.\n\n\n\nData flow\n\ngpt_actions_box_azureflow.png\n\n\n\n\nNow that you have the azure function created, add the sample code below:\nfunction_app.py\njwt_config.json.sample\nrequirements.txt\nMake sure to follow the rest of the Azure guide for post authentication steps and chatGPT configuration : Azure Cookbook Guide\nSchema calls the wrong project or dataset: If ChatGPT calls the wrong project or dataset, consider updating your instructions to make it more explicit either (a) which project / dataset should be called or (b) to require the user provide those exact details before it runs the query\nBox can return a large set of data in the event stream which can cause errors,\nAre there integrations that you’d like us to prioritize? Are there errors in our integrations? File a PR or issue in our github, and we’ll take a look."])</script><script>self.__next_f.push([1,"e2:T203a,"])</script><script>self.__next_f.push([1,"This notebook provides step-by-step instructions on using Google Cloud BigQuery as a database with vector search capabilities, with OpenAI embeddings, then creating a Google Cloud Function on top to plug into a Custom GPT in ChatGPT.\n\nThis can be a solution for customers looking to set up RAG infrastructure contained within Google Cloud Platform (GCP), and exposing it as an endpoint to integrate that with other platforms such as ChatGPT.\n\nGoogle Cloud BigQuery is a fully-managed, serverless data warehouse that enables super-fast SQL queries using the processing power of Google's infrastructure. It allows developers to store and analyze massive datasets with ease.\n\nGoogle Cloud Functions is a lightweight, event-based, asynchronous compute solution that allows you to create small, single-purpose functions that respond to cloud events without managing servers or runtime environments.\n\n\nTo run this cookbook, you must have:\nA GCP project you have access to\nGCP user with permission to create a BigQuery dataset and Google Cloud Function\nGCP CLI installed and connected\nOpenAI API key\nChatGPT Plus, Teams or Enterprise subscription\n\n\n\nBelow is a diagram of the architecture of this solution, which we'll walk through step-by-step:\n\nbigquery-rag-architecture.png\n\n\nSetup of Environment Setup environment by installing and importing the required libraries and configuring our GCP settings. Includes:\n    Install and Import Required Libraries\n    Configure GCP project\n    Configure OpenAI Settings\n\n\nPrepare Data Prepare the data for uploading by embedding the documents, as well as capturing additional metadata. We will use a subset of OpenAI's docs as example data for this.\n\nCreate BigQuery Table with Vector search\nCreate a BigQuery table and upload the data we've prepared. Includes:\n\n    Create Dataset: Steps to create a dataset in BigQuery.\n    Create Table and upload data: Instructions to create a table in BigQuery.\n\nCreate GCP Function using gcloud CLI and environment variables computed previously\n\nInput in a Custom GPT in ChatGPT Perform searches on the embedded data in BigQuery:\n\n    Vector Search: Steps to perform vector-based search queries.\n    Metadata filtering Search: Instructions for performing metadata filtering.\nThe below libraries can be categorized as standard Python libraries, third-party libraries, and GCP-related libraries.\n\nIf not already set-up, we'll install GCP CLI's, authenticate to GCP and set your default project.\n\nThis section guides you through setting up authentication for  OpenAI. Before going through this section, make sure you have your OpenAI API key.\n\nThis section explains how to create a dataset in BigQuery and store vectors of float, used for embeddings \u0026 vector search.\nWe're going to embed and store a few pages of the OpenAI docs in the oai_docs folder. We'll first embed each, add it to a CSV, and then use that CSV to upload to the index.\nWe are going to use some techniques highlighted in this cookbook. This is a quick way to embed text, without taking into account variables like sections, using our vision model to describe images/graphs/diagrams, overlapping text between chunks for longer documents, etc.\nIn order to handle longer text files beyond the context of 8191 tokens, we can either use the chunk embeddings separately, or combine them in some way, such as averaging (weighted by the size of each chunk).\n\nWe will take a function from Python's own cookbook that breaks up a sequence into chunks.\nNow we define a function that encodes a string into tokens and then breaks it up into chunks. We'll use tiktoken, a fast open-source tokenizer by OpenAI.\n\nTo read more about counting tokens with Tiktoken, check out this cookbook.\n\nFinally, we can write a function that safely handles embedding requests, even when the input text is longer than the maximum context length, by chunking the input tokens and embedding each chunk individually. The average flag can be set to True to return the weighted average of the chunk embeddings, or False to simply return the unmodified list of chunk embeddings.\nNote: there are other techniques you can take here, including:\n- using GPT-4o to capture images/chart descriptions for embedding\n- chunking based on paragraphs or sections\n- adding more descriptive metadata about each article.\nNext, we can define a helper function that will capture additional metadata about the documents. In this example, I'll choose from a list of categories to use later on in a metadata filter\nNow, we can define some helper functions to process the .txt files in the oai_docs folder. Feel free to use this on your own data, this supports both .txt and .pdf files.\nWe'll now use this helper function to process our OpenAI documentation. Feel free to update this to use your own data by changing the folder in process_files below.\n\nNote that this will process the documents in chosen folder concurrently, so this should take \u003c30 seconds if using txt files, and slightly longer if using PDFs.\nWe now have an embedded_data.csv file with six columns that we can upload to our vector database!\n\nWe'll leverage Google SDK and create a dataset named \"oai_docs\" with a table name of \"embedded_data\", but feel free to change those variables (you can also change regions).\n\nPS: We won't create a BigQuery index, that could improve the performance of the vector search, because such index requires more than 1k rows in our dataset which we don't have in our example, but feel free to leverage that for your own use-case.\n\nWe'll create the table with the attribute name and types. Note the 'content_vector' attribute that allows to store a vector of float for a single row, which we'll use for our vector search.\n\nThis code will then loop on our CSVs previously created to insert the rows into Bigquery.\nIf you run this code multiple time, multiple identical rows will be inserted which will give less accurate results when doing search (you could put uniqueness on IDs or clean the DB each time).\nNow that the data is uploaded, we'll test both pure vector similarity search and with metadata filtering locally below to make sure it is working as expected.\n\nYou can test both a pure vector search and metadata filtering.\n\nThe query below is pure vector search, where we don't filter out on category.\nMetadata filtering allows to restrict findings that have certain attributes on top of having the closest semantic findings of vector search.\n\nThe provided code snippet demonstrates how to execute a query with metadata filtering:\n\n\nWe'll deploy the function in main.py in this folder (also available here).\n\nIn a first step, we'll export the variables to target our table/dataset as well as to generate Embeddings using OpenAI's API.\n\nWe will now create a google function called \"openai_docs_search\" for our current project, for that we'll launch the CLI command below, leveraging the previously created environment variables. Note that this function can be called from everywhere without authentication, do not use that for production or add additional authentication mechanism.\n\nNow that we have a GCP Function that queries this Vector Search Index, let's put it as a GPT Action!\n\nSee documentation here on GPTs and here on GPT Actions. Use the below as the instructions for the GPT and as the OpenAPI spec for the GPT Action.\n\n\nBelow is a sample OpenAPI spec. When we run the block below, a functional spec should be copied to the clipboard to paste in the GPT Action.\n\nNote that this does not have any authentication by default, but you can set up GCP Functions with Auth by following GCP's docs here.\n\nFeel free to modify instructions as you see fit. Check out our docs here for some tips on prompt engineering.\n\nWe've now succesfully integrated GCP BigQuery Vector Search with GPT Actions in ChatGPT by doing the following:\nEmbedded docs using OpenAI's embeddings, while adding some additional metadata using gpt-4o.\nUploaded that data to GCP BigQuery (raw data and vectors of embeddings)\nCreated an endpoint on GCP Functions to retrieve those\nIncorporated it into a custom GPT.\n\nOur GPT can now retrieve informaiton to help answer user queries, making it much more accurate and customized to our data. Here's the GPT in action:\ngcp-rag-quickstart-gpt.png"])</script><script>self.__next_f.push([1,"e3:T791,This page provides an instruction \u0026 guide for developers building a GPT Action for a specific application. Before you proceed, make sure to first familiarize yourself with the following information:\nIntroduction to GPT Actions\nIntroduction to GPT Actions Library\nExample of Building a GPT Action from Scratch\nThis GPT Action provides an overview of how to connect a GPT to Zapier.  Because the majority of configuration occurs on Zapier, we recommend reviewing this helpful guide from Zapier on connecting GPTs to custom Zapier Actions.\nValue: Users can now connect custom GPTs within ChatGPT to Zapier and get instant integration to 6,0000+ apps and 20,000+ actions across the tech stack.\n\nExample Use Cases:\nAn organization has already setup Zapier integrations, and would like to avoid additional integration work when connecting their tech ecosystem with ChatGPT\nBuild a Calendar Assistant GPT which looks up calendar events, and provides additional context based on attendees' LinkedIn profiles\nA CRM GPT to help connect Hubspot to ChatGPT allowing sales teams to update or review contacts and notes on the go\n\nCheck out these links from the application before you get started:\nApplication Website: https://zapier.com\nAI Actions URL: https://actions.zapier.com/gpt/actions/\nAutomatic OpenAPI Configuration: https://actions.zapier.com/gpt/api/v1/dynamic/openapi.json?tools=meta\nBefore you get started, make sure you go through the following step in your Zapier:\nConfigure the desired AI Actions via the AI Action Manager\nzapier_ai_actions.png\nzapier_action_config.png\nIn ChatGPT, from the custom GPT creator screen, click on \"Actions\" and choose \"Import from URL\". Enter in Zapier URL for provisioning GPTs: https://actions.zapier.com/gpt/api/v1/dynamic/openapi.json?tools=meta\nAre there integrations that you’d like us to prioritize? Are there errors in our integrations? File a PR or issue in our github, and we’ll take a look.e4:Tc18,"])</script><script>self.__next_f.push([1,"In this cookbook, we will explore how to use Structured Outputs to build multi-agent systems.\n\nStructured Outputs is a new capability that builds upon JSON mode and function calling to enforce a strict schema in a model output.\n\nBy using the new parameter strict: true, we are able to guarantee the response abides by a provided schema.\n\nTo demonstrate the power of this feature, we will use it to build a multi-agent system.\n\n\nWhen using function calling, if the number of functions (or tools) increases, the performance may suffer.\n\nTo mitigate this, we can logically group the tools together and have specialized \"agents\" that are able to solve specific tasks or sub-tasks, which will increase the overall system performance.\n\nThe use case we will tackle is a data analysis task.\n\nLet's first set up our 4-agents system:\n\nTriaging agent: Decides which agent(s) to call\nData pre-processing Agent: Prepares data for analysis - for example by cleaning it up\nData Analysis Agent: Performs analysis on the data\nData Visualization Agent: Visualizes the output of the analysis to extract insights\n\nWe will start by defining the system prompts for each of these agents.\nWe will then define the tools for each agent.\n\nApart from the triaging agent, each agent will be equipped with tools specific to their role:\n\n\n\nClean data\nTransform data\nAggregate data\n\n\nStatistical analysis\nCorrelation analysis\nRegression Analysis\n\n\nCreate bar chart\nCreate line chart\nCreate pie chart\n\nWe need to write the code logic to:\nhandle passing the user query to the multi-agent system\nhandle the internal workings of the multi-agent system\nexecute the tool calls\n\nFor the sake of brevity, we will only define the logic for tools that are relevant to the user query.\nFrom the user query, we can infer that the tools we would need to call are clean_data, start_analysis and use_line_chart.\n\nWe will first define the execution function which runs tool calls.\n\nThis maps a tool call to the corresponding function. It then appends the output of the function to the conversation history.\nNext, we will create the tool handlers for each of the sub-agents.\n\nThese have a unique prompt and tool set passed to the model.\n\nThe output is then passed to an execution function which runs the tool calls.\n\nWe will also append the messages to the conversation history.\nFinally, we create the overarching tool to handle processing the user query.\n\nThis function takes the user query, gets a response from the model and handles passing it to the other agents to execute. In addition to this, we will keep the state of the ongoing conversation.\n\nFinally, we run the overarching handle_user_message function on the user query and view the output.\n\nIn this cookbook, we've explored how to leverage Structured Outputs to build more robust multi-agent systems.\n\nUsing this new feature allows to make sure that tool calls follow the specified schema and avoids having to handle edge cases or validate arguments on your side.\n\nThis can be applied to many more use cases, and we hope you can take inspiration from this to build your own use case!"])</script><script>self.__next_f.push([1,"e5:Te10,"])</script><script>self.__next_f.push([1,"Structured Outputs is a new capability in the Chat Completions API and Assistants API that guarantees the model will always generate responses that adhere to your supplied JSON Schema. In this cookbook, we will illustrate this capability with a few examples.\n\nStructured Outputs can be enabled by setting the parameter strict: true in an API call with either a defined response format or function definitions.\n\n\nPreviously, the response_format parameter was only available to specify that the model should return a valid JSON.\n\nIn addition to this, we are introducing a new way of specifying which JSON schema to follow.\n\n\n\nFunction calling remains similar, but with the new parameter strict: true, you can now ensure that the schema provided for the functions is strictly followed.\n\n\n\nStructured Outputs can be useful in many ways, as you can rely on the outputs following a constrained schema.\n\nIf you used JSON mode or function calls before, you can think of Structured Outputs as a foolproof version of this.\n\nThis can enable more robust flows in production-level applications, whether you are relying on function calls or expecting the output to follow a pre-defined structure.\n\nExample use cases include:\n\nGetting structured answers to display them in a specific way in a UI (example 1 in this cookbook)\nPopulating a database with extracted content from documents (example 2 in this cookbook)\nExtracting entities from a user input to call tools with defined parameters (example 3 in this cookbook)\n\nMore generally, anything that requires fetching data, taking action, or that builds upon complex workflows could benefit from using Structured Outputs.\n\nIn this example, we want to build a math tutoring tool that outputs steps to solving a math problem as an array of structured objects.\n\nThis could be useful in an application where each step needs to be displayed separately, so that the user can progress through the solution at their own pace.\n\nThe new version of the SDK introduces a parse helper to provide your own Pydantic model instead of having to define the JSON schema. We recommend using this method if possible.\n\nWhen using Structured Outputs with user-generated input, the model may occasionally refuse to fulfill the request for safety reasons.\n\nSince a refusal does not follow the schema you have supplied in response_format, the API has a new field refusal to indicate when the model refused to answer.\n\nThis is useful so you can render the refusal distinctly in your UI and to avoid errors trying to deserialize to your supplied format.\n\nIn this example, we will ask the model to summarize articles following a specific schema.\n\nThis could be useful if you need to transform text or visual content into a structured object, for example to display it in a certain way or to populate database.\n\nWe will take AI-generated articles discussing inventions as an example.\n\nIn this example, we will use function calling to search for products that match a user's preference based on the provided input.\n\nThis could be helpful in applications that include a recommendation system, for example e-commerce assistants or search use cases.\n\nIn this cookbook, we've explored the new Structured Outputs capability through multiple examples.\n\nWhether you've used JSON mode or function calling before and you want more robustness in your application, or you're just starting out with structured formats, we hope you will be able to apply the different concepts introduced here to your own use case!\n\nStructured Outputs is only available with gpt-4o-mini , gpt-4o-2024-08-06, and future models."])</script><script>self.__next_f.push([1,"e6:T1d02,"])</script><script>self.__next_f.push([1,"This page provides an instruction \u0026 guide for developers building middleware to connect a GPT Action to a specific application. Before you proceed, make sure to first familiarize yourself with the following information:\nIntroduction to GPT Actions\nIntroduction to GPT Actions Library\nExample of Building a GPT Action from Scratch\n\nThis particular GPT Action provides an overview of how to build an Google Cloud Function, Google's cloud-based function builder. This documentation helps a user set up an OAuth-protected Google Cloud Function to connect to a GPT Action, and to a sample application.\n\n\nValue: Users can now leverage ChatGPT's natural language capability to connect directly to Google Cloud Function. This can in a few ways:\n\n100k character limit in GPT Actions: users can use the middleware to pre-process the text response from an API. For example, you can use OpenAI’s API in the middleware to summarize the text before sending it back to ChatGPT.\nTypically for actions, users are relying on the SaaS API to return text. You can convert the response for the vendor API into easily digestible text, and it can handle different data types such as structured and unstructured data.\nIt can return files instead of just text. This can be useful to surface CSV files for Data Analysis, or bring back an PDF file and ChatGPT will treat it like an upload.\n\n\nExample Use Cases:\nA user needs to look up query Google Cloud SQL, but needs a middleware app between ChatGPT and Google Cloud SQL\nA user has built several steps in a row in a Google Cloud function, and needs to be able to kick off that process using ChatGPT\n\n\n\nCheck out these links from the application before you get started:\nApplication Website: https://cloud.google.com/functions/docs\nApplication API Documentation: https://cloud.google.com/functions/docs/writing/write-http-functions\n\n\nBefore you get started, make sure you go through the following steps in your application environment:\nGoogle Cloud Console with access to create Google Cloud Functions and Google Cloud APIs (you will need this to set up the OAuth Client)\n\n\n\nThere are 3 options to create and deploy the Google Cloud Functions\n\nIDE - create using your favorite IDE, e.g. VS Code\nGoogle Cloud Console - create using your browser\nGoogle Cloud CLI (gcloud) - create through command line\n\nYou can read up on the supported runtimes here\n\n\nSee Google's documentation here for how to deploy using VSCode. If you have familiarity with this approach, feel free to use it.\n\n\n\nSee the documentation here for how to deploy using the Google Cloud Console.\n\nSee the documentation here for how to deploy using the Google Cloud Console. We’ll walk through an example here step by step.\n\n\nFollow the steps here that are relevant to the OS you are runnning. The last step of this process is for you to run gcloud init and sign in to your Google account\n\nIn this example, we will be setting up a Node.js environment.\n\nmkdir\ncd\n\nInitialize the Node.js project\n\nnpm init\nAccept the default values for npm init\n\nCreate the index.js file\n\nconst functions = require('@google-cloud/functions-framework');\nconst axios = require('axios');\n\nconst TOKENINFO_URL = 'https://oauth2.googleapis.com/tokeninfo';\n\n// Register an HTTP function with the Functions Framework that will be executed\n// when you make an HTTP request to the deployed function's endpoint.\nfunctions.http('executeGCPFunction', async (req, res) =\u003e {\n  const authHeader = req.headers.authorization;\n\n  if (!authHeader) {\n    return res.status(401).send('Unauthorized: No token provided');\n  }\n\n  const token = authHeader.split(' ')[1];\n  if (!token) {\n    return res.status(401).send('Unauthorized: No token provided');\n  }\n\n  try {\n    const tokenInfo = await validateAccessToken(token);\n    res.json(\"You have connected as an authenticated user to Google Functions\");\n  } catch (error) {\n    res.status(401).send('Unauthorized: Invalid token');\n  }\n});\n\nasync function validateAccessToken(token) {\n  try {\n    const response = await axios.get(TOKENINFO_URL, {\n      params: {\n        access_token: token,\n      },\n    });\n    return response.data;\n  } catch (error) {\n    throw new Error('Invalid token');\n  }\n}\n\nThis step below will install and add the necessary dependencies in your package.json file\n\nnpm install @google-cloud/functions-framework\nnpm install axios\n\nnpx @google-cloud/functions-framework --target=executeGCPFunction\n\ngcloud functions deploy gcp-function-for-chatgpt \\\n  --gen2 \\\n  --runtime=nodejs20 \\\n  --region=us-central1 \\\n  --source=. \\\n  --entry-point=executeGCPFunction \\\n  --trigger-http \\\n  --allow-unauthenticated\n\n\n\nOnce you've created a Custom GPT, copy the text below in the Instructions panel. Have questions? Check out Getting Started Example to see how this step works in more detail.\n\nWhen the user asks you to test the integration, you will make a call to the custom action and display the results\n\n\nOnce you've created a Custom GPT, copy the text below in the Actions panel. Have questions? Check out Getting Started Example to see how this step works in more detail.\n\nBelow is an example of what connecting to this Middlware might look like. You'll need to insert your application's \u0026 function's information in this section.\n\nopenapi: 3.1.0\ninfo:\n  title: {insert title}\n  description: {insert description}\n  version: 1.0.0\nservers:\n  url: {url of your Google Cloud Function}\n    description: {insert description}\npaths:\n  /{your_function_name}:\n    get:\n      operationId: {create an operationID}\n      summary: {insert summary}\n      responses:\n        '200':\n          description: {insert description}\n          content:\n            text/plain:\n              schema:\n                type: string\n                example: {example of response}\n\n\nBelow are instructions on setting up authentication with this 3rd party application. Have questions? Check out Getting Started Example to see how this step works in more detail.\n\n\nIn Google Cloud Console, you need to create OAuth client ID credentials. To navigate to the right page search for \"Credentials\" in Google Cloud Console or enter https://console.cloud.google.com/apis/credentials?project= in your browser. You can read more about it here.\n\nClick on \"CREATE CREDENTIALS\" and select \"Oauth client ID\". Select \"Web Application\" for \"Application type\" and enter the name of your application (see below).\n\n\n\nIn the \"OAuth client created\" modal dialog, please take note of the\n\nClient ID\nClient secret\n\n\n\nIn ChatGPT, click on \"Authentication\" and choose \"OAuth\". Enter in the information below.\n\nClient ID*: *see step above\nClient Secret*: *see step above\nAuthorization URL**: https://accounts.google.com/o/oauth2/auth\nToken URL**: https://oauth2.googleapis.com/token\nScope**: https://www.googleapis.com/auth/userinfo.email\n\n\nEdit the OAuth 2.0 Client ID you create in Google Cloud earlier and add the callback URL you received after creating your custom action.\n\n\n\n\nYou are now ready to test out the GPT. You can enter a simple prompt like \"Test Integration\" and expect to see the following:\n\nRequest to sign into Google\nAllow request to your Google Function\nResponse from ChatGPT showing the response from your function - e.g. \"You have connected as an authenticated user to Google Functions\"\n\nAre there integrations that you’d like us to prioritize? Are there errors in our integrations? File a PR or issue in our github, and we’ll take a look."])</script><script>self.__next_f.push([1,"e7:T1207,"])</script><script>self.__next_f.push([1,"This page provides an instruction \u0026 guide for developers building a GPT Action for a specific application. Before you proceed, make sure to first familiarize yourself with the following information:\nIntroduction to GPT Actions\nIntroduction to GPT Actions Library\nExample of Building a GPT Action from Scratch\nThis solution enables a GPT action to retrieve data from Redshift and perform data analysis.It uses AWS Functions, performing every action from AWS ecosystem and network. The middleware (AWS function) will perform the SQL query, wait for its completion and return the data as a file. The code is provided for information purpose only and should be modified to your needs.\n\nThis solution uses the ability to retrieve files in Actions and use them as if you had uploaded them directly to a conversation.\n\nThis solution highlight a connection to Redshift serverless, the integration with a provisioned Redshift might differ slighltly to retrieve networks and set-up connection, the overall code and (minimal) integration should be similar.\nValue: Leverage ChatGPT's natural language capabilities to connect to Redshift's DWH.\n\nExample Use Cases:\nData scientists can connect to tables and run data analyses using ChatGPT's Data Analysis\nCitizen data users can ask basic questions of their transactional data\nUsers gain more visibility into their data \u0026 potential anomalies\nBefore you get started, make sure that:\nYou have access to a Redshift environment\nYou have the rights to deploy AWS function in the same VPC (Virtual Private Network)\nYour AWS CLI is authenticated\nInstall AWS CLI, required for AWS SAM (docs)\nInstall AWS SAM CLI (docs)\nInstall Python\nInstall yq docs\n\nTo create a function, follow the steps in the AWS Middleware Action cookbook.\n\nTo deploy specifically an application that connects to Redshift, use the following code instead of the \"hello-world\" GitHub repository referenced in the Middleware AWS Function cookbook. You can either clone the repository or take the code pasted below and modify it to your needs.\nThis code is meant to be directional - while it should work out of the box, it is designed to be customized to your needs (see examples towards the end of this document).\n\nTo get the code, you can clone openai-cookbook repository and navigate to the redshift-middleware directory\n\ngit clone https://github.com/pap-openai/redshift-middleware\ncd redshift-middleware\n\nWe will need to connnect our function to Redshift, therefore we need to find the network used by Redshift. You can find this on your Redshift interface the AWS console, under Amazon Redshift Serverless \u003e Workgroup configuration \u003e your_workgroup \u003e Data access, or through the CLI:\n\nCopy env.sample.yaml to env.yaml and replace with the values obtained above. You will need a Redshift user with access to your DB/schema.\n\ncp env.sample.yaml env.yaml\n\nFill in env.yaml with the values retrieved by the previous command as well as your credentials to Redshift.\nAlternatively, you can create a file named env.yaml manually and fill the following variables:\nRedshiftHost: default-workgroup.xxxxx.{region}.redshift-serverless.amazonaws.com\nRedshiftPort: 5439\nRedshiftUser: username\nRedshiftPassword: password\nRedshiftDb: my-db\nSecurityGroupId: sg-xx\nSubnetId1: subnet-xx\nSubnetId2: subnet-xx\nSubnetId3: subnet-xx\nSubnetId4: subnet-xx\nSubnetId5: subnet-xx\nSubnetId6: subnet-xx\n\nThis file will be used to deploy your function with parameters, as shown below:\n\nPARAM_FILE=\"env.yaml\"\nPARAMS=$(yq eval -o=json $PARAM_FILE | jq -r 'to_entries | map(\"\\(.key)=\\(.value|tostring)\") | join(\" \")')\nsam deploy --template-file template.yaml --stack-name redshift-middleware --capabilities CAPABILITY_IAM --parameter-overrides $PARAMS\n\nThe template.yaml has the following content:\nRetrieve the URL information from the previous command output, you can then run a cURL request, which should return data in a file format:\nOnce you've created a Custom GPT, copy the text below in the Instructions panel.\nOnce you've created a Custom GPT, copy the text below in the Actions panel.\n\nThis expects a response that matches the file retrieval structure in our doc here and passes in a query as a parameter to execute.\n\nMake sure to follow the steps in the AWS Middleware cookbook to set up authentication.\nMake sure to switch the function app name based on your function deployment.\n\nYou now have deployed a GPT that uses a middleware in AWS, in an authenticated manner, that's able to connect to Redsfhit. Users with access (that are in Cognito) can now query your databases to perform data analysis task:\n\n../../../images/redshift_gpt.png"])</script><script>self.__next_f.push([1,"e8:T28b9,"])</script><script>self.__next_f.push([1,"This particular GPT Action provides an overview of how to build an AWS Lambda function. This documentation helps a user set up an OAuth-protected AWS Function to connect to a GPT Action, and to a sample application. This example uses AWS SAM (Serverless Application Model) in this example to set-up the AWS stack.\nValue: Users can now leverage ChatGPT's capabilities to connect to an AWS Function. This enables you to connect to any services in AWS and run code/applications on this. This can in a few ways:\n\nAccess 3rd party services such as AWS Redshift, AWS DynamoDB, AWS S3 and even more!\nAllows pre-processing text responses from an API (overcoming context limits, adding context or metadata as examples).\nEnables to return files instead of retrieving text from 3rd party APIs. This can be useful to surface CSV files for Data Analysis, or bring back an PDF file and ChatGPT will treat it like an upload.\n\nExample Use Cases:\nA user needs to look up data in Redshift, but needs a middleware app between ChatGPT and Redshift to return files (data analysis data exactitude as well as large number of data)\nA user has built several steps in an AWS function, and needs to be able to kick off that process using ChatGPT.\nWe will leverage AWS Lambda services to create a middleware function. You can get familiar with this stack by visiting the following links:\n\nLambda Website: https://aws.amazon.com/lambda/\nLambda Documentation: https://docs.aws.amazon.com/lambda/\nAWS SAM docs: https://docs.aws.amazon.com/serverless-application-model/\nBefore you get started, make sure you have an AWS Console with access to create: Lambda Function, S3 Buckets, Application Stack, Cognito User Pool, Cognito User Pool App Clients, API Gateway, Lambda roles, CloudFormation stacks (this feels like a lot but creating those services is automated!).\nTo create an AWS Function you can use AWS SAM. An example of a SAM Template can be found here [0].\n\nThis template includes:\nA User Pool \u0026 User Pool Client, used for OAuth\nA Cognito Authorizer that ensure the function can only be called by authenticated users\nMapping the Lambda function to an existing VPC (useful to connect to other AWS services)\nHas parameters that can be set-up dynamically (e.g: credentials/variables)\nAn API Gateway that maps HTTP routes to the functions\n\nThis code is purely informational to help you get started and doesn't require pre-existing AWS resources. We recommend to map existing user pools if you have any instead of creating new ones, as well as setting up your Lambda in a VPC that has access to other AWS Resources (if you need to leverage those). You can see an example of a set-up like this in the RedShift cookbook.\n\nThe Cognito Authorizer is key to make sure your function can only be called/accessed by authenticated users so make sure to set this up correctly with your environment.\n\n[0]\nAWSTemplateFormatVersion: '2010-09-09'\nTransform: AWS::Serverless-2016-10-31\nDescription: \u003e\n  aws-middleware\n\n  AWS middleware function\n\nParameters:\n  CognitoUserPoolName:\n    Type: String\n    Default: MyCognitoUserPool\n  CognitoUserPoolClientName:\n    Type: String\n    Default: MyCognitoUserPoolClient\n\nResources:\n  MyCognitoUserPool:\n    Type: AWS::Cognito::UserPool\n    Properties:\n      UserPoolName: !Ref CognitoUserPoolName\n      Policies:\n        PasswordPolicy:\n          MinimumLength: 8\n      UsernameAttributes:\n        email\n      Schema:\n        AttributeDataType: String\n          Name: email\n          Required: false\n\n  MyCognitoUserPoolClient:\n    Type: AWS::Cognito::UserPoolClient\n    Properties:\n      UserPoolId: !Ref MyCognitoUserPool\n      ClientName: !Ref CognitoUserPoolClientName\n      GenerateSecret: true\n\n  MiddlewareApi:\n    Type: AWS::Serverless::Api\n    Properties:\n      StageName: Prod\n      Cors: \"'*'\"\n      Auth:\n        DefaultAuthorizer: MyCognitoAuthorizer\n        Authorizers:\n          MyCognitoAuthorizer:\n            AuthorizationScopes:\n              openid\n              email\n              profile\n            UserPoolArn: !GetAtt MyCognitoUserPool.Arn\n\n  MiddlewareFunction:\n    Type: AWS::Serverless::Function\n    Properties:\n      CodeUri: aws-middleware/\n      Handler: app.lambda_handler\n      Runtime: python3.11\n      Timeout: 45\n      Architectures:\n        x86_64\n      Events:\n        SqlStatement:\n          Type: Api\n          Properties:\n            Path: /my_route\n            Method: post\n            RestApiId: !Ref MiddlewareApi\n\nOutputs:\n  MiddlewareApi:\n    Description: \"API Gateway endpoint URL for Prod stage for SQL Statement function\"\n    Value: !Sub \"https://${MiddlewareApi}.execute-api.${AWS::Region}.amazonaws.com/Prod/my_route\"\n  MiddlewareFunction:\n    Description: \"SQL Statement Lambda Function ARN\"\n    Value: !GetAtt MiddlewareFunction.Arn\n  MiddlewareFunctionIamRole:\n    Description: \"Implicit IAM Role created for SQL Statement function\"\n    Value: !GetAtt MiddlewareFunctionRole.Arn\n  CognitoUserPoolArn:\n    Description: \"ARN of the Cognito User Pool\"\n    Value: !GetAtt MyCognitoUserPool.Arn\n\nYou can clone the openai-cookbook repository \u0026 take the sample python code \u0026 SAM template from the lambda-middleware directory:\n\ngit clone https://github.com/pap-openai/aws-lambda-middleware\ncd lambda-middleware\n\nTo build \u0026 deploy your function, run the following commands from this directory\n\nsam build\nsam deploy --template-file template.yaml --stack-name aws-middleware --capabilities CAPABILITY_IAM\n\nOnce you have this deployed, you can go check out the application on AWS Lambda:\n\n../../../images/aws_lambda_1.png\n\nYou can confirm that the function is not reachable unless authenticated by running a curl command without any authentication:\n\ncurl -d {}\n\nwhich should return {\"message\":\"Unauthorized\"}.\nOptional: do those steps only if you created a user pool and are not using an existing one\n\nLet's create a user in the newly user pool. To do that, fetch the output of CognitoUserPoolArn in the deploy command, and get the value after the \"/\", which should be in the format of: your-region_xxxxx.\n\naws cognito-idp admin-create-user \\\n    --user-pool-id \"your-region_xxxxx\" \\\n    --username johndoe@example.com \\\n    --user-attributes Name=email,Value=johndoe@example.com \\\n    --temporary-password \"TempPassword123\"\n\nLet's now make sure we create a webpage/domain on which we can log-in. Go to AWS Cognito, select the newly created user pool \u0026 go to App Integration tab:\n\n../../../images/aws_lambda_3.png\n\nCreate a Cognito Domain by clicking on \"Domains\" then \"Create Cognito Domain\"\n\n../../../images/aws_lambda_8.png\n\nScroll down to App client list on the App Integration page of your User Pool:\n\n../../../images/aws_lambda_9.png\n\nSelect your app client and edit the Hosted UI:\n\n../../../images/aws_lambda_10.png\n\nAnd add a callback URL, Authorization Scheme and OAuth scope:\n\n../../../images/aws_lambda_11.png\n\nNote that you'll come back to this step when ChatGPT will generate a callback URL for the authentication of your action. The postman URL, should be used only for development purpose.\n\nYou can try this connection in Postman, under Authorization for your `, copy/paste the value from AWS for the client_id, client_secret and the URL you set up for the auth domain, make sure to add openid` in the scope to get a valid access_token:\n\n../../../images/aws_lambda_12.png\n\n../../../images/aws_lambda_13.png\n\nIf you're now doing the request on Postman, using the access_token you just retrieve, you'll get a success JSON returned:\n\n../../../images/aws_lambda_14.png\nNow let's integrate this into ChatGPT.\n\nCreate an action and copy paste the following spec:\n\nopenapi: 3.1.0\ninfo:\n  title: Success API\n  description: API that returns a success message.\n  version: 1.0.0\nservers:\n  url: https://3ho5n15aef.execute-api.us-east-1.amazonaws.com/Prod\n    description: Main production server\npaths:\n  /my_route:\n    post:\n      operationId: postSuccess\n      summary: Returns a success message.\n      description: Endpoint to check the success status.\n      responses:\n        '200':\n          description: A JSON object indicating success.\n          content:\n            application/json:\n              schema:\n                type: object\n                properties:\n                  success:\n                    type: boolean\n                    example: true\n\nIf you try to test the action (you can click the \"Test\" Button), you'll see that you have a 401 as you're not authenticated.\n\nLet's now add authentication in the action.\n\nClick on Authentication \u003e OAuth.\nWe'll now need to fetch AWS Cognito's variables. Let's go on your User Pool \u003e User Pool App Client. From there you can retrieve your client ID and client Secret.\n\n../../../images/aws_lambda_15.png\n\nCopy paste those values in ChatGPT. Now let's add the Token URLs.\n\nFrom your User Pool you'll find the URL you've previously created for the hosted domain.\n\n../../../images/aws_lambda_16.png\n\nWe'll take this URL and append AWS routes for OAuth.\n\ntoken: /oauth2/token\nauthorization: /oauth2/authorize\n\nCopy paste those in ChatGPT.\n\nIn scope, add openid and click on Save.\nNow go back on your GPT (moving out of the action subview), and you'll see a callback URL provided by ChatGPT for the Authentication:\n\n../../../images/aws_lambda_17.png\n\nGet this URL and edit the hosted UI of your User Pool App client \u0026 save the changes:\n\n../../../images/aws_lambda_18.png\nYou can now test this action again:\n\n../../../images/aws_lambda_19.png\n\nYou will be redirected to AWS Cognito page, which you can log-in in using the credentials previously set-up.\n\nIf you now ask the GPT to run the same action, it will answer correctly as you're now authenticated and able to run this function!\n\n../../../images/aws_lambda_20.png\nYou've now set-up an action in ChatGPT that can talk with your applications in AWS, in an authenticated way! This cookbook shows you how to create the Cognito Pool from scratch using username/password, though, we recommend to set-up Cognito based on your needs (for example by plugging your own IDP into Cognito).\n\nAdditionally, the function is not connected to any other services, which is the advantage of being able to communicate to an AWS Lambda function in a safe way. You can therefore tweak the code and AWS SAM template to fit your need. An example of a more complex function is Redshift, that follows those steps to create the function and authentication but has a different code/deployment."])</script><script>self.__next_f.push([1,"e9:T1513,"])</script><script>self.__next_f.push([1,"This page provides an instruction \u0026 guide for developers building a GPT Action for a specific application. Before you proceed, make sure to first familiarize yourself with the following information:\n\n\nIntroduction to GPT Actions\nIntroduction to GPT Actions Library\nExample of Building a GPT Action from Scratch\n\nThis particular GPT Action provides an overview of how to connect to Google Drive, Google’s File storage system. This action will allow you to list and query against file names, load the file content into your GPT, and ultimately use that data as context in ChatGPT.  This set of actions is extensible by additional methods found via the Google Drive API.  This is great if you want a generalist GPT that can read smaller files, such as:\n\nMeetings minutes\nProduct design documents\nShort memos\nFrequently-asked questions\n\nFor something that wants to read longer memos such as entire books, complex CSVs with many rows, we suggest building a Google Docs or Google Sheets-specific GPT.\n\n\nUsers can now leverage ChatGPT's natural language capability to connect directly to files in Google Drive\n\nExample Use Cases:\n\nA user needs to look up which files relate to a certain topic\nA user needs an answer to a critical question, buried deep in documents\n\n\n\n\n\nCheck out these links from the application before you get started:\n\n\nApplication Website: https://www.google.com/drive/\nApplication API Documentation: https://developers.google.com/drive/api/guides/about-sdk\n\n\n\nBefore you get started, make sure you have a Google Cloud account and that the Drive API is enabled:\n\n\n\nSet up a Google Cloud project\nEnable Google Drive API from Google API Library\nIf application’s  “Publishing Status” is “Testing”, ensure users are added to your application\n\n\n\n\n\nOnce you've created a Custom GPT, to get started, copy the text below in the Instructions panel. You may have to add additional context specific to your use case.  In this way, it is worth testing additional instructions you add to optimize for clarity and accuracy. Have questions? Check out Getting Started Example to see how this step works in more detail.\n\n\nOnce you've created a Custom GPT, copy the text below in the Actions panel. This offers an example of what you could include as functions of your GPT.\n\nHave questions? Check out Getting Started Example to see how this step works in more detail.  As well, try ActionsGPT, a CustomGPT OpenAI created to help with Actions. The three examples are:\n\n\nList Files**: this is the core action that lists the files in your drive.  Within this are a few parameters, such as q, includeItemsFromAllDrives,supportsAllDrives\nGet Metadata**: in case list doesn't work, this can offer as a backup based on certain results - for example, if users attempt to make a search via “meeting from last week”, etc\nExport**: exports in a byte content.  For more reading, please consult https://developers.google.com/drive/api/reference/rest/v3/files/export\n\nGenerally, if ‘get’ is used, the model will attempt to download the file, which may be undesirable. Thus, Export is recommended instead.\n\n\n\nBelow are instructions on setting up authentication with this 3rd party application. Have questions? Check out Getting Started Example to see how this step works in more detail.\n\n\n\nBefore you set up authentication in ChatGPT, please take the following steps in the application.\n\n\n\nGo to the Google Cloud Console\nNavigate to Enabled API \u0026 Services and enable Google Drive API\n\nalt_text\n\nalt_text\n\n\nWithin the search bar, search Google Drive API:\n\nalt_text\n\n\nCreate new OAuth credentials (or use an existing one).  Note that if you haven’t set up an OAuth credentials screen, you will need to do that.\n\n\nalt_text\n\n\n\n\nWithin this process, you will need to grant access to the correct permissions, establish the primary tester as a testing email if Testing is enabled, and set up the OAuth rate limit.\nNext, go to credentials and click “+ Create Credentials” and click “Create Credentials”.  Below is an example of what this screen looks like when it’s already set up.\n\n\nalt_text\n\n\n\n\nLocate your OAuth Client ID \u0026 Client Secret and store both values securely (see screenshot below)\n\n\n\nalt_text\n\n\n\n\nIn ChatGPT, click on \"Authentication\" and choose \"OAuth\". Enter in the information below.\n\nClient ID**: use Client ID from steps above\nClient Secret**: use Client Secret from steps above\nAuthorization URL**: https://accounts.google.com/o/oauth2/auth\nToken URL**: https://oauth2.googleapis.com/token\nScope**: https://www.googleapis.com/auth/drive\n    Note: for a list of more detailed scopes enabled, please refer to Google’s OAuth 2.0 guide.\nToken**: Default (POST)\nPrivacy Policy**: https://policies.google.com/privacy?hl=en-US\n\n\n\nOnce you've set up authentication in ChatGPT, follow the steps below in the application to finalize the Action.\n\n\n\nCopy the callback URL from the GPT Action\n\n\nalt_text\n\n\n\n\nIn the “Authorized redirect URIs”, add your callback URL\n\n\nalt_text\n\n\n\n\n\n\nCallback URL Error: If you get a callback URL error in ChatGPT, pay close attention to the screenshot above. You need to add the callback URL directly into GCP for the action to authenticate correctly.\n\nAre there integrations that you’d like us to prioritize? Are there errors in our integrations? File a PR or issue in our GitHub, and we’ll take a look.\n\n\n\n\ngd2md-html: xyzzy Mon Aug 12 2024"])</script><script>self.__next_f.push([1,"ea:T1f40,"])</script><script>self.__next_f.push([1,"This page provides an instruction \u0026 guide for developers building a GPT Action for a specific application. Before you proceed, make sure to first familiarize yourself with the following information:\n\n\n\nIntroduction to GPT Actions\nIntroduction to GPT Actions Library\nExample of Building a GPT Action from Scratch\nThis particular GPT Action provides an overview of how to connect to a Snowflake Data Warehouse. This Action takes a user’s question, scans the relevant tables to gather the data schema, then writes a SQL query to answer the user’s question.\n\nNote: This cookbook returns back a ResultSet SQL statement, rather than the full result that is not limited by GPT Actions application/json payload limit. For production and advanced use-case, a middleware is required to return back a CSV file. You can follow instructions in the GPT Actions - Snowflake Middleware cookbook to implement this flow instead.\n\nValue: Users can now leverage ChatGPT's natural language capability to connect directly to Snowflake’s Data Warehouse.\n\nExample Use Cases:\n\n\n\nData scientists can connect to tables and run data analyses using ChatGPT's Data Analysis\nCitizen data users can ask basic questions of their transactional data\nUsers gain more visibility into their data \u0026 potential anomalies\n\nCheck out these links from the application before you get started:\n\nApplication Website: https://app.snowflake.com/\nApplication API Documentation: https://docs.snowflake.com/en/developer-guide/sql-api/intro\nBefore you get started, make sure you go through the following steps in your application environment:\n\nProvision a Snowflake Data Warehouse\nEnsure that the user authenticating into Snowflake via ChatGPT has access to the database, schemas, and tables with the necessary role\n\n\nOnce you've created a Custom GPT, copy the text below in the Instructions panel. Have questions? Check out Getting Started Example to see how this step works in more detail.\n\n\nOnce you've created a Custom GPT, copy the text below in the Actions panel. Update the servers url to match your Snowflake Account Name url plus /api/v2 as described here. Have questions? Check out Getting Started Example to see how this step works in more detail.\nBelow are instructions on setting up authentication with this 3rd party application. Have questions? Check out Getting Started Example to see how this step works in more detail.\nSnowflake accounts with network policies that limit connections by IP, may require exceptions to be added for ChatGPT.\nReview the Snowflake documentation on Network Policies\nGo to the Snowflake Worksheets\nCreate a network rule with the ChatGPT IP egress ranges listed here\nCreate a corresponding Network Policy\nNetwork policies can be applied at the account, security integration, and user level. The most specific network policy overrides the more general network policies. Depending on how these policies are applied, you may need to alter the policies for individual users in addition to the security integration. If you face this issue, you may encounter Snowflake's error code 390422 or a generic \"Invalid Client\" error.\nReview the Snowflake OAuth Overview: https://docs.snowflake.com/en/user-guide/oauth-snowflake-overview\nCreate new OAuth credentials through a Security Integration - you will need a new one for each OAuth app/custom GPT since Snowflake Redirect URIs are 1-1 mapped to Security Integrations\n\n  Optional: Automate Network Rule Configuration\n\n  There are now over 100 egress IP addresses used by ChatGPT. The list updates irregularly and without announcement. To keep up to date with it, we can fetch the list on a daily basis and apply it to our network rule.\n\nNetwork rule to allow outbound traffic to OpenAI\n    CREATE OR REPLACE NETWORK RULE chatgpt_actions_rule\n  MODE = EGRESS       -- outbound\n  TYPE = HOST_PORT\n  VALUE_LIST = ('openai.com:443');\nAccess Integration to apply the rule\n    CREATE OR REPLACE EXTERNAL ACCESS INTEGRATION chatgpt_actions_integration\n  ALLOWED_NETWORK_RULES = (chatgpt_actions_rule)\n  ENABLED = TRUE;\n\nUDF to Fetch the IP ranges\n    CREATE OR REPLACE FUNCTION getChatGPTActionsAddresses()\n  RETURNS ARRAY  -- array\n  LANGUAGE PYTHON\n  RUNTIME_VERSION = 3.10\n  PACKAGES = ('requests')\n  EXTERNAL_ACCESS_INTEGRATIONS = (chatgpt_actions_integration)\n  HANDLER = 'get_ip_address_ranges'\nAS\n$$\nimport requests\n\ndef get_ip_address_ranges():\n    resp = requests.get(\"https://openai.com/chatgpt-actions.json\", timeout=10)\n    resp.raise_for_status()\n    data = [entry[\"ipv4Prefix\"] for entry in resp.json().get(\"prefixes\", []) if \"ipv4Prefix\" in entry]\n    return data\n$$;\nProcedure to update the network rule\n    CREATE OR REPLACE PROCEDURE update_chatgpt_network_rule()\n  RETURNS STRING\n  LANGUAGE SQL\nAS\n$$\nDECLARE\n  ip_list STRING;\nBEGIN\n  -- Properly quote the IPs for use in VALUE_LIST\n  ip_list := '''' || ARRAY_TO_STRING(getChatGPTActionsAddresses(), ''',''') || '''';\n\n  -- Run the dynamic SQL to update the rule\n  EXECUTE IMMEDIATE\n    'ALTER NETWORK RULE chatgpt_network_rule SET VALUE_LIST = (' || ip_list || ')';\n\n  RETURN 'chatgpt_network_rule updated with ' || ARRAY_SIZE(getChatGPTActionsAddresses()) || ' entries';\nEND;\n$$;\n\nCall the procedure\n    CALL update_chatgpt_network_rule();\n\nRun the procedure every day at 6AM Pacific Time\n    CREATE OR REPLACE TASK auto_update_chatgpt_network_rule\n  WAREHOUSE = COMPUTE_WH\n  SCHEDULE = 'USING CRON 0 6 * * * America/Los_Angeles'\nAS\n  CALL update_chatgpt_network_rule();\n\nRetrieve your OAuth Client ID, Auth URL, and Token URL\n\n\nYou’ll find the required information in these 3 rows:\n\n../../../images/snowflake_direct_oauth.png\n\nRetrieve your OAuth Client Secret using SHOW_OAUTH_CLIENT_SECRETS\nNow is a good time to test your Snowflake integration in Postman. If you configured a network policy for your security integration, ensure that it includes the IP of the machine you're using to test.\nIn ChatGPT, click on \"Authentication\" and choose \"OAuth\". Enter in the information below.\n\n| Form Field | Value  |\n| -------- | -------- |\n| Authentication Type   | OAuth   |\n| Client ID   | OAUTH_CLIENT_ID from SHOW_OAUTH_CLIENT_SECRETS   |\n| Client Secret   | OAUTH_CLIENT_SECRET from SHOW_OAUTH_CLIENT_SECRETS   |\n| Authorization URL   | OAUTH_AUTHORIZATION_ENDPOINT from DESCRIBE SECURITY INTEGRATION |\n| Token URL   | OAUTH_TOKEN_ENDPOINT from DESCRIBE SECURITY INTEGRATION   |\n| Scope   | session:role:CHATGPT_INTEGRATION_ROLE*   |\n| Token Exchange Method   | Default (POST Request)   |\n\n\n*Snowflake scopes pass the role in the format session:role: for example session:role:CHATGPT_INTEGRATION_ROLE. You can optionally leave this field empty and specify the role in the GPT instructions, but by adding it here it becomes included in OAuth Consent Request which can sometimes be more reliable.\n\nOnce you've set up authentication in ChatGPT, follow the steps below in the application to finalize the Action.\n\nCopy the callback URL from the GPT Action\nUpdate the Redirect URI in your Security Integration to the callback URL provided in ChatGPT.\n\nThis guide is intended to illustrate general concepts and is provided for reference purposes only. We are unable to provide full support for the third party API integration.\nThe callback url can change if you update the YAML, double check it is correct when making changes.\nCallback URL Error: If you get a callback URL error in ChatGPT, pay close attention to the Post-Action Steps above. You need to add the callback URL directly into your Security Integration for the action to authenticate correctly\nSchema calls the wrong warehouse or database: If ChatGPT calls the wrong warehouse or database, consider updating your instructions to make it more explicit either (a) which warehouse / database should be called or (b) to require the user provide those exact details before it runs the query\n\n\nAre there integrations that you’d like us to prioritize? Are there errors in our integrations? File a PR or issue in our github, and we’ll take a look."])</script><script>self.__next_f.push([1,"eb:T47f6,"])</script><script>self.__next_f.push([1,"This page provides an instruction \u0026 guide for developers building a GPT Action for a specific application. Before you proceed, make sure to first familiarize yourself with the following information:\n\nIntroduction to GPT Actions\nIntroduction to GPT Actions Library\nExample of Buliding a GPT Action from Scratch\n\nThis guide provides details on how to connect ChatGPT with a Snowflake Data Warehouse for the purposes of returning a SQL query to ChatGPT for use with Data Analysis. The GPT requires an action that interfaces with middleware (ie Azure function) so that the action can properly format the response from Snowflake for use in the Python notebook environment. Data must be returned as a file, so the middleware function should transform the SQL response into a CSV/Excel file, under 10MB in size.\n\nThis document will outline the Middleware function GPT action. For setting up the middleware function itself, see GPT Actions library (Middleware) - Azure Functions. You can combine this Snowflake middleware action with an action to Snowflake Directly to enable a GPT that can form and test SQL queries prior to executing them.\n\nExisting Snowflake customers can leverage these guidelines to query data from their data warehouse and load that data into the Data Analysis Python environment for further insights. This enables ChatGPT powered analysis such as visualizing data sets, identifying patterns/anomalies, or identifying gaps for data cleansing purposes. This GPT can be used to drive business decisions from relatively small datasets, or to explore subsets of data through AI to generate hypotheses as you explore the holistic dataset in your BI tool, saving time and money, while identifying previously unseen patterns.\n\nCheck out these links from Snowflake and Azure before you get started:\n\nSnowflake Action\n\nApplication Website: https://app.snowflake.com/\nApplication Python Connector Documentation: https://docs.snowflake.com/en/developer-guide/python-connector/python-connector-connect\n\nAzure Function\n\nApplication Website: https://learn.microsoft.com/en-us/azure/azure-functions/\nApplication API Documentation: https://learn.microsoft.com/en-us/azure/azure-functions/functions-reference/\n\n\nBefore you get started, make sure you go through the following steps in your application environment:\n\nProvision a Snowflake Data Warehouse\nEnsure that the user authenticating into Snowflake via ChatGPT has access to the database, schemas, and tables with the necessary role\n\nIn addition, before creating your application in Azure Function App, you’ll need a way to handle user authentication. You’ll need to set up an OAuth App Registration in Azure Entra ID that can be linked with a Snowflake External OAuth security integration. Snowflake’s External OAuth security integrations allow external systems to issue access tokens that Snowflake can use for determining level of access. In this case, that external token provider is Azure Entra ID. Since ChatGPT will connect to Azure rather than Snowflake, the GPT user’s OAuth token will be provisioned by Azure associated with their user in Entra ID. Thus you’ll need a way to map users in Snowflake to their corresponding user in Azure.\n\nAll of the necessary steps for both the Azure side and the Snowflake side are laid out below.\n\nWe’ll set up a new App Registration, configure the necessary Snowflake Scopes in Azure that will be used, and retrieve all of the OAuth configuration parameters that will be needed in both Snowflake and ChatGPT. This section will all be in Azure so that in the next section, you’ll have the necessary info to link to this App Registration when configuring on the Snowflake side.\nNavigate to the Microsoft Azure Portal and authenticate.\nNavigate to Azure Entra ID (formerly Active Directory).\nClick on App Registrations under Manage.\nClick on New Registration.\nEnter Snowflake GPT OAuth Client, or similar value as the Name.\nVerify the Supported account types is set to Single Tenant.\nIgnore Redirect URI for now. You will come back for this once you are configuring your GPT\nClick Register.\nNote down the Directory (tenant) ID (TENANT_ID) under Essentials. You will use this to generate your AZURE_AD_ISSUER and AZURE_AD_JWS_KEY_ENDPOINT.\n    The AZURE_AD_ISSUER is https://sts.windows.net/TENANT_ID/\n    The AZURE_AD_JWS_KEY_ENDPOINT is https://login.microsoftonline.com/TENANT_ID/discovery/v2.0/keys\nClick on Endpoints in the Overview interface.\nOn the right-hand side, note the OAuth 2.0 authorization endpoint (v2) as the AZURE_AD_OAUTH_AUTHORIZATION_ENDPOINT  and OAuth 2.0 token endpoint (v2) as the AZURE_AD_OAUTH_TOKEN_ENDPOINT.\n    The endpoints should be similar to https://login.microsoftonline.com/90288a9b-97df-4c6d-b025-95713f21cef9/oauth2/v2.0/authorization and https://login.microsoftonline.com/90288a9b-97df-4c6d-b025-95713f21cef9/oauth2/v2.0/token.\nClick on Expose an API **under **Manage.\nClick on the Set link next to Application ID URI to set the Application ID URI.\n    The Application ID URI must be unique within your organization’s directory, such as https://your.company.com/4d2a8c2b-a5f4-4b86-93ca-294185f45f2e. This value will be referred to as the `` in the subsequent configuration steps.\nTo add a Snowflake Role as an OAuth scope for OAuth flows where the programmatic client acts on behalf of a user, click on Add a scope to add a scope representing the Snowflake role.\n    Enter the scope by having the name of the Snowflake role with the session:scope: prefix. For example, for the Snowflake Analyst role, enter session:scope:analyst.\n    Select who can consent.\n    Enter a display name for the scope (e.g.: Account Admin).\n    Enter a description for the scope (e.g.: Can administer the Snowflake account).\n    Click Add Scope.\n    Save the scope as AZURE_AD_SCOPE. It should be a concatenation of your Application ID URI and your Scope name\nIn the Overview section, copy the ClientID from the Application (client) ID field. This will be known as the OAUTH_CLIENT_ID in the following steps.\nClick on Certificates \u0026 secrets and then New client secret.\nAdd a description of the secret.\nSelect 730 days (24 months). For testing purposes, select secrets that don’t expire soon.\nClick Add. Copy the secret. This will be known as the OAUTH_CLIENT_SECRET in the following steps.\nFor programmatic clients that will request an Access Token on behalf of a user, configure Delegated permissions for Applications as follows.\n    Click on API Permissions.\n    Click on Add Permission.\n    Click on My APIs.\n    Click on the Snowflake OAuth Resource that you created in Configure the OAuth resource in Azure AD.\n    Click on the Delegated Permissions box.\n    Check on the Permission related to the Scopes defined in the Application that you wish to grant to this client.\n    Click Add Permissions.\n    Click on the Grant Admin Consent button to grant the permissions to the client. Note that for testing purposes, permissions are configured this way. However, in a production environment, granting permissions in this manner is not advisable.\n    Click Yes.\n\nOnce the App Registration is complete in Azure Entra ID, the next step is to link that App Registration to Snowflake via an External OAuth Security Integration. The external_oauth_audience_list parameter of the security integration must match the Application ID URI that you specified while configuring Azure Entra ID.\n\nThe Issuer and the JWS Keys endpoint will also come from values collected in the previous steps. The User Mapping Attribute can either be set to EMAIL_ADDRESS or LOGIN_NAME, and this is how user’s Microsoft login credentials will be mapped to their user in Snowflake to ensure permissions in Snowflake are honored by the access token issued to ChatGPT.\nMake sure you go through the following steps in your Azure environment:\n\nAzure Portal or VS Code with access to create Azure Function Apps and Azure Entra App Registrations\nThere is a detailed section in this guide related to deploying and designing the function required to wrap the response from Snowflake in order to return the query results as a CSV to ChatGPT. The Azure Function App allows your GPT to ingest larger datasets as ChatGPT can ingest more data from files responses rather than from application/json payloads. Additionally, those datasets will only be available for Data Analysis (aka Code Interpreter) with a response formatted as a CSV file.\nNow that we have the GPT created and handled Azure/Snowflake authentication, we can create the Azure Function App itself to execute the SQL query and handle the response formatting enabling the GPT to download the result as a CSV for use with Data Analysis.\n\nFollow this Azure Cookbook Guide for further details deploying an Azure Function App. Below you will find sample code to add to the function.\n\nThis code is meant to be directional - while it should work out of the box, you should customize it based on the needs specific to your GPT and your IT setup.\nYou’ll need to setup the following flows in your Azure Function App:\n\nExtracting the token from the HTTP request and using it to connect to Snowflake\nExecuting the SQL query and writing the results to a CSV\nTemporarily storing that CSV in Blob Storage*\nGenerating a pre-signed URL to access that CSV securely*\nResponding with an openaiFileResponse\n\n*These steps may not be required if you use the file stream option instead of the url option for returning files to your GPT. More on this below.\n\nEnsure you have the necessary libraries installed and imported into your script. In addition to Python standard libraries, this sample script leveraged the following:\nTo connect to Snowflake, you’ll need to extract the access token assigned from Azure Entra ID from the Authorization header and use that token when connecting to the Snowflake server.\n\nIn this this example, Snowflake usernames are email addresses which simplifies the mapping of the Entra ID user extracted from the HTTP access token to the Snowflake user ID needed to connect. If this is not the case for your organization, you can map email addresses to Snowflake user IDs in your Python application.\n\nMy application was built to interface with a single Snowflake Account (i.e. ab12345.eastus2.azure) and Warehouse. If you need to access multiple accounts or warehouses, you may consider passing these parameters in your GPT action parameters so you can extract them from the HTTP request.\nOnce you connect to Snowflake you’ll need to execute the query and store the results into a CSV. While the role in Snowflake should prevent any chance of harmful queries, you may want to sanitize your query in your application (not included below) just as you would any other programmatic SQL query execution.\nThere are 2 methods for returning files to ChatGPT for processing. You can either stream the base64 encoded data along with the mimeType and file name in the openaiFileResponse list response, or you can return a list of URLs. In this solution we’ll focus on the latter.\n\nTo do this, you’ll need to upload the CSV to Azure Blob Storage and return a pre-signed URL for accessing that file securely in ChatGPT. It is important to note that in order to download a URL in ChatGPT, you’ll need to ensure that URL includes a content_type and content_disposition, as in the below example. If you’d like to inspect whether a URL has the necessary headers, you can use `curl -I ` from any terminal.\n\nYou’ll need to get a connection String for your Azure storage bucket, as per instructions here.\nLastly, you’ll need to format the response appropriately to instruct ChatGPT to process that response as a file or series of files. The openaiFileResponse is a list which can include up to 10 URLs (or base64 encodings if using the inline option).\n\nThere are a lot of moving pieces to this application, so testing your Azure Function App can be important. ChatGPT can be a difficult testing grounds given that requests and responses can sometimes be more opaque than needed for debugging. Initial testing of your application through cURL or Postman to invoke the HTTP request from a more controlled environment will allow you to debug and triage issues more easily. Once you determine that responses are being returned as expected in those tools, you are ready to build your GPT.\nOnce you've created a Custom GPT, use the text below in the Instructions panel for inspiration. Have questions? Check out Getting Started Example to see how this step works in more detail.\nIt is important that ChatGPT understands your table schema to properly form SQL queries. There are different methods for doing so, and this Instruction set represents the most direct way. We are working to publish additional instructions for different versions of Snowflake GPTs you may want to build to allow for working with multiple different tables, schemas and databases, or to even learn dynamically for schemas that tend to change over time.\n\nBelow are some basic instructions when working with a single schema and table. This GPT has been optimized for a single use case (analyzing flight data from January 2013 out of NYC) which allows for the most simple instructions to provide the most reliable GPT performance.\nYou are an expert at writing SQL queries to fetch data from Snowflake. You help users convert their prompts into SQL queries. Any question around flight data will be converted into a Snowflake SQL query that hits the table FLIGHTS.PUBLIC.JAN_2013_NYC. Pass any query into the \"sql_query\" parameter\n\n\nThe schema of the table includes\nID\tNUMBER\tA unique identifier for each flight\nYEAR\tNUMBER\tThe year of the flight\nMONTH\tNUMBER\tThe month of the flight\nDAY\t\tNUMBER\tThe day of the month on which the flight departed\nDEP_TIME\tNUMBER\tThe actual departure time of the flight\nSCHED_DEP_TIME\tNUMBER\tThe scheduled departure time of the flight\nDEP_DELAY\tNUMBER\tThe departure delay in minutes (negative values indicate early departures)\nARR_TIME\tNUMBER\tThe actual arrival time of the flight\nSCHED_ARR_TIME\tNUMBER\tThe scheduled arrival time of the flight\nARR_DELAY\tNUMBER\tThe arrival delay in minutes (negative values indicate early arrivals)\nCARRIER_CODE\tTEXT\tThe carrier code of the airline\nFLIGHT\tNUMBER\tThe flight number\nTAILNUM\tTEXT\tThe aircraft tail number\nORIGIN_AIRPORT_CODE\tTEXT\tThe origin airport code\nDEST_AIRPORT_CODE\tTEXT\tThe destination airport code\nAIR_TIME\tNUMBER\tThe total airtime of the flight in minutes\nDISTANCE\tNUMBER\tThe distance traveled by the flight in miles\nHOUR\tNUMBER\tThe hour part of the scheduled departure time\nMINUTE\tNUMBER\tThe minute part of the scheduled departure time\nTIME_HOUR\tNUMBER\tThe time at which the flight departed (rounded to the nearest hour)\nCARRIER_NAME\tTEXT\tThe full name of the airline carrier\nORIGIN_AIRPORT_NAME\tTEXT\tThe full name of the origin airport\nORIGIN_REGION\tTEXT\tThe region code of the origin airport\nORIGIN_MUNICIPALITY\tTEXT\tThe city where the origin airport is located\nORIGIN_COORDINATES\tTEXT\tThe geographical coordinates of the origin airport\nDEST_AIRPORT_NAME\tTEXT\tThe full name of the destination airport\nDEST_REGION\tTEXT\tThe region code of the destination airport\nDEST_MUNICIPALITY\tTEXT\tThe city where the destination airport is located\nDEST_COORDINATES\tTEXT\tThe geographical coordinates of the destination airport\n\n\nWhen a user asks for data around flights, perform the following:\n\n\nUse the executeSQL action to send a POST request to the Azure function endpoint\nReceive the file that is returned as part of the Action response. Display it as a spreadsheet\nPerform analysis on the file and provide the necessary information that the user has asked for\n\n\nThe user will wish to ask questions about the data in code interpreter, so use that for any data analysis insights from the dataset you pulled.\nOnce you've created a Custom GPT, copy the text below in the Actions panel, replacing the placeholder values with your specific function details and updating your parameters based on any additional inputs you built into your Azure Function App.\n\nHave questions? Check out Getting Started Example to see how this step works in more detail.\nFiles returned to ChatGPT are limited in size to 10MB. Your request may fail if the file returned is larger than that. Ensure to include LIMITs on your SQL commands if you find you are running into these limitations.\nWhy is the Azure Function App requred in the first place? ChatGPT’s Data Analysis feature (aka Code Interpreter) depends on a secure Python environment that is separate from the model’s context window. Data passed to Data Analysis must be done so by uploading a file today. GPT actions returning data must then return that data as a CSV or other data file type. In order to return a file via GPT action, the response must be wrapped in an openaiFileResponse object. This requires custom code to properly format the response.\nMy company uses a different cloud provider than Azure. For connecting other middleware functions to ChatGPT via GPT action, please refer to other AWS or GCP middleware cookbooks. You can use the concepts discussed in this cookbook to advise on considerations when building your middleware app, but connecting that middleware to Snowflake may be different for different cloud providers. For example, Snowflake built an External OAuth integration specifically for linking with Azure Entra ID.\nHow do I limit the datasets that my GPT has access to? It can be imporant to limit the scope of access ChatGPT has within Snowflake. There are a few ways to do this:\n    Snowflake roles can limit who has access to which tables, and will be respected by the GPT user’s access token provisioned by Azure Entra ID\n    In your middleware function you can add sanity checks to verify the tables accessed are approved by for that application\n    You may want to generate an entirely new Database/Warehouse specific to integrating with ChatGPT that is scrubbed of anything sensitive, such as PII.\nSchema calls the wrong warehouse or dataset: If ChatGPT calls the wrong warehouse or database, consider updating your instructions to make it more explicit either (a) which warehouse / database should be called or (b) to require the user provide those exact details before it runs the query\n\nAre there integrations that you’d like us to prioritize? Are there errors in our integrations? File a PR or issue in our github, and we’ll take a look."])</script><script>self.__next_f.push([1,"ec:T108d,"])</script><script>self.__next_f.push([1,"This page provides an instruction \u0026 guide for developers building a GPT Action for a specific application. Before you proceed, make sure to first familiarize yourself with the following information:\nIntroduction to GPT Actions\nIntroduction to GPT Actions Library\nExample of Building a GPT Action from Scratch\n\nThis particular GPT Action provides an overview of how to connect to a Retool Workflow. This Action takes a users input and sends it to the workflow in Retool using a webhook trigger. Retool then performns the configured workflow and sends a response back to ChatGPT as a JSON object.\n\n\nValue: Users can now leverage ChatGPT's natural language capability to connect directly to any workflow in Retool.\n\nExample Use Cases:\nYou have custom code running in a Retool workflow that you'd like to incorporate into a GPT.\nData Scientists maintain an external VectorDB (either using Retool Vector or another vector DB) and would like to send the results of the vector search back to ChatGPT.\nRetool is used as middleware to connect to internal services, and you'd like to use Retool's webhooks to provide access to these services to ChatGPT.\n\nCheck out these links from the application before you get started:\nApplication Website: https://retool.com/products/workflows\nApplication API Documentation: https://docs.retool.com/workflows\n\n\nBefore you get started, make sure you go through the following steps in your Retool environment:\nSet up a Retool account\nCreate a simple workflow\n\n\nBelow is an example of a basic Retool Workflow. This workflow takes in 2 values and adds them and responds to the webhook trigger with the result.\n\nNote:* Your workflow must be deployed before it will be accessible from your GPT.\n\n\n\n\n\nOnce you've created a Custom GPT, you should add Instructions to the GPT providing context about the GPTs role, and the actions it is able to perform. Have questions? Check out Getting Started Example to see how this step works in more detail.\n\n\nOnce you've created a Custom GPT, copy the text below in the Actions panel. Have questions? Check out Getting Started Example to see how this step works in more detail.\n\nNote:* You need to replace the __ value in the OpenAPI spec below with the ID for your workflow.\n\n\nopenapi: 3.1.0\ninfo:\n  title: Retool Workflow API\n  description: API for interacting with Retool workflows.\n  version: 1.0.0\nservers:\n  url: https://api.retool.com/v1\n    description: Main (production) server\npaths:\n  /workflows//startTrigger:\n    post:\n      operationId: add_numbers\n      summary: Takes 2 numbers and adds them.\n      description: Initiates a workflow in Retool by triggering a specific workflow ID.\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              type: object\n              properties:\n                first:\n                  type: integer\n                  description: First parameter for the workflow.\n                second:\n                  type: integer\n                  description: Second parameter for the workflow.\n      responses:\n        \"200\":\n          description: Workflow triggered successfully.\n        \"400\":\n          description: Bad Request - Invalid parameters or missing data.\n        \"401\":\n          description: Unauthorized - Invalid or missing API key.\n      security:\n        apiKeyAuth: []\n\n\nBelow are instructions on setting up authentication with this 3rd party application. Have questions? Check out Getting Started Example to see how this step works in more detail.\n\n\nBefore you set up authentication in ChatGPT, please take the following steps in the application.\nGet your API Key from the Webhook config panel\n\nretool_api_key.png\n\n\nIn ChatGPT, click on \"Authentication\" and choose \"API Key\". Enter in the information below.\n\nAPI Key**: (Paste your API Key provided by the Retool Workflow Webhook Trigger)\nAuth Type**: Custom\nCustom Header Name**: X-Workflow-Api-Key\n\n\nAuth Error: Ensure you have set the custom header name correctly.\nInvalid Workflow Error: Ensure you have deployed your workflow within Retool.\n\nAre there integrations that you’d like us to prioritize? Are there errors in our integrations? File a PR or issue in our github, and we’ll take a look."])</script><script>self.__next_f.push([1,"ed:Tdfe,"])</script><script>self.__next_f.push([1,"In this guide, we’ll explore how to use the o1 model, specifically o1-preview, to perform data validation through reasoning. We’ll walk through a practical example involving a synthetic medical dataset and demonstrate how to assess the model’s accuracy in identifying issues within the data.\n\nData validation is a critical step in ensuring the quality and reliability of datasets, especially in sensitive fields like healthcare. Traditional validation methods often rely on predefined rules and patterns. However, advanced  models like o1 can understand context and reason about data, offering a more flexible and intelligent approach to validation.\n\nIn this tutorial, we will:\nGenerate a synthetic dataset of medical data that contains inconsistencies.\nDefine a function that takes in a row of data and validates its accuracy\nRun the validation process and compute accuracy metrics.\nAnalyze and interpret the results.\nWe will use a lot of the principles described in the Synthetic Data Generation cookbook to create the foundation of our dataset.\n\nWe will prompt the model to generate sets of medical data for our use case. We have provided detailed instructions to the model on how to create the dataset, what format to follow, and how to fill it with inaccuracies. We also provide a few rows of sample data to get the model started.\n\nEach row in the dataset will have the following fields:\nPatient ID: A randomly generated patient id\nDate of Birth: Date of birth of the patient\nGender: M/F\nMedical History: Past diagnoses\nCurrent Medications: Medication the patient is taking\nAllergies: Identified allergies\nLab Results (Glucose mg/dL)\nDiagnoses: Current diagnosis\nTreatment Plan: Current treatment plan\nIs Valid: Whether or not the current row of data is valid (True/False)\nIssue: If the row of data is not valid, what the issue is\n\nSome examples of inaccuracies that may be present in the data are:\nPrescribing medications that the patient is allergic to\nCurrent medications do not match medical history\nTreatment plan does not match diagnosis\nNow that we have our dataset prepared, we will prompt the reasoning model to review each row of data and determine whether or not it contains an issue. We will ask the model to output whether or not there is an issue in the data and then offer an explanation of the issue.\n\nOnce we have the model determine its list of invalid data, we will pass those results on to a model grader to assess two metrics:\nAccuracy of the model's ability correctly identify issues with the data\nFor the subset of data that issues have been correctly identified, what is the accuracy of the model in identifying the issue at hand\n\nGiven that this task is much more narrow, we can use the faster gpt-4o model to calculate the accuracy.\n\nREMINDER: Given that these models are still in beta, rate limits will be significantly reduced. Please adjust the number of concurrent workers accordingly.\nNow that we have the model's results, we can compare it against the source of truth and determine the system's accuracy\nWe will now determine the model's ability to accurately classify the issue in the data\nBelow we'll display the subset of rows that we correctly identified contained an issue. For each row, we'll show the predicted vs. true issue and whether or not there is a match\n\nWe can see from the results here that we're able to generate a high precision/recall for issue identification as well as decent accuracy for pinpointing the exact issue in the data.\n\nThis should help streamline data validation for eval sets across a variety of domains."])</script><script>self.__next_f.push([1,"ee:T184b,"])</script><script>self.__next_f.push([1,"When developing customer service solutions, one of the initial steps involves transforming knowledge base articles into a set of routines that an LLM can comprehend and follow. A routine, in this context, refers to a set of step-by-step instructions designed specifically for the LLM to execute efficiently. Each routine is carefully structured so that a step corresponds to a clear action. Actions can include responding to a user, triggering a function call, or retrieving additional relevant knowledge.\n\nMost internal knowledge base articles are complex and structured for human interpretation. They often include intricate diagrams, multi-step processes, and decision trees that pose challenges for LLM-based solutions to reason through in a meaningful way. By breaking down these documents into routines, each instruction can be simplified and formatted in a way that guides the LLM through a series of small, manageable tasks. This granular approach reduces ambiguity, allowing the LLM to process the information methodically and reducing the risk of hallucination or deviation from the expected path.\n\nConverting these knowledge base articles into routines can be time-consuming and challenging, especially for companies attempting to build an automated pipeline. Each routine must account for various user scenarios, where actions need to be clearly defined. For instance, when a function call is necessary, the routine must specify the exact information to retrieve or the action to execute—whether it’s triggering an API, retrieving external data, or pulling in additional context. While automating this process with traditional GPT-class models can significantly reduce the manual effort involved, it often introduces new challenges. Some challenges include designing robust instructions that are specific enough for the LLM to follow consistently, capturing unique edge cases that may arise during customer interactions, providing high-quality few-shot examples to guide the model’s behavior, and in some cases, fine-tuning the model to achieve more reliable or specialized outcomes.\n\no1 has demonstrated the capability to efficiently deconstruct these articles and convert them into sets of routines zero-shot, meaning that the LLM can understand and follow the instructions without extensive examples or prior training on similar tasks. This minimizes the prompting effort required, as the routine structure itself provides the necessary guidance for the LLM to complete each step. By breaking down tasks into specific actions and integrating function calls where needed, o1’s approach ensures that even complex workflows can be handled seamlessly by the LLM, leading to more effective and scalable customer service solutions.\n\nIn this example, we will use a set of publicly available Help Center articles from the OpenAI website and convert them into internal routines that an LLM can execute. Besides transforming the policies into routines, we will also have the model generate functions that allow the LLM to perform actions on behalf of the user. This is necessary to allow the LLM to execute the same actions that human agents have, and access additional information that may not be immediately available just from the policy documentation.\n\nWe will begin by using the following Help Center articles for conversion into routines:\nHow do I delete my payment method\nHow can I get a Business Associate Agreement (BAA) with OpenAI?\nHow can I set up prepaid billing?\nHow do I submit a VAT exemption request\nWe have our articles stored in an accessible csv. We will take the articles and pass them to o1-preview in parallel and generate the initial routines.\n\nOur instructions for converting the policy to a routine include:\nConverting the policy from an external facing document to an internal SOP routine\nBreaking down the policy in specific actions and sub-actions\nOutlining specific conditions for moving between steps\nDeterming where external knowledge/actions may be required, and defining functions that we could use to get that information\nWe'll store the results of our routines in a dataframe and print them out so we can get an initial look.\n\nUpon reviewing the generated routines, we can derive several insights:\nSample Responses: The model effectively generates sample responses that the LLM can utilize when executing the policy (e.g., “Instruct the user: ‘Confirm and purchase your initial amount of credits.’”).\nDiscrete Steps: The model excels at decomposing the problem into discrete actions that the LLM needs to execute. Each instruction is clearly defined and easy to interpret.\nFunction Definitions: The routines’ outputs include clearly defined functions to retrieve external information or trigger actions (e.g., review_and_apply_tax_exemption, get_billing_plan, update_payment_method).\n    This is crucial for any successful routine because LLMs often need to interact with external systems. Leveraging function calls is an effective way to interact with those systems and execute actions.\nIFTTT Logic: The model effectively employs IFTTT (If This, Then That) logic, which is ideal for an LLM (e.g., “If the customer requests assistance, proceed to step 3f.”).\n    This type of translation becomes extremely valuable when the original knowledge base articles contain complex workflows and diagrams. Such complexity may not be easily understood by humans, and even less so by an LLM. IFTTT logic is easily comprehensible and works well for customer service solution\n\nThese routines can now be integrated into agentic systems to address specific customer issues. When a customer requests assistance with tasks such as setting up prepaid billing, we can employ a classifier to determine the appropriate routine to retrieve and provide that to the LLM to interact directly with the customer. Beyond providing instructions to the user on how to set up billing, the system can also perform the action on their behalf.\n\nBefore deploying these routines into production, we should develop comprehensive evaluations to test and validate the quality of the model’s responses. This process may necessitate adjusting the routines to ensure compliance and effectiveness."])</script><script>self.__next_f.push([1,"ef:T710,The initially released versions (September 2024) of o1 reasoning models have advanced capabilities but do not have structured outputs support.\n\nThis means that requests with o1 don't have reliable type-safety and rely on the prompt itself to return a useful JSON.\n\nIn this guide, we'll explore two methods to prompt o1 models, specifically o1-preview, to return a valid JSON format when using the OpenAI API.\n\nThe simplest way to return a JSON response using o1-preview is to explicitly prompt it.\n\nLet's run through an example of:\nFetching a wikipedia page of companies\nDetermining which could benefit the most from AI capabilities\nReturning them in a JSON format, which could then be ingested by other systems\nNote that the response is already quite good - it returns the JSON with the appropriate responses. However, it runs into the same pitfalls as existing use-cases of prompt-only JSON inference:\nYou must manually process this JSON into your type-safe structure\nModel refusals are not explicitly returned from the API as a separate structure\nLet's now do this with structured outputs. To enable this functionality, we’ll link the o1-preview response with a follow-up request to gpt-4o-mini, which can effectively process the data returned from the initial o1-preview response.\n\nStructured outputs allow your code to have reliable type-safety and simpler prompting. In addition, it allows you to re-use your object schemas for easier integration into your existing workflows.\n\nThe o1 class of models currently doesn't have structured outputs support, but we can re-use existing structured outputs functionality from gpt-4o-mini by chaining two requests together. This flow currently requires two calls, but the second gpt-4o-mini call cost should be minimal compared to the o1-preview/o1-mini calls.f0:T1c52,"])</script><script>self.__next_f.push([1,"Disclaimer: This cookbook is for educational purposes only. Ensure that you comply with all applicable laws and service terms when using web search and scraping technologies. This cookbook will restrict the search to openai.com domain to retrieve the public information to illustrate the concepts.\n\nLarge Language Models (LLMs) such as GPT-4o have a knowledge cutoff date, which means they lack information about events that occurred after that point. In scenarios where the most recent data is essential, it's necessary to provide LLMs with access to current web information to ensure accurate and relevant responses.\n\nIn this guide, we will build a Bring Your Own Browser (BYOB) tool using Python to overcome this limitation. Our goal is to create a system that provides up-to-date answers in your application, including the most recent developments such as the latest product launches by OpenAI. By integrating web search capabilities with an LLM, we'll enable the model to generate responses based on the latest information available online.\n\nWhile you can use any publicly available search APIs, we'll utilize Google's Custom Search API to perform web searches. The retrieved information from the search results will be processed and passed to the LLM to generate the final response through Retrieval-Augmented Generation (RAG).\n\nBring Your Own Browser (BYOB) tools allow users to perform web browsing tasks programmatically. In this notebook, we'll create a BYOB tool that:\n\n#1. Set Up a Search Engine: Use a public search API, such as Google's Custom Search API, to perform web searches and obtain a list of relevant search results.\n\n#2. Build a Search Dictionary: Collect the title, URL, and a summary of each web page from the search results to create a structured dictionary of information.\n\n#3. Generate a RAG Response: Implement Retrieval-Augmented Generation (RAG) by passing the gathered information to the LLM, which then generates a final response to the user's query.\n\n\nIn this cookbook, we'll take the example of a user who wants to list recent product launches by OpenAI in chronological order. Because the current GPT-4o model has a knowledge cutoff date, it is not expected that the model will know about recent product launches such as the o1-preview model launched in September 2024.\n\nGiven the knowledge cutoff, as expected the model does not know about the recent product launches by OpenAI.\nTo provide the model with recent events information, we'll follow these steps:\n\n\n\nBefore we begin, ensure you have the following: Python 3.12 or later installed on your machine. You will also need a Google Custom Search API key and Custom Search Engine ID (CSE ID). Necessary Python packages installed: requests, beautifulsoup4, openai. And ensure the OPENAI_API_KEY is set up as an environment variable.\nYou can use any publicly available web search APIs to perform this task. We will configure a custom search engine using Google's Custom Search API. This engine will fetch a list of relevant web pages based on the user's query, focusing on obtaining the most recent and pertinent results.\n\na. Configure Search API key and Function: Acquire a Google API key and a Custom Search Engine ID (CSE ID) from the Google Developers Console. You can navigate to this Programmable Search Engine Link to set up an API key as well as Custom Search Engine ID (CSE ID).\n\nThe search function below sets up the search based on search term, the API and CSE ID keys, as well as number of search results to return. We'll introduce a parameter site_filter to restrict the output to only openai.com\n\nb. Identify the search terms for search engine: Before we can retrieve specific results from a 3rd Party API, we may need to use Query Expansion to identify specific terms our browser search API should retrieve. Query expansion is a process where we broaden the original user query by adding related terms, synonyms, or variations. This technique is essential because search engines, like Google's Custom Search API, are often better at matching a range of related terms rather than just the natural language prompt used by a user.\n\nFor example, searching with only the raw query \"List the latest OpenAI product launches in chronological order from latest to oldest in the past 2 years\" may return fewer and less relevant results than a more specific and direct search on a succinct phrase such as \"Latest OpenAI product launches\". In the code below, we will use the user's original search_query to produce a more specific search term to use with the Google API to retrieve the results.\nc. Invoke the search function: Now that we have the search term, we will invoke the search function to retrieve the results from Google search API. The results only have the link of the web page and a snippet at this point. In the next step, we will retrieve more information from the webpage and summarize it in a dictionary to pass to the model.\nAfter obtaining the search results, we'll extract and organize the relevant information, so it can be passed to the LLM for final output.\n\na. Scrape Web Page Content: For each URL in the search results, retrieve the web page to extract textual content while filtering out non-relevant data like scripts and advertisements as demonstrated in function retrieve_content.\n\nb. Summarize Content: Use an LLM to generate concise summaries of the scraped content, focusing on information pertinent to the user's query. Model can be provided the original search text, so it can focus on summarizing the content for the search intent as outlined in function summarize_content.\n\nc. Create a Structured Dictionary: Organize the data into a dictionary or a DataFrame containing the title, link, and summary for each web page. This structure can be passed on to the LLM to generate the summary with the appropriate citations.\n\nWe retrieved the most recent results. (Note these will vary depending on when you execute this script.)\nWith the search data organized in a JSON data structure, we will pass this information to the LLM with the original user query to generate the final response. Now, the LLM response includes information beyond its original knowledge cutoff, providing current insights.\n\nLarge Language Models (LLMs) have a knowledge cutoff and may not be aware of recent events. To provide them with the latest information, you can build a Bring Your Own Browser (BYOB) tool using Python. This tool retrieves current web data and feeds it to the LLM, enabling up-to-date responses.\n\nThe process involves three main steps:\n\n#1 Set Up a Search Engine: Use a public search API, like Google's Custom Search API, to perform web searches and obtain a list of relevant search results.\n\n#2 Build a Search Dictionary: Collect the title, URL, and a summary of each web page from the search results to create a structured dictionary of information.\n\n#3. Generate a RAG Response: Implement Retrieval-Augmented Generation (RAG) by passing the gathered information to the LLM, which then generates a final response to the user's query.\n\nBy following these steps, you enhance the LLMs ability to provide up-to-date answers in your application that include the most recent developments, such as the latest product launches by OpenAI."])</script><script>self.__next_f.push([1,"f1:T1242,"])</script><script>self.__next_f.push([1,"OpenAI offers discounted prompt caching for prompts exceeding 1024 tokens, resulting in up to an 80% reduction in latency for longer prompts over 10,000 tokens. By caching repetitive information across LLM API requests, you can greatly reduce both latency and costs. Prompt caching is scoped at the organization level, meaning only members of the same organization can access shared caches. Additionally, caching is eligible for zero data retention, as no data is stored during the process.\n\nPrompt caching automatically activates for prompts longer than 1024 tokens-- you don't have to change anything in your completions request. When an API request is made, the system first checks if the beginning portion (prefix) of the prompt has already been cached. If a match is found (cache hit), the cached prompt is used, leading to reduced latency and costs. If there's no match, the system processes the full prompt from scratch and caches the prefix for future use.\n\nWith these benefits in mind, some of the key use cases where prompt caching can be especially advantageous are:\n\n\nAgents using tools and structured outputs**: Cache the extended list of tools and schemas.\nCoding and writing assistants**: Insert large sections or summaries of codebases and workspaces directly in prompts.\nChatbots**: Cache static portions of multi-turn conversations to maintain context efficiently over extended dialogues.\n\nIn this cookbook, we'll go through a couple examples of caching tools and images. Recall that in general, you'll want to put static content like instructions and examples at the beginning of your prompt, and variable content, such as user-specific information, at the end. This also applies to images and tools, which must be identical even in their ordering between requests. All requests, including those with fewer than 1024 tokens, will display a cached_tokens field of the usage.prompt_tokens_details chat completions object indicating how many of the prompt tokens were a cache hit. For requests under 1024 tokens, cached_tokens will be zero. Caching discounts are based on the actual number of tokens processed, including those used for images, which also count toward your rate limits.\n\nIn this example, we define tools and interactions for a customer support assistant, capable of handling tasks such as checking delivery dates, canceling orders, and updating payment methods. The assistant processes two separate messages, first responding to an initial query, followed by a delayed response to a follow-up query.\n\nWhen caching tools, it is important that the tool definitions and their order remain identical for them to be included in the prompt prefix. To cache message histories in a multi-turn conversation, append new elements to the end of the messages array. In the response object and the output below, for the second completion run2, you can see that the cached_tokens value is greater than zero, indicating successful caching.\n\nIn our second example we include multiple image URLs of grocery items in the messages array, along with a user query, run three times with delays. Images—whether linked or encoded in base64 within user messages—qualify for caching. Make sure the detail parameter remains consistent, as it affects how images are tokenized. Note that GPT-4o-mini adds extra tokens to cover image processing costs, even though it uses a low-cost token model for text. Caching discounts are based on the actual number of tokens processed, including those used for images, which also count toward your rate limits.\n\nThe output for this example shows that a cache was hit for the second run, however it was not hit for the third run because of a different first url (eggs_url instead of veggie_url), even though the user query is the same.\n\nTo get the most out of prompt caching, consider following these best practices:\n\nPlace static or frequently reused content at the beginning of prompts: This helps ensure better cache efficiency by keeping dynamic data towards the end of the prompt.\n\nMaintain consistent usage patterns: Prompts that aren't used regularly are automatically removed from the cache. To prevent cache evictions, maintain consistent usage of prompts.\n\nMonitor key metrics: Regularly track cache hit rates, latency, and the proportion of cached tokens. Use these insights to fine-tune your caching strategy and maximize performance.\n\nBy implementing these practices, you can take full advantage of prompt caching, ensuring that your applications are both responsive and cost-efficient. A well-managed caching strategy will significantly reduce processing times, lower costs, and help maintain smooth user experiences."])</script><script>self.__next_f.push([1,"f2:T1074,"])</script><script>self.__next_f.push([1,"This page provides an instruction \u0026 guide for developers building a GPT Action for a specific application. Before you proceed, make sure to first familiarize yourself with the following information:\nIntroduction to GPT Actions\nIntroduction to GPT Actions Library\nExample of Building a GPT Action from Scratch\nThis guide explains how to connect Google Ads reporting data to ChatGPT to retrieve key performance metrics like impressions, clicks and cost at campaign, ad group or ad level. To simplify this process, you will use Adzviser as middleware, which ensures that the data returned from the Google Ads API is properly formatted and ready for analysis in ChatGPT’s Data Analysis environment.\n\nHow Adzviser works: First, connect your Google Ads account to Adzviser via OAuth. When you ask questions like “How much did I spend per campaign last month?” in ChatGPT, Adzviser sends a Google Ads Query Language request and transforms the response into a CSV file (under 10MB). This file is then returned to ChatGPT for analysis. Adzviser enables you to easily review and analyze your campaign performance while brainstorming optimization strategies based on historical data insights.\n\nValue: Google Ads marketers can now leverage ChatGPT’s natural language capabilities to easily query performance metrics and account settings without navigating the Google Ads UI. No need to upload or download any files in the entire process.\n\nExample Use Cases:\nAn eCommerce business owner wants to quickly check the Return on Ad Spend (ROAS) for their Google Ads campaigns from the previous month\nA brand marketer aims to conduct keyword and search term analysis using reporting data from the past 3 months to identify which keywords to pause or scale, and which search terms to add as negative keywords.\nAn agency marketer needs to generate a monthly report featuring key metrics such as Cost-per-Click (CPC), Cost-per-Conversion (CPA), and Search Impression Share with month-over-month comparisons.\nA freelance marketer needs to audit a new client’s Google Ads account to evaluate performance and find optimization opportunities during the onboarding process.\nGPT Search Term Analysis Part 1GPT Search Term Analysis Part 2\nCheck out these links from the application before you get started:\nHow to create a workspace on Adzviser: https://docs.adzviser.com/getStarted/workspace\nAdzviser Custom GPT Documentaion: https://docs.adzviser.com/chatgpt/expert\nGoogle Ads prompt library: https://docs.adzviser.com/chatgpt/googleAdsPromptTemplates\nBefore you get started, make sure you go through the following steps in your application environment:\nConfirm that you have Read-only, Standard, or Admin access to a Google Ads account.\nSign up for an account on Adzviser and  activate a subscription (starting at $0.99).\nConnect your Google Ads account to Adzviser by creating a workspace\nOnce you've created a Custom GPT, copy the text below in the Instructions panel. Have questions? Check out Getting Started Example to see how this step works in more detail.\nOnce you've created a Custom GPT, copy the text below in the Actions panel. Have questions? Check out Getting Started Example to see how this step works in more detail.\nBelow are instructions on setting up authentication with this 3rd party application. Have questions? Check out Getting Started Example to see how this step works in more detail.\nGPT OAuth Settings\nIn ChatGPT, click on \"Authentication\" and choose \"OAuth\". Enter in the information below.\nClient ID**: (Leave blank)\nClient Secret**: (Leave blank)\nAuthorization URL**: https://adzviser.com/authorize-gpt\nToken URL**: https://adzviser.com/api/oauth-exchange-token-gpt\nScope**: (Leave blank)\nToken Exchange Method**: Default (POST)\nEmpty Google Ads account list: If you encounter an empty Google Ads accounts list when trying to connect your Google Ads account, it is likely that you have not yet named your Google Ads account yet. To solve it, go to ads.google.com and sign in. Then follow the instructions here to name your Google Ads account.\nAre there integrations that you’d like us to prioritize? Are there errors in our integrations? File a PR or issue in our github, and we’ll take a look."])</script><script>self.__next_f.push([1,"f3:T1ad6,"])</script><script>self.__next_f.push([1,"OpenAI recently released Distillation which allows to leverage the outputs of a (large) model to fine-tune another (smaller) model. This can significantly reduce the price and the latency for specific tasks as you move to a smaller model. In this cookbook we'll look at a dataset, distill the output of gpt-4o to gpt-4o-mini and show how we can get significantly better results than on a generic, non-distilled, 4o-mini.\n\nWe'll also leverage Structured Outputs for a classification problem using a list of enum. We'll see how fine-tuned model can benefit from structured output and how it will impact the performance. We'll show that Structured Ouputs work with all of those models, including the distilled one.\n\nWe'll first analyze the dataset, get the output of both 4o and 4o mini, highlighting the difference in performance of both models, then proceed to the distillation and analyze the performance of this distilled model.\n\nLet's install and load dependencies.\nMake sure your OpenAI API key is defined in your environment as \"OPENAI_API_KEY\" and it'll be loaded by the client directly.\n\nFor this cookbook, we'll load the data from the following Kaggle challenge: https://www.kaggle.com/datasets/zynicide/wine-reviews.\n\nThis dataset has a large number of rows and you're free to run this cookbook on the whole data, but as a biaised french wine-lover, I'll narrow down the dataset to only French wine to focus on less rows and grape varieties.\n\nWe're looking at a classification problem where we'd like to guess the grape variety based on all other criterias available, including description, subregion and province that we'll include in the prompt. It gives a lot of information to the model, you're free to also remove some information that can help significantly the model such as the region in which it was produced to see if it does a good job at finding the grape.\n\nLet's filter the grape varieties that have less than 5 occurences in reviews.\n\nLet's proceed with a subset of 500 random rows from this dataset.\nLet's retrieve all grape varieties to include them in the prompt and in our structured outputs enum list.\n\nLet's build out a function to generate our prompt and try it for the first wine of our list.\nTo get a understanding of the cost before running the queries, you can leverage tiktoken to understand the number of tokens we'll send and the cost associated to run this. This will only give you an estimate for to run the completions, not the fine-tuning process (used later in this cookbook when running the distillation), which depends on other factors such as the number of epochs, training set etc.\n\nAs we're looking at a limited list of response (enumerate list of grape varieties), let's leverage structured outputs so we make sure the model will answer from this list. This also allows us to compare the model's answer directly with the grape variety and have a deterministic answer (compared to a model that could answer \"I think the grape is Pinot Noir\" instead of just \"Pinot noir\"), on top of improving the performance to avoid grape varieties not in our dataset.\n\nIf you want to know more on Structured Outputs you can read this cookbook and this documentation guide.\nTo distill a model, you need to store all completions from a model, allowing you to give it as a reference to the smaller model to fine-tune it. We're therefore adding a store=True parameter to our client.chat.completions.create method so we can store those completions from gpt-4o.\n\nWe're going to store all completions (even 4o-mini and our future fine-tuned model) so we are able to run Evals from OpenAI platform directly.\n\nWhen storing those completions, it's useful to store them with a metadata tag, that will allow filtering from the OpenAI platform to run distillation \u0026 evals on the specific set of completions you'd like to run those.\n\nAs we'll run this on a large number of rows, let's make sure we run those completions in parallel and use concurrent futures for this. We'll iterate on our dataframe and output progress every 20 rows. We'll store the completion from the model we run the completion for in the same dataframe using the column name {model}-variety.\nLet's try out our call model function before processing the whole dataframe and check the output.\nGreat! We confirmed we can get a grape variety as an output, let's now process the dataset with both gpt-4o and gpt-4o-mini and compare the results.\n\nNow that we've got all chat completions for those two models ; let's compare them against the expected grape variety and assess their accuracy at finding it. We'll do this directly in python here as we've got a simple string check to run, but if your task involves more complex evals you can leverage OpenAI Evals or our open-source eval framework.\nWe can see that gpt-4o is better a finding grape variety than 4o-mini (12.80% higher or almost 20% relatively to 4o-mini!). Now I'm wondering if we're making gpt-4o drink wine during training!\n\n\nLet's assume we'd like to run this prediction often, we want completions to be faster and cheaper, but keep that level of accuracy. That'd be great to be able to distill 4o accuracy to 4o-mini, wouldn't it? Let's do it!\n\nWe'll now go to OpenAI Stored completions page: https://platform.openai.com/chat-completions.\n\nLet's select the model gpt-4o (make sure to do this, you don't want to distill the outputs of 4o-mini that we ran). Let's also select the metadata distillation: wine-distillation to get only stored completions ran from this cookbook.\n\nFiltering out completions\n\nOnce you've selected completions, you can click on \"Distill\" on the top right corner to fine-tune a model based on those completions. Once we've done that, a file to run the fine-tuning process will automatically be created. Let's then select gpt-4o-mini as the base model, keep the default parameters (but you're free to change them or iterate with it to improve performance).\n\nDistilling modal\n\nOnce the fine-tuning job is starting, you can retrieve the fine tuning job ID from the fine-tuning page, we'll use it to monitor status of the fine-tuned job as well as retrieving the fine-tuned model id once done.\n\nFine tuning job\n\nNow that we've got our model fine-tuned, we can use this model to run completions and compare accuracy with both gpt4o and gpt4o-mini.\nLet's grab a different subset of french wines (as we restricted the outputs to french grape varieties, without outliers, we'll need to focus our validation dataset to this too). Let's run this on 300 entries for each models.\nLet's compare accuracy of models\nThat's almost a 22% relative improvement over the non-distilled gpt-4o-mini! 🎉\n\nOur fine-tuned model performs way better than gpt-4o-mini, while having the same base model. We'll be able to use this model to run inferences at a lower cost and lower latency for future grape variety prediction."])</script><script>self.__next_f.push([1,"f4:T2601,"])</script><script>self.__next_f.push([1,"Have you ever wanted to translate a podcast into your native language? Translating and dubbing audio content can make it more accessible to audiences worldwide. With GPT-4o's new audio-in and audio-out modality, this process is now easier than ever.\n\nThis guide will walk you through translating an English audio file into Hindi using OpenAI's GPT-4o audio modality API.\n\nGPT-4o simplifies the dubbing process for audio content. Previously, you had to convert the audio to text and then translate the text into the target language before converting it back into audio. Now, with GPT-4o’s voice-to-voice capability, you can achieve this in a single step with audio input and output.\n\nA note on semantics used in this Cookbook regarding Language and written Script. These words are generally used interchangeably, though it's important to understand the distinction, given the task at hand.\n\nLanguage** refers to the spoken or written system of communication. For instance, Hindi and Marathi are different languages, but both use the Devanagari script. Similarly, English and French are different languages, but are written in Latin script.\n\nScript** refers to the set of characters or symbols used to write the language. For example, Serbian language traditionally written in Cyrillic Script, is also written in Latin script.\n\n\nGPT-4o audio-in and audio-out modality makes it easier to dub the audio from one language to another with one API call.\n\n1. Transcribe the source audio file into source language script using GPT-4o. This is an optional step that can be skipped if you already have the transcription of source audio content.\n\n2. Dub the audio file from source language directly to the target langauge.\n\n3. Obtain Translation Benchmarks using BLEU or ROUGE.\n\n4. Interpret and improve scores by adjusting prompting parameters in steps 1-3 as needed.\n\nBefore we get started, make sure you have your OpenAI API key configured as an environment variable, and necessary packages installed as outlined in the code cells below.\n\nLet's start by creating a function that sends an audio file to OpenAI's GPT-4o API for processing, using the chat completions API endpoint.\n\nThe function process_audio_with_gpt_4o takes three inputs:\n\nA base64-encoded audio file (base64_encoded_audio) that will be sent to the GPT-4o model.\nDesired output modalities (such as text, or both text and audio).\nA system prompt that instructs the model on how to process the input.\n\nThe function sends an API request to OpenAI's chat/completions endpoint. The request headers include the API key for authorization. The data payload contains the model type (gpt-4o-audio-preview), the selected output modalities, and audio details, such as the voice type and format (in this case, \"alloy\" and \"wav\"). It also includes the system prompt and the base64-encoded audio file as part of the \"user\" message. If the API request is successful (HTTP status 200), the response is returned as JSON. If an error occurs (non-200 status), it prints the error code and message.\n\nThis function enables audio processing through OpenAI's GPT-4o API, allowing tasks like dubbing, transcription, or translation to be performed based on the input provided.\nUsing the function process_audio_with_gpt_4o, we will first get an English transcription of the source audio. You can skip this step if you already have a transcription in the source language.\n\nIn this step, we:\nRead the WAV file and convert it into base64 encoding.\nSet the output modality to [\"text\"], as we only need a text transcription.\nProvide a system prompt to instruct the model to focus on transcribing the speech and to ignore background noises like applause.\nCall the process_audio_with_gpt_4o function to process the audio and return the transcription.\nThis English transcript will serve as our ground truth as we benchmark the Hindi language dubbing of the audio in Step 3.\n\nWith GPT-4o, we can directly dub the audio file from English to Hindi and get the Hindi transcription of the audio in one API call. For this, we set the output modality to [\"text\", \"audio\"] \nIn the following code snippet, we will retrieve both the Hindi transcription and the dubbed audio from the GPT-4o response. Previously, this would have been a multistep process, involving several API calls to first transcribe, then translate, and finally produce the audio in the target language. With GPT-4o, we can now accomplish this in a single API call.\nThe transcribed text is a combination of Hindi and English, represented in their respective scripts: Devanagari for Hindi and Latin for English. This approach ensures more natural-sounding speech with the correct pronunciation of both languages' words. We will use the pydub module to play the audio as demonstrated in the code below.\n\nWe can assess the quality of the translated text by comparing it to a reference translation using evaluation metrics like BLEU and ROUGE.\n\nBLEU (Bilingual Evaluation Understudy): Measures the overlap of n-grams between the candidate and reference translations. Scores range from 0 to 100, with higher scores indicating better quality.\n\nROUGE (Recall-Oriented Understudy for Gisting Evaluation): Commonly used for summarization evaluation. Measures the overlap of n-grams and the longest common subsequence between the candidate and reference texts.\n\nIdeally, a reference translation (a human-translated version) of the original text is needed for an accurate evaluation. However, developing such evaluations can be challenging, as it requires time and effort from bilingual humans proficient in both languages.\n\nAn alternative is to transcribe the output audio file from the target language back into the original language to assess the quality of the translation using GPT-4o.\nWith the text transcribed back into English language script from the Hindi audio, we can run the evaluation metrics by comparing it to the original English transcription.\n\nIn this example, both BLEU and ROUGE scores indicate that the quality of the voice translation is between very good and excellent.\n\nInterpreting BLEU Scores: While there is no universally accepted scale, some interpretations suggest:\n\n0 to 10: Poor quality translation; significant errors and lack of fluency.\n\n10 to 20: Low quality; understandable in parts but contains many errors.\n\n20 to 30: Fair quality; conveys the general meaning but lacks precision and fluency.\n\n30 to 40: Good quality; understandable and relatively accurate with minor errors.\n\n40 to 50: Very good quality; accurate and fluent with very few errors.\n\n50 and above: Excellent quality; closely resembles human translation.\n\nInterpreting ROUGE scores: The interpretation of a \"good\" ROUGE score can vary depending on the task, dataset, and domain. The following guidelines indicate a good outcome:\n\nROUGE-1 (unigram overlap): Scores between 0.5 to 0.6 are generally considered good for abstractive summarization tasks.\n\nROUGE-L (Longest Common Subsequence): Scores around 0.4 to 0.5 are often regarded as good, reflecting the model's ability to capture the structure of the reference text.\n\nIf the score for your translation is unsatisfactory, consider the following questions:\n\nIf the transcription contains errors, such as confusing similar-sounding words, you can provide a glossary of such terms in the system prompt during step 1. This helps the model avoid misinterpretations and ensures accurate transcription of specific terms.\n\nIf the source audio contains grammatical errors, consider using a post-processing step with the GPT model to refine the transcription by removing grammatical mistakes and adding appropriate punctuation. After this, instead of using GPT-4o’s audio-in and audio-out modality, you can use the corrected transcription with GPT-4o’s text-in and audio-out modality to generate the audio in the target language.\n\nCertain terms or concepts may not have a suitable translation in the target language or may be better understood in their original form. Revisit your glossary_of_terms_to_keep_in_original_language and include any such terms to maintain clarity and context.\n\nIn summary, this cookbook offers a clear, step-by-step process for translating and dubbing audio, making content more accessible to a global audience. Using GPT-4o’s audio input and output capabilities, translating and dubbing audio files from one language to another becomes much simpler. Our example focused on translating an audio file from English to Hindi.\n\nThe process can be broken down into the following steps:\n\n1. Transcription: Obtain transcription of the source language audio into source language script using GPT-4o text modality.\n\n2. Dub: Directly dub the audio file into the target language using GPT-4o's audio modality.\n\n3. Benchmark Translation Quality: Evaluate the translation’s accuracy using BLEU or ROUGE scores compared to reference text.\n\n4. Optimize the Process: If needed, adjust the prompting parameters to improve the transcription and dubbing results.\n\nThis guide also highlights the crucial distinction between \"language\" and \"script\"—terms that are often confused but are essential in translation work. Language refers to the system of communication, either spoken or written, while script is the set of characters used to write a language. Grasping this difference is vital for effective translation and dubbing.\n\nBy following the techniques in this cookbook, you can translate and dub a wide range of content—from podcasts and training videos to full-length films—into multiple languages. This method applies across industries such as entertainment, education, business, and global communication, empowering creators to extend their reach to diverse linguistic audiences."])</script><script>self.__next_f.push([1,"f5:T1569,"])</script><script>self.__next_f.push([1,"Welcome to our cookbook on meta prompting! In this guide, we'll explore how to take a basic prompt and refine it to enhance the quality of outputs from a language model. We'll use the example of summarizing news reports to illustrate the process.\n\n\nMeta-prompting is a technique where you use an LLM to generate or improve prompts. Typically this is done using a higher intelligence model that optimizes prompts for a model with less intelligence. It’s a process of using prompts to guide, structure, and optimize other prompts, helping ensure they’re more effective in guiding the LLM towards high-quality, relevant outputs. We'll be leveraging the capabilities of o1-preview, a more intelligent model with advanced reasoning skills, to improve a prompt for gpt-4o.\n\nWe're committed to making your development journey with LLMs smoother and more accessible through this technique. Don't forget to check out our Generate Anything feature in the playground — it's a fantastic starting point to dive into meta prompting.\n\nIn this example, we'll begin with a simple prompt for summarizing news articles and then enhance it to see how the outputs improve. We'll use o1-preview to analyze and refine our prompt, adding more detail and clarity along the way. Finally, we'll evaluate the outputs systematically to understand the impact of our refinements.\n\nLet's kick things off by importing the bbc_news_alltime dataset from HuggingFace. This dataset contains all BBC News articles, capturing everything published monthly from 2017 up to the latest complete month. For our experiment, we'll focus exclusively on a sample from a recent month—August 2024—to keep things current and manageable.\n\n\nLet's start with a straightforward prompt and then use o1-preview to enhance it for better results. We want to summarize news articles, so this is what i'll ask the model to do.\nTo improve the prompt, we need to provide o1-preview with the context and goals we want to achieve. We can then ask it to generate a more detailed prompt that would produce richer and more comprehensive news summaries.\n\nNow that we have both prompts, let's generate the summaries! For each entry in our dataset, we'll use both the simple and the enhanced prompts to see how they compare. By doing this, we'll get a firsthand look at how our refinements with o1-preview can lead to richer and more detailed summaries. Let's dive in and see the difference for ourselves!\nLet's check if everything looks good and if we can generate a summary for the first news report.\nBy comparing the summaries generated from the simple and enhanced prompts, we can already see significant improvements. The initial summary gives us a general overview of the article, whereas the enhanced summary dives deeper — it not only provides a detailed summary but also categorizes the news type, lists relevant tags, and even includes a sentiment analysis.\n\nLet's test on the entire dataset now!\n\nTo assess the difference in performance between the two prompts, we'll use a structured evaluation approach with the LLM acting as a judge. This means we'll leverage the language model itself to evaluate and compare the outputs based on specific criteria.\n\nWhat Does \"LLM as a Judge\" Mean?\n\nUsing an LLM as a judge involves having the language model evaluate its own outputs or those of another model. It applies predefined criteria to assess aspects like accuracy, clarity, and relevance. This approach helps us obtain an objective and consistent evaluation without human bias, making it easier to identify improvements between different prompts. Our cookbook on Getting Started with OpenAI Evals offers a glimps on how you can get started with this approach.\n\n\nHere's the prompt we'll use for evaluation:\nHere's a pro tip — you can actually use meta prompting to refine your evaluation prompt as well! By applying the same iterative enhancement to the prompt that instructs the LLM to act as a judge, you can make your evaluations even more precise and insightful.\n\nLet's use this prompt to evaluate our summaries!\nAfter evaluating the results, we found that while the basic prompt performed well in clarity and structure, the enhanced prompt significantly improved outputs across several other key criteria: Categorization, Keywords and Tags, Sentiment Analysis, and Detail and Completeness. The complex prompt led to summaries that were more informative, better organized, and richer in content.\n\nThis demonstrates how refining prompts can greatly enhance the quality of the generated summaries. Although this is a simplified example, the benefits of prompt optimization are expected to be even more pronounced in real-world, production-level applications, leading to outputs that are more aligned with specific goals and user needs.\n\nMeta prompting is a powerful technique that can significantly enhance the quality of outputs from language models. Our exploration showed that starting with a simple prompt and refining it using o1-preview led to summaries that were more informative, better organized, and richer in content—improving across key criteria like categorization, keywords and tags, sentiment analysis, and completeness. This exercise underscores the value of prompt optimization, and even in this simplified example, the benefits are clear. In real-world applications, leveraging meta prompting and tools like o1-preview can elevate language model performance to better meet your specific goals and user needs."])</script><script>self.__next_f.push([1,"f6:T1c79,"])</script><script>self.__next_f.push([1,"This page provides instructions for developers connecting a GPT Action to GitHub. Before proceeding, familiarize yourself with the following resources:\nIntroduction to GPT Actions\nGPT Actions Library\nBuilding a GPT Action from Scratch\n\nThis GPT Action helps developers evaluate the quality and security of a GitHub Pull Request diff. It provides feedback and suggestions for each domain, allowing developers to modify or accept the feedback before automatically submitting it as a comment on the Pull Request.\n\n\nUsers can leverage ChatGPT's natural language capabilities to assist with GitHub Pull Request reviews.\n\nFor developers**: Analyze code changes and perform high-quality reviews with instant feedback on proposed modifications.\nFor organizations**: Ensure diffs adhere to best practices and coding standards, or automatically propose refactored alternatives (additional API requests may be required to define best practices).\nOverall**: Boost productivity and ensure higher-quality, more secure code with this AI-powered Code Review assistant.\n\nA reviewer seeks feedback on the quality and security of a proposed code change.\nAn organization encourages adherence to best practices and standards automatically during code review.\n\nWatch the video\n\n\nBefore starting, explore these resources:\nGitHub\nGitHub API Documentation\n\nEnsure you have a repository with an open pull request.\n\n\nNavigate to a repository, e.g., example PR.\n   Note the owner (e.g., \"microsoft\"), repository name (e.g., \"vscode\"), and PR number (e.g., \"229241\").\n   If the repository owner is an SSO organization, your token may need approval.\nReview how to perform a high-quality code review.\n\nLog in to GitHub and go to Settings.\nNavigate to Developer settings \u003e Fine Grained Personal access tokens.\nClick Generate new token, name it, set an expiration date, and select the necessary scopes (e.g., read:content, read\u0026write:pull_requests).\nCopy and securely store the token.\n\n\n\nOnce you've created a Custom GPT, copy the following into the Instructions panel:\n\n\n\nIf you don't already have it, ask the user to specify the pull request owner, repository and pull request number they want assistance with and the particular area of focus (e.g., code performance, security vulnerabilities, and best practices).\nRetrieve the Pull Request information from GitHub using the getPullRequestDiff API call, owner, repository and the pull request number provided.\nProvide a summary of the pull request diff in four sentences or less then make improvement suggestions where applicable for the particular areas of focus (e.g., code performance, security vulnerabilities, and best practices).\nAsk the user if they would like to post the feedback as a comment or modify it before posting. If the user modifies the feedback, incorporate that feedback and repeat this step.\nIf the user confirms they would like the feedback posted as a comment back to the Pull request, use the postPullRequestComment API to comment the feedback on the pull request.\n\n\nOnce you've created a Custom GPT, copy the text below in the Actions panel. Have questions? Check out Getting Started Example to see how this step works in more detail.\n\nBelow is an example of what connecting to GitHub to GET the Pull Request Diff and POST the Feedback to the Pull Request might look like.\n\nopenapi: 3.1.0\ninfo:\n  title: GitHub Pull Request API\n  description: Retrieve the diff of a pull request and post comments back to it.\n  version: 1.0.0\nservers:\n  url: https://api.github.com\n    description: GitHub API\npaths:\n  /repos/{owner}/{repo}/pulls/{pull_number}:\n    get:\n      operationId: getPullRequestDiff\n      summary: Get the diff of a pull request.\n      parameters:\n        name: owner\n          in: path\n          required: true\n          schema:\n            type: string\n          description: Owner of the repository.\n        name: repo\n          in: path\n          required: true\n          schema:\n            type: string\n          description: Name of the repository.\n        name: pull_number\n          in: path\n          required: true\n          schema:\n            type: integer\n          description: The number of the pull request.\n        name: Accept\n          in: header\n          required: true\n          schema:\n            type: string\n            enum:\n              application/vnd.github.v3.diff\n          description: Media type for the diff format.\n      responses:\n        \"200\":\n          description: Successfully retrieved the pull request diff.\n          content:\n            text/plain:\n              schema:\n                type: string\n        \"404\":\n          description: Pull request not found.\n  /repos/{owner}/{repo}/issues/{issue_number}/comments:\n    post:\n      operationId: postPullRequestComment\n      summary: Post a comment to the pull request.\n      parameters:\n        name: owner\n          in: path\n          required: true\n          schema:\n            type: string\n          description: Owner of the repository.\n        name: repo\n          in: path\n          required: true\n          schema:\n            type: string\n          description: Name of the repository.\n        name: issue_number\n          in: path\n          required: true\n          schema:\n            type: integer\n          description: The issue or pull request number.\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              type: object\n              properties:\n                body:\n                  type: string\n                  description: The content of the comment.\n      responses:\n        \"201\":\n          description: Successfully created a comment.\n          content:\n            application/json:\n              schema:\n                type: object\n                properties:\n                  id:\n                    type: integer\n                  body:\n                    type: string\n                  user:\n                    type: object\n                    properties:\n                      login:\n                        type: string\n                      id:\n                        type: integer\n        \"404\":\n          description: Pull request not found.\n\n\nBelow are instructions on setting up authentication with this 3rd party application. Have questions? Check out Getting Started Example to see how this step works in more detail.\n\n\nIn ChatGPT, click on \"Authentication\" and choose \"Bearer\". Enter in the information below. Ensure your token has the permissions described in Application setup, above.\n\nAuthentication Type: API Key\nAuth Type: Bearer\nAPI Key\n\n\nYou are now ready to test out the GPT. You can enter a simple prompt like \"Can you review my pull request? owner: , repo: , pull request number: \" and expect to see the following:\n\nlanding_page.png\n\nA summary of changes in the referenced pull request(PR).\n\nFirst Interaction\n\nQuality and Security feedback and suggestions to incorporate in the next iteration of the PR.\n\nFirst Feedback\n\nAn option to iterate on the feedback or accept it and have the GPT post it directly to the PR as a comment from you.\n\nFirst Interaction\n\nAre there integrations that you’d like us to prioritize? Are there errors in our integrations? File a PR or issue in our github, and we’ll take a look."])</script><script>self.__next_f.push([1,"f7:T1ce5,"])</script><script>self.__next_f.push([1,"Let's say you're working on a customer service bot and trying to evaluate the quality of its responses. Consider a question like \"What is your return policy?\" If the correct answer is \"You can return items within 30 days of purchase,\" but your bot generates \"You can return items within 30 days,\" how would you evaluate whether this is a good response?\n\nA heuristic like the Levenshtein string distance would indicate that the response is incorrect. However, a better approach is to use an LLM-as-a-judge to assess the accuracy of the response. LLM-as-a-judge is a technique that leverages an LLM to score the quality of answers. LLMs can reason about language beyond surface-level string comparisons, enabling them to evaluate answers more accurately.\n\nIn this cookbook, we'll walk through how to build an LLM-as-a-judge scorer that can detect hallucinations using Braintrust, a third-party evaluation platform that is compatible with OpenAI's models.\n\n\nLet's install a few basic dependencies. We'll use the CoQA dataset (via DuckDB), Braintrust for evals, and OpenAI's models. Please note that Braintrust is a third-party evaluation platform and you should review their terms of service and privacy policy before proceeding.\n\nNext, let's initialize the OpenAI client. We'll use the AsyncOpenAI client so that we can parallelize our requests. The braintrust.wrap_openai function\nwraps the OpenAI client to enable logging LLM calls to Braintrust. We'll use Braintrust to facilitate the evaluations below.\nBefore proceeding, you should sign up for a Braintrust account and set BRAINTRUST_API_KEY in your environment to a valid API key.\n\n\nWe'll use the CoQA dataset which contains a diverse set of passages, questions, and answers. Because CoQA is quite large, we'll just look at the first several passages. As with any public dataset, there's a chance that the underlying LLMs have memorized aspects of the dataset, so when developing your own scorers, it's a good idea to test them using\nyour own private data.\n\nThe data contains a series of passages, each with a number of questions and answers. Let's flatten this into a list of (passage, question, answer) tuples.\n\n\nBecause Braintrust's scorer is designed to test hallucinations, we can use the QA pairs to generate known hallucinations. We'll create hallucinated answers by asking an\nLLM to confidently generate an answer to each question without using the passage.\n\n\nWe'll consider a few popular approaches for creating an LLM-as-a-judge. For each approach, we'll create a scorer and then \"meta-evaluate\" it to see how it performs.\nSince we know that the hallucinated answers are incorrect, we'll assess the quality of an evaluator by testing how often it scores the hallucinated answers as 0.\n\n\nA common initial intuition when creating an LLM-as-a-judge is asking the LLM to rate the answer on a scale of 1 to 5. The benefit of this approach is that\nit's easy to convert the LLM's output into a numeric score.\n\nWe'll use a modified version of the Factuality template, but ask the LLM to\nrate the answer on a scale of 1 to 10.\n\nThis looks promising! Now that we have sanity checked it on a single example, let's run a proper evaluation and see how it performs on a wider set of data. An evaluation consists of three components:\n\nData**: In this case, the input is the question, hallucinated answer, and ground truth answer. The scorer will convert this into a score between 0 and 1. The expected score is 0, since it's a hallucination.\nTask**: The task is simply calling the numeric rater for each input.\nScores**: We'll assess the quality of the generated score by comparing it with the ground truth score. Since we know both numbers are between 0 and 1, we can use the normalized difference as the score.\n\nIt looks like the numeric rater scored almost 94% in total. That's not bad, but if 6% of your evals are incorrectly judged, that could make it very hard to trust them. Let's dig into the Braintrust\nUI to get some insight into what's going on.\n\nPartial credit\n\nIt looks like a number of the incorrect answers were scored with numbers between 1 and 10. However, we do not currently have any insight into why the model gave these scores. Let's see if we can\nfix that next.\n\n\nLet's tweak the prompt to get the LLM to also reason about its rating. This method is called Chain of Thought Reasoning. In addition\nto potentially improving the score, it will give us some insight into why the model gave these scores.\n\nIt doesn't look like adding reasoning helped the score (in fact, it's 3% percent worse). However, if we look at one of the failures, we'll get some insight into\nwhat the model was thinking. Here is an example of a hallucinated answer:\n\nOutput\n\nAnd the score along with its reasoning:\n\nReasoning\n\nIt looks like the model is applying its own judgement to compute partial credit. This is a common problem with numeric rating—both for models and for humans—and can often be solved\nby using better prompting.\n\n\nNext, we'll spell out specific criteria and ask the model to classify the answer according to those criteria. This method allows us to more precisely guide the model\ntowards the hallucinations we're testing for. Intuitively, giving the model specific criteria to rate will result in a more accurate score.\n\nThe classifier scored 98% which is a significant improvement!\n\n\nThe classifier above can simply be rewritten as:\n\nPROMPT = \"\"\"\\\nYou are comparing a submitted answer to an expert answer on a given question. Here is the data:\n[BEGIN DATA]\n[Question]: {{input}}\n[Expert]: {{expected}}\n[Submission]: {{output}}\n[END DATA]\n\nCompare the factual content of the submitted answer with the expert answer. Ignore any differences in style, grammar, or punctuation.\nThe submitted answer may either be a subset or superset of the expert answer, or it may conflict with it. Determine which case applies. Answer the question by selecting one of the following options:\n(A) The submitted answer is a subset of the expert answer and is fully consistent with it.\n(B) The submitted answer is a superset of the expert answer and is fully consistent with it.\n(C) The submitted answer contains all the same details as the expert answer.\n(D) There is a disagreement between the submitted answer and the expert answer.\n(E) The answers differ, but these differences don't matter from the perspective of factuality.\n\nAnswer the question by calling select_choice with your reasoning in a step-by-step matter to be\nsure that your conclusion is correct. Avoid simply stating the correct answer at the outset. Select a\nsingle choice by setting the choice parameter to a single choice from A, B, C, D, or E.\n\"\"\"\n\nClassifier = autoevals.LLMClassifier(\n    name=\"Hallucination detector\",\n    prompt_template=PROMPT,\n    choice_scores={\"A\": 0.5, \"B\": 0, \"C\": 1, \"D\": 0, \"E\": 1},\n    use_cot=True,\n)\n\n\nAs a next step, you could dig into the individual improvements and regressions to assess them and consider future improvements to the prompt. You could also test it on your own data, and double check that the results hold for your use case.\nYou could also measure a model like o1, try fine-tuning a smaller model and see if the results are reproducible, or use few-shot prompting to align the model with more subjective criteria.\nIn all cases, you should strive to evaluate your results, so you can rigorously assess the impact of each change."])</script><script>self.__next_f.push([1,"f8:T3b52,"])</script><script>self.__next_f.push([1,"We're excited to announce the launch of Vision Fine-Tuning on GPT-4o, a cutting-edge multimodal fine-tuning capability that empowers developers to fine-tune GPT-4o using both images and text. With this new feature, you can customize models to have stronger image understanding capabilities, unlocking possibilities across various industries and applications.\n\nFrom advanced visual search to improved object detection for autonomous vehicles or smart cities, vision fine-tuning enables you to craft solutions tailored to your specific needs. By combining text and image inputs, this product is uniquely positioned for tasks like visual question answering, where detailed, context-aware answers are derived from analyzing images. In general, this seems to be most effective when the model is presented with questions and images that resemble the training data as we are able to teach the model how to search and identify relevant parts of the image to answer the question correctly. Similarly to fine-tuning on text inputs, vision fine-tuning is not as useful for teaching the model new information.\n\nIn this guide, we’ll walk you through the steps to fine-tune GPT-4o with multimodal inputs. Specifically, we’ll demonstrate how to train a model for answering questions related to images of books, but the potential applications span countless domains—from web design and education to healthcare and research.\n\nWhether you're looking to build smarter defect detection models for manufacturing, enhance complex document processing and diagram understanding, or develop applications with better visual comprehension for a variety of other use cases, this guide will show you just how fast and easy it is to get started.\n\nFor more information, check out the full Documentation.\nWe will work with a dataset of question-answer pairs on images of books from the OCR-VQA dataset, accessible through HuggingFace. This dataset contains 207,572 images of books with associated question-answer pairs inquiring about title, author, edition, year and genre of the book. In total, the dataset contains ~1M QA pairs. For the purposes of this guide, we will only use a small subset of the dataset to train, validate and test our model.\n\nWe believe that this dataset will be well suited for fine-tuning on multimodal inputs as it requires the model to not only accurately identify relevant bounding boxes to extract key information, but also reason about the content of the image to answer the question correctly.\nWe'll begin by sampling 150 training examples, 50 validation examples and 100 test examples. We will also explode the questions and answers columns to create a single QA pair for each row. Additionally, since our images are stored as byte strings, we'll convert them to images for processing.\nLet's inspect a random sample from the training set.\n\nIn this example, the question prompts the model to determine the title of the book. In this case, the answer is quite ambiguous as there is the main title \"Patty's Patterns - Advanced Series Vol. 1 \u0026 2\" as well as the subtitle \"100 Full-Page Patterns Value Bundle\" which are found in different parts of the image. Also, the name of the author here is not an individual, but a group called \"Penny Farthing Graphics\" which could be mistaken as part of the title.\n\nThis type of task is typical in visual question answering, where the model must interpret complex images and provide accurate, context-specific responses. By training on these kinds of questions, we can enhance the model's ability to perform detailed image analysis across a variety of domains.\nTo ensure successful fine-tuning of our model, it’s crucial to properly structure the training data. Correctly formatting the data helps avoid validation errors during training and ensures the model can effectively learn from both text and image inputs. The good news is, this process is quite straightforward.\n\nEach example in the training dataset should be a conversation in the same format as the Chat Completions API. Specifically, this means structuring the data as a series of messages, where each message includes a role (such as \"user\" or \"assistant\") and the content of the message.\n\nSince we are working with both text and images for vision fine-tuning, we’ll construct these messages to include both content types. For each training sample, the question about the image is presented as a user message, and the corresponding answer is provided as an assistant message.\n\nImages can be included in one of two ways:\nAs HTTP URLs, referencing the location of the image.\nAs data URLs containing the image encoded in base64.\n\nHere’s an example of how the message format should look:\nLet's start by defining the system instructions for our model. These instructions provide the model with important context, guiding how it should behave when processing the training data. Clear and concise system instructions are particularly useful to make sure the model reasons well on both text and images.\nTo ensure our images are properly formatted for vision fine-tuning, they must be in base64 format and either RGB or RGBA. This ensures the model can accurately process the images during training. Below is a function that handles the encoding of images, while also converting them to the correct format if necessary.\n\nThis function allows us to control the quality of the image encoding, which can be useful if we want to reduce the size of the file. 100 is the highest quality, and 1 is the lowest. The maximum file size for a fine-tuning job is 1GB, but we are unlikely to see improvements with a very large amount of training data. Nevertheless, we can use the quality parameter to reduce the size of the file if needed to accomodate file size limits.\nWe will also include Few-Shot examples from the training set as user and assistant messages to help guide the model's reasoning process.\n\nNow that we have our system instructions, few-shot examples, and the image encoding function in place, the next step is to iterate through the training set and construct the messages required for fine-tuning. As a reminder, each training example must be formatted as a conversation and must include both the image (in base64 format) and the corresponding question and answer.\n\nTo fine-tune GPT-4o, we recommend providing at least 10 examples, but you’ll typically see noticeable improvements with 50 to 100 training examples. In this case, we'll go all-in and fine-tune the model using our larger training sample of 150 images, and 721 QA pairs.\nWe save our final training set in a .jsonl file where each line in the file represents a single example in the training dataset.\nJust like the training set, we need to structure our validation and test sets in the same message format. However, for the test set, there's a key difference: since the test set is used for evaluation, we do not include the assistant's message (i.e., the answer). This ensures the model generates its own answers, which we can later compare to the ground truth for performance evaluation.\nNow that we have prepared our training and validation datasets in the right format, we can upload them using the Files API for fine-tuning.\nOnce the files are uploaded, we're ready to proceed to the next step: starting the fine-tuning job.\n\nTo create a fine-tuning job, we use the fine-tuning API. This may take some time to complete, but you can track the progress of the fine-tuning job in the Platform UI.\nOnce the fine-tuning job is complete, it’s time to evaluate the performance of our model by running inference on the test set. This step involves using the fine-tuned model to generate responses to the questions in the test set and comparing its predictions to the ground truth answers for evaluation. We will also run inference on the test set using the non-fine-tuned GPT-4o model for comparison.\nNow that we’ve run inference using our fine-tuned model, let’s inspect a few specific examples to understand how well the model performed compared to the actual answers.\nAs we can see, the fine-tuned model does a great job at answering the questions, with many responses being exactly correct.\n\nHowever, there are also cases where the model’s predicted answers are close to the ground truth, while not matching exactly, particularly in open-ended questions where phrasing or details may differ. To assess the quality of these predictions, we will use GPT-4o to evaluate the similarity between the predicted responses and the ground truth labels from the dataset.\n\nIn order to evaluate our model responses, we will use GPT-4o to determine the similarity between the ground truth and our predicted responses. We will rank our predicted answers based on the following criteria:\nVery Similar**: The predicted answer exactly matches the ground truth and there is no important information omitted, although there may be some minor ommissions or discrepancies in punctuation.\n\nMostly Similar**: The predicted answer closely aligns with the ground truth, perhaps with some missing words or phrases.\n\nSomewhat Similar**: Although the predicted answer has noticeable differences to the ground truth, the core content is accurate and semantically similar, perhaps with some missing information.\n\nIncorrect**: The predicted answer is completely incorrect, irrelevant, or contains critical errors or omissions from the ground truth.\n\nTo fully understand the impact of fine-tuning, we also evaluated the same set of test questions using the non-fine-tuned GPT-4o model.\n\nLet's start by comparing the performance of the fine-tuned model vs the non-fine-tuned model for Closed form (Yes/No) questions.\n\nNote that with the fine-tuned model, we can check for exact matches between the predicted and actual answers because the model has learned to produce consistent answers that follow the response format specified in the system prompt. However, for the non-fine-tuned model, we need to account for variations in phrasing and wording in the predicted answers. Below is an example of a non-fine-tuned model output. As we can see, the final answer is correct but the response format is inconsistent and outputs reasoning in the response.\nWith a generous allowance for variations in phrasing and wording for the non-fine-tuned model including ignoring case and allowing for partial matches, the fine-tuned model still outperforms the non-fine-tuned model by a margin of 2.64% on this set of questions.\n\nNow, let's compare the performance of the fine-tuned model vs the non-fine-tuned model over all the open-ended questions. First, we'll check for exact matches between the predicted and actual answers, again allowing for general variations in phrasing and wording for the non-fine-tuned model, but maintaining a strict standard for the fine-tuned model.\n\nThe improvement in accuracy here is much more pronounced, with the fine-tuned model outperforming the non-fine-tuned model by a substantial margin of 17.97%, even with very generous allowances for variations in phrasing and wording for the non-fine-tuned model!\n\nIf we were to afford the same leniency to the fine-tuned model, we would see an additional 4.1% increase in accuracy, bringing the total margin of improvement to 22.07%.\n\nTo dig a little deeper, we can also look at the accuracy by question type.\nIt appears that the largest performance gains for the fine-tuned model are for questions in the Genre category e.g. \"What type of book is this?\" or \"What is the genre of this book?\". This might be indicative of the benefits of fine-tuning in general in that we teach the model to classify genres based on the categories present in the training data. However, it also highlights the model's strong visual undserstanding capabilties, since we are able to identify the genre based on the visual content of the book cover alone.\n\nAdditionally, we see significant lift in the Title category, which suggests that fine-tuning has boosted the model's OCR capbilities and its ability to understand the layout and structure of the book cover to extract the relevant information.\n\nFinally, let's compare the distribution of similarity ratings between the fine-tuned model and the non-fine-tuned model to allow for variations in phrasing and wording.\nThe results provide a clear picture of the benefits gained through fine-tuning, without any other modifications.\nComparing the distribution of ratings between the fine-tuned GPT-4o model and GPT-4o without fine-tuning, we see that the fine-tuned model gets many more responses exactly correct, with a comparable amount of incorrect responses.\nImproved Precision**: Fine-tuning helped the model produce more precise answers that matched the ground truth, especially in highly domain-specific tasks like OCR on book covers.\nBetter Generalization**: While the non-fine-tuned GPT-4o was able to get at least somewhat to the ground truth for many questions, it was less consistent. The fine-tuned model exhibited better generalization across a variety of test questions, thanks to the exposure to multimodal data during training.\nWhile the results from vision fine-tuning are promising, there are still opportunities for improvement. Much like fine-tuning on text, the effectiveness of vision fine-tuning depends heavily on the quality, diversity, and representativeness of the training data. In particular, models benefit from focusing on cases where errors occur most frequently, allowing for targeted improvements.\n\nUpon reviewing the incorrect results, many of the \"Incorrect\" responses from the fine-tuned model are in fact due to inconsistencies in the labels from the dataset. For example, some ground truth answers provide only the first and last name of the author, whereas the image actually shows the middle initial as well. Similarly, some ground truth labels for the title include subheadings and taglines, whereas others do not.\n\nAnother common theme was miscategorization of genres. Although the model was almost always able to produce a semantically similar genre to the ground truth, the answer sometimes deviated. This is likely due to the lack of presence of these genres in the training data. Providing the model with more diverse training examples to cover these genres, or clearer instructions for dealing with edge cases can help to guide the model’s understanding.\n\nExpand the Training Dataset**: Adding more varied examples that cover the model’s weaker areas, such as identifying genres, could significantly enhance performance.\n\nExpert-Informed Prompts**: Incorporating domain-specific instructions into the training prompts may further refine the model’s ability to accurately interpret and respond in complex cases.\n\nAlthough there is still some progress to be made on this particular task, the initial results are highly encouraging. With minimal setup and effort, we’ve already observed a substantial uplift in overall accuracy with vision fine-tuning, indicating that this approach holds great potential. Vision fine-tuning opens up possibilities for improvement across a wide range of visual question answering tasks, as well as other tasks that rely on strong visual understanding."])</script><script>self.__next_f.push([1,"f9:T768,Our traditional TTS APIs don't have the ability to steer the voice of the generated audio. For example, if you wanted to convert a paragraph of text to audio, you would not be able to give any specific instructions on audio generation.\n\nWith audio chat completions, you can give specific instructions before generating the audio. This allows you to tell the API to speak at different speeds, tones, and accents. With appropriate instructions, these voices can be more dynamic, natural, and context-appropriate.\n\nTraditional TTS can specify voices, but not the tone, accent, or any other contextual audio parameters.\n\nWith chat completions, you can give specific instructions before generating the audio. In the following example, we generate a British accent in a learning setting for children. This is particularly useful for educational applications where the voice of the assistant is important for the learning experience.\n\nWe can also generate audio in different language accents. In the following example, we generate audio in a specific Spanish Uruguayan accent.\n\nThe ability to steer the voice of the generated audio opens up a lot of possibilities for richer audio experiences. There are many use cases such as:\nEnhanced Expressiveness**: Steerable TTS allows adjustments in tone, pitch, speed, and emotion, enabling the voice to convey different moods (e.g., excitement, calmness, urgency).\nLanguage learning and education**: Steerable TTS can mimic accents, inflections, and pronunciation, which is beneficial for language learners and educational applications where accurate intonation and emphasis are critical.\nContextual Voice**: Steerable TTS adapts the voice to fit the content’s context, such as formal tones for professional documents or friendly, conversational styles for social interactions. This helps create more natural conversations in virtual assistants and chatbots.fa:T1e3f,"])</script><script>self.__next_f.push([1,"This notebook provides a step-by-step guide for using Pinecone as a vector database to store OpenAI embeddings. As an example, it demonstrates how to integrate this setup with Retool to create a REST endpoint, enabling seamless interaction with ChatGPT as an action. However, Retool is just one of many approaches available for connecting your Pinecone database to ChatGPT.\n\nPinecone is a fully managed vector database designed for storing, indexing, and querying large-scale vector embeddings. It enables fast and efficient similarity searches, making it ideal for AI-powered applications like recommendation systems, semantic search, and natural language processing.\n\nRetool is a low-code platform that simplifies building custom internal tools by connecting to databases, APIs, and third-party services. It enables users to create powerful, user-friendly interfaces and workflows with minimal coding, making it ideal for streamlining business operations and integrating complex systems.\n\n\n\nA Pinecone account\nA Retool account\nA Custom GPT with actions enabled\nAn OpenAI API key\n\n\n\nSetup Pinecone\nSetup Noteboook\nPrepare Data\nCreate a Pinecone Index\nPopulate the Pinecone Index\nCreate a Retool Workflow\nCreate a Custom GPT Action\n\n\n\nIf you haven't got a Pinecone account, sign up for an account. You're ready to move on to the next section once you get the following screen. Go to API Keys and create a new API key.\n\nVectors in Pinecone\n\n\n\nInstall required libraries from OpenAI and Pinecone.\nImport the OpenAI and Pinecone libraries.\n\nDefine a sample dataset to embed store in Pinecone and to search over from ChatGPT.\nWe are now ready to convert the text to embeddings. The example below is the most simple implementation of this function. If your text is longer than the context window of the model you are using, you will need to chunk the text into smaller pieces.\n\nThe next step is to create a Pinecone index, we'll do this programmatically, alternatively you can do this from the Pinecone dashboard.\n\nNow that we've created the index, we can populate it with our embeddings. Before we do this we need to append the ID to the embeddings along with the raw text, this is so we can retrieve the original text when we query the index.\n\nWhen upserting vectors we choose a namespace, this is optional but can be useful if you want to store multiple datasets in the same index as it allows you to partition the data. For example if you needed to store a dataset of customer support queries and a dataset of product descriptions you could create two namespaces and query over each one separately.\nYou should now see the vectors in the Pinecone Dashboard.\n\nVectors in Pinecone\nThe vectors should now be visible in the Pincone Dashbaord.\n\nTo test the search functionality we can query the index. Below we are taking a sample question, running this through the same embedding function and then checking the index for matching vectors.\n\ntop_k refers to the number of results we want to return.\ninclude_values and include_metadata are used to return the embeddings and original text of the results.\n\nNow we have a working vector database, we can create a Retool workflow to connect to it to run our queries from ChatGPT.\n\nOpen Retool and create a new workflow.\n\nYou should now see the following screen.\n\nRetool Workflow 2\n\nIn this example we'll be using Python to query the Pinecone index. To do this we'll need to import the pinecone and openai library. First switch to Python.\n\nWe are now ready to add our code to the code block.\n\nStart by declaring the libraries we just imported to this workflow.\n\nfrom pinecone import Pinecone\nfrom openai import OpenAI\nWe now need to set the API keys for Pinecone and OpenAI. You can put these directly in the code block or use Retool Configuration Variables. Configuration variables are recommended as they are more secure, this shown below.\n\nclient = OpenAI(api_key=retoolContext.configVars.openai_api_key)\npc = Pinecone(api_key=retoolContext.configVars.pinecone_api_key)\nWe can then reuse our OpenAI Embedding and Pinecone query functions from above in the Retool code snippet and return the results. Below is the completed code block.\n\nfrom pinecone import Pinecone\nfrom openai import OpenAI\n\nclient = OpenAI(api_key=retoolContext.configVars.openai_api_key)\npc = Pinecone(api_key=retoolContext.configVars.pinecone_api_key)\nindex = pc.Index(\"openai-cookbook-pinecone-retool\")\n\n\ndef embed(query):\n    res = client.embeddings.create(\n        input=query,\n        model=\"text-embedding-3-large\"\n    )\n    doc_embeds = [r.embedding for r in res.data]\n    return doc_embeds\n\nx = embed([startTrigger.data.query])\n\nresults = index.query(\n    namespace=\"ns1\",\n    vector=x[0],\n    top_k=2,\n    include_values=False,\n    include_metadata=True\n)\n\nreturn results.to_dict()['matches']\nThis should look like this in the UI. You can test this by clicking the run button at the top of the code block. You should see the results returned in the Data section at the bottom of the code block.\n\nRetool Workflow 3\nWe now have a workflow with a start trigger that will take a user query pass this to our Vector_Search code block. This will return the top 2 results from the Pinecone index. Next we need to add a block that will take these results and respond to the start trigger request.\n\n\n\nFinally we need to configure the start trigger to support calling via API to allow it to be used as a ChatGPT action.\n\nGo to Triggers, and toggle the switch to enable the Webhook. Click on the Webhook to open the configuration screen. We can optionally add an Alias to better describe what this webhook will trigger. In this case we'll call it vector_search. This provides a more identifiable name in the URL. When complete click Save Changes.\n\nRetool Workflow 4\n\nThe final step is to deploy this workflow. Click the Deploy button at the top of the screen. The workflow is now accessible via API. You can test this by clicking the copy button next to the Alias URL, choosing Copy as cURL and then running this in the terminal.\n\n\n\n\nWe now have a working Vector Database, and a way of querying this over API through the Retool Workflow. The next step is to connect the Retool Workflow to ChatGPT via an action.\n\nGo to you GPT, and create a new action. Below is an example of the OpenAPI spec required to connect to the Retool Workflow. You will need to replace the URL and API key with your own.\n\nopenapi: 3.1.0\ninfo:\n  title: Vector Search API\n  description: An API for performing vector-based search queries.\n  version: 1.0.0\nservers:\n  url: YOUR_URL_HERE\n    description: Sandbox server for the Vector Search API\npaths:\n  /url/vector-search:\n    post:\n      operationId: performVectorSearch\n      summary: Perform a vector-based search query.\n      description: Sends a query to the vector search API and retrieves results.\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              type: object\n              properties:\n                query:\n                  type: string\n                  description: The search query.\n              required:\n                query\n      responses:\n        '200':\n          description: Successful response containing search results.\n        '400':\n          description: Bad Request. The input data is invalid.\n        '500':\n          description: Internal Server Error. Something went wrong on the server side.\n\nUnder the Authentication section set the auth method to API Key. Paste in your API from the Retool Workflow trigger settings. Then set Auth Type to Custom and set the Custom Header Name to\n\nYour setup is now complete. You can test this by sending a message to your GPT asking for information from the vector database."])</script><script>self.__next_f.push([1,"fb:T42c9,"])</script><script>self.__next_f.push([1,"Implementing Retrieval-Augmented Generation (RAG) presents unique challenges when working with documents rich in images, graphics and tables. Traditional RAG models excel with textual data but often falter when visual elements play a crucial role in conveying information. In this cookbook, we bridge that gap by leveraging the vision modality to extract and interpret visual content, ensuring that the generated responses are as informative and accurate as possible.\n\nOur approach involves parsing documents into images and utilizing metadata tagging to identify pages containing images, graphics and tables. When a semantic search retrieves such a page, we pass the page image to a vision model instead of relying solely on text. This method enhances the model's ability to understand and answer user queries that pertain to visual data.\n\nIn this cookbook, we will explore and demonstrate the following key concepts:\n\nLearn how to initialize and configure Pinecone to store vector embeddings efficiently.\n\nDiscover techniques for converting PDF pages into images.\nUse GPT-4o vision modality to extract textual information from pages with images, graphics or tables.\n\nUtilize embedding models to create vector representations of textual data.\nFlag the pages that have visual content so that we set a metadata flag on vector store, and retrieve images to pass on the GPT-4o using vision modality.\n\nUpload these embeddings to Pinecone for storage and retrieval.\n\nImplement semantic search on page text to find pages that best match the user's query.\nProvide the matching page text to GPT-4o as context to answer user's query.\n\nLearn how to pass the image using GPT-4o vision modality for question answering with additional context.\nUnderstand how this process improves the accuracy of responses involving visual data.\n\nBy the end of this cookbook, you will have a robust understanding of how to implement RAG systems capable of processing and interpreting documents with complex visual elements. This knowledge will empower you to build AI solutions that deliver richer, more accurate information, enhancing user satisfaction and engagement.\n\nWe will use the World Bank report - A Better Bank for a Better World: Annual Report 2024 to illustrate the concepts as this document has a mix of images, tables and graphics data.\n\nKeep in mind that using the Vision Modality is resource-intensive, leading to increased latency and cost. It is advisable to use Vision Modality only for cases where performance on evaluation benchmarks is unsatisfactory with plain text extraction methods. With this context, let's dive in.\nIn this section, we'll set up a vector store using Pinecone to store and manage our embeddings efficiently. Pinecone is a vector database optimized for handling high-dimensional vector data, which is essential for tasks like semantic search and similarity matching.\n\nPrerequisites\nSign-up for Pinecone and obtain an API key by following the instructions here Pinecone Database Quickstart\nInstall the Pinecone SDK using pip install \"pinecone[grpc]\". gRPC (gRPC Remote Procedure Call) is a high-performance, open-source universal RPC framework that uses HTTP/2 for transport, Protocol Buffers (protobuf) as the interface definition language, and enables client-server communication in a distributed system. It is designed to make inter-service communication more efficient and suitable for microservices architectures.\n\nStore the API Key Securely\nStore the API key in an .env file for security purposes in you project directory as follows:\n PINECONE_API_KEY=your-api-key-here.\n Install pip install python-dotenv to read the API Key from the .env file.\n\nCreate the Pinecone Index\nWe'll use the create_index function to initialize our embeddings database on Pinecone. There are two crucial parameters to consider:\n\nDimension: This must match the dimensionality of the embeddings produced by your chosen model. For example, OpenAI's text-embedding-ada-002 model produces embeddings with 1536 dimensions, while text-embedding-3-large produces embeddings with 3072 dimensions. We'll use the text-embedding-3-large model, so we'll set the dimension to 3072.\n\nMetric: The distance metric determines how similarity is calculated between vectors. Pinecone supports several metrics, including cosine, dotproduct, and euclidean. For this cookbook, we'll use the cosine similarity metric. You can learn more about distance metrics in the Pinecone Distance Metrics documentation.\nNavigate to Indexes list on Pinecone and you should be able to view my-test-index in the list of indexes.\n\nIn this section, we will parse our PDF document the World Bank report - A Better Bank for a Better World: Annual Report 2024 and extract textual and visual information, such as describing images, graphics, and tables. The process involves three main steps:\n\nParse the PDF into individual pages: We split the PDF into separate pages for easier processing.\nConvert PDF pages to images: This enabled vision GPT-4o vision capability to analyze the page as an image.\nProcess images and tables: Provide instructions to GPT-4o to extract text, and also describe the images, graphics or tables in the document.\n\nPrerequisites\n\nBefore proceeding, make sure you have the following packages installed. Also ensure your OpenAI API key is set up as an environment variable. You may also need to install Poppler for PDF rendering.\n\npip install PyPDF2 pdf2image pytesseract pandas tqdm\n\nStep Breakdown:\n\n1. Downloading and Chunking the PDF:\nThe chunk_document function downloads the PDF from the provided URL and splits it into individual pages using PyPDF2.\nEach page is stored as a separate PDF byte stream in a list.\n\n2. Converting PDF Pages to Images:\nThe convert_page_to_image function takes the PDF bytes of a single page and converts it into an image using pdf2image.\nThe image is saved locally in an 'images' directory for further processing.\n\n3. Extracting Text Using GPT-4o vision modality:\nThe extract_text_from_image function uses GPT-4o vision capability to extract text from the image of the page.\nThis method can extract textual information even from scanned documents.\nNote that this modality is resource intensive thus has higher latency and cost associated with it.\n\n4. Processing the Entire Document:\nThe process_document function orchestrates the processing of each page.\nIt uses a progress bar (tqdm) to show the processing status.\nThe extracted information from each page is collected into a list and then converted into a Pandas DataFrame.\nLet's examine the DataFrame to ensure that the pages have been processed correctly. For brevity, we will retrieve and display only the first five rows. Additionally, you should be able to see the page images generated in the 'images' directory.\nLet's take a look at a sample page, such as page 21, which contains embedded graphics and text. We can observe that the vision modality effectively extracted and described the visual information. For instance, the pie chart on this page is accurately described as:\n\n\"FIGURE 6: MIDDLE EAST AND NORTH AFRICA IBRD AND IDA LENDING BY SECTOR - FISCAL 2024 SHARE OF TOTAL OF $4.6 BILLION\" is a circular chart, resembling a pie chart, illustrating the percentage distribution of funds among different sectors. The sectors include:\n\nIn this section, we focus on transforming the textual content extracted from each page of the document into vector embeddings. These embeddings capture the semantic meaning of the text, enabling efficient similarity searches and various Natural Language Processing (NLP) tasks. We also identify pages containing visual elements, such as images, graphics, or tables, and flag them for special handling.\n\nStep Breakdown:\n\n1. Adding a flag for visual content\n\nTo process pages containing visual information, in Step 2 we used the vision modality to extract content from charts, tables, and images. By including specific instructions in our prompt, we ensure that the model adds markers such as DESCRIPTION OF THE IMAGE OR CHART or TRANSCRIPTION OF THE TABLE when describing visual content. In this step, if such a marker is detected, we set the Visual_Input_Processed flag to 'Y'; otherwise, it remains 'N'.\n\nWhile the vision modality captures most visual information effectively, some details—particularly in complex visuals like engineering drawings—may be lost in translation. In Step 6, we will use this flag to determine when to pass the image of the page to GPT-4 Vision as additional context. This is an optional enhancement that can significantly improve the effectiveness of a RAG solution.\n\n2. Generating Embeddings with OpenAI's Embedding Model\n\nWe use OpenAI's embedding model, text-embedding-3-large, to generate high-dimensional embeddings that represent the semantic content of each page.\n\nNote: It is crucial to ensure that the dimensions of the embedding model you use are consistent with the configuration of your Pinecone vector store. In our case, we set up the Pinecone database with 3072 dimensions to match the default dimensions of text-embedding-3-large.\n\nWe can verify that our logic correctly flagged pages requiring visual input. For instance, page 21, which we previously examined, has the Visual_Input_Needed flag set to \"Y\".\n\nIn this section, we will upload the embeddings we've generated for each page of our document to Pinecone. Along with the embeddings, we'll include relevant metadata tags that describe each page, such as the page number, text content, image paths, and whether the page includes graphics.\n\nStep Breakdown:\n\n1. Create Metadata Fields:\nMetadata enhances our ability to perform more granular searches, find the text or image associated with the vector, and enables filtering within the vector database.\npageId: Combines the document_id and pageNumber to create a unique identifier for each page. We will use this as a unique identifier for our embeddings.\npageNumber: The numerical page number within the document.\ntext: The extracted text content from the page.\nImagePath: The file path to the image associated with the page.\nGraphicIncluded: A boolean or flag indicating whether the page includes graphical elements that may require visual processing.\n\n2. Upload embeddings:\nWe will use Pinecone API to in function upsert_vector to \"upserts\" the values -\n\nA unique identifier\nEmbeddings\nMetadata as defined above\n\nNote: \"Upsert\" is a combination of the words \"update\" and \"insert.\" In database operations, an upsert is an atomic operation that updates an existing record if it exists or inserts a new record if it doesn't. This is particularly useful when you want to ensure that your database has the most recent data without having to perform separate checks for insertion or updating.\nNavigate to Indexes list on Pinecone and you should be able to view the vectors upserted into the database with metadata.\nIn this section, we implement a semantic search to find the most relevant pages in our document that answer a user's question. This approach uses the embeddings stored in the Pinecone vector database to retrieve pages based on the semantic similarity of their content to the user's query. By doing so, we can effectively search textual content, and provide it as context to GPT-4o for answering user's question.\n\nStep Breakdown:\n\n1. Generate an Embedding for the User's Question\n\nWe use OpenAI's embedding model to generate a high-dimensional vector representation of the user's question.\nThis vector captures the semantic meaning of the question, allowing us to perform an efficient similarity search against our stored embeddings.\nThe embedding is crucial for ensuring that the search query is semantically aligned with the content of the document, even if the exact words do not match.\n\n2. Query the Pinecone Index for Relevant Pages\n\nUsing the generated embedding, we query the Pinecone index to find the most relevant pages.\nPinecone performs a similarity search by comparing the question's embedding to the embeddings stored in the vector database using cosine similarity. If you recall, we set this as metric parameter in Step 1 when we created our Pinecone database.\nWe specify the number of top matches to retrieve, typically based on a balance between coverage and relevance. For instance, retrieving the top 3-5 pages is often sufficient to provide a comprehensive answer without overwhelming the model with too much context.\n\n3. Compile the Metadata of Matched Pages to Provide Context\n\nOnce the relevant embeddings are identified, we gather their associated metadata, including the extracted text and the page number.\nThis metadata is essential for structuring the context provided to GPT-4o.\nWe also format the compiled information as a JSON to make it easy for the LLM to interpret.\n\n4. Use the GPT-4o Model to Generate an Answer\n\nFinally, we pass the compiled context to the GPT-4o.\nThe model uses the context to generate an informative, coherent, and contextually relevant answer to the user's question.\nThe retrieved context helps the LLM answer questions with greater accuracy, as it has access to relevant information from the document.\nNow, let's pose a question that requires information from a diagram. In this case, the relevant details are found within a pie chart.\nLet's make it more challenging by asking a question that requires interpretation of information presented in a table. In our Step 2, we extracted this information using the GPT-4o vision modality.\nThis approach worked well. However, there may be cases where information is embedded within images or graphics that lose fidelity when translated to text, such as complex engineering drawings.\n\nBy using the GPT-4o Vision modality, we can pass the image of the page directly to the model as context. In the next section, we will explore how to improve the accuracy of model responses using image inputs.\nWhen metadata indicates the presence of an image, graphic or a table, we can pass the image as the context to GPT-4o instead of the extracted text. This approach can be useful in cases where text description of the visual information is not sufficient to convey the context. It can be the case for complex graphics such as engineering drawings or complex diagrams.\n\nStep Breakdown:\n\nThe difference between this Step and Step 5, is that we've added additional logic to identify when Visual_Input_Processed flag is set for an embedding. In that case, instead of passing the text as the context, we pass the image of the page using GPT-4o vision modality as the context.\n\nNote: This approach does increase both latency and cost, as processing image inputs is more resource intensive and expensive. Therefore, it should only be used if the desired results cannot be achieved with the text-only modality as outlined in Step 5 above.\nLet's examine the same questions we asked for the text only semantic search in Step 5. We notice that the GPT-4o model can identify the diagram that has relevant information to answer the question.\nNow let's ask a question that possibly cannot be answered by text-only modality, such as find a relevant image in the document and describe the image.\n\nIn this cookbook, we embarked on a journey to enhance Retrieval-Augmented Generation (RAG) systems for documents rich in images, graphics and tables. Traditional RAG models, while proficient with textual data, often overlook the wealth of information conveyed through visual elements. By integrating vision models and leveraging metadata tagging, we've bridged this gap, enabling AI to interpret and utilize visual content effectively.\n\nWe began by setting up a vector store using Pinecone, establishing a foundation for efficient storage and retrieval of vector embeddings. Parsing PDFs and extracting visual information using GPT-4o vision modality allowed us to convert document pages into relevant text. By generating embeddings and flagging pages with visual content, we created a robust metadata filtering system within our vector store.\n\nUploading these embeddings to Pinecone facilitated seamless integration with our RAG processing workflow. Through semantic search, we retrieved relevant pages that matched user queries, ensuring that both textual and visual information were considered. Handling pages with visual content by passing them to vision models enhanced the accuracy and depth of the responses, particularly for queries dependent on images or tables.\n\nUsing the World Bank's A Better Bank for a Better World: Annual Report 2024 as our guiding example, we demonstrated how these techniques come together to process and interpret complex documents. This approach not only enriches the information provided to users but also significantly enhances user satisfaction and engagement by delivering more comprehensive and accurate responses.\n\nBy following the concepts outlined in this cookbook, you are now equipped to build RAG systems capable of processing and interpreting documents with intricate visual elements. This advancement opens up new possibilities for AI applications across various domains where visual data plays a pivotal role."])</script><script>self.__next_f.push([1,"fc:T365f,"])</script><script>self.__next_f.push([1,"General App Information\nAuthentication from ChatGPT to Workday\nSample Use Case: PTO Submission and Benefit Plan Inquiry\nAdditional Resources\nConclusion\n\n\nWorkday is a cloud-based platform that offers solutions for human capital management, payroll, and financial management. Integrating ChatGPT with Workday through Custom Actions can enhance HR operations by providing automated responses to employee inquiries, guiding employees through HR processes, and retrieving key information from Workday.\n\nChatGPT’s Custom Actions with Workday allow organizations to use AI to improve HR processes, automate tasks, and offer personalized employee support. This includes virtual HR assistants for inquiries about benefits, time off, and payroll.\n\n\nTo connect ChatGPT with Workday, use OAuth:\n\nRequires Workday Admin access to obtain Client ID and Client Secret.\nImportant URLs:\n    Authorization URL: [Workday Tenant URL]/authorize, typically in this format: https://wd5-impl.workday.com//authorize\n    Token URL: [Workday Tenant URL]/token, typically in this format: https://wd5-impl-services1.workday.com/ccx/oauth2//token\n\nReference the URls Workday provides once you create the API Client in Workday. They will provide the specific URLs needed based on the tenant and data center.\n\nSteps to Set Up OAuth:\n\nUse the Register API client task in Workday.\nSet your API client settings in workday similar to the provided example below.\nScopes will vary depending on the actions being performed by GPT. For this use-case, you will need: Staffing, Tenant Non-Configurable, Time Off and Leave, Include Workday Owned Scope\nEnter the Redirection URI from the GPT into the API client settings.\nStore the Client ID and Client Secret for later use in GPT.\nAdd the OAuth details into the GPT Authentication section as shown below.\n\nThe redirection URI is retrieved from the GPT setup once OAuth has been selected as authentication, on the GPT set-up screen.\n\nworkday-cgpt-oauth.png\n\nworkday-api-client.png\n\nThe Workday Community page on API client) can be a good resource to go deeper (this requires a community account).\n\n\n\nThis use case demonstrates how to help employees submit PTO requests, retrieve worker details, and view benefit plans through a RAAS report.\n\n\nUse the following instructions to cover PTO Submission use-cases, Worker details retrieval and benefit plan inquiry:\n\nAsk the user for PTO details, including start date, end date, and type of leave.\nSubmit the request using the Request_Time_Off API call.\nProvide a summary of the submitted PTO request, including any information on approvals.\n\nRetrieve the worker’s details using Get_Workers.\nSummarize the employee’s job title, department, and contact details for easy reference.\n\nRetrieve benefit plan details using Get_Report_As_A_Service.\nPresent a summary of the benefits.\n\n\nAs employee ID is required to take actions on Workday onto the employee, this information will need to be retrieved before doing any queries. We have accomplished this by calling a RAAS report in workday after authentication that provides the user who is logging in. There may be another way to do this via just a REST API call itself. Once the ID has been returned it will be used in all other actions.\n\nSample RAAS Report: Using the field Current User will return the worker who has authenticated via OAuth.\ncustom-report-workday-01.png\n\ncustom-report-workday-02.png\n\n\nBelow is an example OpenAPI schema generated using the Workday REST API Reference and ActionsGPT.\n\nWe're using the following API calls:\n\\[POST\\] Request\\_Time\\_Off**: Creates a time off request for an employee.\n\\[GET\\] Get\\_Workers**: Retrieves information on worker details.\n\\[GET\\] Get\\_eligibleAbsenceTypes**: Retrieves eligible time off plans.\n\\[GET\\] Get\\_Report\\_As\\_A\\_Service (RAAS)**: Pulls reports, including custom RAAS reports, for benefit details.\n\n\nReplace the paths with the correct tenant ID and configure them to the appropriate servers. Ensure the required IDs are set correctly for different PTO types.\n\nopenapi: 3.1.0\ninfo:\n  title: Workday Employee API\n  description: API to manage worker details, absence types, and benefit plans in Workday.\n  version: 1.3.0\nservers:\n  url: https://wd5-impl-services1.workday.com/ccx\n    description: Workday Absence Management API Server\npaths:\n  /service/customreport2/tenant/GPT_RAAS:\n    get:\n      operationId: getAuthenticatedUserIdRaaS\n      summary: Retrieve the Employee ID for the authenticated user.\n      description: Fetches the Employee ID for the authenticated user from Workday.\n      responses:\n        '200':\n          description: A JSON object containing the authenticated user's Employee ID.\n          content:\n            application/json:\n              schema:\n                type: object\n                properties:\n                  employeeId:\n                    type: string\n                    description: The Employee ID of the authenticated user.\n                    example: \"5050\"\n        '401':\n          description: Unauthorized - Invalid or missing Bearer token.\n      security:\n        bearerAuth: []\n\n  /api/absenceManagement/v1/tenant/workers/Employee_ID={employeeId}/eligibleAbsenceTypes:\n    get:\n      operationId: getEligibleAbsenceTypes\n      summary: Retrieve eligible absence types by Employee ID.\n      description: Fetches a list of eligible absence types for a worker by their Employee ID, with a fixed category filter.\n      parameters:\n        name: employeeId\n          in: path\n          required: true\n          description: The Employee ID of the worker (passed as Employee_ID=3050 in the URL).\n          schema:\n            type: string\n            example: \"5050\"\n        name: category\n          in: query\n          required: true\n          description: Fixed category filter for the request. This cannot be changed.\n          schema:\n            type: string\n            example: \"17bd6531c90c100016d4b06f2b8a07ce\"\n      responses:\n        '200':\n          description: A JSON array of eligible absence types.\n          content:\n            application/json:\n              schema:\n                type: object\n                properties:\n                  absenceTypes:\n                    type: array\n                    items:\n                      type: object\n                      properties:\n                        id:\n                          type: string\n                        name:\n                          type: string\n        '401':\n          description: Unauthorized - Invalid or missing Bearer token.\n        '404':\n          description: Worker or absence types not found.\n      security:\n        bearerAuth: []\n\n  /api/absenceManagement/v1/tenant/workers/Employee_ID={employeeId}:\n    get:\n      operationId: getWorkerById\n      summary: Retrieve worker details by Employee ID.\n      description: Fetches detailed information of a worker using their Employee ID.\n      parameters:\n        name: employeeId\n          in: path\n          required: true\n          description: The Employee ID of the worker.\n          schema:\n            type: string\n            example: \"5050\"\n      responses:\n        '200':\n          description: A JSON object containing worker details.\n          content:\n            application/json:\n              schema:\n                type: object\n                properties:\n                  id:\n                    type: string\n                  name:\n                    type: object\n                    properties:\n                      firstName:\n                        type: string\n                      lastName:\n                        type: string\n                  position:\n                    type: string\n                  email:\n                    type: string\n        '401':\n          description: Unauthorized - Invalid or missing Bearer token.\n        '404':\n          description: Worker not found.\n      security:\n        bearerAuth: []\n\n  /api/absenceManagement/v1/tenant/workers/Employee_ID={employeeId}/requestTimeOff:\n    post:\n      operationId: requestTimeOff\n      summary: Request time off for a worker.\n      description: Allows a worker to request time off by providing the necessary details.\n      parameters:\n        name: employeeId\n          in: path\n          required: true\n          description: The Employee ID of the worker requesting time off.\n          schema:\n            type: string\n            example: \"5050\"\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              type: object\n              properties:\n                days:\n                  type: array\n                  description: Array of days for which the time off is being requested.\n                  items:\n                    type: object\n                    properties:\n                      start:\n                        type: string\n                        format: date\n                        description: The start date of the time off.\n                        example: \"2024-11-26\"\n                      date:\n                        type: string\n                        format: date\n                        description: The specific date for the time off.\n                        example: \"2024-11-26\"\n                      end:\n                        type: string\n                        format: date\n                        description: The end date of the time off.\n                        example: \"2024-11-26\"\n                      dailyQuantity:\n                        type: number\n                        description: The number of hours per day to take off.\n                        example: 8\n                      timeOffType:\n                        type: object\n                        description: Time off type with corresponding ID.\n                        properties:\n                          id:\n                            type: string\n                            description: The ID of the time off type.\n                            example: \"b35340ce4321102030f8b5a848bc0000\"\n                            enum:\nFlexible Time Off ID (hexa format)\nSick Leave ID (hexa format)\n      responses:\n        '200':\n          description: Time off request created successfully.\n        '400':\n          description: Invalid input or missing parameters.\n        '401':\n          description: Unauthorized - Invalid or missing Bearer token.\n        '404':\n          description: Worker not found.\n      security:\n        bearerAuth: []\n\n  /service/customreport2/tenant/GPT_Worker_Benefit_Data:\n    get:\n      operationId: getWorkerBenefitPlans\n      summary: Retrieve worker benefit plans enrolled by Employee ID.\n      description: Fetches the benefit plans in which the worker is enrolled using their Employee ID.\n      parameters:\n        name: Worker!Employee_ID\n          in: query\n          required: true\n          description: The Employee ID of the worker.\n          schema:\n            type: string\n            example: \"5020\"\n        name: format\n          in: query\n          required: true\n          description: The format of the response (e.g., json).\n          schema:\n            type: string\n            example: \"json\"\n      responses:\n        '200':\n          description: A JSON array of the worker's enrolled benefit plans.\n          content:\n            application/json:\n              schema:\n                type: object\n                properties:\n                  benefitPlans:\n                    type: array\n                    items:\n                      type: object\n                      properties:\n                        planName:\n                          type: string\n                        coverage:\n                          type: string\n                        startDate:\n                          type: string\n                          format: date\n                        endDate:\n                          type: string\n                          format: date\n        '401':\n          description: Unauthorized - Invalid or missing Bearer token.\n        '404':\n          description: Worker or benefit plans not found.\n      security:\n        bearerAuth: []\n\ncomponents:\n  securitySchemes:\n    bearerAuth:\n      type: http\n      scheme: bearer\n      bearerFormat: JWT\n  schemas:\n    worker:\n      type: object\n      properties:\n        id:\n          type: string\n        name:\n          type: object\n          properties:\n            firstName:\n              type: string\n            lastName:\n              type: string\n        position:\n          type: string\n        email:\n          type: string\n    absenceTypes:\n      type: array\n      items:\n        type: object\n        properties:\n          id:\n            type: string\n          name:\n            type: string\n    benefitPlans:\n      type: array\n      items:\n        type: object\n        properties:\n          planName:\n            type: string\n          coverage:\n            type: string\n          startDate:\n            type: string\n            format: date\n          endDate:\n            type: string\n            format: date\n    timeOffTypes:\n      type: object\n      description: Mapping of human-readable time off types to their corresponding IDs.\n      properties:\n        Flexible Time Off:\n          type: string\n          example: \"b35340ce4321102030f8b5a848bc0000\"\n        Sick Leave:\n          type: string\n          example: \"21bd0afbfbf21011e6ccc4dc170e0000\"\n\n\n\n\nCongratulations on setting up a GPT for Workday with capabilities such as PTO submission, employee details retrieval, and benefits plan inquiry!\n\nThis integration can streamline HR processes, provide quick access to personal details, and make it easy for employees to request PTO. This guide provides a customizable framework for implementing ChatGPT with Workday, allowing you to easily add more actions and enhance GPT capabilities further.\n\nworkday-gpt.png\n\npto-request.png"])</script><script>self.__next_f.push([1,"fd:T302f,"])</script><script>self.__next_f.push([1,"This page provides an instruction \u0026 guide for developers building a GPT Action for a specific application. Before you proceed, make sure to first familiarize yourself with the following information:\n\nIntroduction to GPT Actions\nIntroduction to GPT Actions Library\nExample of Building a GPT Action from Scratch\n\nThis GPT Action provides an overview of how to connect to your Google Calendar. It uses OAuth to link to your Google account, enabling you to create, read, update, and delete events within your calendar.\n\n\nValue: Users can now leverage ChatGPT's natural language capability to connect directly to their Google Calendar.\n\nExample Use Cases:\nYou want to create a new event in your calendar.\nYou want to search your calendar for events based on a specific criteria.\nYou want to delete an event from your calendar.\n\nNote:* This is a good example of an GPT that may be useful to call from other GPTs using the @ function. You can find more information on this feature on our help site.\n\nBefore you get started, ensure you can meet the following pre-requistes.\n\n A Google account with Google Calendar access.\n Permissions to access the Google Calendar API and use the Google Cloud Console to configure your OAuth credentials.\n\nVisit console.cloud.google.com.\nIn the project selector, choose the project you’d like to use for this GPT Action. If you don’t have a project yet, click the Create Project button.\nWhen creating a new project, enter a name for it and select the billing account you’d like to associate. In this example, ‘No Organization’ is selected.\n\n\n\nYou now have a Google Cloud Project and are ready to configure the API access to your Google Calendar.\n\nIn the Quck Access menu, select APIs \u0026 Services \u003e Library\nSearch for Google Calendar API (not DKIM) and click on it.\nClick on the Enable button.\n\n\n\n\nThe next step is to configure the OAuth credentials to allow your GPT Action to access your Google Calendar.\n\nDepending on your current configuration you may need to configure your OAuth consent screen. We'll start with that.\n\nIn the left menu click Credentials\nNow click Configure consent screen\nIf you get the option, choose Go To New Experience and click Get Started\nEnter your app name and choose your email in the User support email dropdown.\nChoose Internal audience and enter a contact email.\nAgree to the terms and click Create\n\nWe are now ready to create the OAuth credentials.\n\nClick Create OAuth Credentials\nChoose Web Application\nEnter your application name\nUnder Authorizes JavaScript Origins, enter https://chat.openai.com \u0026 https://chatgpt.com\nFor now we'll leave the Authorized redirect URIs blank. (we'll come back to this later)\nClick Create\nOpen the credentials page and you'll see your OAuth client ID and client secret on the right of the screen.\n\n\n\n\n\nNext, configure the scopes (or services) that the OAuth client ID will have access to. In this case, we’ll configure access to the Google Calendar API.\n\nIn the left menu click Data Access\nClick Add or Remove Scopes\nIn the right panel filter on https://www.googleapis.com/auth/calendar\nIn the filtered results, choose the first result, the scope should end with /auth/calendar\nClick Update and then Save\n\n\n\n\n\nWe are now ready to configure the GPT Action. First we'll configure the OAuth settings to allow the GPT to authenticate with Google Calendar.\n\nIn your GPT, create an action.\nClick on the settings gear icon and select OAuth\nEnter the Client ID and Client Secret from the Google Cloud Console.\nEnter the following details:\n  Authorization URL: https://accounts.google.com/o/oauth2/auth\n  Token URL: https://oauth2.googleapis.com/token\n  Scopes: https://www.googleapis.com/auth/calendar\nLeave the Token Exchange Method as default.\nClick Save\n\n\n\n\nWe can now enter the OpenAPI schema for the action. The config below allows reading and creating events. Enter this in the OpenAPI schema field.\n\nopenapi: 3.1.0\ninfo:\n  title: Google Calendar API\n  description: This API allows you to read and create events in a user's Google Calendar.\n  version: 1.0.0\nservers:\n  url: https://www.googleapis.com/calendar/v3\n    description: Google Calendar API server\n\npaths:\n  /calendars/primary/events:\n    get:\n      summary: List events from the primary calendar\n      description: Retrieve a list of events from the user's primary Google Calendar.\n      operationId: listEvents\n      tags:\n        Calendar\n      parameters:\n        name: timeMin\n          in: query\n          description: The lower bound (inclusive) of the events to retrieve, in RFC3339 format.\n          required: false\n          schema:\n            type: string\n            format: date-time\n            example: \"2024-11-01T00:00:00Z\"\n        name: timeMax\n          in: query\n          description: The upper bound (exclusive) of the events to retrieve, in RFC3339 format.\n          required: false\n          schema:\n            type: string\n            format: date-time\n            example: \"2024-12-01T00:00:00Z\"\n        name: maxResults\n          in: query\n          description: The maximum number of events to return.\n          required: false\n          schema:\n            type: integer\n            default: 10\n        name: singleEvents\n          in: query\n          description: Whether to expand recurring events into instances. Defaults to false.\n          required: false\n          schema:\n            type: boolean\n            default: true\n        name: orderBy\n          in: query\n          description: The order of events. Can be \"startTime\" or \"updated\".\n          required: false\n          schema:\n            type: string\n            enum:\n              startTime\n              updated\n            default: startTime\n      responses:\n        '200':\n          description: A list of events\n          content:\n            application/json:\n              schema:\n                type: object\n                properties:\n                  items:\n                    type: array\n                    items:\n                      type: object\n                      properties:\n                        id:\n                          type: string\n                          description: The event ID\n                        summary:\n                          type: string\n                          description: The event summary (title)\n                        start:\n                          type: object\n                          properties:\n                            dateTime:\n                              type: string\n                              format: date-time\n                              description: The start time of the event\n                            date:\n                              type: string\n                              format: date\n                              description: The start date of the all-day event\n                        end:\n                          type: object\n                          properties:\n                            dateTime:\n                              type: string\n                              format: date-time\n                              description: The end time of the event\n                            date:\n                              type: string\n                              format: date\n                              description: The end date of the all-day event\n                        location:\n                          type: string\n                          description: The location of the event\n                        description:\n                          type: string\n                          description: A description of the event\n        '401':\n          description: Unauthorized access due to missing or invalid OAuth token\n        '400':\n          description: Bad request, invalid parameters\n\n    post:\n      summary: Create a new event on the primary calendar\n      description: Creates a new event on the user's primary Google Calendar.\n      operationId: createEvent\n      tags:\n        Calendar\n      requestBody:\n        description: The event data to create.\n        required: true\n        content:\n          application/json:\n            schema:\n              type: object\n              properties:\n                summary:\n                  type: string\n                  description: The title of the event\n                  example: \"Team Meeting\"\n                location:\n                  type: string\n                  description: The location of the event\n                  example: \"Conference Room 1\"\n                description:\n                  type: string\n                  description: A detailed description of the event\n                  example: \"Discuss quarterly results\"\n                start:\n                  type: object\n                  properties:\n                    dateTime:\n                      type: string\n                      format: date-time\n                      description: Start time of the event\n                      example: \"2024-11-30T09:00:00Z\"\n                    timeZone:\n                      type: string\n                      description: Time zone of the event start\n                      example: \"UTC\"\n                end:\n                  type: object\n                  properties:\n                    dateTime:\n                      type: string\n                      format: date-time\n                      description: End time of the event\n                      example: \"2024-11-30T10:00:00Z\"\n                    timeZone:\n                      type: string\n                      description: Time zone of the event end\n                      example: \"UTC\"\n                attendees:\n                  type: array\n                  items:\n                    type: object\n                    properties:\n                      email:\n                        type: string\n                        description: The email address of an attendee\n                        example: \"attendee@example.com\"\n              required:\n                summary\n                start\n                end\n      responses:\n        '201':\n          description: Event created successfully\n          content:\n            application/json:\n              schema:\n                type: object\n                properties:\n                  id:\n                    type: string\n                    description: The ID of the created event\n                  summary:\n                    type: string\n                    description: The event summary (title)\n                  start:\n                    type: object\n                    properties:\n                      dateTime:\n                        type: string\n                        format: date-time\n                        description: The start time of the event\n                  end:\n                    type: object\n                    properties:\n                      dateTime:\n                        type: string\n                        format: date-time\n                        description: The end time of the event\n        '400':\n          description: Bad request, invalid event data\n        '401':\n          description: Unauthorized access due to missing or invalid OAuth token\n        '500':\n          description: Internal server error\n\nIf successful, you'll see the two endpoints appear at the bottom of the configuration screen.\n\n\n\n\nNow that we've configured the OAuth settings and set the OpenAPI schema, ChatGPT will generate a callback URL. You’ll need to add this URL to the Authorized redirect URIs in the Google Cloud Console.\n\nExit the action configuration screen in ChatGPT and scroll to the bottom. There, you'll find the generated callback URL.\n\nNote: If you modify the OAuth settings, a new callback URL will be generated, which will also need to be added to the Authorized redirect URIs in the Google Cloud Console.\"\n\n\n\nCopy this URL and add it to the Authorized redirect URIs in the Google Cloud Console, then click Save.\n\n\n\n\n\nWith your action configured, you can now test it in ChatGPT. Start by asking your GPT a test question, for example: What events do I have today? If this is the first time you've used the action, you'll be prompted to authorize the action. Click Sign in with googleapis.com and follow the prompts to authorize the action.\n\nOnce authorized, you should then see the results from your calendar."])</script><script>self.__next_f.push([1,"fe:Tb99,"])</script><script>self.__next_f.push([1,"This page provides an instruction \u0026 guide for developers building a set of GPT Actions across a set of applications. Before you proceed, make sure to first familiarize yourself with the following information:\nIntroduction to GPT Actions\nIntroduction to GPT Actions Library\nExample of Building a GPT Action from Scratch\n\nThis particular GPT Action(s) provides an overview of how to connect to a Tray.ai API Management Operations.\n\nValue: Users can now leverage ChatGPT's natural language capability to connect directly to APIs created through API Management in Tray.ai.\n\nExample Use Cases:\nTray.ai is a middleware that composes workflows, handles workflow action scaling, and interfaces with hundreds of 3rd party APIs\nYou have a custom operation running in Tray.ai workflow(s) that you'd like to incorporate into a GPT.\nYou would like to govern access to actions for your organization/team  under a single API interface\n\n\n\nCheck out these links from the application before you get started:\nApplication Website: https://tray.ai/universal-automation-cloud/api-management\nApplication API Documentation: https://tray.ai/documentation/tray-uac/api-management/api-management-overview/\n\n\nBefore you get started, make sure you go through the following steps in your Tray.ai environment:\nSet up a Tray.ai account\nCreate a project with a set of simple API Management Operations\n\n\nBelow is an example of a building and extending a basic set of API Management operations:\\\nTray.ai APIM Create Operation Gif\n\n\n\nOnce you've created a Custom GPT, you should add Instructions to the GPT providing context about the GPTs role, and the actions it is able to perform. Have questions? Check out Getting Started Example to see how this step works in more detail.\n\n\nOnce you've created a Custom GPT, download the API specification from your Tray.ai project, copy the contents, and paste it into your Custom GPT action\nschema. Once pasted, update your schema's openapi property to version 3.1.0.\n\nBelow are instructions on setting up authentication with this 3rd party application. Have questions? Check out Getting Started Example to see how this step works in more detail.\n\n\nBefore you set up authentication in ChatGPT, please take the following steps in the application:\nCreate a new role with the name full\nCreate a new policy specifying name, operations to allow, and policy rules with \"Authentication\" == True and role is full\nCreate a new client with roles set to full\nSave your API Token for future steps\n\nTray.ai APIM Create Operation Gif\n\n\n\nIn ChatGPT, click on \"Authentication\" and choose \"API Key\". Enter in the information below.\n\nAPI Key**: (Paste your API Key provided by the Tray.ai API Management Client)\nAuth Type**: Bearer\n\n\nAuth/Forbidden Error: Ensure you have properly entered your API key and have set the Auth Type as Bearer.\nTray.ai Internal Error: You can configure responses back to your CustomGPT configuring error handling and responding back with error messages."])</script><script>self.__next_f.push([1,"ff:T259a,"])</script><script>self.__next_f.push([1,"This guide explains how to integrate OpenAI reasoning models into your GitHub Pull Request (PR) workflow to automatically review code for quality, security, and enterprise standards compliance. By leveraging AI-driven insights early in the development process, you can catch issues sooner, reduce manual effort, and maintain consistent best practices across your codebase.\n\n• Save time during code reviews by automatically detecting code smells, security vulnerabilities, and style inconsistencies.\n• Enforce coding standards organization-wide for consistent, reliable code.\n• Provide developers with prompt, AI-guided feedback on potential improvements.\n\n• A reviewer wants feedback on the security of a new code change before merging.\n• A team seeks to enforce standard coding guidelines, ensuring consistent code quality across the organization.\n\n\nGo to platform.openai.com/api-keys and click to create a new secret key.\nSecurely store the token in your GitHub repository secrets as OPENAI_API_KEY.\n\nUse OpenAI Reasoning Models for in-depth analysis of code changes. Begin with the most advanced model and refine your prompt as needed.\n\nConfirm GitHub Actions is enabled for your repository.\nEnsure you have permissions to configure repository secrets or variables (e.g., for your PROMPT, MODELNAME, and BEST_PRACTICES variables).\n\nStore your standards as a repository variable (BEST_PRACTICES). These may include:\n• Code style \u0026 formatting\n• Readability \u0026 maintainability\n• Security \u0026 compliance\n• Error handling \u0026 logging\n• Performance \u0026 scalability\n• Testing \u0026 QA\n• Documentation \u0026 version control\n• Accessibility \u0026 internationalization\n\nConstruct a meta-prompt to guide OpenAI toward security, quality, and best-practice checks. Include:\nCode Quality \u0026 Standards\nSecurity \u0026 Vulnerability Analysis\nFault Tolerance \u0026 Error Handling\nPerformance \u0026 Resource Management\nStep-by-Step Validation\n\nEncourage OpenAI to provide a thorough, line-by-line review with explicit recommendations.\n\n\nThis GitHub Actions workflow is triggered on every pull request against the main branch and comprises two jobs. The first job gathers a diff of all changed files—excluding .json and .png files—and sends these changes to OpenAI for analysis. Any suggested fixes from OpenAI are included in a comment on the PR. The second job evaluates the PR against your defined enterprise standards and returns a markdown table that summarizes the code’s adherence to those standards. You can easily adjust or refine the workflow by updating variables such as the prompt, model name, and best practices.\n\nname: PR Quality and Security Check\n\non:\n  pull_request:\n    branches: [main]\n\npermissions:\n  contents: read\n  pull-requests: write\n\njobs:\n  quality-security-analysis:\n    runs-on: ubuntu-latest\n    steps:\n      name: Check out code\n        uses: actions/checkout@v3\n        with:\n          fetch-depth: 0  # Ensure full history for proper diff\n\n      name: Gather Full Code From Changed Files\n        run: |\n          CHANGED_FILES=$(git diff --name-only origin/main...HEAD)\n          echo '{\"original files\": [' \u003e original_files_temp.json\n          for file in $CHANGED_FILES; do\n            if [[ $file == *.json ]] || [[ $file == *.png ]]; then\n              continue\n            fi\n            if [ -f \"$file\" ]; then\n              CONTENT=$(jq -Rs . \u003e original_files_temp.json\n            fi\n          done\n          sed -i '$ s/,$//' original_files_temp.json\n          echo \"]}\" \u003e\u003e original_files_temp.json\n\n      name: Display Processed Diff (Debug)\n        run: cat original_files_temp.json\n\n      name: Get Diff\n        run: |\n          git diff origin/main...HEAD \\\n            | grep '^[+-]' \\\n            | grep -Ev '^(---|\\+\\+\\+)' \u003e code_changes_only.txt\n          jq -Rs '{diff: .}' code_changes_only.txt \u003e diff.json\n          if [ -f original_files_temp.json ]; then\n            jq -s '.[0] * .[1]' diff.json original_files_temp.json \u003e combined.json\n            mv combined.json diff.json\n\n      name: Display Processed Diff (Debug)\n        run: cat diff.json\n\n      name: Analyze with OpenAI\n        env:\n          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}\n        run: |\n          DIFF_CONTENT=$(jq -r '.diff' diff.json)\n          ORIGINAL_FILES=$(jq -r '.\"original files\"' diff.json)\n          PROMPT=\"Please review the following code changes for any obvious quality or security issues. Provide a brief report in markdown format:\\n\\nDIFF:\\n${DIFF_CONTENT}\\n\\nORIGINAL FILES:\\n${ORIGINAL_FILES}\"\n          jq -n --arg prompt \"$PROMPT\" '{\n            \"model\": \"gpt-4\",\n            \"messages\": [\n              { \"role\": \"system\", \"content\": \"You are a code reviewer.\" },\n              { \"role\": \"user\", \"content\": $prompt }\n            ]\n          }' \u003e request.json\n          curl -sS https://api.openai.com/v1/chat/completions \\\n            -H \"Content-Type: application/json\" \\\n            -H \"Authorization: Bearer ${OPENAI_API_KEY}\" \\\n            -d @request.json \u003e response.json\n\n      name: Extract Review Message\n        id: extract_message\n        run: |\n          ASSISTANT_MSG=$(jq -r '.choices[0].message.content' response.json)\n          {\n            echo \"message\u003e $GITHUB_OUTPUT\n\n      name: Post Comment to PR\n        env:\n          COMMENT: ${{ steps.extract_message.outputs.message }}\n          GH_TOKEN: ${{ github.token }}\n        run: |\n          gh api \\\n            repos/${{ github.repository }}/issues/${{ github.event.pull_request.number }}/comments \\\n            -f body=\"$COMMENT\"\n  enterprise-standard-check:\n    runs-on: ubuntu-latest\n    needs: [quality-security-analysis]\n\n    steps:\n      name: Checkout code\n        uses: actions/checkout@v3\n        with:\n          fetch-depth: 0  # ensures we get both PR base and head\n\n      name: Gather Full Code From Changed Files\n        run: |\nIdentify changed files from the base (origin/main) to the pull request HEAD\n          CHANGED_FILES=$(git diff --name-only origin/main...HEAD)\n\nBuild a JSON array containing filenames and their content\n          echo '{\"original files\": [' \u003e original_files_temp.json\n          for file in $CHANGED_FILES; do\nSkip .json and .txt files\n            if [[ $file == *.json ]] || [[ $file == *.txt ]]; then\n              continue\n            fi\n\nIf the file still exists (i.e., wasn't deleted)\n            if [ -f \"$file\" ]; then\n              CONTENT=$(jq -Rs . \u003e original_files_temp.json\n            fi\n          done\n\nRemove trailing comma on the last file entry and close JSON\n          sed -i '$ s/,$//' original_files_temp.json\n          echo \"]}\" \u003e\u003e original_files_temp.json\n\n      name: Analyze Code Against Best Practices\n        id: validate\n        env:\n          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}\n        run: |\n          set -e\nRead captured code\n          ORIGINAL_FILES=$(cat original_files_temp.json)\n\nConstruct the prompt:\n- Summarize each best-practice category\n- Provide a rating for each category: 'extraordinary', 'acceptable', or 'poor'\n- Return a Markdown table titled 'Enterprise Standards'\n          PROMPT=\"You are an Enterprise Code Assistant. Review each code snippet below for its adherence to the following categories:\n          1) Code Style \u0026 Formatting\n          2) Security \u0026 Compliance\n          3) Error Handling \u0026 Logging\n          4) Readability \u0026 Maintainability\n          5) Performance \u0026 Scalability\n          6) Testing \u0026 Quality Assurance\n          7) Documentation \u0026 Version Control\n          8) Accessibility \u0026 Internationalization\n\n          Using \\${{ vars.BEST_PRACTICES }} as a reference, assign a rating of 'extraordinary', 'acceptable', or 'poor' for each category. Return a markdown table titled 'Enterprise Standards' with rows for each category and columns for 'Category' and 'Rating'.\n\n          Here are the changed file contents to analyze:\n          $ORIGINAL_FILES\"\n\nCreate JSON request for OpenAI\n          jq -n --arg system_content \"You are an Enterprise Code Assistant ensuring the code follows best practices.\" \\\n                --arg user_content \"$PROMPT\" \\\n          '{\n            \"model\": \"${{ vars.MODELNAME }}\",\n            \"messages\": [\n              {\n                \"role\": \"system\",\n                \"content\": $system_content\n              },\n              {\n                \"role\": \"user\",\n                \"content\": $user_content\n              }\n            ]\n          }' \u003e request.json\n\nMake the API call\n          curl -sS https://api.openai.com/v1/chat/completions \\\n            -H \"Content-Type: application/json\" \\\n            -H \"Authorization: Bearer $OPENAI_API_KEY\" \\\n            -d @request.json \u003e response.json\n\nExtract the model's message\n          ASSISTANT_MSG=$(jq -r '.choices[0].message.content' response.json)\n\nStore for next step\n          {\n            echo \"review\u003e $GITHUB_OUTPUT\n\n      name: Post Table Comment\n        env:\n          COMMENT: ${{ steps.validate.outputs.review }}\n          GH_TOKEN: ${{ github.token }}\n        run: |\nIf COMMENT is empty or null, skip posting\n          if [ -z \"$COMMENT\" ] || [ \"$COMMENT\" = \"null\" ]; then\n            echo \"No comment to post.\"\n            exit 0\n          fi\n\n          gh api \\\n            repos/${{ github.repository }}/issues/${{ github.event.pull_request.number }}/comments \\\n            -f body=\"$COMMENT\"\n\nCommit this workflow to your repository, then open a new PR. The workflow will run automatically, posting AI-generated feedback as a PR comment.\n\nFor a public example, see the OpenAI-Forum repository’s workflow: pr_quality_and_security_check.yml.\n\npr_quality_and_security_check.png\n\nworkflow_check.png"])</script><script>self.__next_f.push([1,"100:T1e29,"])</script><script>self.__next_f.push([1,"LLMs are fundamentally non-deterministic in their responses, this attribute makes them wonderfully creative and dynamic in their responses. However, this trait poses significant challenges in achieving consistency, a crucial aspect for integrating LLMs into production environments.\n\nThe key to harnessing the potential of LLMs in practical applications lies in consistent and systematic evaluation. This enables the identification and rectification of inconsistencies and helps with monitoring progress over time as the application evolves.\n\n\nThis notebook aims to demonstrate a framework for evaluating LLMs, particularly focusing on:\n\nUnit Testing:** Essential for assessing individual components of the application.\nEvaluation Metrics:** Methods to quantitatively measure the model's effectiveness.\nRunbook Documentation:** A record of historical evaluations to track progress and regression.\n\nThis example focuses on a natural language to SQL use case - code generation use cases fit well with this approach when you combine code validation with code execution, so your application can test code for real as it is generated to ensure consistency.\n\nAlthough this notebook uses SQL generation usecase to demonstrate the concept, the approach is generic and can be applied to a wide variety of LLM driven applications.\n\nWe will use two versions of a prompt to perform SQL generation.  We will then use the unit tests and evaluation functions to test the perforamance of the prompts.  Specifically, in this demonstration, we will evaluate:\n\nThe consistency of JSON response.\nSyntactic correctness of SQL in response.\n\n\n\nSetup: Install required libraries, download data consisting of SQL queries and corresponding natural language translations.\nTest Development: Create unit tests and define evaluation metrics for the SQL generation process.\nEvaluation: Conduct tests using different prompts to assess the impact on performance.\nReporting: Compile a report that succinctly presents the performance differences observed across various tests.\n\nImport our libraries and the dataset we'll use, which is the natural language to SQL b-mc2/sql-create-context dataset from HuggingFace.\n\nWe use Huggingface datasets library to download SQL create context dataset.  This dataset consists of:\n\nQuestion, expressed in natural language\nAnswer, expressed in SQL designed to answer the question in natural language.\nContext, expressed as a CREATE SQL statement, that describes the table that may be used to answer the question.\n\nIn our demonstration today, we will use LLM to attempt to answer the question (in natural language).  The LLM will be expected to generate a CREATE SQL statement to create a context suitable to answer the user question and a coresponding SELECT SQL query designed to answer the user question completely.\n\nThe dataset looks like this:\n\nTo test the output of the LLM generations, we'll develop two unit tests and an evaluation, which will combine to give us a basic evaluation framework to grade the quality of our LLM iterations.\n\nTo re-iterate, our purpose is to measure the correctness and consistency of LLM output given our questions.\n\n\nUnit tests should test the most granular components of your LLM application.\n\nFor this section we'll develop unit tests to test the following:\ntest_valid_schema will check that a parseable create and select statement are returned by the LLM.\ntest_llm_sql will execute both the create and select statements on a sqlite database to ensure they are syntactically correct.\n\nFor this demonstration purposes, we use a fairly simple prompt requesting GPT to generate a (context, answer) pair. context is the CREATE SQL statement, and answer is the SELECT SQL statement. We supply the natural language question as part of the prompt.  We request the response to be in JSON format, so that it can be parsed easily.\n\nOur first simple unit test checks that the LLM response is parseable into the LLMResponse Pydantic class that we've defined.\n\nWe'll test that our first response passes, then create a failing example to check that the check fails. This logic will be wrapped in a simple function test_valid_schema.\n\nWe expect GPT to respond with a valid SQL, we can validate this using LLMResponse base model.  test_valid_schema is designed to help us validate this.\n\nTo simulate a scenario in which we get an invalid JSON response from GPT, we hardcode an invalid JSON as response.  We expect test_valid_schema function to throw an exception.\nAs expected, we get an exception thrown from the test_valid_schema fucntion.\n\nNext we'll validate the correctness of the SQL.  This test will be desined to validate:\n\nThe CREATE SQL returned in GPT response is syntactically correct.\nThe SELECT SQL returned in the GPT response is syntactically correct.\n\nTo achieve this, we will use a sqlite instance. We will direct the retured SQL functions to a sqlite instance.  If the SQL statements are valid, sqlite instance will accept and execute the statements; otherwise we will expect an exception to be thrown.\n\ncreate_connection function below will setup a sqlite instance (in-memory by default) and create a connection to be used later.\nNext, we will create the following functions to carry out the syntactical correctness checks.\n\n\ntest_create: Function testing if the CREATE SQL statement succeeds.\ntest_select: Function testing if the SELECT SQL statement succeeds.\ntest_llm_sql: Wrapper function executing the two tests above.\n\nNext, we evaluate whether the generated SQL actually answers the user's question. This test will be performed by gpt-4o-mini, and will assess how relevant the produced SQL query is when compared to the initial user request.\n\nThis is a simple example which adapts an approach outlined in the G-Eval paper, and tested in one of our other cookbooks.\n\nWe will test these functions in combination including our unit test and evaluations to test out two system prompts.\n\nEach iteration of input/output and scores should be stored as a run. Optionally you can add GPT-4 annotation within your evaluations or as a separate step to review an entire run and highlight the reasons for errors.\n\nFor this example, the second system prompt will include an extra line of clarification, so we can assess the impact of this for both SQL validity and quality of solution.\n\nWe want to build a function, test_system_prompt, which will run our unit tests and evaluation against a given system prompt.\n\nThe system under test is the first system prompt as shown below.  This run will generate responses for this system prompt and evaluate the responses using the functions we've created so far.\nWe can now group the outcomes of:\nthe unit tests, which test the structure of response; and\nthe evaluation, which checks if the SQL is syntatically correct.\n\nWe now use a new system prompt to run same unit test and evaluation.\nAs above, we can group the unit test and evaluation results.\n\nWe'll make a simple dataframe to store and display the run performance - this is where you can use tools like Weights \u0026 Biases Prompts or Gantry to store the results for analytics on your different iterations.\n\nWe can create a simple bar chart to visualise the results of unit tests for both runs.\n\nWe can similarly plot the results of the evaluation.\n\nNow you have a framework to test SQL generation using LLMs, and with some tweaks this approach can be extended to many other code generation use cases. With GPT-4 and engaged human labellers you can aim to automate the evaluation of these test cases, making an iterative loop where new examples are added to the test set and this structure detects any performance regressions.\n\nWe hope you find this useful, and please supply any feedback."])</script><script>self.__next_f.push([1,"101:T13a4,"])</script><script>self.__next_f.push([1,"For most of our users, the default usage and cost dashboards are sufficient. However, if you need more detailed data or a custom dashboard, you can use the Completions Usage API.\n\nThis notebook demonstrates how to retrieve and visualize usage data from the OpenAI Completions Usage API and Costs API. We'll:\nCall the API to get completions usage data.\nParse the JSON response into a pandas DataFrame.\nVisualize token usage over time using matplotlib.\nUse grouping by model to analyze token usage across different models.\nDisplay model distribution with a pie chart.\n\nWe also include placeholders for all possible API parameters for a comprehensive overview.\n\nSet up an Admin Key - https://platform.openai.com/settings/organization/admin-keys\n\nReplace 'PLACEHOLDER' with your actual ADMIN API key. It's best practice to load the key from an environment variable for security.\n\nLet's take a look at the raw JSON response from the API to understand its structure.\n\n\nNow we will parse the JSON data, extract relevant fields, and create a pandas DataFrame for easier manipulation and analysis.\n\nWe'll create a bar chart to visualize input and output token usage for each time bucket.\n\n\nIn this section, we retrieve and visualize usage data grouped by model and project_id. This can help you see the total tokens used by each model over the specified period.\n\n\nIf you do not specify a group_by parameter, fields such as project_id, model, and others will return as null.\n  Although the group_by parameter is optional, it is recommended to include it in most cases to retrieve meaningful data.\n\nYou can specify multiple group fields by separating them with commas. For example: group_by=[\"model\", \"project_id\"].\n\nNow we will parse the JSON data, extract relevant fields, and create a pandas DataFrame for easier manipulation and analysis.\n\nThis section visualizes the distribution of token usage across different models using a pie chart.\n\n\nIn this section, we'll work with the OpenAI Costs API to retrieve and visualize cost data. Similar to the completions data, we'll:\nCall the Costs API to get aggregated cost data.\nParse the JSON response into a pandas DataFrame.\nVisualize costs grouped by line item using a bar chart.\n\nWe will now parse the JSON data from the Costs API, extract relevant fields, and create a pandas DataFrame for further analysis.\n\n\nWe'll create a bar chart to visualize the total costs aggregated by day. This helps give a high level perspective on organizational spend.\n\nWe'll create a bar chart to visualize the total costs aggregated by line item. This helps identify which categories (e.g., models or other services) contribute most to the expenses.\n\nYou can extend this notebook with more visualizations for both the Completions and Costs APIs. For example:\n\nCompletions API:\nGroup by user, project, or model to see which ones consume the most tokens.\nCreate line plots for time series analysis of token usage over days or hours.\nUse pie charts to visualize distribution of tokens across models, users, or projects.\nExperiment with different group_by parameters (e.g., [\"model\", \"user_id\"]) to gain deeper insights.\n\nCosts API:\nGroup by project or line item to identify spending patterns.\nCreate line or bar charts to visualize daily cost trends.\nUse pie charts to show how costs are distributed across projects, services, or line items.\nTry various group_by options (e.g., [\"project_id\"], [\"line_item\"]) for granular analysis.\n\nExperiment with different parameters and visualization techniques using pandas and matplotlib (or libraries like Plotly/Bokeh) to gain deeper insights, and consider integrating these visualizations into interactive dashboards for real-time monitoring.\n\n\nTo bring OpenAI usage and cost data into external dashboarding tools like Tableau, Power BI, or custom platforms (e.g., Plotly Dash, Bokeh), follow these steps:\n\nData Collection \u0026 Preparation:\n   Use Python scripts to regularly fetch data from the Completions and Costs APIs.\n   Process and aggregate the data with pandas, then store it in a database, data warehouse, or export it as CSV/JSON files.\n\nConnecting to a Dashboard:\n   BI Tools (Tableau, Power BI):\n     Connect directly to the prepared data source (SQL database, CSV files, or web APIs).\n     Use built-in connectors to schedule data refreshes, ensuring dashboards always display current information.\n   Custom Dashboards (Plotly Dash, Bokeh):\n     Embed API calls and data processing into the dashboard code.\n     Build interactive visual components that automatically update as new data is fetched.\n\nReal-Time \u0026 Automated Updates:\n   Schedule scripts using cron jobs, task schedulers, or workflow tools (e.g., Apache Airflow) to refresh data periodically.\n   Implement webhooks or streaming APIs (if available) for near real-time data updates.\n\nBy integrating API data into third-party platforms, you can create interactive, real-time dashboards that combine OpenAI metrics with other business data, offering comprehensive insights and automated monitoring."])</script><script>self.__next_f.push([1,"102:T4334,"])</script><script>self.__next_f.push([1,"At the core of providing a LLM Agent capability to interact with the outside world or other Agents is “tool (or function) calling,” where a LLM can invoke a function (a block of code) with arguments. Typically, these functions are predefined by the developer, along with their expected inputs and outputs. However, in this Cookbook, we explore a more flexible paradigm - to dynamically generate tools using LLM models (in this case o3-mini), with ability to execute the tool using a code interpreter.\n\nA Dynamically Generated Tool is a function or code block created by the LLM itself at runtime based on the user’s prompt. This means you don’t have to predefine every possible scenario in your codebase—enabling far more open-ended, creative, and adaptive problem-solving.\n\nDynamically Generated Tool Calling goes a step further by granting the LLM the ability to generate tools and execute code blocks on the fly. This dynamic approach is particularly useful for tasks that involve:\n\nData analysis and visualization\nData manipulation and transformation\nMachine learning workflow generation and execution\nProcess automation and scripting\nAnd much more, as new possibilities emerge through experimentation\n\n\nReleased on 31-Jan-25, o3-mini model has exceptional STEM capabilities—with particular strength in science, math, and coding—all while maintaining the low cost and reduced latency of smaller models. In this Cookbook, we will demonstrate o3-mini's capabilities to generate python code to interpret data and draw insights.\n\nReasoning models are particularly good at generating dynamic tools to analyze data since they can reason on their own, without the need of an explicit chain-of-thought prompt. In fact, providing explicit chain of thought instructions may interfere with model's internal reasoning and lead to suboptimal outcomes. You can learn more about o3-mini here.\n\n\nMany API providers—such as OpenAI’s Assistants API—offer built-in code interpreter functionality. These built-in code interpreters can be immensely powerful, but there are situations where developers may need to create their own custom code interpreter. For example:\n\nLanguage or library support: The built-in interpreter may not support the specific programming language (e.g., C++, Java, etc.) or libraries required for your task.\nTask compatibility: Your use case may not be compatible with the provider’s built-in solution.\nModel constraints: You might require a language model that isn’t supported by the provider’s interpreter.\nCost considerations: The cost structure for code execution or model usage may not fit your budget or constraints.\nFile size: The file size of input data is too large or not supported by the provider's interpreter.\nIntegrating with internal systems: The provider's interpreter may not be able to integrate with your internal systems.\n\nBy following this Cookbook, you will learn how to:\n\nSet up an isolated Python code execution environment using Docker\nConfigure your own code interpreter tool for LLM agents\nEstablish a clear separation of “Agentic” concerns for security and safety\nUsing o3-mini model to dynamically generate code for data analysis\nOrchestrate agents to efficiently accomplish a given task\nDesign an agentic application that can dynamically generate and execute code\n\nYou’ll learn how to build a custom code interpreter tool from the ground up, leverage the power of LLMs to generate sophisticated code, and safely execute that code in an isolated environment—all in pursuit of making your AI-powered applications more flexible, powerful, and cost-effective.\n\nWe'll use the sample data provided at Key Factors Traffic Accidents to answer a set of questions. These questions do not require to be pre-defined, we will give LLM the ability to generate code to answer such question.\n\nSample questions could be:\nWhat factors contribute the most to accident frequency? (Feature importance analysis)\nWhich areas are at the highest risk of accidents? (Classification/Clustering)\nHow does traffic fine amount influence the number of accidents? (Regression/Causal inference)\nCan we determine the optimal fine amounts to reduce accident rates? (Optimization models)\nDo higher fines correlate with lower average speeds or reduced accidents? (Correlation/Regression)\nand so on ...\n\nUsing the traditional Predefined Tool Calling approach, developer would need to pre-define the function for each of these questions. This limits the LLM's ability to answer any other questions not defined in the pre-defined set of functions. We overcome this limitation by using the Dynamic Tool Calling approach where the LLM generates code and uses a Code Interpretter tool to execute the code.\nLet's dive into the steps to build this Agentic Applicaiton with Dynamically generated tool calling. There are three components to this application:\n\nWe need a secure environment where our LLM generated function calls can be executed. We want to avoid directly running the LLM generated code on the host machine so will create a Docker container environment with restricted resource access (e.g., no network access). By default, Docker containers cannot access the host machine’s file system, which helps ensure that any code generated by the LLM remains contained.\n\nLLMs could generate harmful code with unintended consequences. As a best practice, isolate the code execution environment with only required access to resources as needed by the task. Avoid running the LLM generated code on your host machine or laptop.\n\n\"What is an Agent?\" In the context of this Cookbook, an Agent is:\nSet of instructions for the LLM to follow, i.e. the developer prompt\nA LLM model, and ability to call the model via the API\nTool call access to a function, and ability to execute the function\n\nWe will define two agents:\nFileAccessAgent: This agent will read the file and provide the context to the PythonCodeExecAgent.\nPythonCodeExecAgent: This agent will generate the Python code to answer the user's question and execute the code in the Docker container.\n\nThere are various ways to orchestrate the Agents based on the application requirements. In this example, we will use a simple orchestration where the user provides a task and the agents are called in sequence to accomplish the task.\n\nThe overall orchestration is shown below:\n\n\n\n\nBefore you begin, ensure you have the following installed and configured on your host machine:\n\nDocker: installed and running on your local machine. You can learn more about Docker and install it from here.\nPython: installed on your local machine. You can learn more about Python and install it from here.\nOpenAI API key: set up on your local machine as an environment variable or in the .env file in the root directory. You can learn more about OpenAI API key and set it up from here.\n\nLets define a Dockerized container environment that will be used to execute our code. I have defined the dockerfile under resources/docker directory that will be used to create the container environment with the following specifications:\nPython 3.10 as the base\nA non-root user\nPreinstall the packages in requirements.txt\n\nThe requirements.txt included in the docker image creation process contains all the potential packages our LLM generated code may need to accomplish its tasks. Given we will restrict the container from network access, so we need to pre-install the packages that are required for the task. Our LLM will not be allowed to install any additional packages for security purposes.\n\nYou could create your own docker image with the language requirements (such as Python 3.10) and pre-install the packages that are required for the task, or create a custom docker image with the specific language (such as Java, C++, etc.) and packages that are required for the task.\nLet's build the docker image with the following command. For the sake of brevity, I have redirected the output to grep the success message and print a message if the build fails.\nLet's run the container in restricted mode. The container will run in the background. This is our opportunity to define the security policies for the container. It is good practice to only allow the bare minimum features to the container that are required for the task. By default, the container cannot access the host file system from within the container. Let's also restrict its access to network so it cannot access the Internet or any other network resources.\nLet's make sure container is running using the docker ps that should list our container.\n\nFor our purposes, we will define two agents.\nAgent 1: File Access Agent (with Pre-defined Tool Calling)\nInstructions to understand the contents of the file to provide as context to Agent 2.\nHas access to the host machine’s file system.\nCan read a file from the host and copy it into the Docker container.\nCannot access the code interpreter tool.\nUses gpt-4o model.\n\nAgent 2: Python Code Generator and Executor (with Dynamically Generated Tool Calling and Code Execution)\nRecieve the file content's context from Agent 1.\nInstructions to generate a Python script to answer the user's question.\nHas access to the code interpreter within the Docker container, which is used to execute Python code.\nHas access only to the file system inside the Docker container (not the host).\nCannot access the host machine’s file system or the network.\nUses our newest o3-mini model that excels at code generation.\n\nThis separation concerns of the File Access (Agent 1) and the Code Generator and Executor (Agent 2) is crucial to prevent the LLM from directly accessing or modifying the host machine.\n\nLimit the Agent 1 to Static Tool Calling as it has access to the host file system.\n\n| Agent | Type of Tool Call | Access to Host File System | Access to Docker Container File System | Access to Code Interpreter |\n|-------|-------------------|----------------------------|----------------------------------------|----------------------------|\n| Agent 1: File Access | Pre-defined Tools | Yes | Yes | No |\n| Agent 2: Python Code Generator and Executor | Dynamically Generated Tools | No | Yes | Yes |\n\nTo keep the Agents and Tools organized, we've defined a set of core classes that will be used to create the two agents for consistency using Object Oriented Programming principles.\n\nBaseAgent**: We start with an abstract base class that enforces common method signatures such as task(). Base class also provides a logger for debugging, a language model interface and other common functions such as add_context() to add context to the agent.\nChatMessages**: A class to store the conversation history given ChatCompletions API is stateless.\nToolManager**: A class to manage the tools that an agent can call.\nToolInterface**: An abstract class for any 'tool' that an agent can call so that the tools will have a consistent interface.\n\nThese classes are defined in the object_oriented_agents/core_classes directory.\nThe following class diagram shows the relationship between the core classes. This UML (Unified Modeling Language) has been generated using Mermaid\n\n\nDefine Agent 1: FileAccessAgent with FileAccessTool\n\nLet's start with definin the FileAccessTool that inherits from the ToolInterface class. The FileAccessTool tool is defined in the file_access_tool.py file in the resources/registry/tools directory.\n\nFileAccessTool implements the ToolInterface class, which ensures that the tools will have a consistent interface.\nBinding the tool definition for the OpenAI Function Calling API in the get_definition method and the tool's run method ensures maintainability, scalability, and reusability.\nNow, let's define the FileAccessAgent that extends the BaseAgent class and bind the FileAccessTool to the agent. The FileAccessAgent is defined in the file_acess_agent.py file in resources/registry/agents directory. The FileAccessAgent is:\n\nA concrete implementation of the BaseAgent class.\nInitialized with the developer prompt, model name, logger, and language model interface. These values can be overridden by the developer if needed.\nHas a setup_tools method that registers the FileAccessTool to the tool manager.\nHas a task method that calls the FileAccessTool to read the file and provide the context to the PythonCodeExecAgent.\nmodel_name='gpt-4o' that provides sufficient reasoning and tool calling ability for the task.\n\nDefine Agent 2: PythonExecAgent with PythonExecTool\n\nSimilarly, PythonExecTool inherits from the ToolInterface class and implements the get_definition and run methods. The get_definition method returns the tool definition in the format expected by the OpenAI Function Calling API. The run method executes the Python code in a Docker container and returns the output. This tool is defined in the python_code_interpreter_tool.py file in the resources/registry/tools directory.\n\nLikewise, PythonExecAgent is a concrete implementation of the BaseAgent class. It is defined in the python_code_exec_agent.py file in the resources/registry/agents directory. The PythonExecAgent is:\n\nA concrete implementation of the BaseAgent class.\nInitialized with the developer prompt, model name, logger, and language model interface. These values can be overridden by the developer if needed.\nHas a setup_tools method that registers the PythonExecTool to the tool manager.\nHas a task method that calls the OpenAI API to perform the user's task, which in this case involves generating a Python script to answer the user's question and run it with Code Interpreter tool.\nmodel_name='o3-mini' that excels at STEM tasks such as code generation.\nreasoning_effort='high' that allows for more complete reasoning given the complexity of the task at the cost of more tokens generated and slower responses. The default value is medium, which is a balance between speed and reasoning accuracy.\n\nYou can learn more about the reasoning_effort parameter here.\n\nWith the Agents defined, now we can define the orchestration loop that will run the application. This loop will prompt the user for a question or task, and then call the FileAccessAgent to read the file and provide the context to the PythonExecAgent. The PythonExecAgent will generate the Python code to answer the user's question and execute the code in the Docker container. The output from the code execution will be displayed to the user.\n\nUser can type 'exit' to stop the application. Our question: What factors contribute the most to accident frequency? Note that we did not pre-define the function to answer this question.\n\n\nIn this example, the o3-mini dynamically generated a tool (Python script) based on user's question to analyze the data. Note that o3-mini examined the problem using multiple approaches such as correlation analysis, linear regression and random forest models. This approach highlights the following:\n\nreasoning_effort: The depth of reasoning the model performs e.g., in this case number of approaches, generally increases when the parameter is increased from low, medium to high. You can try with different levels of reasoning effort to see the difference.\n\nDynamically Generated Tool Calling: The tool (Python script) to analyze the data was not manually written or predetermined by the developer. Instead, the o3-mini model created the relevant data exploration and correlation analysis code at runtime.\n\nIsolated Code Execution: To ensure security and avoid running untrusted code on the host machine, the Python script was executed inside a Docker container using the execute_python_code tool. This container had restricted resource access (e.g., no network and limited filesystem access), minimizing potential risks posed by arbitrary code execution.\n\n\nThe Cookbook provides a guide for developing a custom code interpreter tailored to specific application needs, addressing limitations found in vendor-provided solutions such as language constraints, cost considerations, and the need for flexibility with different LLMs or models.\n\nApproach for Managing Agents and Tools: We also defined a set of core classes to manage the agents and tools. This approach ensures that the agents and tools will have a consistent interface and can be reused across different applications. A repository of agents and tools such as the registry folder can be created to manage the agents and tools.\n\no3-mini model: We demonstrated o3-mini model's ability to generate sophisticated code at run time to analyze data based on user's minimal prompt. o3-mini model then reasoned over the outcome of the analysis to explain the results to the user.\n\nFinally, to recap, the three steps to build an Agentic Application with Dynamic Tool Calling are:\nSet up an isolated code execution container environment\nDefine and Test the Agents\nSet up Agentic Orchestration to run the application\n\nWe discussed the importance of isolating the code execution environment to ensure security and avoid running untrusted code on the host machine. With the use case of a CSV file, we demonstrated how to dynamically generate a tool (a Python script) to analyze the data and answer the user's question. We also showed how to execute the code in a Docker container and return the output to the user."])</script><script>self.__next_f.push([1,"103:T153a,"])</script><script>self.__next_f.push([1,"Although RAG can be overwhelming, searching amongst PDF file shouldn't be complicated. One of the most adopted options as of now is parsing your PDF, defining your chunking strategies, uploading those chunks to a storage provider, running embeddings on those chunks of texts and storing those embeddings in a vector database. And that's only the setup — retrieving content in our LLM workflow also requires multiple steps.\n\nThis is where file search — a hosted tool you can use in the Responses API — comes in. It allows you to search your knowledge base and generate an answer based on the retrieved content. In this cookbook, we'll upload those PDFs to a vector store on OpenAI and use file search to fetch additional context from this vector store to answer the questions we generated in the first step. Then, we'll initially create a small set of questions based on PDFs extracted from OpenAI's blog (openai.com/news).\n\nFile search was previously available on the Assistants API. It's now available on the new Responses API, an API that can be stateful or stateless, and with from new features like metadata filtering\n\nWe will create a Vector Store on OpenAI API and upload our PDFs to the Vector Store. OpenAI will read those PDFs, separate the content into multiple chunks of text, run embeddings on those and store those embeddings and the text in the Vector Store. It will enable us to query this Vector Store to return relevant content based on a query.\n\nNow that our vector store is ready, we are able to query the Vector Store directly and retrieve relevant content for a specific query. Using the new vector search API, we're able to find relevant items from our knowledge base without necessarily integrating it in an LLM query.\nWe can see that different size (and under-the-hood different texts) have been returned from the search query. They all have different relevancy score that are calculated by our ranker which uses hybrid search.\n\n\nHowever instead of querying the vector store and then passing the data into the Responses or Chat Completion API call, an even more convenient way to use this search results in an LLM query would be to plug use file_search tool as part of OpenAI Responses API.\nWe can see that gpt-4o-mini was able to answer a query that required more recent, specialised knowledge about OpenAI's Deep Research. It used content from the file Introducing deep research _ OpenAI.pdf that had chunks of texts that were the most relevant. If we want to go even deeper in the analysis of chunk of text retrieved, we can also analyse the different texts that were returned by the search engine by adding include=[\"output[*].file_search_call.search_results\"] to our query.\n\n\nWhat is key for those information retrieval system is to also measure the relevance \u0026 quality of files retrieved for those answers. The following steps of this cookbook will consist in generating an evaluation dataset and calculating different metrics over this generated dataset. This is an imperfect approach and we'll always recommend to have a human-verified evaluation dataset for your own use-cases, but it will show you the methodology to evaluate those.  It will be imperfect because some of the questions generated might be generic (e.g: What's said by the main stakeholder in this document) and our retrieval test will have a hard time to figure out which document that question was generated for.\n\nWe will create functions that will read through the PDFs we have locally and generate a question that can only be answered by this document. Therefore it'll create our evaluation dataset that we can use after.\nIf we run the function generate_question for the first PDF file we will be able to see the kind of question it generates.\nWe can now generate all the questions for all the PDFs we've got stored locally.\nWe now have a dictionary of filename:question that we can loop through and ask gpt-4o(-mini) about without providing the document, and gpt-4o should be able to find the relevant document in the Vector Store.\n\nWe'll convert our dictionary into a dataframe and process it using gpt-4o-mini. We will look out for the expected file\nRecall \u0026 Precision are at 1 for this example, and our file ranked first so we're having a MRR and MAP = 1 on this example.\n\nWe can now execute this processing on our set of questions.\nThe outputs logged above would either show that a file wasn't ranked first when our evaluation dataset expected it to rank first or that it wasn't found at all. As we can see from our imperfect evaluation dataset, some questions were generic and expected another doc, which our retrieval system didn't specifically retrieved for this question.\nWith this cookbook we were able to see how to:\nGenerate a dataset of evaluations using PDF context-stuffing (leveraging vision modality of 4o) and traditional PDF readers\nCreate a vector store and populate it with PDF\nGet an LLM answer to a query, leveraging a RAG system available out-of-the-box with file_search tool call in OpenAI's Response API\nUnderstand how chunks of texts are retrieved, ranked and used as part of the Response API\nMeasure accuracy, precision, retrieval, MRR and MAP on the dataset of evaluations previously generated\n\nBy using file search with Responses, you can simplify RAG architecture and leverage this in a single API call using the new Responses API. File storage, embeddings, retrieval all integrated in one tool!"])</script><script>self.__next_f.push([1,"104:T27f4,"])</script><script>self.__next_f.push([1,"Let's say you're an AI lead at a consumer tech company. You have the vision of deploying a single entry point digital voice assistant with the ability to help users with any query, regardless of whether they want to take action on their account, find product information, or receive real-time guidance.\n\nHowever, turning this vision into reality can be extremely difficult - it requires building and testing the capability to handle each individual use case through text first, integrating access to the wide range of tools and systems they require, and somehow orchestrating them into a coherent experience. Then, once you’ve achieved a satisfactory level of quality (and even evaluating this can be a struggle), you face the daunting task of refactoring the entire workflow for voice interaction.\n\nFortunately for you, three recent releases from OpenAI have made implementing this vision simpler than ever by providing the tools to build and orchestrate modular agentic workflows through voice with minimal configuration:\n\nResponses API - an agentic API for easy engagement with our frontier models through managed stateful conversations, tracing of responses to enable evaluation, and built-in tools for file search, web search, computer use, and more\nAgents SDK - a lightweight, customizable open source framework for building and orchestrating workflows across many different agents, enabling your assistant to route inputs to the appropriate agent and to scale to support many use cases\nVoice agents - an extension of the Agents SDK to support the use of voice pipelines, enabling your agents to go from being text-base to being able to interpret and produce audio in just a few lines of code\n\nThis cookbook demonstrates how to build a simple in-app voice assistant for a fictitious consumer application using the tools above. We'll create a Triage Agent that greets the user, determines their intent, and routes requests to one of three specialised agents:\n\nSearch Agent** - performs a web search via the built-in tooling of the Responses API to provide real-time information on the user's query\nKnowledge Agent** - utilises the file search tooling of the Responses API to retrieve information from an OpenAI managed vector database\nAccount Agent** - uses function calling to provide the ability to trigger custom actions via API\n\nFinally, we'll convert this workflow into a live voice assistant using the AgentsSDK's Voice funtionality, capturing microphone input, performing speech‑to‑text, routing through our agents, and responding with text‑to‑speech.\n\nTo execute this cookbook, you'll need to install the following packages providing access to OpenAI's API, the Agents SDK, and libraries for audio processing. Additionally, you can set your OpenAI API key for use by the agents via the set_default_openai_key function.\n\nToday we're going to be building an assitant for our fictitious consumer application, ACME shop, focussed on initially supporting use cases across three key use cases:\n\nAnswering real-time questions to inform purchasing decisions using web search\nProviding information on the available options in our product portfolio\nProviding account information to enable the user to understand their budget and spending\n\nTo achieve this we'll be using an agentic architecture. This allows us to split the functionality for each use case into a separate agent, in turn reducing the complexity/range of tasks that a single agent could be asked to complete and increasing accuracy. Our agent architecture is relatively simple focussing on the three use cases above, but the beauty of the Agents SDK is that it is incredibly easy to extend and add aditional agents to the workflow when you want to add new functionality:\n\nAgent Architecture\n\n\n\nOur first agent is a simple web search agent that uses the WebSearchTool provided by the Responses API to find real-time information on the user's query. We'll be keeping the instruction prompts simple for each of these examples, but we'll iterate later to show how to optimise the response format for your use case.\nFor more information on web search and the Responses API, be sure to check out the Web Search and States with Responses API cookbook\n\nOur second agent needs to be able to answer questions on our product portfolio. To do this, we'll use the FileSearchTool to retrieve information from a vector store managed by OpenAI containing our company specific product information. For this, we have two options:\n\nUse the OpenAI Platform Website - go to platform.openai.com/storage and create a vector store, uploading your documents of choice. Then, take the vector store ID and substitute it into the FileSearchTool initialisation below.\n\nUse the OpenAI API - use the vector_stores.create function from the OpenAI Python client to create a vector store and then the vector_stores.files.create function to add files to it. Once this is complete you can again use the FileSearchTool to search the vector store. Please see the code below for an example of how to do this, either using the example file provided or altering to your own local file path:\nHaving implemented your vector store, we can now enable the knowledge agent to use the FileSearchTool to search the given store ID.\nFor more information on the power of file search and the Responses API, be sure to check out the excellent cookbook on the subject where the example code above was taken from: Doing RAG on PDFs using File Search in the Responses API\n\nWhilst so far we've been using the built-in tools provided by the Agents SDK, you can define your own tools to be used by the agents to integrate with your systems with the function_tool decorator. Here, we'll define a simple dummy function to return account information for a given user ID for our account agent.\nFor more information on function calling with the Agents SDK, see the Agents SDK Documentation\nFinally, we'll define the triage agent that will route the user's query to the appropriate agent based on their intent. Here we're using the prompt_with_handoff_instructions function, which provides additional guidance on how to treat handoffs and is recommended to provide to any agent with a defined set of handoffs with a defined set of instructions.\n\nNow that we've defined our agents, we can run the workflow on a few example queries to see how it performs.\n\nAbove we can see the outputs appear to be in line with our expectations, but one key benefit of the Agents SDK is that it includes built-in tracing which enables tracking of the flow of events during an agent run across the LLM calls, handoffs, and tools.\n\nUsing the Traces dashboard, we can debug, visualize, and monitor our workflows during development and in production. As we can see below, each test query was correctly routed to the appropriate agent.\nTraces Dashboard\n\nHaving designed our workflow, here in reality we would spend time evaluating the traces and iterating on the workflow to ensure it is as effective as possible. But let's assume we're happy with the workflow, so we can now start thinking about how to convert our in-app assistant from text-based to voice-based interactions.\n\nTo do this, we can simply leverage the classes provided by the Agents SDK to convert our text-based workflow into a a voice-based one. The VoicePipeline class provides an interface for transcribing audio input, executing a given agent workflow and generating a text to speech response for playback to the user, whilst the SingleAgentVoiceWorkflow class enables us to leverage the same agent workflow we used earlier for our text-based workflow. To provide and receive audio, we'll use the sounddevice library.\n\nEnd to end, the new workflow looks like this:\n\nAgent Architecture 2\n\nAnd the code to enable this is as follows:\nExecuting the above code, gives us the following responses which correctly provide the same functionality as the text-based workflow.\nTip: when using tracing with voice agents, you can playback audio in the traces dashboard\n\nAudio trace\n\n\nThis is a great start, but we can do better. As we've simply converted our text-based agents into voice-based ones, the responses are not optimised in their output for either tone or format, meaning they feel robotic and unnatural.\n\nTo address this, we'll need to make a few changes to our prompts.\n\nFirstly, we can adapt our existing agents to include a common system prompt, providing instructions on how to optimise their text response for later conversion to the voice format\n\n\n\nNext, we can instruct the default OpenAI TTS model used by the Agents SDK, gpt-4o-mini-tts, on how to communicate the audio output of the agent generated text with the instructions field.\n\nHere we have a huge amount of control over the output, including the ability to specify the personality, pronunciation, speed and emotion of the output.\n\nBelow i've included a few examples on how to prompt the model for different applications.\nOur configuration is going to focus on creating a friendly, warm, and supportive tone that sounds natural when spoken aloud and guides the user through the conversation.\nRunning the above code gives us the following responses which are much more naturally worded and engaging in the delivery.\n...And for something less subtle, we can switch to the themed_character_assistant instructions and receive the following responses:\n\nVoila!\n\nIn this cookbook, we've demonstrated how to:\n\nDefine agents to provide specific use case functionality for our in-app voice assistant\nLeverage in-built and custom tools with the Responses API to provide agents with a range of functionality and evaluate their performance with tracing\nOrchestrate these agents using the Agents SDK\nConvert agents from text-based to voice-based interactions using the Agents SDK's Voice functionality\n\nThe Agents SDK enables a modular approach to building your voice assistant, allowing you to work on a use case by use case basis, evaluating and iterating on each use case individually, before implementing the next and then converting the workflow from text to voice when you're ready.\n\nWe hope this cookbook has provided you with a useful guide to help you get started with building your own in-app voice assistant!"])</script><script>self.__next_f.push([1,"105:T25e5,"])</script><script>self.__next_f.push([1,"One of the most exciting things about the Realtime API is that the emotion, tone and pace of speech are all passed to the model for inference. Traditional cascaded voice systems (involving STT and TTS) introduce an intermediate transcription step, relying on SSML or prompting to approximate prosody, which inherently loses fidelity. The speaker's expressiveness is literally lost in translation. Because it can process raw audio, the Realtime API preserves those audio attributes through inference, minimizing latency and enriching responses with tonal and inflectional cues. Because of this, the Realtime API makes LLM-powered speech translation closer to a live interpreter than ever before.\n\nThis cookbook demonstrates how to use OpenAI's  Realtime API to build a multi-lingual, one-way translation workflow with WebSockets. It is implemented using the Realtime + WebSockets integration in a speaker application and a WebSocket server to mirror the translated audio to a listener application.\n\nA real-world use case for this demo is a multilingual, conversational translation where a speaker talks into the speaker app and listeners hear translations in their selected native language via the listener app. Imagine a conference room with a speaker talking in English and a participant with headphones in choosing to listen to a Tagalog translation. Due to the current turn-based nature of audio models, the speaker must pause briefly to allow the model to process and translate speech. However, as models become faster and more efficient, this latency will decrease significantly and the translation will become more seamless.\n\n\nLet's explore the main functionalities and code snippets that illustrate how the app works. You can find the code in the accompanying repo if you want to run the app locally.\n\n\nThis project has two applications - a speaker and listener app. The speaker app takes in audio from the browser, forks the audio and creates a unique Realtime session for each language and sends it to the OpenAI Realtime API via WebSocket. Translated audio streams back and is mirrored via a separate WebSocket server to the listener app. The listener app receives all translated audio streams simultaneously, but only the selected language is played. This architecture is designed for a POC and is not intended for a production use case. Let's dive into the workflow!\n\nArchitecture\n\n\n\nWe need a unique stream for each language - each language requires a unique prompt and session with the Realtime API. We define these prompts in  translation_prompts.js.\n\nThe Realtime API is powered by GPT-4o Realtime or GPT-4o mini Realtime which are turn-based and trained for conversational speech use cases. In order to ensure the model returns translated audio (i.e. instead of answering a question, we want a direct translation of that question), we want to steer the model with few-shot examples of questions in the prompts. If you're translating for a specific reason or context, or have specialized vocabulary that will help the model understand context of the translation, include that in the prompt as well. If you want the model to speak with a specific accent or otherwise steer the voice, you can follpow tips from our cookbook on Steering Text-to-Speech for more dynamic audio generation.\n\nWe can dynamically input speech in any language.\n\n// Define language codes and import their corresponding instructions from our prompt config file\nconst languageConfigs = [\n  { code: 'fr', instructions: french_instructions },\n  { code: 'es', instructions: spanish_instructions },\n  { code: 'tl', instructions: tagalog_instructions },\n  { code: 'en', instructions: english_instructions },\n  { code: 'zh', instructions: mandarin_instructions },\n];\n\n\nSpeakerApp\n\nWe need to handle the setup and management of client instances that connect to the Realtime API, allowing the application to process and stream audio in different languages. clientRefs holds a map of RealtimeClient instances, each associated with a language code (e.g., 'fr' for French, 'es' for Spanish) representing each unique client connection to the Realtime API.\n\nconst clientRefs = useRef(\n    languageConfigs.reduce((acc, { code }) =\u003e {\n      acc[code] = new RealtimeClient({\n        apiKey: OPENAI_API_KEY,\n        dangerouslyAllowAPIKeyInBrowser: true,\n      });\n      return acc;\n    }, {} as Record)\n  ).current;\n\n  // Update languageConfigs to include client references\n  const updatedLanguageConfigs = languageConfigs.map(config =\u003e ({\n    ...config,\n    clientRef: { current: clientRefs[config.code] }\n  }));\n\nNote: The dangerouslyAllowAPIKeyInBrowser option is set to true because we are using our OpenAI API key in the browser for demo purposes but in production you should use an ephemeral API key generated via the OpenAI REST API.\n\nWe need to actually initiate the connection to the Realtime API and send audio data to the server. When a user clicks 'Connect' on the speaker page, we start that process.\n\nThe connectConversation function orchestrates the connection, ensuring that all necessary components are initialized and ready for use.\n\nconst connectConversation = useCallback(async () =\u003e {\n    try {\n        setIsLoading(true);\n        const wavRecorder = wavRecorderRef.current;\n        await wavRecorder.begin();\n        await connectAndSetupClients();\n        setIsConnected(true);\n    } catch (error) {\n        console.error('Error connecting to conversation:', error);\n    } finally {\n        setIsLoading(false);\n    }\n}, []);\n\n connectAndSetupClients ensures we are using the right model and voice. For this demo, we are using gpt-4o-realtime-preview-2024-12-17 and coral.\n\n   // Function to connect and set up all clients\n  const connectAndSetupClients = async () =\u003e {\n    for (const { clientRef } of updatedLanguageConfigs) {\n      const client = clientRef.current;\n      await client.realtime.connect({ model: DEFAULT_REALTIME_MODEL });\n      await client.updateSession({ voice: DEFAULT_REALTIME_VOICE });\n    }\n  };\n\n\n\nSending audio with WebSockets requires work to manage the inbound and outbound PCM16 audio streams (more details on that). We abstract that using wavtools, a library for both recording and streaming audio data in the browser. Here we use WavRecorder for capturing audio in the browser.\n\nThis demo supports both manual and voice activity detection (VAD) modes for recording that can be toggled by the speaker. For cleaner audio capture we recommend using manual mode here.\n\nconst startRecording = async () =\u003e {\n    setIsRecording(true);\n    const wavRecorder = wavRecorderRef.current;\n\n    await wavRecorder.record((data) =\u003e {\n      // Send mic PCM to all clients\n      updatedLanguageConfigs.forEach(({ clientRef }) =\u003e {\n        clientRef.current.appendInputAudio(data.mono);\n      });\n    });\n  };\n\n\nWe listen for response.audio_transcript.done events to update the transcripts of the audio. These input transcripts are generated by the Whisper model in parallel to the GPT-4o Realtime inference that is doing the translations on raw audio.\n\nWe have a Realtime session running simultaneously for every selectable language and so we get transcriptions for every language (regardless of what language is selected in the listener application). Those can be shown by toggling the 'Show Transcripts' button.\n\nListeners can choose from a dropdown menu of translation streams and after connecting, dynamically change languages. The demo application uses French, Spanish, Tagalog, English, and Mandarin but OpenAI supports 57+ languages.\n\nThe app connects to a simple Socket.IO server that acts as a relay for audio data. When translated audio is streamed back to from the Realtime API, we mirror those audio streams to the listener page and allow users to select a language and listen to translated streams.\n\nThe key function here is connectServer that connects to the server and sets up audio streaming.\n\n  // Function to connect to the server and set up audio streaming\n  const connectServer = useCallback(async () =\u003e {\n    if (socketRef.current) return;\n    try {\n      const socket = io('http://localhost:3001');\n      socketRef.current = socket;\n      await wavStreamPlayerRef.current.connect();\n      socket.on('connect', () =\u003e {\n        console.log('Listener connected:', socket.id);\n        setIsConnected(true);\n      });\n      socket.on('disconnect', () =\u003e {\n        console.log('Listener disconnected');\n        setIsConnected(false);\n      });\n    } catch (error) {\n      console.error('Error connecting to server:', error);\n    }\n  }, []);\n\n\nThis is a demo and meant for inspiration. We are using WebSockets here for easy local development. However, in a production environment we’d suggest using WebRTC (which is much better for streaming audio quality and lower latency) and connecting to the Realtime API with an ephemeral API key generated via the OpenAI REST API.\n\nCurrent Realtime models are turn based - this is best for conversational use cases as opposed to the uninterrupted, UN-style live translation that we really want for a one-directional streaming use case. For this demo, we can capture additional audio from the speaker app as soon as the model returns translated audio (i.e. capturing more input audio while the translated audio played from the listener app), but there is a limit to the length of audio we can capture at a time. The speaker needs to pause to let the translation catch up.\n\nIn summary, this POC is a demonstration of a one-way translation use of the Realtime API but the idea of forking audio for multiple uses can expand beyond translation. Other workflows might be simultaneous sentiment analysis, live guardrails or generating subtitles."])</script><script>self.__next_f.push([1,"106:T1ac6,"])</script><script>self.__next_f.push([1,"In this cookbook, we will learn how to monitor the internal steps (traces) of the OpenAI agent SDK and evaluate its performance using Langfuse.\n\nThis guide covers online and offline evaluation metrics used by teams to bring agents to production fast and reliably. To learn more about evaluation strategies, check out this blog post.\n\nWhy AI agent Evaluation is important:\nDebugging issues when tasks fail or produce suboptimal results\nMonitoring costs and performance in real-time\nImproving reliability and safety through continuous feedback\n\n\nBelow we install the openai-agents library (the OpenAI Agents SDK), the pydantic-ai[logfire] OpenTelemetry instrumentation, langfuse and the Hugging Face datasets library\n\nIn this notebook, we will use Langfuse to trace, debug and evaluate our agent.\n\nNote: If you are using LlamaIndex or LangGraph, you can find documentation on instrumenting them here and here.\nWith the environment variables set, we can now initialize the Langfuse client. get_client() initializes the Langfuse client using the credentials provided in the environment variables.\nPydantic Logfire offers an instrumentation for the OpenAi Agent SDK. We use this to send traces to the Langfuse OpenTelemetry Backend.\n\nHere is a simple Q\u0026A agent. We run it to confirm that the instrumentation is working correctly. If everything is set up correctly, you will see logs/spans in your observability dashboard.\nCheck your Langfuse Traces Dashboard to confirm that the spans and logs have been recorded.\n\nExample trace in Langfuse:\n\nExample trace in Langfuse\n\nLink to the trace\n\nNow that you have confirmed your instrumentation works, let's try a more complex query so we can see how advanced metrics (token usage, latency, costs, etc.) are tracked.\n\nLangfuse records a trace that contains spans, which represent each step of your agent’s logic. Here, the trace contains the overall agent run and sub-spans for:\nThe tool call (get_weather)\nThe LLM calls (Responses API with 'gpt-4o')\n\nYou can inspect these to see precisely where time is spent, how many tokens are used, and so on:\n\nTrace tree in Langfuse\n\nLink to the trace\n\nOnline Evaluation refers to evaluating the agent in a live, real-world environment, i.e. during actual usage in production. This involves monitoring the agent’s performance on real user interactions and analyzing outcomes continuously.\n\nWe have written down a guide on different evaluation techniques here.\n\n\nCosts — The instrumentation captures token usage, which you can transform into approximate costs by assigning a price per token.\nLatency — Observe the time it takes to complete each step, or the entire run.\nUser Feedback — Users can provide direct feedback (thumbs up/down) to help refine or correct the agent.\nLLM-as-a-Judge — Use a separate LLM to evaluate your agent’s output in near real-time (e.g., checking for toxicity or correctness).\n\nBelow, we show examples of these metrics.\n\nBelow is a screenshot showing usage for gpt-4o calls. This is useful to see costly steps and optimize your agent.\n\nCosts\n\nLink to the trace\n\nWe can also see how long it took to complete each step. In the example below, the entire run took 7 seconds, which you can break down by step. This helps you identify bottlenecks and optimize your agent.\n\nLatency\n\nLink to the trace\n\nLangfuse allows you to pass additional attributes to your spans. These can include user_id, tags, session_id, and custom metadata. Enriching traces with these details is important for analysis, debugging, and monitoring of your application's behavior across different users or sessions.\n\nIn this example, we pass a user_id, session_id and trace_tags to Langfuse.\nExample trace in Langfuse\n\nIf your agent is embedded into a user interface, you can record direct user feedback (like a thumbs-up/down in a chat UI). Below is an example using IPython.display for simple feedback mechanism.\n\nIn the code snippet below, when a user sends a chat message, we capture the OpenTelemetry trace ID. If the user likes/dislikes the last answer, we attach a score to the trace.\nUser feedback is then captured in Langfuse:\n\nUser feedback is being captured in Langfuse\n\nLLM-as-a-Judge is another way to automatically evaluate your agent's output. You can set up a separate LLM call to gauge the output’s correctness, toxicity, style, or any other criteria you care about.\n\nWorkflow:\nYou define an Evaluation Template, e.g., \"Check if the text is toxic.\"\nYou set a model that is used as judge-model; in this case gpt-4o-mini.\nEach time your agent generates output, you pass that output to your \"judge\" LLM with the template.\nThe judge LLM responds with a rating or label that you log to your observability tool.\n\nExample from Langfuse:\n\nLLM-as-a-Judge Evaluation Template\nLLM-as-a-Judge Evaluator\nYou can see that the answer of this example is judged as \"not toxic\".\n\nLLM-as-a-Judge Evaluation Score\n\nAll of these metrics can be visualized together in dashboards. This enables you to quickly see how your agent performs across many sessions and helps you to track quality metrics over time.\n\nObservability metrics overview\n\nOnline evaluation is essential for live feedback, but you also need offline evaluation—systematic checks before or during development. This helps maintain quality and reliability before rolling changes into production.\n\nIn offline evaluation, you typically:\nHave a benchmark dataset (with prompt and expected output pairs)\nRun your agent on that dataset\nCompare outputs to the expected results or use an additional scoring mechanism\n\nBelow, we demonstrate this approach with the search-dataset, which contains questions that can be answered via the web search tool and expected answers.\nNext, we create a dataset entity in Langfuse to track the runs. Then, we add each item from the dataset to the system.\nDataset items in Langfuse\n\nWe define a helper function run_openai_agent() that:\nStarts a Langfuse span\nRuns our agent on the prompt\nRecords the trace ID in Langfuse\n\nThen, we loop over each dataset item, run the agent, and link the trace to the dataset item. We can also attach a quick evaluation score if desired.\nYou can repeat this process with different:\nSearch tools (e.g. different context sized for OpenAI's WebSearchTool)\nModels (gpt-4o-mini, o1, etc.)\nTools (search vs. no search)\n\nThen compare them side-by-side in Langfuse. In this example, I did run the agent 3 times on the 50 dataset questions. For each run, I used a different setting for the context size of OpenAI's WebSearchTool. You can see that an increased context size also slightly increased the answer correctness from 0.89 to 0.92. The correct_answer score is created by an LLM-as-a-Judge Evaluator that is set up to judge the correctness of the question based on the sample answer given in the dataset.\n\nDataset run overview\nDataset run comparison"])</script><script>self.__next_f.push([1,"107:T3fcf,"])</script><script>self.__next_f.push([1,"This page provides an instruction \u0026 guide for developers building middleware to connect a GPT Action to a specific application. Before you proceed, make sure to first familiarize yourself with the following information:\n\nIntroduction to GPT Actions\nIntroduction to GPT Actions Library\nExample of Building a GPT Action from Scratch\n\nThis particular GPT Action provides an overview of how to build a GPT that retrieves information from Salesforce and Gong. This will include creating multiple custom actions which are documented in existing cookbooks. We will highlight these cookbooks in the next section.\n\n\nValue: Users can now leverage ChatGPT's capabilities to:\n\nConnect to Salesforce\nSearch for customer accounts\nRetrieve Gong transcripts from previous calls\n\nExample Use Cases:\n\nA sales rep is preparing for an upcoming customer meeting. Using this integration, they can quickly retrieve relevant account details from Salesforce, access recent Gong call transcripts, and receive AI-generated summaries and insights structured around proven sales methodologies like MEDPICC or SPICED. This empowers the rep with a clear, actionable understanding of the customer's current state and next steps — all in minutes\n\nIn this example, we are connecting to Salesforce and Gong (via a middleware). We are going to refer to existing cookbooks for basic setup and authentication instructions for Salesforce and creating a middleware.\n\nRefer to our cookbook on setting up a GPT Action for Salesforce. The two settings to pay attention to in that cookbook are:\n\nApplication Information - this covers the necessary concepts to be familiar with in Salesforce\nAuthentication Instructions - this covers creating a Connected App in Salesforce and configuring OAuth (on both Salesforce and ChatGPT)\n\nRefer to any one of our cookbooks on creating a middleware:\n\nGPT Actions library (Middleware) - AWS\nGPT Actions library (Middleware) - Azure Functions\nGPT Actions library (Middleware) - Google Cloud Function\n\n\nIn addition to the prerequisites in the cookbooks above, please ensure that you have access to a Gong API key\n\nThis serverless function will accept an array of callIds, fetch the transcripts from Gong and clean up the response that it sends to ChatGPT. Here is an example of what it looks like on Azure Functions (Javascript)\n\nconst { app } = require('@azure/functions');\nconst axios = require('axios');\n\n// Replace with your Gong API token\nconst GONG_API_BASE_URL = \"https://api.gong.io/v2\";\nconst GONG_API_KEY = process.env.GONG_API_KEY;\n\napp.http('callTranscripts', {\n    methods: ['POST'],\n    authLevel: 'function',\n    handler: async (request, context) =\u003e {\n        try {\n            const body = await request.json();\n            const callIds = body.callIds;\n\n            if (!Array.isArray(callIds) || callIds.length === 0) {\n                return {\n                    status: 400,\n                    body: \"Please provide call IDs in the 'callIds' array.\"\n                };\n            }\n\n            // Fetch call transcripts\n            const transcriptPayload = { filter: { callIds } };\n            const transcriptResponse = await axios.post(${GONG_API_BASE_URL}/calls/transcript, transcriptPayload, {\n                headers: {\n                    'Authorization': Basic ${GONG_API_KEY},\n                    'Content-Type': 'application/json'\n                }\n            });\n\n            const transcriptData = transcriptResponse.data;\n\n            // Fetch extensive call details\n            const extensivePayload = {\n                filter: { callIds },\n                contentSelector: {\n                    exposedFields: { parties: true }\n                }\n            };\n\n            const extensiveResponse = await axios.post(${GONG_API_BASE_URL}/calls/extensive, extensivePayload, {\n                headers: {\n                    'Authorization': Basic ${GONG_API_KEY},\n                    'Content-Type': 'application/json'\n                }\n            });\n\n            const extensiveData = extensiveResponse.data;\n\n            // Create a map of call IDs to metadata and speaker details\n            const callMetaMap = {};\n            extensiveData.calls.forEach(call =\u003e {\n                callMetaMap[call.metaData.id] = {\n                    title: call.metaData.title,\n                    started: call.metaData.started,\n                    duration: call.metaData.duration,\n                    url: call.metaData.url,\n                    speakers: {}\n                };\n\n                call.parties.forEach(party =\u003e {\n                    callMetaMap[call.metaData.id].speakers[party.speakerId] = party.name;\n                });\n            });\n\n            // Transform transcript data into content and include metadata\n            transcriptData.callTranscripts.forEach(call =\u003e {\n                const meta = callMetaMap[call.callId];\n                if (!meta) {\n                    throw new Error(Metadata for callId ${call.callId} not found.);\n                }\n\n                let content = '';\n                call.transcript.forEach(segment =\u003e {\n                    const speakerName = meta.speakers[segment.speakerId] || \"Unknown Speaker\";\n\n                    // Combine all sentences for the speaker into a paragraph\n                    const sentences = segment.sentences.map(sentence =\u003e sentence.text).join(' ');\n                    content += ${speakerName}: ${sentences}\\n\\n; // Add a newline between speaker turns\n                });\n\n                // Add metadata and content to the call object\n                call.title = meta.title;\n                call.started = meta.started;\n                call.duration = meta.duration;\n                call.url = meta.url;\n                call.content = content;\n\n                delete call.transcript;\n            });\n\n            // Return the modified transcript data\n            return {\n                status: 200,\n                headers: { 'Content-Type': 'application/json' },\n                body: JSON.stringify(transcriptData)\n            };\n        } catch (error) {\n            context.log('[ERROR]', \"Error processing request:\", error);\n\n            return {\n                status: error.response?.status || 500,\n                body: {\n                    message: \"An error occurred while fetching or processing call data.\",\n                    details: error.response?.data || error.message\n                }\n            };\n        }\n    }\n});\n\n\nHere are the dependencies that you would include in your package.json file\n\n\"dependencies\": {\n    \"@azure/functions\": \"^4.0.0\",\n    \"axios\": \"^1.7.7\"\n  }\n\n\n\nOnce you've created a Custom GPT, copy the text below in the Instructions panel. Have questions? Check out Getting Started Example to see how this step works in more detail.\n\nUser enters the name of an account that they want to prepare for\n\nRetrieve Account Names - Make a call to the executeSOSLSearch custom action searching for a Salesforce Account with that name (SOSL). Retrieve up to 5 accounts. This is what the query should look like - FIND {Acme} IN ALL FIELDS RETURNING Account(Id, Name) LIMIT 5\n\nShow the accounts in this format - Account Name - salesforceID. Ask the user to confirm which account they are interested in.\n\nGet Gong Call IDs for the account - For the confirmed account, make a call to executeSOQLQuery to get all the Gong Call IDs. It should look like this - `SELECT XXX, YYY, ZZZ\nFROM Gong__Gong_Call__c\nWHERE Gong__Primary_Account__c = ''\nORDER BY Gong__Call_Start__c DESC\nLIMIT 2\n`\n\nPass in the callIds to getTranscriptsByCallIds \n\nUser says \"Summarize call\"\n\n\nUse both the transcripts and provide the following output\n\nPrint out the account name\nPlease list the calls for which you retrieved the transcripts along with their dates and attendees in this table format:\n\u003eHeaders: , , ,\nAnalyze the transcripts to identify themes, challenges, and opportunities. Based on this, generate a list of recommended focus areas for the next meeting. These should be actionable and specific to the client’s needs. Explain why each item should be a meeting focus.\n\nFor each of the following insights, specify which call and date you sourced the insight from:\n\nQuantifiable outcomes the customer is trying to achieve. These could be cost reduction, increased revenue, user growth, efficiency gains, etc. Look for KPIs or success measures mentioned.\n\nIdentify if the true economic decision-maker was mentioned or involved. This includes titles, names, or hints at budget ownership or final authority.\n\nWhat are the key factors the customer will use to evaluate solutions? These could include price, performance, support, integrations, ease of use, etc.\n\nDescribe how the customer plans to make the buying decision: stages, stakeholders involved, approval processes, timelines.\n\nAny mention of legal, procurement, compliance, or contract-related steps and timelines should be captured here.\n\nHighlight the core business challenges the customer is facing, ideally in their own words. Understand what’s driving urgency.\n\nIs there someone internally who is championing our solution? Mention names, roles, or behaviors that indicate advocacy (e.g., “I’m pushing this internally”).\n\nMention any competing vendors, internal builds, or alternative solutions discussed.\nIn the above example, replace the query in (3) to retrieves the Gong Call IDs from your custom Salesforce object.\n\nYou will now create 2 separate actions - one to connect to Salesforce and the other to connect to the middleware that calls the Gong APIs\n\n\nOnce you've created a Custom GPT, copy the text below in the Actions panel. Have questions? Check out Getting Started Example to see how this step works in more detail.\n\nBelow is an example of what connecting to Salesforce might look like. You'll need to insert your URL in this section.\n\nopenapi: 3.1.0\ninfo:\n  title: Salesforce API\n  version: 1.0.0\n  description: API for accessing Salesforce sObjects and executing queries.\nservers:\n  url: https://.my.salesforce.com/services/data/v59.0\n    description: Salesforce API server\npaths:\n  /query:\n    get:\n      summary: Execute a SOQL Query\n      description: Executes a given SOQL query and returns the results.\n      operationId: executeSOQLQuery\n      parameters:\n        name: q\n          in: query\n          description: The SOQL query string to be executed.\n          required: true\n          schema:\n            type: string\n      responses:\n        '200':\n          description: Query executed successfully.\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/QueryResult'\n\n  /search:\n    get:\n      summary: Execute a SOSL Search\n      description: Executes a SOSL search based on the given query and returns matching records.\n      operationId: executeSOSLSearch\n      parameters:\n        name: q\n          in: query\n          description: The SOSL search string (e.g., 'FIND {Acme}').\n          required: true\n          schema:\n            type: string\n      responses:\n        '200':\n          description: Search executed successfully.\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/SearchResult'\n\ncomponents:\n  schemas:\n    QueryResult:\n      type: object\n      description: Result of a SOQL query.\n      properties:\n        totalSize:\n          type: integer\n          description: The total number of records matching the query.\n        done:\n          type: boolean\n          description: Indicates if the query result includes all records.\n        records:\n          type: array\n          description: The list of records returned by the query.\n          items:\n            $ref: '#/components/schemas/SObject'\n\n    SearchResult:\n      type: object\n      description: Result of a SOSL search.\n      properties:\n        searchRecords:\n          type: array\n          description: The list of records matching the search query.\n          items:\n            $ref: '#/components/schemas/SObject'\n\n    SObject:\n      type: object\n      description: A Salesforce sObject, which represents a database table record.\n      properties:\n        attributes:\n          type: object\n          description: Metadata about the sObject, such as type and URL.\n          properties:\n            type:\n              type: string\n              description: The sObject type.\n            url:\n              type: string\n              description: The URL of the record.\n        Id:\n          type: string\n          description: The unique identifier for the sObject.\n      additionalProperties: true\n\nPlease follow the steps shown in GPT Actions library - Salesforce\n\nIn this example, we are setting this up for an Azure Function that calls the Gong APIs. Replace url with your own Middleware URL\n\nopenapi: 3.1.0\ninfo:\n  title: Call Transcripts API\n  description: API to retrieve call transcripts and associated metadata by specific call IDs.\n  version: 1.0.1\nservers:\n  url: https://.azurewebsites.net/api\n    description: Production server\npaths:\n  /callTranscripts:\n    post:\n      operationId: getTranscriptsByCallIds\n      x-openai-isConsequential: false\n      summary: Retrieve call transcripts by call IDs\n      description: Fetches specific call transcripts based on the provided call IDs in the request body.\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              type: object\n              properties:\n                callIds:\n                  type: array\n                  description: List of call IDs for which transcripts need to be fetched.\n                  items:\n                    type: string\n              required:\n                callIds\n      responses:\n        '200':\n          description: A successful response containing the requested call transcripts and metadata.\n          content:\n            application/json:\n              schema:\n                type: object\n                properties:\n                  requestId:\n                    type: string\n                    description: Unique request identifier.\n                  records:\n                    type: object\n                    description: Metadata about the pagination.\n                    properties:\n                      totalRecords:\n                        type: integer\n                        description: Total number of records available.\n                      currentPageSize:\n                        type: integer\n                        description: Number of records in the current page.\n                      currentPageNumber:\n                        type: integer\n                        description: The current page number.\n                  callTranscripts:\n                    type: array\n                    description: List of call transcripts.\n                    items:\n                      type: object\n                      properties:\n                        callId:\n                          type: string\n                          description: Unique identifier for the call.\n                        title:\n                          type: string\n                          description: Title of the call or meeting.\n                        started:\n                          type: string\n                          format: date-time\n                          description: Timestamp when the call started.\n                        duration:\n                          type: integer\n                          description: Duration of the call in seconds.\n                        url:\n                          type: string\n                          format: uri\n                          description: URL to access the call recording or details.\n                        content:\n                          type: string\n                          description: Transcript content of the call.\n        '400':\n          description: Invalid request. Possibly due to missing or invalid callIds parameter.\n        '401':\n          description: Unauthorized access due to invalid or missing API key.\n        '500':\n          description: Internal server error.\n\n\nAre there integrations that you’d like us to prioritize? Are there errors in our integrations? File a PR or issue in our github, and we’ll take a look."])</script><script>self.__next_f.push([1,"108:T4856,"])</script><script>self.__next_f.push([1,"The GPT-4.1 family of models represents a significant step forward from GPT-4o in capabilities across coding, instruction following, and long context. In this prompting guide, we collate a series of important prompting tips derived from extensive internal testing to help developers fully leverage the improved abilities of this new model family.\n\nMany typical best practices still apply to GPT-4.1, such as providing context examples, making instructions as specific and clear as possible, and inducing planning via prompting to maximize model intelligence. However, we expect that getting the most out of this model will require some prompt migration. GPT-4.1 is trained to follow instructions more closely and more literally than its predecessors, which tended to more liberally infer intent from user and system prompts. This also means, however, that GPT-4.1 is highly steerable and responsive to well-specified prompts - if model behavior is different from what you expect, a single sentence firmly and unequivocally clarifying your desired behavior is almost always sufficient to steer the model on course.\n\nPlease read on for prompt examples you can use as a reference, and remember that while this guidance is widely applicable, no advice is one-size-fits-all. AI engineering is inherently an empirical discipline, and large language models are inherently nondeterministic; in addition to following this guide, we advise building informative evals and iterating often to ensure your prompt engineering changes are yielding benefits for your use case.\n\nGPT-4.1 is a great place to build agentic workflows. In model training we emphasized providing a diverse range of agentic problem-solving trajectories, and our agentic harness for the model achieves state-of-the-art performance for non-reasoning models on SWE-bench Verified, solving 55% of problems.\n\nIn order to fully utilize the agentic capabilities of GPT-4.1, we recommend including three key types of reminders in all agent prompts. The following prompts are optimized specifically for the agentic coding workflow, but can be easily modified for general agentic use cases.\n\nPersistence: this ensures the model understands it is entering a multi-message turn, and prevents it from prematurely yielding control back to the user. Our example is the following:\n\nYou are an agent - please keep going until the user’s query is completely resolved, before ending your turn and yielding back to the user. Only terminate your turn when you are sure that the problem is solved.\n\nTool-calling: this encourages the model to make full use of its tools, and reduces its likelihood of hallucinating or guessing an answer. Our example is the following:\n\nIf you are not sure about file content or codebase structure pertaining to the user’s request, use your tools to read files and gather the relevant information: do NOT guess or make up an answer.\n\nPlanning \\[optional\\]: if desired, this ensures the model explicitly plans and reflects upon each tool call in text, instead of completing the task by chaining together a series of only tool calls. Our example is the following:\n\nYou MUST plan extensively before each function call, and reflect extensively on the outcomes of the previous function calls. DO NOT do this entire process by making function calls only, as this can impair your ability to solve the problem and think insightfully.\n\nGPT-4.1 is trained to respond very closely to both user instructions and system prompts in the agentic setting. The model adhered closely to these three simple instructions and increased our internal SWE-bench Verified score by close to 20% \\- so we highly encourage starting any agent prompt with clear reminders covering the three categories listed above. As a whole, we find that these three instructions transform the model from a chatbot-like state into a much more “eager” agent, driving the interaction forward autonomously and independently.\n\nCompared to previous models, GPT-4.1 has undergone more training on effectively utilizing tools passed as arguments in an OpenAI API request. We encourage developers to exclusively use the tools field to pass tools, rather than manually injecting tool descriptions into your prompt and writing a separate parser for tool calls, as some have reported doing in the past. This is the best way to minimize errors and ensure the model remains in distribution during tool-calling trajectories \\- in our own experiments, we observed a 2% increase in SWE-bench Verified pass rate when using API-parsed tool descriptions versus manually injecting the schemas into the system prompt.\n\nDevelopers should name tools clearly to indicate their purpose and add a clear, detailed description in the \"description\" field of the tool. Similarly, for each tool param, lean on good naming and descriptions to ensure appropriate usage. If your tool is particularly complicated and you'd like to provide examples of tool usage, we recommend that you create an # Examples section in your system prompt and place the examples there, rather than adding them into the \"description' field, which should remain thorough but relatively concise. Providing examples can be helpful to indicate when to use tools, whether to include user text alongside tool calls, and what parameters are appropriate for different inputs. Remember that you can use “Generate Anything” in the Prompt Playground to get a good starting point for your new tool definitions.\n\n\nAs mentioned already, developers can optionally prompt agents built with GPT-4.1 to plan and reflect between tool calls, instead of silently calling tools in an unbroken sequence. GPT-4.1 is not a reasoning model \\- meaning that it does not produce an internal chain of thought before answering \\- but in the prompt, a developer can induce the model to produce an explicit, step-by-step plan by using any variant of the Planning prompt component shown above. This can be thought of as the model “thinking out loud.” In our experimentation with the SWE-bench Verified agentic task, inducing explicit planning increased the pass rate by 4%.\n\nBelow, we share the agentic prompt that we used to achieve our highest score on SWE-bench Verified, which features detailed instructions about workflow and problem-solving strategy. This general pattern can be used for any agentic task.\n\nGPT-4.1 has a performant 1M token input context window, and is useful for a variety of long context tasks, including structured document parsing, re-ranking, selecting relevant information while ignoring irrelevant context, and performing multi-hop reasoning using context.\n\n\nWe observe very good performance on needle-in-a-haystack evaluations up to our full 1M token context, and we’ve observed very strong performance at complex tasks with a mix of both relevant and irrelevant code and other documents. However, long context performance can degrade as more items are required to be retrieved, or perform complex reasoning that requires knowledge of the state of the entire context (like performing a graph search, for example).\n\n\nConsider the mix of external vs. internal world knowledge that might be required to answer your question. Sometimes it’s important for the model to use some of its own knowledge to connect concepts or make logical jumps, while in others it’s desirable to only use provided context\n\n// for internal knowledge\nOnly use the documents in the provided External Context to answer the User Query. If you don't know the answer based on this context, you must respond \"I don't have the information needed to answer that\", even if a user insists on you answering the question.\n// For internal and external knowledge\nBy default, use the provided external context to answer the User Query, but if other basic knowledge is needed to answer, and you're confident in the answer, you can use some of your own knowledge to help answer the question.\n\n\nEspecially in long context usage, placement of instructions and context can impact performance. If you have long context in your prompt, ideally place your instructions at both the beginning and end of the provided context, as we found this to perform better than only above or below. If you’d prefer to only have your instructions once, then above the provided context works better than below.\n\nAs mentioned above, GPT-4.1 is not a reasoning model, but prompting the model to think step by step (called “chain of thought”) can be an effective way for a model to break down problems into more manageable pieces, solve them, and improve overall output quality, with the tradeoff of higher cost and latency associated with using more output tokens. The model has been trained to perform well at agentic reasoning about and real-world problem solving, so it shouldn’t require much prompting to perform well.\n\nWe recommend starting with this basic chain-of-thought instruction at the end of your prompt:\n\n...\n\nFirst, think carefully step by step about what documents are needed to answer the query. Then, print out the TITLE and ID of each document. Then, format the IDs into a list.\n\nFrom there, you should improve your chain-of-thought (CoT) prompt by auditing failures in your particular examples and evals, and addressing systematic planning and reasoning errors with more explicit instructions. In the unconstrained CoT prompt, there may be variance in the strategies it tries, and if you observe an approach that works well, you can codify that strategy in your prompt. Generally speaking, errors tend to occur from misunderstanding user intent, insufficient context gathering or analysis, or insufficient or incorrect step by step thinking, so watch out for these and try to address them with more opinionated instructions.\n\nHere is an example prompt instructing the model to focus more methodically on analyzing user intent and considering relevant context before proceeding to answer.\n\nQuery Analysis: Break down and analyze the query until you're confident about what it might be asking. Consider the provided context to help clarify any ambiguous or confusing information.\nContext Analysis: Carefully select and analyze a large set of potentially relevant documents. Optimize for recall - it's okay if some are irrelevant, but the correct documents must be in this list, otherwise your final answer will be wrong. Analysis steps for each:\n\ta. Analysis: An analysis of how it may or may not be relevant to answering the query.\n\tb. Relevance rating: [high, medium, low, none]\nSynthesis: summarize which documents are most relevant and why, including all documents with a relevance rating of medium or higher.\n\n{user_question}\n\n{external_context}\n\nFirst, think carefully step by step about what documents are needed to answer the query, closely adhering to the provided Reasoning Strategy. Then, print out the TITLE and ID of each document. Then, format the IDs into a list.\n\n\nGPT-4.1 exhibits outstanding instruction-following performance, which developers can leverage to precisely shape and control the outputs for their particular use cases. Developers often extensively prompt for agentic reasoning steps, response tone and voice, tool calling information, output formatting, topics to avoid, and more. However, since the model follows instructions more literally, developers may need to include explicit specification around what to do or not to do. Furthermore, existing prompts optimized for other models may not immediately work with this model, because existing instructions are followed more closely and implicit rules are no longer being as strongly inferred.\n\nHere is our recommended workflow for developing and debugging instructions in prompts:\n\nStart with an overall “Response Rules” or “Instructions” section with high-level guidance and bullet points.\nIf you’d like to change a more specific behavior, add a section to specify more details for that category, like # Sample Phrases.\nIf there are specific steps you’d like the model to follow in its workflow, add an ordered list and instruct the model to follow these steps.\nIf behavior still isn’t working as expected:\n   Check for conflicting, underspecified, or wrong instructions and examples. If there are conflicting instructions, GPT-4.1 tends to follow the one closer to the end of the prompt.\n   Add examples that demonstrate desired behavior; ensure that any important behavior demonstrated in your examples are also cited in your rules.\n   It’s generally not necessary to use all-caps or other incentives like bribes or tips. We recommend starting without these, and only reaching for these if necessary for your particular prompt. Note that if your existing prompts include these techniques, it could cause GPT-4.1 to pay attention to it too strictly.\n\nNote that using your preferred AI-powered IDE can be very helpful for iterating on prompts, including checking for consistency or conflicts, adding examples, or making cohesive updates like adding an instruction and updating instructions to demonstrate that instruction.\n\n\nThese failure modes are not unique to GPT-4.1, but we share them here for general awareness and ease of debugging.\n\nInstructing a model to always follow a specific behavior can occasionally induce adverse effects. For instance, if told “you must call a tool before responding to the user,” models may hallucinate tool inputs or call the tool with null values if they do not have enough information. Adding “if you don’t have enough information to call the tool, ask the user for the information you need” should mitigate this.\nWhen provided sample phrases, models can use those quotes verbatim and start to sound repetitive to users. Ensure you instruct the model to vary them as necessary.\nWithout specific instructions, some models can be eager to provide additional prose to explain their decisions, or output more formatting in responses than may be desired. Provide instructions and potentially examples to help mitigate.\n\nThis demonstrates best practices for a fictional customer service agent. Observe the diversity of rules, the specificity, the use of additional sections for greater detail, and an example to demonstrate precise behavior that incorporates all prior rules.\n\nTry running the following notebook cell - you should see both a user message and tool call, and the user message should start with a greeting, then echo back their answer, then mention they're about to call a tool. Try changing the instructions to shape the model behavior, or trying other user messages, to test instruction following performance.\n\n\nFor reference, here is a good starting point for structuring your prompts.\n\n\n\n\n\n\n\n\n\nAdd or remove sections to suit your needs, and experiment to determine what’s optimal for your usage.\n\n\nHere are some general guidelines for selecting the best delimiters for your prompt. Please refer to the Long Context section for special considerations for that context type.\n\nMarkdown: We recommend starting here, and using markdown titles for major sections and subsections (including deeper hierarchy, to H4+). Use inline backticks or backtick blocks to precisely wrap code, and standard numbered or bulleted lists as needed.\nXML: These also perform well, and we have improved adherence to information in XML with this model. XML is convenient to precisely wrap a section including start and end, add metadata to the tags for additional context, and enable nesting. Here is an example of using XML tags to nest examples in an example section, with inputs and outputs for each:\n\n\n\nSan Francisco\n- SF\n\n\n\nJSON is highly structured and well understood by the model particularly in coding contexts. However it can be more verbose, and require character escaping that can add overhead.\n\nGuidance specifically for adding a large number of documents or files to input context:\n\nXML performed well in our long context testing.\n  Example: The quick brown fox jumps over the lazy dog\nThis format, proposed by Lee et al. (ref), also performed well in our long context testing.\n  Example: ID: 1 | TITLE: The Fox | CONTENT: The quick brown fox jumps over the lazy dog\nJSON performed particularly poorly.\n  Example: [{'id': 1, 'title': 'The Fox', 'content': 'The quick brown fox jumped over the lazy dog'}]\n\nThe model is trained to robustly understand structure in a variety of formats. Generally, use your judgement and think about what will provide clear information and “stand out” to the model. For example, if you’re retrieving documents that contain lots of XML, an XML-based delimiter will likely be less effective.\n\nIn some isolated cases we have observed the model being resistant to producing very long, repetitive outputs, for example, analyzing hundreds of items one by one. If this is necessary for your use case, instruct the model strongly to output this information in full, and consider breaking down the problem or using a more concise approach.\nWe have seen some rare instances of parallel tool calls being incorrect. We advise testing this, and considering setting the parallel\\_tool\\_calls param to false if you’re seeing issues.\n\nDevelopers have provided us feedback that accurate and well-formed diff generation is a critical capability to power coding-related tasks. To this end, the GPT-4.1 family features substantially improved diff capabilities relative to previous GPT models. Moreover, while GPT-4.1 has strong performance generating diffs of any format given clear instructions and examples, we open-source here one recommended diff format, on which the model has been extensively trained. We hope that in particular for developers just starting out, that this will take much of the guesswork out of creating diffs yourself.\n\nSee the example below for a prompt that applies our recommended tool call correctly.\n\nHere’s a reference implementation of the apply\\_patch tool that we used as part of model training. You’ll need to make this an executable and available as \\apply\\_patch\\ from the shell where the model will execute commands:\n\nIf you want to try using a different diff format, we found in testing that the SEARCH/REPLACE diff format used in Aider’s polyglot benchmark, as well as a pseudo-XML format with no internal escaping, both had high success rates.\n\nThese diff formats share two key aspects: (1) they do not use line numbers, and (2) they provide both the exact code to be replaced, and the exact code with which to replace it, with clear delimiters between the two."])</script><script>self.__next_f.push([1,"109:Tb48,"])</script><script>self.__next_f.push([1,"In this cookbook, you'll learn how to use GPT Image, our new large language model with image generation capabilities.\n\nThis model has world knowledge and can generate images leveraging this broad understanding of the world.\nIt is also much better at instruction following and producing photorealistic images compared to our previous-generation image models, DallE 2 and 3.\n\nTo learn more about image generation, refer to our guide.\n\nGPT Image 1 is great at instruction-following, meaning you can prompt the model to generate images with very detailed instructions.\n\nYou can customize the following output properties:\nQuality can be low, medium, high or auto (default value)\nSize can be 1024x1024 (square), 1536x1024 (portrait), 1024x1536 (landscape) or auto (default)\nYou can adjust the compression level (from 0-100%) for JPEG and WEBP formats\nYou can choose to generate an image with a transparent background (only available for PNG or WEBP)\n\nYou can use the background property to request a transparent background, but if you include in your prompt that you want a transparent background, it will be set to transparent by default.\n\nGPT Image can also accept image inputs, and use them to create new images. You can also provide a mask if you don't want the model to change a specific part of the input image.\n\nYou can use a maximum of 10 input images, and if you use a mask, it will be applied to the first image provided in the image array.\n\nYou can also provide a mask along with your input images (if there are several, the mask will be applied on the first one) to edit only the part of the input image that is not covered by the mask. Please note that the model might still edit some parts of the image inside the mask, but it will avoid it.\n\nImportant note: the mask should contain an alpha channel. If you're generating it manually, for example using an image editing software, make sure you include this alpha channel.\n\nFor this example, we'll use our model to generate the mask automatically for us. The mask might not be exact, but it will be enough for our purposes.\nIf you need to have an exact mask, feel free to use an image segmentation model.\nThis step is optional, if you want to turn a black \u0026 white image into a mask with an alpha channel that can be used in the Image Edit API.\nWhen using a mask, we still need the prompt the model describing the entiring resulting image, not just the area that is masked.\nIn this cookbook, we've seen how to use our new image generation model, GPT Image, to either generate new images from scratch, or use reference images. We've also covered how to create a mask with an alpha channel to apply it to an input image, to guide the image edition even further.\n\nFeel free to use this as a starting point to explore other use cases, and if you're looking for some inspiration, check out the image gallery in our docs.\n\nHappy building!"])</script><script>self.__next_f.push([1,"10a:T1cac,"])</script><script>self.__next_f.push([1,"OpenAI now offers function calling using reasoning models. Reasoning models are trained to follow logical chains of thought, making them better suited for complex or multi-step tasks.\nReasoning models like o3 and o4-mini are LLMs trained with reinforcement learning to perform reasoning. Reasoning models think before they answer, producing a long internal chain of thought before responding to the user. Reasoning models excel in complex problem solving, coding, scientific reasoning, and multi-step planning for agentic workflows. They're also the best models for Codex CLI, our lightweight coding agent.\n\nFor the most part, using these models via the API is very simple and comparable to using familiar 'chat' models.\n\nHowever, there are some nuances to bear in mind, particularly when it comes to using features such as function calling.\n\nAll examples in this notebook use the newer Responses API which provides convenient abstractions for managing conversation state. However the principles here are relevant when using the older chat completions API.\nLet's make a simple call to a reasoning model using the Responses API.\nWe specify a low reasoning effort and retrieve the response with the helpful output_text attribute.\nWe can ask follow up questions and use the previous_response_id to let OpenAI manage the conversation history automatically\nNice and easy!\n\nWe're asking relatively complex questions that may require the model to reason out a plan and proceed through it in steps, but this reasoning is hidden from us - we simply wait a little longer before being shown the response.\n\nHowever, if we inspect the output we can see that the model has made use of a hidden set of 'reasoning' tokens that were included in the model context window, but not exposed to us as end users.\nWe can see these tokens and a summary of the reasoning (but not the literal tokens used) in the response.\nIt is important to know about these reasoning tokens, because it means we will consume our available context window more quickly than with traditional chat models.\n\nWhat happens if we ask the model a complex request that also requires the use of custom tools?\nLet's imagine we have more questions about Olympic Cities, but we also have an internal database that contains IDs for each city.\nIt's possible that the model will need to invoke our tool partway through its reasoning process before returning a result.\nLet's make a function that produces a random UUID and ask the model to reason about these UUIDs.\n\nWe didn't get an output_text this time. Let's look at the response output\nAlong with the reasoning step, the model has successfully identified the need for a tool call and passed back instructions to send to our function call.\n\nLet's invoke the function and send the results to the model so it can continue reasoning.\nFunction responses are a special kind of message, so we need to structure our next message as a special kind of input:\n{\n    \"type\": \"function_call_output\",\n    \"call_id\": function_call.call_id,\n    \"output\": tool_output\n}\nThis works great here - as we know that a single function call is all that is required for the model to respond - but we also need to account for situations where multiple tool calls might need to be executed for the reasoning to complete.\n\nLet's add a second call to run a web search.\n\nOpenAI's web search tool is not available out of the box with reasoning models (as of May 2025 - this may soon change) but it's not too hard to create a custom web search function using 4o mini or another web search enabled model.\n\nSome OpenAI models support the parameter parallel_tool_calls which allows the model to return an array of functions which we can then execute in parallel. However, reasoning models may produce a sequence of function calls that must be made in series, particularly as some steps may depend on the results of previous ones.\nAs such, we ought to define a general pattern which we can use to handle arbitrarily complex reasoning workflows:\nAt each step in the conversation, initialise a loop\nIf the response contains function calls, we must assume the reasoning is ongoing and we should feed the function results (and any intermediate reasoning) back into the model for further inference\nIf there are no function calls and we instead receive a Reponse.output with a type of 'message', we can safely assume the agent has finished reasoning and we can break out of the loop\nNow let's demonstrate the loop concept we discussed before.\nSo far so good! It's really cool to watch the model pause execution to run a function before continuing.\nIn practice the example above is quite trivial, and production use cases may be much more complex:\nOur context window may grow too large and we may wish to prune older and less relevant messages, or summarize the conversation so far\nWe may wish to allow users to navigate back and forth through the conversation and re-generate answers\nWe may wish to store messages in our own database for audit purposes rather than relying on OpenAI's storage and orchestration\netc.\n\nIn these situations we may wish to take full control of the conversation. Rather than using previous_message_id we can instead treat the API as 'stateless' and make and maintain an array of conversation items that we send to the model as input each time.\n\nThis poses some Reasoning model specific nuances to consider.\nIn particular, it is essential that we preserve any reasoning and function call responses in our conversation history.\nThis is how the model keeps track of what chain-of-thought steps it has run through. The API will error if these are not included.\n\nLet's run through the example above again, orchestrating the messages ourselves and tracking token usage.\n\nNote that the code below is structured for readibility - in practice you may wish to consider a more sophisticated workflow to handle edge cases\nIn this cookbook, we identified how to combine function calling with OpenAI's reasoning models to demonstrate multi-step tasks that are dependent on external data sources., including searching the web.\n\nImportantly, we covered reasoning-model specific nuances in the function calling process, specifically that:\nThe model may choose to make multiple function calls or reasoning steps in series, and some steps may depend on the results of previous ones\nWe cannot know how many of these steps there will be, so we must process responses with a loop\nThe responses API makes orchestration easy using the previous_response_id parameter, but where manual control is needed, it's important to maintain the correct order of conversation item to preserve the 'chain-of-thought'\n\nThe examples used here are rather simple, but you can imagine how this technique could be extended to more real-world use cases, such as:\n\nLooking up a customer's transaction history and recent correspondence to determine if they are eligible for a promotional offer\nCalling recent transaction logs, geolocation data, and device metadata to assess the likelihood of a transaction being fraudulent\nReviewing internal HR databases to fetch an employee’s benefits usage, tenure, and recent policy changes to answer personalized HR questions\nReading internal dashboards, competitor news feeds, and market analyses to compile a daily executive briefing tailored to their focus areas"])</script><script>self.__next_f.push([1,"10b:T9ee,"])</script><script>self.__next_f.push([1,"Why would you want to do this?\nIn many production workflows you must answer several independent questions about the same piece of content.\nDoing those analyses one-by-one increases latency and can increase total cost if any step fails and forces a retry.\nBy \"fanning out\" multiple specialized agents at the same time and then \"fanning in\" their outputs to a final “meta” agent, you're able to reduce this latency.\n\nThis notebook present a toy example that you likely wouldn't parallelize in the real world, but that shows:\nHow to define several focused agents with the OpenAI Agents SDK.\nHow to execute them concurrently using either Python asyncio for lower latency, lightweight parallelization or directly through the Agents SDK for ease of management and dynamic tool call planning.\nHow to gather their individual outputs and feed them into a downstream meta-agent that produces the final, user-ready answer.\nA simple timeline visualization so you can see the latency benefit of parallelization.\n\nThis same pattern can be adapted to real world scenarios such as customer-support triage, content moderation, or other scenarios where you might want to run multiple independent analyses on an input and merge them into a single outcome.\nInstall dependencies\nDefine your Agents\nCreate function for parallel execution\nThe agents can also be parallelized directly through the SDK via the \"agent as tool\" route, adding convenience and the assistance of the planner dynamically deciding which tools to call at the expense of higher latency. This latency comes both from the additional planning API call up front, along with the higher overhead and context from the tool call objects.\n\nFrom the above, we can see two different patterns for parallelizing agents. Ultimately, the approach you use will depend on the balance you want between:\n\nConvenience vs. customization\n    If you prefer convenience, the agent as tool route is the way to go. If you want to customize how agents fan in and out across multiple layers, building a graph with asyncio.gather might make more sense\nPlanning vs. determinism\n    If you want your planner (in this case the meta agent) to dynamically decide which tools to call and the order, you should use agents as tools whereas asyncio.gather makes more sense if you want a deterministic order.\nLatency sensitivity\n    If you're highly sensitive to latency, you may want to use asyncio to avoid the additional upfront cost of planning the parallel tools and the overhead of tool outputs and longer context windows."])</script><script>self.__next_f.push([1,"10c:T4697,"])</script><script>self.__next_f.push([1,"This cookbook serves as a practical guide to help AI Engineers maximize the effectiveness of OpenAI's Realtime API, specifically when dealing with data-intensive function calls. We'll focus on scenarios common in speech-to-speech agents, where vast amounts of data must be handled smoothly and efficiently.\n\nThis post won't cover the basics of setting up a Realtime API solution. Instead, you'll gain clear insights and actionable strategies to enhance the performance and reliability of your real-time conversational agents. It addresses specific challenges unique to handling large amounts of data in real-time conversational contexts.\n\nBefore we dive in, let’s quickly recap the API for those who are new. The OpenAI Realtime API is a recent offering that supports low-latency, multimodal interactions—such as speech-to-speech conversations and live transcription. Picture scenarios like real-time voice-based customer support or live movie transcriptions.\n\nAgents need access to tools and relevant data to perform their tasks. For instance, a financial analyst agent might pull real-time market data. In many cases, services already exist in your environment that expose this information through APIs.\n\nHistorically, APIs weren’t designed with agents in mind and often return large volumes of data, depending on the service. As engineers, we frequently wrap these APIs with function calls to accelerate agent development—which makes perfect sense. Why reinvent what already exists?\n\nIf not carefully optimized, these data-intensive function calls can quickly overwhelm the Realtime API—leading to slow responses or even failures to process user requests.\n\nOur example centers on an NBA Scouting Agent that calls multiple functions to deliver in-depth analysis of upcoming draft prospects. To demonstrate practical guidelines for Realtime API interactions, we use large, realistic payloads inspired by NBA draft prospects. Below, you’ll find a monolithic searchDraftProspects function defined in the Realtime session to set the stage.\n// \"Hey, pull up point guards projected in the top 10 in the 2025 draft\"\n{\n  \"type\": \"session.update\",\n  \"session\": {\n    \"tools\": [\n      {\n        \"type\": \"function\",\n        \"name\": \"searchDraftProspects\",\n        \"description\": \"Search draft prospects for a given year e.g., Point Guard\",\n        \"parameters\": {\n          \"type\": \"object\",\n          \"properties\": {\n            \"sign\": {\n              \"type\": \"string\",\n              \"description\": \"The player position\",\n              \"enum\": [\n                \"Point Guard\",\n                \"Shooting Guard\",\n                \"Small Forward\",\n                \"Power Forward\",\n                \"Center\",\n                \"Any\"\n              ]\n            },\n            year: { type: \"number\", description: \"Draft year e.g., 2025\" },\n            mockDraftRanking: { type: \"number\", description: \"Predicted Draft Ranking\" },\n          },\n          \"required\": [\"position\", \"year\"]\n        }\n      }\n    ],\n    \"tool_choice\": \"auto\",\n  }\n}\n\nThe searchDraftProspects function call returns a hefty payload. The example’s structure and size are drawn from real-world scenarios we’ve encountered.\n\n// Example Payload\n{\n  \"status\": {\n    \"code\": 200,\n    \"message\": \"SUCCESS\"\n  },\n  \"found\": 4274,\n  \"offset\": 0,\n  \"limit\": 10,\n  \"data\": [\n    {\n      \"prospectId\": 10001,\n      \"data\": {\n        \"ProspectInfo\": {\n          \"league\": \"NCAA\",\n          \"collegeId\": 301,\n          \"isDraftEligible\": true,\n          \"Player\": {\n            \"personalDetails\": {\n              \"firstName\": \"Jalen\",\n              \"lastName\": \"Storm\",\n              \"dateOfBirth\": \"2003-01-15\",\n              \"nationality\": \"USA\"\n            },\n            \"physicalAttributes\": {\n              \"position\": \"PG\",\n              \"height\": {\n                \"feet\": 6,\n                \"inches\": 4\n              },\n              \"weightPounds\": 205\n            },\n            \"hometown\": {\n              \"city\": \"Springfield\",\n              \"state\": \"IL\"\n            }\n          },\n          \"TeamInfo\": {\n            \"collegeTeam\": \"Springfield Tigers\",\n            \"conference\": \"Big West\",\n            \"teamRanking\": 12,\n            \"coach\": {\n              \"coachId\": 987,\n              \"coachName\": \"Marcus Reed\",\n              \"experienceYears\": 10\n            }\n          }\n        },\n        \"Stats\": {\n          \"season\": \"2025\",\n          \"gamesPlayed\": 32,\n          \"minutesPerGame\": 34.5,\n          \"shooting\": {\n            \"FieldGoalPercentage\": 47.2,\n            \"ThreePointPercentage\": 39.1,\n            \"FreeThrowPercentage\": 85.6\n          },\n          \"averages\": {\n            \"points\": 21.3,\n            \"rebounds\": 4.1,\n            \"assists\": 6.8,\n            \"steals\": 1.7,\n            \"blocks\": 0.3\n          }\n        },\n        \"Scouting\": {\n          \"evaluations\": {\n            \"strengths\": [\"Court vision\", \"Clutch shooting\"],\n            \"areasForImprovement\": [\"Defensive consistency\"]\n          },\n          \"scouts\": [\n            {\n              \"scoutId\": 501,\n              \"name\": \"Greg Hamilton\",\n              \"organization\": \"National Scouting Bureau\"\n            }\n          ]\n        },\n        \"DraftProjection\": {\n          \"mockDraftRanking\": 5,\n          \"lotteryPickProbability\": 88,\n          \"historicalComparisons\": [\n            {\n              \"player\": \"Chris Paul\",\n              \"similarityPercentage\": 85\n            }\n          ]\n        },\n        \"Media\": {\n          \"highlightReelUrl\": \"https://example.com/highlights/jalen-storm\",\n          \"socialMedia\": {\n            \"twitter\": \"@jstorm23\",\n            \"instagram\": \"@jstorm23_ig\"\n          }\n        },\n        \"Agent\": {\n          \"agentName\": \"Rick Allen\",\n          \"agency\": \"Elite Sports Management\",\n          \"contact\": {\n            \"email\": \"rallen@elitesports.com\",\n            \"phone\": \"555-123-4567\"\n          }\n        }\n      }\n    },\n    // ... Many thousands of tokens later.\n  ]\n}\n\nIt almost goes without saying—when building function calls, your top priority is to design clear, well-defined functions. This makes it easy to trim response sizes and avoid overwhelming the model. Each function call should be straightforward to explain, sharply scoped, and return only the information needed for its purpose. Overlapping responsibilities between functions inevitably invites confusion.\n\nFor example, we can limit the searchDraftProspects function call to return only general details—such as player stats—for each prospect, dramatically reducing the response size. If more information is needed, the new getProspectDetails function call provides expanded details. There’s no universal solution; the right approach depends on your use case and data model.\n\n{\n  \"tools\": [\n    {\n      \"type\": \"function\",\n      \"name\": \"searchDraftProspects\",\n      \"description\": \"Search NBA draft prospects by position, draft year, and projected ranking, returning only general statistics to optimize response size.\",\n      \"parameters\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"position\": {\n            \"type\": \"string\",\n            \"description\": \"The player's basketball position.\",\n            \"enum\": [\n              \"Point Guard\",\n              \"Shooting Guard\",\n              \"Small Forward\",\n              \"Power Forward\",\n              \"Center\",\n              \"Any\"\n            ]\n          },\n          \"year\": {\n            \"type\": \"number\",\n            \"description\": \"Draft year, e.g., 2025\"\n          },\n          \"maxMockDraftRanking\": {\n            \"type\": \"number\",\n            \"description\": \"Maximum predicted draft ranking (e.g., top 10)\"\n          }\n        },\n        \"required\": [\"position\", \"year\"]\n      }\n    },\n    {\n      \"type\": \"function\",\n      \"name\": \"getProspectDetails\",\n      \"description\": \"Fetch detailed information for a specific NBA prospect, including comprehensive stats, agent details, and scouting reports.\",\n      \"parameters\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"playerName\": {\n            \"type\": \"string\",\n            \"description\": \"Full name of the prospect (e.g., Jalen Storm)\"\n          },\n          \"year\": {\n            \"type\": \"number\",\n            \"description\": \"Draft year, e.g., 2025\"\n          },\n          \"includeAgentInfo\": {\n            \"type\": \"boolean\",\n            \"description\": \"Include agent information\"\n          },\n          \"includeStats\": {\n            \"type\": \"boolean\",\n            \"description\": \"Include detailed player statistics\"\n          },\n          \"includeScoutingReport\": {\n            \"type\": \"boolean\",\n            \"description\": \"Include scouting report details\"\n          }\n        },\n        \"required\": [\"playerName\", \"year\"]\n      }\n    }\n  ],\n  \"tool_choice\": \"auto\"\n}\n\nRealtime conversations allow for generous 30-minute sessions—but the rolling context window only supports ~16,000 tokens (depending on the model snapshot, context window limitations are improving). As a result, you may notice performance gradually decline during extended exchanges. As conversations progress and more function calls are made, the conversation state can expand quickly with both important information and unnecessary noise—so it’s important to focus on keeping the most relevant details. This approach helps maintain strong performance and reduces cost.\ni) Periodically summarize the conversation state\n\nPeriodically summarizing the conversation as it unfolds is an excellent way to reduce context size—cutting both cost and latency.\n\nSee @Minhajul's' epic guide on implementing automatic summarization in Realtime conversations (link).\nii) Periodically remind the the model of its role and responsibilities\n\nData-heavy payloads can quickly fill the context window. If you notice the model losing track of instructions or available tools, periodically remind it of its system prompt and tools by calling session.update—this keeps it focused on its role and responsibilities.\ni) Use filtering in your function calls to trim data-heavy responses down to only the essential fields needed to answer the question\n\nGenerally, fewer tokens returned by function calls lead to better quality responses. Common pitfalls occur when function calls return excessively large payloads spanning thousands of tokens. Focus on applying filters in each function call, either at the data-level or function-level, to minimize response sizes.\n\n// Filtered response\n{\n  \"status\": {\n    \"code\": 200,\n    \"message\": \"SUCCESS\"\n  },\n  \"found\": 4274,\n  \"offset\": 0,\n  \"limit\": 5,\n  \"data\": [\n    {\n    \"zpid\": 7972122,\n      \"data\": {\n        \"PropertyInfo\": {\n            \"houseNumber\": \"19661\",\n            \"directionPrefix\": \"N \",\n            \"streetName\": \"Central\",\n            \"streetSuffix\": \"Ave\",\n            \"city\": \"Phoenix\",\n            \"state\": \"AZ\",\n            \"postalCode\": \"85024\",\n            \"zipPlusFour\": \"1641\"\n            \"bedroomCount\": 2,\n            \"bathroomCount\": 2,\n            \"storyCount\": 1,\n            \"livingAreaSize\": 1089,\n            \"livingAreaSizeUnits\": \"Square Feet\",\n            \"yearBuilt\": \"1985\"\n          }\n\t\t    }\n\t\t\t}\n\t\t]\n\t\t// ...\n}\nii) Flatten hierarchical payloads—without losing key information\n\nHierarchical payloads from API calls can sometimes include repeated level titles—like \"ProspectInfo\" or \"Stats\"—which may add extra noise and make things harder for the model to process. As you explore ways to make your data more efficient, you might try flattening these structures by trimming away some of the unnecessary labels. This can help improve performance, but consider what information is important to keep for your particular use case.\n\n// Flattened payload\n{\n  \"status\": {\n    \"code\": 200,\n    \"message\": \"SUCCESS\"\n  },\n  \"found\": 4274,\n  \"offset\": 0,\n  \"limit\": 2,\n  \"data\": [\n    {\n      \"prospectId\": 10001,\n      \"league\": \"NCAA\",\n      \"collegeId\": 301,\n      \"isDraftEligible\": true,\n      \"firstName\": \"Jalen\",\n      \"lastName\": \"Storm\",\n      \"position\": \"PG\",\n      \"heightFeet\": 6,\n      \"heightInches\": 4,\n      \"weightPounds\": 205,\n      \"hometown\": \"Springfield\",\n      \"state\": \"IL\",\n      \"collegeTeam\": \"Springfield Tigers\",\n      \"conference\": \"Big West\",\n      \"teamRanking\": 12,\n      \"coachId\": 987,\n      \"coachName\": \"Marcus Reed\",\n      \"gamesPlayed\": 32,\n      \"minutesPerGame\": 34.5,\n      \"FieldGoalPercentage\": 47.2,\n      \"ThreePointPercentage\": 39.1,\n      \"FreeThrowPercentage\": 85.6,\n      \"averagePoints\": 21.3,\n      \"averageRebounds\": 4.1,\n      \"averageAssists\": 6.8,\n      \"stealsPerGame\": 1.7,\n      \"blocksPerGame\": 0.3,\n      \"strengths\": [\"Court vision\", \"Clutch shooting\"],\n      \"areasForImprovement\": [\"Defensive consistency\"],\n      \"mockDraftRanking\": 5,\n      \"lotteryPickProbability\": 88,\n      \"highlightReelUrl\": \"https://example.com/highlights/jalen-storm\",\n      \"agentName\": \"Rick Allen\",\n      \"agency\": \"Elite Sports Management\",\n      \"contactEmail\": \"rallen@elitesports.com\"\n    },\n\t\t...\n }\n iii) Experiment with different data formats\n\nThe way you structure your data has a direct impact on how well the model processes and summarizes API responses. In our experience, clear, key-based formats like JSON or YAML help the model interpret data more accurately than tabular formats such as Markdown. Large tables, especially, tend to overwhelm the model—resulting in less fluent and less accurate outputs. Still, it’s worth experimenting with different formats to find what works best for your use case.\n\nstatus:\n  code: 200\n  message: \"SUCCESS\"\nfound: 4274\noffset: 0\nlimit: 10\ndata:\n  prospectId: 10001\n    data:\n      ProspectInfo:\n        league: \"NCAA\"\n        collegeId: 301\n        isDraftEligible: true\n        Player:\n          firstName: \"Jalen\"\n          lastName: \"Storm\"\n          position: \"PG\"\n          heightFeet: 6\n          heightInches: 4\n          weightPounds: 205\n          hometown: \"Springfield\"\n          state: \"IL\"\n        TeamInfo:\n          collegeTeam: \"Springfield Tigers\"\n          conference: \"Big West\"\n          teamRanking: 12\n          coachId: 987\n          coachName: \"Marcus Reed\"\n      Stats:\n        gamesPlayed: 32\n        minutesPerGame: 34.5\n        FieldGoalPercentage: 47.2\n        ThreePointPercentage: 39.1\n        FreeThrowPercentage: 85.6\n        averagePoints: 21.3\n        averageRebounds: 4.1\n        averageAssists: 6.8\n        stealsPerGame: 1.7\n        blocksPerGame: 0.3\n      Scouting:\n        strengths:\n          \"Court vision\"\n          \"Clutch shooting\"\n        areasForImprovement:\n          \"Defensive consistency\"\n      DraftProjection:\n        mockDraftRanking: 5\n        lotteryPickProbability: 88\n      Media:\n        highlightReelUrl: \"https://example.com/highlights/jalen-storm\"\n      Agent:\n        agentName: \"Rick Allen\"\n        agency: \"Elite Sports Management\"\n        contactEmail: \"rallen@elitesports.com\"\n\nUnderlying models often struggle to transition smoothly from data-heavy responses to accurate answers. To improve fluency and accuracy when working with complex data, provide a function call hint immediately after the function call. These hints guide the model on the specific task—teaching it how to interpret key fields and domain-specific values.\n\nThe following example illustrates an effective hint prompt.\n\n// Function call hint\nlet prospectSearchPrompt = `\nParse NBA prospect data and provide a concise, engaging response.\n\nGeneral Guidelines\nAct as an NBA scouting expert.\nHighlight key strengths and notable attributes.\nUse conversational language.\nMention identical attributes once.\nIgnore IDs and URLs.\n\nPlayer Details\nState height conversationally (\"six-foot-eight\").\nRound weights to nearest 5 lbs.\n\nStats \u0026 Draft Info\nRound stats to nearest whole number.\nUse general terms for draft ranking (\"top-five pick\").\nExperience\nRefer to players as freshman, sophomore, etc., or mention professional experience.\nLocation \u0026 TeamMention hometown city and state/country.\nDescribe teams conversationally.\n\nSkip (unless asked explicitly)\nExact birth dates\nIDs\nAgent/contact details\nURLs\n\nExamples\n\"Jalen Storm, a dynamic six-foot-four point guard from Springfield, Illinois, averages 21 points per game.\"\n\"Known for his clutch shooting, he's projected as a top-five pick.\"\n\nImportant: Respond based strictly on provided data, without inventing details.\n`;\nIn practice, we first append the function call result to the conversation. Then, we emit a response from the Realtime API with the hint prompt. Voilà—the model gracefully handles all the information.\n// Add new conversation item for the model\nconst conversationItem = {\n  type: 'conversation.item.create',\n  previous_item_id: output.id,\n  item: {\n    call_id: output.call_id,\n    type: 'function_call_output',\n    output: Draft Prospect Search Results: ${result}\n  }\n};\n\ndataChannel.send(JSON.stringify(conversationItem));\n\n// Emit a response from the model including the hint prompt\nconst event = {\n  type: 'response.create',\n  conversation: \"none\",\n  response: {\n    instructions: prospectSearchPrompt # function call hint\n  }\n};\n\ndataChannel.send(JSON.stringify(event));\n\nBuilding effective agents with the Realtime API is an ongoing process of exploration and adaptation.\n\nSummary of Key Recommendations\n\nFilter data:** Only include fields and details that are directly relevant to the user’s request or the model’s next step. Trim the rest.\nFlatten and simplify structures:** Reduce deeply nested or redundant data. Present information in a way that’s easy for both models and humans to scan.\nPrefer clear, structured formats:** Use JSON (or YAML) with consistent field names and minimal noise. Avoid large tables or markdown for data-heavy responses.\nGuide the model with hint prompts:** After returning lots of data, follow up with a targeted prompt that explains exactly what the model should extract or summarize.\n\nRemember—experimentation is essential. Realtime models keep improving, and we’ll continue sharing tips to help you get the most out of the Realtime API."])</script><script>self.__next_f.push([1,"10d:T4758,"])</script><script>self.__next_f.push([1,"The best model for you depends on your business goal. Many startups choose large language models (LLMs) based on offline evaluations and public benchmarks. However, a model that achieves high scores on a benchmark may not necessarily lead your users to pay, subscribe, or continue using your product. Models that look strong on paper can underperform when measured against actual business outcomes.\n\nThis guide describes an evaluation approach grounded in one of the most important business outcomes for startups: whether people are willing to pay for your product.\n\nWe’ll walk through HyperWrite’s model evaluation process, with a focus on real payment conversion—specifically Stripe payments for one-time purchases or monthly recurring revenue (MRR) subscriptions. If your goal is to improve conversion rates, or to maintain them while switching to a less expensive model, this evaluation example may be a useful pattern to follow.\nTo apply this guide to your business, you’ll need:\n\nA payment processor.** We use Stripe in this example, but you can make slight adjustments and use the same approach with any payment provider.\nEnough users to yield a meaningful signal.** Aim for at least one thousand users per test variant. For higher statistical significance, you’ll need more users.\nAn AI-powered product with a conversion event.** We use an LLM application, and our conversion event is payment. The same testing approach applies to apps built around voice, video, and other modalities.\nHyperWrite builds AI-powered writing tools and research assistants. The company’s core offering is a writing assistant with advanced research capabilities.\n\nOffline benchmarks did not predict what mattered most for HyperWrite: whether users engaged with the writing assistant in a way that led them to subscribe and continue using the product. The HyperWrite team shifted to focusing on the outcome of interest—conversion—and began selecting between AI models based on real-world A/B tests comparing Stripe conversion rates.\nAt many startups, having users sign up for and continue to use the product is the goal. Using classic A/B testing, using the same statistical methods scientists have relied on for decades, you can design a model evaluation process:\nNew users are batched, and each batch is served a different AI model.\nTo standardize when users encounter an upgrade prompt, a consistent rate limit is applied after users have sent the assistant a set number of messages—enough to create a meaningful upgrade moment.\nConversion to a paid subscription (via Stripe) is tracked for each group.\n\nRandom assignment of users to models and control of other factors (onboarding, features, prompts, etc.) allows attribution of differences in conversion rates to the models being tested, rather than to external variation. Statistics provide confidence that observed differences are unlikely to be due to chance.\n\nWhen a true, non-random improvement is found (e.g., one model yields a higher conversion rate), the impact is tangible: higher Stripe conversions, more paying users, and often lower costs if the model is more efficient.\nA/B testing can serve as a real-world evaluation tool for model selection. Randomly split users into groups, give each group a different experience (here, a different AI model), and observe which group performs better on the key metric—in this case, Stripe conversions.\nA standard setup includes a “control” (your current model) and a “variant” (a challenger). Users are randomly assigned to either group. To ensure the test isolates the model’s effect, everything else is kept the same: onboarding, features, prompts, and the opportunity to convert. After a predetermined period or number of users, conversion rates are compared: did more people pay when using Model A or Model B?\nHyperWrite’s goal was to deploy a less expensive LLM without materially reducing monetization. This was a non-inferiority scenario: the interest was in ensuring the new model was not significantly worse than the control. With cost savings in mind, a one-sided non-inferiority test was designed.\nTest focus:** Cost savings without harming Stripe conversion.\nDesign:** One-tailed, two-proportion Z-test (focused on detecting whether the new model is worse).\nAlpha (Type I error rate):** 0.15 (i.e., 85% confidence). For this startup, iteration speed was prioritized over very strict significance thresholds.\nPower:** 0.60 (sufficient to catch meaningful drops, balanced against traffic constraints).\nMinimum detectable effect (MDE):** A 30% drop in conversion—any decline less than this would be considered “close enough” if the cost savings justified it.\nPopulation:** A segment of new sign-ups over a defined period, randomized by user_id at signup.\nTrigger:** Users send messages, hit an upgrade paywall, and may convert via Stripe checkout.\nNot every observed difference will be meaningful—some differences occur by chance. A/B testing helps separate real effects from random noise. The commonly used statistical tool here is the “two-proportion Z-test,” which checks whether the difference in conversion rates between two groups is large enough to be considered statistically significant.\n\nThere are a few variations of this test:\nOne-tailed test:** Checks if the new model is better than (or, depending on design, not worse than) the control\nTwo-tailed test:** Checks for any difference, whether up or down\nMultivariate tests (A/B/n):** Three or more models are compared simultaneously\n\nThe choice depends on your goal. If you require a clear upgrade in conversion, a one-tailed test looking for improvement may suffice. If you’re willing to adopt a model that is no worse but cheaper, you may design a non-inferiority (one-sided) test to ensure the new model is not significantly worse.\nType I Error (False Positive):** Concluding there is an effect when there is none\nType II Error (False Negative):** Failing to detect a real effect\nAlpha (α):** The acceptable risk of a Type I error (often set at 0.05, i.e., 5%)\nPower:** The probability of detecting a true effect (80% is a common target)\nConsider choosing between your current model (Control) and a new variant (Model X). Suppose you run a one-tailed two-proportion Z-test to see if Model X converts better than the Control. You set α = 0.05 and, after doing a power calculation with your baseline conversion rate and desired minimum detectable effect, determine that roughly 1,500 users per group will provide ~75% power—a compromise allowing for faster directional insight.\n\nAfter both groups reach the required sample size, the data might look like:\n\n| Group                      | Users Assigned | Conversions | Conversion Rate | p-value | Stat. Significant? | Winner? | Type I Error Guarded? | Type II Error Guarded? |\n|----------------------------|----------------|-------------|-----------------|---------|--------------------|---------|-----------------------|------------------------|\n| Control (Current Model)    | 1500           | 15          | 1.0%            | --      | Reference          | No      | Yes                   | Yes                    |\n| Model X (Variant)          | 1500           | 30          | 2.0%            | 0.012   | Yes                | Yes     | Yes                   | Yes                    |\n\nUsers Assigned:** Number of users randomly placed in each group.\nConversions:** How many paid via Stripe in each group.\nConversion Rate:** Conversions divided by users assigned.\np-value:** Result of the one-tailed two-proportion Z-test, showing if Model X’s higher rate is likely not due to chance.\nStat. Significant?:** Does the p-value beat your alpha (here, 0.05)?\nWinner?:** If statistically significant, Model X is the new winner.\nType I Error Guarded?:** Did we keep the false positive risk within our alpha threshold?\nType II Error Guarded?:** Did our sample size give us enough power to detect a real effect?\n\nIn this run, Model X’s conversion rate is 1 percentage point higher than the control (2.0% vs. 1.0%)—a 100% relative increase. The p-value of 0.012 is well below 0.05, so we mark it as statistically significant: Model X is the winner. Because we planned the sample size for 75% statistical power, we’re also confident we didn’t miss a true effect (Type II error). And since we set our alpha at 0.05, the risk of a false positive (Type I error) is controlled.\nHyperWrite did not default to the textbook 95% confidence and 80% power. Traffic is expensive, and maximizing statistical certainty can slow learning and consume capital. The chosen 85% confidence and 60% power allowed detection of any material drop (about a 30% decrease) while avoiding over-optimizing for small differences.\n\nConversion rates tend to rise as a test runs longer. In these tests, runs were stopped once the required sample size (N) was reached. Only a fraction of incoming traffic was allocated to each test arm, with the majority remaining on the proven control experience.\nAn A/B/n (“many-vs-one”) design was used: each candidate model (GPT-4.1 and GPT-4.1-mini) was evaluated against the production control (Claude 3.5 Sonnet) but not directly against each other.\n\nBecause the launch decision was variant-specific (“ship the arm if its own one-tailed non-inferiority test at α = 0.15 passes; otherwise discard”), a family-wise error rate correction was not applied. This is standard for small-k, control-centric tests. The false positive risk applies only to the single arm launched, and avoiding Bonferroni-type splits preserves power.\nTo demonstrate exactly how the statistics behind our A/B test work, here’s a 10-line Python snippet that converts raw conversion counts into a p-value using a one-tailed two-proportion Z-test (variant better than control). Paste it into any Python REPL, Colab, or notebook and swap in your own numbers when you run real experiments.\nfrom statsmodels.stats.proportion import proportions_ztest\n\nconversions   = [30, 15]     # [variant, control]\nsample_sizes  = [1500, 1500] # [variant, control]\n\nz_stat, p_val = proportions_ztest(\n    conversions,\n    sample_sizes,\n    alternative=\"larger\"      # \"larger\" → variant \u003e control\n)\n\nprint(f\"Z-statistic = {z_stat:.2f}\")\nprint(f\"p-value     = {p_val:.3f}\")    # → 0.012 (α = 0.05)\n\nHow to read the results:\nIf the p-value is ≤ 0.05, your variant’s higher conversion is statistically significant—go ahead and ship it, or keep monitoring for more data.\nIf it’s \u003e 0.05, the result could be random noise—collect more data, or stick with your control.\nTail fishing / p-hacking:** Decide one- vs two-tailed before the first user flows in; switching later inflates your Type I error (false positives).\nLow counts:** If either arm has \u003c ~10 conversions, swap the Z-test for Fisher’s exact test or Wilson/Wald CIs.\nEarly peeking:** Repeated looks at the data without α-spending corrections raise false-positive risk. Use a fixed sample or a group-sequential design.\nUser overlap / contamination:** Make sure the same user ID can’t land in two arms (e.g., via logout/login).\nMultiple challengers:** If you plan to pick the single “best” of many variants, control family-wise error (Bonferroni, Holm) or use a multi-armed bandit.\nCaching \u0026 prompt drift:** Confirm your inference layer doesn’t leak one model’s response into another’s cache; keep prompts identical across arms.\n\nTo learn more about these pitfalls and how they are avoided, check out Evan Miller's \"How Not to Run an A/B Test\"\nA/B testing isn’t just for landing pages or button colors—it’s essential for picking the right LLM for your product. By making it part of your workflow, you’ll dodge costly mistakes and spot upgrades grounded in what your users value: a product worth paying for.\nModel pricing often increases as capabilities improve. HyperWrite spent several months looking for a model that could match its incumbent (Anthropic’s Claude 3.5 Sonnet) without harming conversion or user experience, ideally at a lower cost. After several models performed worse, OpenAI’s GPT-4.1 provided a notable result: matching the incumbent’s Stripe conversion at a lower price.\n\nHere’s how the variants stacked up on Stripe conversion:\n\n| Variant                                      | Assigned | Conversions | Rate  | Req N | % Done | Conv cut-off (≤) | Worse? |\n|----------------------------------------------|---------:|------------:|------:|------:|-------:|-----------------:|:------:|\n| anthropic/claude-3.5-sonnet (control)        |    4550 |          42 | 0.92% |  3378 |   135% | —                | —      |\n| openai/gpt-4.1 (variant)                     |    4513 |          58 | 1.29% |  3378 |   134% | 32               | No     |\n| openai/gpt-4.1-mini (variant)                |    4557 |          45 | 0.99% |  3378 |   135% | 33               | No     |\nVariant:** Model name (control or challenger).\nAssigned:** Number of users randomly placed in that arm.\nConversions:** Users in the arm who paid via Stripe.\nRate:** Conversions divided by Assigned.\nReq N:** Pre-computed sample-size target for the non-inferiority test.\n% Done:** Assigned divided by Req N (progress toward the target).\nConv cut-off (≤):** Maximum conversions below which the arm would be flagged “significantly worse” than control.\nWorse?:** “Yes” if the arm fell below its cut-off (i.e., statistically worse); otherwise “No”.\n\nResults\n\nBoth GPT-4.1 variants beat their cut-offs—meaning neither was statistically worse than the control.\nGPT-4.1 (full) held its own on conversion rate against Claude 3.5 Sonnet, while delivering substantial cost savings.\nTo perform this analysis, you need a system that links user behavior to Stripe payment events. There’s no universal template for this, but the architecture used at HyperWrite illustrates one way to implement it. This workflow can be adapted for any startup where users interact with an AI and can upgrade via Stripe.\nUser Tracking: Assign a unique identifier to each new signup that persists through their lifecycle.\nModel Assignment: Randomly assign each user to a test group (model variant) at signup, and store this assignment in your database.\nInteraction Logging: Log key events (e.g., first use, rate limit reached) along with user IDs and model assignments.\nConversion Event Capture: Set up a Stripe webhook to listen for checkout.session.completed events. When triggered, match the Stripe customer to your internal user ID and update your database to reflect payment/conversion.\nData Aggregation: Regularly pull test group assignments and conversion data into a single table or dashboard for analysis.\nStatistical Testing: Use a basic Z-test (many libraries/Excel templates exist) to analyze whether the conversion rate differences are meaningful.\n\nThe following sequence diagram outlines the process:\n\nProcess diagram\n\nHere’s what a user journey looks like at HyperWrite:\nUser signs up: When a user creates an account, their information is stored in the database and a unique user_id is assigned.\nFirst message sent: The new user interacts with the writing assistant for the first time.\nRate limit triggers: After a set number of messages, a rate limit is reached. This introduces a consistent point where an upgrade prompt can be shown.\nConversion opportunity: Some users opt to subscribe at this point—they are directed to Stripe checkout.\nWe care about two key Stripe actions:\nStripe event listening: The system listens for the checkout.session.completed event from Stripe’s webhook, which fires when a payment succeeds.\nDatabase update: When the webhook is received, the corresponding user_id is marked as converted in the database.\nRoutinely check to see if the test is done:\nQuery test groups: Retrieve all users assigned to each model variant.\nJoin Stripe data: Merge your user data with Stripe subscription events, so you know exactly which users in each group converted.\nRun stats: Use a one-tailed two-proportion Z-test (see the previous section) to check if the difference in conversion rates is statistically meaningful.\nA primary lesson from this approach is that real-world testing tied to business metrics (such as Stripe conversions) can reveal which model choices actually drive results for your product. While offline benchmarks and lab tests have their place, connecting evaluation to the moment a user decides to pay often leads to decisions that benefit both customers and the business.\nBeating your incumbent model is not always necessary; a model that performs “as well” on your key metric at a lower cost can be valuable. In this case, OpenAI’s GPT-4.1 matched the incumbent’s Stripe conversion rate while reducing cost.\n\nThis underscores the value of tying model evaluation to Stripe-driven A/B tests—you gain clear, revenue-linked answers rather than relying solely on benchmarks or subjective impressions.\n\nStartups can extend this testing in several directions:\nSegment by persona or use case:** Divide your audience (e.g., power users vs. newcomers, different industries) and see which models or prompts perform best for each group.\nFind the revenue–cost sweet spot:** Consider not only top-line revenue but also the cost to serve each model. The optimal choice may balance profit rather than maximize sales alone.\nMonitor long-term impact:** Look beyond immediate conversions. Track metrics like subscriber lifetime value, churn, or retention to optimize for sustainable growth.\n\nThere’s a lot of room to get creative with what you measure and how you experiment, so you can tune your product for what matters most to your team.\n\nFor questions about this type of testing, feedback on your approach, or input on setting up your own test, feel free to reach out: josh@othersideai.com.\n\nHere’s to building, experimenting, and letting your users—and your Stripe dashboard—guide the way.\n\n\nThis cookbook was contributed by Josh Bickett, Lead Engineer at HyperWrite, a company building AI-powered writing tools and research assistants. The methods and case studies reflect HyperWrite's experience but are intended as a general guide for startups evaluating LLMs using payment conversion metrics."])</script><script>self.__next_f.push([1,"10e:T1464,"])</script><script>self.__next_f.push([1,"This notebook evaluates a model's ability to answer questions about the tiktoken GitHub repository using the OpenAI Evals framework with a custom in-memory dataset.\n\nWe use a custom, in-memory dataset of Q\u0026A pairs and compare two models: gpt-4.1 and o4-mini, that leverage the MCP tool for repository-aware, contextually accurate answers.\n\nGoals:\nShow how to set up and run an evaluation using OpenAI Evals with a custom dataset.\nCompare the performance of different models leveraging MCP-based tools.\nProvide best practices for professional, reproducible evaluation workflows.\n\nNext: We will set up our environment and import the necessary libraries.\n\nWe begin by importing the required libraries and configuring the OpenAI client.\nThis step ensures we have access to the OpenAI API and all necessary utilities for evaluation.\n\nWe define a small, in-memory dataset of question-answer pairs about the tiktoken repository.\nThis dataset will be used to test the models' ability to provide accurate and relevant answers with the help of the MCP tool.\n\nEach item contains a query (the user’s question) and an answer (the expected ground truth).\nYou can modify or extend this dataset to suit your own use case or repository.\n\n\nTo evaluate the model’s answers, we use two graders:\n\nPass/Fail Grader (LLM-based):**\n  An LLM-based grader that checks if the model’s answer matches the expected answer (ground truth) or conveys the same meaning.\nPython MCP Grader:**\n  A Python function that checks whether the model actually used the MCP tool during its response (for auditing tool usage).\nBest Practice:\nUsing both LLM-based and programmatic graders provides a more robust and transparent evaluation.\n\n\nWe now configure the evaluation using the OpenAI Evals framework.\n\nThis step specifies:\nThe evaluation name and dataset.\nThe schema for each item (what fields are present in each Q\u0026A pair).\nThe grader(s) to use (LLM-based and/or Python-based).\nThe passing criteria and labels.\nBest Practice:\nClearly defining your evaluation schema and grading logic up front ensures reproducibility and transparency.\n\nWe now run the evaluation for each model (gpt-4.1 and o4-mini).\n\nEach run is configured to:\nUse the MCP tool for repository-aware answers.\nUse the same dataset and evaluation configuration for fair comparison.\nSpecify model-specific parameters (such as max completions tokens, and allowed tools).\nBest Practice:\nKeeping the evaluation setup consistent across models ensures results are comparable and reliable.\n\nAfter launching the evaluation runs, we can poll the run until they are complete.\n\nThis step ensures that we are analyzing results only after all model responses have been processed.\nBest Practice:\nPolling with a delay avoids excessive API calls and ensures efficient resource usage.\n\nFinally, we display the outputs from each model for manual inspection and further analysis.\n\nEach model's answers are printed for each question in the dataset.\nYou can compare the outputs side-by-side to assess quality, relevance, and correctness.\n\nBelow are screenshots from the OpenAI Evals Dashboard illustrating the evaluation outputs for both models:\n\nEvaluation Output\n\nFor a comprehensive breakdown of the evaluation metrics and results, navigate to the \"Data\" tab in the dashboard:\n\nEvaluation Data Tab\nNote that the 4.1 model was constructed to never use its tools to answer the query thus it never called the MCP server. The o4-mini model wasn't explicitly instructed to use it's tools either but it wasn't forbidden, thus it called the MCP server 3 times. We can see that the 4.1 model performed worse than the o4 model. Also notable is the one example that the o4-mini model failed was one where the MCP tool was not used.\n\nWe can also check a detailed analysis of the outputs from each model for manual inspection and further analysis.\n\nIf we add the phrase \"Always use your tools since they are the way to get the right answer in this task.\" to the system message of the o4-mini model, what do you think will happen? (try it out)\n\n\n\n\nIf you guessed that the model would now call to MCP tool everytime and get every answer correct, you are right!\nEvaluation Data Tab\nEvaluation Data Tab\nIn this notebook, we demonstrated a sample workflow for evaluating the ability of LLMs to answer technical questions about the tiktoken repository using the OpenAI Evals framework leveraging MCP tooling.\n\nKey points covered:\nDefined a focused, custom dataset for evaluation.\nConfigured LLM-based and Python-based graders for robust assessment.\nCompared two models (gpt-4.1 and o4-mini) in a reproducible and transparent manner.\nRetrieved and displayed model outputs for automated/manual inspection.\n\nNext steps:\nExpand the dataset:** Add more diverse and challenging questions to better assess model capabilities.\nAnalyze results:** Summarize pass/fail rates, visualize performance, or perform error analysis to identify strengths and weaknesses.\nExperiment with models/tools:** Try additional models, adjust tool configurations, or test on other repositories.\nAutomate reporting:** Generate summary tables or plots for easier sharing and decision-making.\n\nFor more information, check out the OpenAI Evals documentation."])</script><script>self.__next_f.push([1,"10f:Te11,"])</script><script>self.__next_f.push([1,"This notebook walks you through a set of focused, runnable examples how to use the OpenAI Evals framework to test, grade, and iterate on tasks that require large‑language models to produce structured outputs.\nWhy does this matter?\nProduction systems often depend on JSON, SQL, or domain‑specific formats.  Relying on spot checks or ad‑hoc prompt tweaks quickly breaks down.  Instead, you can codify expectations as automated evals and let your team ship with safety bricks instead of sand.\n\n\n\nSection 1 – Prerequisites**: environment variables and package setup\nSection 2 – Walk‑through: Code‑symbol extraction**: end‑to‑end demo that grades the model’s ability to extract function and class names from source code.  We keep the original logic intact and simply layer documentation around it.\nSection 3 – Additional Recipes**: sketches of common production patterns such as sentiment extraction as additional code sample for evaluation.\nSection 4 – Result Exploration**: lightweight helpers for pulling run output and digging into failures.\n\nInstall dependencies (minimum versions shown):\n\npip install --upgrade openai\n\nAuthenticate by exporting your key:\n\nexport OPENAI_API_KEY=\"sk‑...\"\n\nOptional: if you plan to run evals in bulk, set up an organization‑level key with appropriate limits.\n\n\nThe goal is to extract all function, class, and constant symbols from python files inside the OpenAI SDK.\nFor each file we ask the model to emit structured JSON like:\n\n{\n  \"symbols\": [\n    {\"name\": \"OpenAI\", \"kind\": \"class\"},\n    {\"name\": \"Evals\", \"kind\": \"module\"},\n    ...\n  ]\n}\n\nA rubric model then grades completeness (did we capture every symbol?) and quality (are the kinds correct?) on a 1‑7 scale.\n\nLet us walk though an example to evaluate a model's ability to extract symbols from code using the OpenAI Evals framework with a custom in-memory dataset.\nCreates an openai.OpenAI client using the OPENAI_API_KEY we exported above.  Nothing will run without this.\nget_dataset builds a small in-memory dataset by reading several SDK files.\nstructured_output_grader defines a detailed evaluation rubric.\nclient.evals.create(...) registers the eval with the platform.\nHere we launch two runs against the same eval: one that calls the Completions endpoint, and one that calls the Responses endpoint.\nNext, we will use a simple loop that waits for all runs to finish, then saves each run’s JSON to disk so you can inspect it later or attach it to CI artifacts.\nWe will fetch the output items for both runs so we can print or post‑process them.\nLet us print a side-by-side view of completions vs responses.\n\nBelow are visualizations that represent the evaluation data and code outputs for structured QA evaluation. These images provide insights into the data distribution and the evaluation workflow.\n\nEvaluation Data Overview\n\nEvaluation Data Part 1\n\nEvaluation Data Part 2\n\nEvaluation Code Workflow\n\nEvaluation Code Structure\n\nBy reviewing these visualizations, you can better understand the structure of the evaluation dataset and the steps involved in evaluating structured outputs for QA tasks.\n\nIn a similar way, let us evaluate a multi-lingual sentiment extraction model with structured outputs.\nimage\n\nIn this notebook, we have demonstrated how to use the OpenAI Evaluation API to evaluate a model's performance on a structured output task.\n\nNext steps:\nWe encourage you to try out the API with your own models and datasets.\nYou can also explore the API documentation for more details on how to use the API.\n\nFor more information, see the OpenAI Evals documentation."])</script><script>self.__next_f.push([1,"110:T89d,"])</script><script>self.__next_f.push([1,"This cookbook shows how to measure and improve a model’s ability to extract structured information from source code with tool evaluation. In this case, the set of symbols (functions, classes, methods, and variables) defined in Python files.\n\nInstall the latest openai Python package ≥ 1.14.0 and set your OPENAI_API_KEY environment variable.  If you also want to evaluate an assistant with tools, enable the Assistants v2 beta in your account.\n\npip install --upgrade openai\nexport OPENAI_API_KEY=sk‑...\nBelow we import the SDK, create a client, and define a helper that builds a small dataset from files inside the openai package itself.\nget_dataset builds a small in-memory dataset by reading several SDK files.\nstructured_output_grader defines a detailed evaluation rubric.\nsampled.output_tools[0].function.arguments.symbols specifies the extracted symbols from the code file based on the tool invocation.\nclient.evals.create(...) registers the eval with the platform.\n\nHere we create an eval that will be used to evaluate the quality of extracted information from code files.\n\nHere we launch two runs against the same eval: one that calls the Completions endpoint, and one that calls the Responses endpoint.\n\nWe create a utility poller that will be used to poll for the results of the eval runs.\n\nFor both completions and responses, we print the symbols dictionary that the model returned. You can diff this against the reference answer or compute precision / recall.\n\nYou can navigate to the Evals Dashboard in order to visualize the data.\n\n\nevals_tool_dashboard\n\n\nYou can also take a look at the explanation of the failed results in the Evals Dashboard after the run is complete as shown in the image below.\n\nevals_tool_failed\n\n\n\nThis notebook demonstrated how to use OpenAI Evals to assess and improve a model’s ability to extract structured information from Python code using tool calls.\n\nOpenAI Evals provides a robust, reproducible framework for evaluating LLMs on structured extraction tasks. By combining clear tool schemas, rigorous grading rubrics, and well-structured datasets, you can measure and improve overall performance.\n\nFor more details, see the OpenAI Evals documentation."])</script><script>self.__next_f.push([1,"111:Tc70,"])</script><script>self.__next_f.push([1,"This notebook demonstrates how to evaluate a model's ability to retrieve correct answers from the web using the OpenAI Evals framework with a custom in-memory dataset.\n\nGoals:\nShow how to set up and run an evaluation for web search quality.\nProvide a template for evaluating information retrieval capabilities of LLMs.\n\n\n\n\nWe begin by importing the required libraries and configuring the OpenAI client.\nThis ensures we have access to the OpenAI API and all necessary utilities for evaluation.\n\nWe define a small, in-memory dataset of question-answer pairs for web search evaluation.\nEach item contains a query (the user's search prompt) and an answer (the expected ground truth).\nTip:\nYou can modify or extend this dataset to suit your own use case or test broader search scenarios.\n\nTo evaluate the model’s answers, we use an LLM-based pass/fail grader:\n\nPass/Fail Grader:**\n  An LLM-based grader that checks if the model’s answer (from web search) matches the expected answer (ground truth) or contains the correct information.\nBest Practice:\nUsing an LLM-based grader provides flexibility for evaluating open-ended or fuzzy responses.\n\nWe now configure the evaluation using the OpenAI Evals framework.\n\nThis step specifies:\nThe evaluation name and dataset.\nThe schema for each item (what fields are present in each Q\u0026A pair).\nThe grader(s) to use (LLM-based pass/fail).\nThe passing criteria and labels.\nBest Practice:\nClearly defining your evaluation schema and grading logic up front ensures reproducibility and transparency.\n\nWe now run the evaluation for the selected models (gpt-4.1 and gpt-4.1-mini).\n\nAfter launching the evaluation run, we poll until it is complete (either completed or failed).\nBest Practice:\nPolling with a delay avoids excessive API calls and ensures efficient resource usage.\n\nFinally, we display the outputs from the model for manual inspection and further analysis.\n\nEach answer is printed for each query in the dataset.\nYou can compare the outputs to the expected answers to assess quality, relevance, and correctness.\n\nYou can visualize the results in the evals dashboard by going to https://platform.openai.com/evaluations as shown in the image below:\n\nevals-websearch-dashboard\n\nIn this notebook, we demonstrated a workflow for evaluating the web search capabilities of language models using the OpenAI Evals framework.\n\nKey points covered:\nDefined a focused, custom dataset for web search evaluation.\nConfigured an LLM-based grader for robust assessment.\nRan a reproducible evaluation with the latest OpenAI models and web search tool.\nRetrieved and displayed model outputs for inspection.\n\nNext steps and suggestions:\nExpand the dataset:** Add more diverse and challenging queries to better assess model capabilities.\nAnalyze results:** Summarize pass/fail rates, visualize performance, or perform error analysis to identify strengths and weaknesses.\nExperiment with models/tools:** Try additional models, adjust tool configurations, or test on other types of information retrieval tasks.\nAutomate reporting:** Generate summary tables or plots for easier sharing and decision-making.\n\nFor more information, see the OpenAI Evals documentation."])</script><script>self.__next_f.push([1,"112:T1d33,"])</script><script>self.__next_f.push([1,"The Deep Research API enables you to automate complex research workflows that require reasoning, planning, and synthesis across real-world information. It is designed to take a high-level query and return a structured, citation-rich report by leveraging an agentic model capable of decomposing the task, performing web searches, and synthesizing results.\n\nUnlike ChatGPT where this process is abstracted away, the API provides direct programmatic access. When you send a request, the model autonomously plans sub-questions, uses tools like web search and code execution, and produces a final structured response. This cookbook will provide a brief introduction to the Deep Research API and how to use it.\n\nYou can access Deep Research via the responses endpoint using the following models:\n\no3-deep-research-2025-06-26: Optimized for in-depth synthesis and higher-quality output\no4-mini-deep-research-2025-06-26: Lightweight and faster, ideal for latency-sensitive use cases\n\nInstall the latest version of the OpenAI Python SDK.\nImport the OpenAI client and initialize with your API key.\n\nLet’s walk through an example of a Deep Research API call. Imagine we’re working at a healthcare financial services firm tasked with producing an in-depth report on the economic implications of recent medications used to treat type 2 diabetes and obesity—particularly semaglutide. Our goal is to synthesize clinical outcomes, cost-effectiveness, and regional pricing data into a structured, citation-backed analysis that could inform investment, payer strategy, or policy recommendations.\n\nTo get started, let's:\nPut our role in the system message, outlining what type of report we'd like to generate\nSet the summary paramter to \"auto\" for now for the best available summary. (If you'd like for your report to more detailed, you can set summary to detailed)\nInclude the required tool web_search_preview and optionally add code_interpreter.\nSet the background parameter to True. Since a Deep Research task can take several minutes to execute, enabling background mode will allow you to run the request asynchronously without having to worry about timeouts or other connectivity issues.\n\nThe Deep Research API response includes a structured final answer along with inline citations, summaries of the reasoning steps, and source metadata.\n\n\nHere's the main text output of this report.\n\nInline citations in the response text are annotated and linked to their corresponding source metadata. Each annotation contains:\nstart_index and end_index: the character span in the text the citation refers to\ntitle: a brief title of the source\nurl: the full source URL\n\nThis structure will allow you to build a citation list or bibliography, add clickable hyperlinks in downstream apps, and highlight \u0026 trace data-backed claims in your report.\nThe Deep Research API also exposes all intermediate steps taken by the agent, including reasoning steps, web search calls, and code executions. You can use these to debug, analyze, or visualize how the final answer was constructed.\nEach intermediate step is stored in response.output, and the type field indicates what kind it is.\n\nThese represent internal summaries or plans generated by the model as it reasons through sub-questions.\nThese show what search queries were executed and can help you trace what information the model retrieved.\nIf the model used the code interpreter (e.g. for parsing data or generating charts), those steps will appear as type \"code_interpreter_call\" or similar.\n\nSuppose you would like to pull in your own internal documents as part of a Deep Research task. The Deep Research models and the Responses API both support MCP-based tools, so you can extend them to query your private knowledge stores or other 3rd party services.\n\nIn the example below, we configure an MCP tool that lets Deep Research fetch your organizations internal semaglutide studies on demand. The MCP server is a proxy for the OpenAI File Storage service that automagically vectorizes your uploaded files for performant retrieval.\n\nIf you would like to see how we built this simple MCP server, refer to this related cookbook.\n\nFirst 100 characters of your Research Report, followed by Citations and MCP tool calls.\nIf you’ve used Deep Research in ChatGPT, you may have noticed that it often asks follow-up questions after you submit a query. This is intentional: ChatGPT uses an intermediate model (like gpt-4.1) to help clarify your intent and gather more context (such as your preferences, goals, or constraints) before the research process begins. This extra step helps the system tailor its web searches and return more relevant and targeted results.\n\nIn contrast, the Deep Research API skips this clarification step. As a developer, you can configure this processing step to rewrite the user prompt or ask a set of clarifying questions, since the model expects fully-formed prompts up front and will not ask for additional context or fill in missing information; it simply starts researching based on the input it receives.\n\nTo get strong, reliable outputs from the API, you can use two approaches.\nUse a prompt rewriter using another lightweight model (e.g., gpt-4.1) to expand or specify user queries before passing them to the research model.\nInclude all relevant details: desired scope, comparisons, metrics, regions, preferred sources, and expected output format.\n\nThis setup gives developers full control over how research tasks are framed, but also places greater responsibility on the quality of the input prompt. Here's an example of a generic rewriting_prompt to better direct the subsequent deep research query.\n\n../../images/intro_dr.png\n\nHere's an example of a rewriting prompt:\nIn this instance, a user submitted a generic or open-ended query without specifying key details like travel dates, destination preferences, budget, interests, or travel companions; the rewriting prompt rewrote the query so Deep Research will attempt to generate a broad and inclusive response that anticipates common use cases.\n\nWhile this behavior can be helpful in surfacing a wide range of options, it often leads to verbosity, higher latency, and increased token usage, as the model must account for many possible scenarios. This is especially true for queries that trigger complex planning or synthesis tasks (e.g. multi-destination travel itineraries, comparative research, product selection).\n\nInstead of proceeding immediately with a broad research plan, let's trying using a lighter weight model to gently ask clarification questions from the user before generating a full answer and then using the rewriting prompt for clearer output for the model.\nAnd there you have it! A deep research report crafted for your upcoming trip to France!\n\nIn this notebook, we explored how to use the Deep Research API to automate complex, real-world research tasks, from analyzing the economic impact of semaglutide to planning a trip to France that works for you. Deep Research shines when you need structured, citation-backed answers grounded in real-world evidence. Some standout use cases include:\nProduct comparisons and market analyses\nCompetitive intelligence and strategy reports\nTechnical literature reviews and policy synthesis\n\n\nWhether you're looking to build research agents, generate structured reports, or integrate high-quality synthesis into your workflows, we hope the examples here help you get started.\n\nWhat's next? Deep Research Agents"])</script><script>self.__next_f.push([1,"113:T11e2,"])</script><script>self.__next_f.push([1,"This cookbook demonstrates how to build Agentic research workflows using the OpenAI Deep Research API and the OpenAI Agents SDK. It is a continuation of a fundamentals cookbook, if you have not already familiarized yourself with that content, please consider doing so.\n\nYou’ll learn how to orchestrate single and multi-agent pipelines, enrich user queries to maximize output quality, stream research progress, integrate web search and MCP for internal file search, and architect a robust research application.\n\nConsider using Deep Research Agents for tasks that require planning, synthesis, tool use, or multi-step reasoning. Do not use Deep Research for trivial fact lookups, simple Q\u0026A, or short-form chat, a vanilla openai.responsesAPI would be faster and cheaper.\nOpenAI API key (set as OPENAI_API_KEY in your environment)\nAgents SDK and OpenAI Python SDK\n\nInstall dependencies\n\nZero Data Retention\n\nWe disable Data Retention through the os.environ setting below. This allows Enterprises to operate in a Zero Data Retention environment with Deep Research. If Data Retention is not an active constraint for you, then consider keeping it enabled so you can have automated tracability for your agent workflows and deep integration with other platform tools like evaluations and fine tuning.\n\nThe Basic Research Agent performs Deep Research using the o4-mini-deep-research-alpha model. It has native WebSearch access to the public internet and streams its findings directly back into the notebook. In this case we are using the o4-mini-deep-research-alpha model, because it is faster than the full o3 deep research model, with acceptable intelligence.\n\nLearning objective:\n\nAfter this, you can run a single-agent research task and stream its progress.\n\nMulti-Agent Deep Research\n\nConsider how you might further improve the Research quality \"Deep Research\" produces. In this case, we are leveraging a multi-agent architecture to enrich the prompt with more information about the users query and what we expect to see in the final research report, before submitting it to a deep research agent.\n\n\nThe supporting Agent prompts are specifically designed to improve the quality of the final research output by providing structure and rigor to the users intial query.\n\nTriage Agent\n   Inspects the user’s query\n   If context is missing, routes to the Clarifier Agent; otherwise routes to the Instruction Agent\n\nClarifier Agent\n   Asks follow-up questions\n   Waits for user (or mock) answers\n\nInstruction Builder Agent\n   Converts the enriched input into a precise research brief\n\nResearch Agent (o3-deep-research)\n   Performs web-scale empirical research with WebSearchTool\n   Performs a search against internal knowledge store using MCP, if there are relevant documents, the agent incorporates those relevant snippets in its reference material.\n   Streams intermediate events for transparency\n   Outputs final Research Artifact (which we later parse)\n\n../../images/agents_dr.png\n\nFor more insight into how the MCP server is build. See this resource.\n\nAlthough provided natively through Agent SDK traces you may want to print human-readable high-level agent interaction flow with tool calls. Run print_agent_interaction to get a simplified readable sequence of agent steps, including: Agent name, Type of event (handoff, tool call, message output), Brief tool call info (tool name and arguments).\n\n\nBelow is a Python snippet to extract and print the URL citations related to the final output:\n\nWith the patterns in this notebook, you now have a foundation for building scalable, production-ready research workflows using OpenAI Deep Research Agents. The examples demonstrate not only how to orchestrate multi-agent pipelines and stream research progress, but also how to integrate web search and MCP for external knowledge access.\n\nBy leveraging agentic workflows, you can move beyond simple Q\u0026A to tackle complex, multi-step research tasks that require planning, synthesis, and tool use. The modular multi-agent design: triage, clarification, instruction, and research agents enables you to adapt these pipelines to a wide range of domains and use cases, from healthcare and finance to technical due diligence and market analysis.\n\nAs the Deep Research API and Agents SDK continue to evolve, these patterns will help you stay at the forefront of automated, data-backed research. Whether you’re building internal knowledge tools, automating competitive intelligence, or supporting expert analysts, these workflows provide a strong, extensible starting point.\n\nHappy researching!"])</script><script>self.__next_f.push([1,"114:Tc34,"])</script><script>self.__next_f.push([1,"This is a minimal example of a Deep Research style MCP server for searching and fetching files from the OpenAI file storage service.\n\nFor a reference of how to call this service from the Responses API, with Deep Research see this cookbook. To see how to call the MCP server with the Agents SDK, checkout this cookbook!\n\nThe Deep Research agent relies specifically on Search and Fetch tools. Search should look through your object store for a set of specfic, top-k IDs. Fetch, is a tool that takes objectIds as arguments and pulls back the relevant resources.\n\n\nStore your internal file(s) in OpenAI Vector Storage\n\nPython setup:\n\npython3 -m venv env\nsource env/bin/activate\npip install -r requirements.txt\n\nRun the server:\n\npython main.py\n\nThe server will start on http://0.0.0.0:8000/sse/ using SSE transport. If you want to reach the server from the public internet, there are a variety of ways to do that including with ngrok:\n\nbrew install ngrok\nngrok config add-authtoken\nngrok http 8000\n\nYou should now be able to reach your local server from your client.\n\nmain.py: Main server code\n\n\n../../../images/mcp_dr.png\n\n\nsystem_message = \"\"\"\nYou are a professional researcher preparing a structured, data-driven report on behalf of a global health economics team. Your task is to analyze the health question the user poses.\n\nDo:\nFocus on data-rich insights: include specific figures, trends, statistics, and measurable outcomes (e.g., reduction in hospitalization costs, market size, pricing trends, payer adoption).\nWhen appropriate, summarize data in a way that could be turned into charts or tables, and call this out in the response (e.g., \"this would work well as a bar chart comparing per-patient costs across regions\").\nPrioritize reliable, up-to-date sources: peer-reviewed research, health organizations (e.g., WHO, CDC), regulatory agencies, or pharmaceutical earnings reports.\nInclude an internal file lookup tool to retrieve information from our own internal data sources. If you've already retrieved a file, do not call fetch again for that same file. Prioritize inclusion of that data.\nInclude inline citations and return all source metadata.\n\nBe analytical, avoid generalities, and ensure that each section supports data-backed reasoning that could inform healthcare policy or financial modeling.\n\"\"\"\n\nuser_query = \"Research the economic impact of semaglutide on global healthcare systems.\"\n\nresponse = client.responses.create(\n  model=\"o3-deep-research-2025-06-26\",\n  input=[\n    {\n      \"role\": \"developer\",\n      \"content\": [\n        {\n          \"type\": \"input_text\",\n          \"text\": system_message,\n        }\n      ]\n    },\n    {\n      \"role\": \"user\",\n      \"content\": [\n        {\n          \"type\": \"input_text\",\n          \"text\": user_query,\n        }\n      ]\n    }\n  ],\n  reasoning={\n    \"summary\": \"auto\"\n  },\n  tools=[\n    {\n      \"type\": \"web_search_preview\"\n    },\n    { # ADD MCP TOOL SUPPORT\n      \"type\": \"mcp\",\n      \"server_label\": \"internal_file_lookup\",\n      \"server_url\": \"http://0.0.0.0:8000/sse/\", # Update to the location of your MCP server\n      \"require_approval\": \"never\"\n    }\n  ]\n)"])</script><script>self.__next_f.push([1,"115:Td7e,"])</script><script>self.__next_f.push([1,"This cookbook shows how you can leverage the input_fidelity parameter, available in the Image API and the Responses image generation tool, to preserve distinctive features from the input.\n\nSetting input_fidelity=\"high\" is especially useful when editing images with faces, logos, or any other details that require high fidelity in the output.\n\nIf you're not already familiar with image generation using the OpenAI API, we recommend starting with our introductory image generation cookbook.\n\n\nHigh input fidelity allows you to make subtle edits to an image without altering unrelated areas. This is ideal for controlled, localized changes.\n\nExample use cases:\nItem edits:** Change isolated elements (e.g., swap a mug color) while leaving everything else untouched.\nElement removal:** Cleanly remove an isolated element without changing the rest of the picture.\nElement addition:** Seamlessly insert new objects into a scene.\n\n\nWhen using high input fidelity, faces are preserved far more accurately than in standard mode. Use this when you need people to remain recognizable across edits.\n\nExample use cases:\nImage editing:** Edit your photos while preserving facial features.\nPersonalization:** Create avatars that still look like the original person across different backgrounds or styles.\nPhoto merge:** Combine faces from multiple pictures into one image.\n\nNote: Currently, while all input images are preserved with high fidelity, only the first one you provide is preserved with extra richness in texture. When working with multiple faces from different photos, try combining all needed faces into a single composite image before sending the request (see the example below).\n\nSometimes, maintaining brand identity in generated images is essential. High input fidelity ensures that logos and other unique design elements remain true to the original assets.\n\nExample use cases:\nMarketing assets:** Generate banners or social posts that include your brand logo without distortion.\nMockups:** Place your logo or other brand assets into templates or lifestyle scenes without unintended changes.\nProduct photography:** Change a product’s background for different campaigns while keeping the product's details crisp.\n\n\nE-commerce and fashion often require editing outfits or product details without compromising realism. High input fidelity ensures fabric textures, patterns, and logos remain consistent.\n\nExample use cases:\nOutfit variations:** Change the color or style of clothing on a model photo.\nAccessory addition:** Add jewelry, hats, or other accessories to a model photo without altering their pose or face.\nProduct extraction:** Show the same product or outfit in new settings while keeping details intact.\n\nIn this example, we'll combine 2 input images. The image containing the face should be provided as the first input as more details are retained from the first image.\nIn this guide, we covered how to enable high input fidelity to better preserve important visual details from input images.\n\nUse the example use cases above as inspiration, and try the parameter with your own images to see where high input fidelity makes the biggest difference.\n\nKeep in mind that high input fidelity consumes more image input tokens than the default. Also, while all input images are processed with high input fidelity, the first image in the list preserves the finest detail and richest texture, which is especially important for faces.\n\nHappy building!"])</script><script>self.__next_f.push([1,"116:T1121,"])</script><script>self.__next_f.push([1,"This cookbook shows you how to embed the OpenAI Codex CLI into your CI/CD pipeline so that when your builds or tests fail, codex automatically generates \u0026 proposes fixes. The following is an example in a node project with CI running in GitHub Actions.\n\nBelow is the pipeline flow we’ll implement:\n\n\n\n\nA GitHub Repo with Actions workflows\n\nYou’ll need to create OPENAI_API_KEY as an environment variable in GitHub settings under https://github.com/{org-name}/{repo-name}/settings/secrets/actions. You can also set this at org level(for sharing secrets across multiple repos)\n\nCodex requires python as a prerequisite to use codex login\n\nYou’ll need to check the setting to enable actions to create PRs on your repo, and also in your organization:\n\n\n\n\n\n\nThe following YAML shows a GitHub action that auto triggers when CI fails, installs Codex, uses codex exec and then makes a PR on the failing branch with the fix. Replace \"CI\" with the name of the workflow you want to monitor.\nname: Codex Auto-Fix on Failure\n\non:\n  workflow_run:\nTrigger this job after any run of the primary CI workflow completes\n    workflows: [\"CI\"]\n    types: [completed]\n\npermissions:\n  contents: write\n  pull-requests: write\n\njobs:\n  auto-fix:\nOnly run when the referenced workflow concluded with a failure\n    if: ${{ github.event.workflow_run.conclusion == 'failure' }}\n    runs-on: ubuntu-latest\n    env:\n      OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}\n      FAILED_WORKFLOW_NAME: ${{ github.event.workflow_run.name }}\n      FAILED_RUN_URL: ${{ github.event.workflow_run.html_url }}\n      FAILED_HEAD_BRANCH: ${{ github.event.workflow_run.head_branch }}\n      FAILED_HEAD_SHA: ${{ github.event.workflow_run.head_sha }}\n    steps:\n      name: Check OpenAI API Key Set\n        run: |\n          if [ -z \"$OPENAI_API_KEY\" ]; then\n            echo \"OPENAI_API_KEY secret is not set. Skipping auto-fix.\" \u003e\u00262\n            exit 1\n          fi\n      name: Checkout Failing Ref\n        uses: actions/checkout@v4\n        with:\n          ref: ${{ env.FAILED_HEAD_SHA }}\n          fetch-depth: 0\n\n      name: Setup Node.js\n        uses: actions/setup-node@v4\n        with:\n          node-version: '20'\n          cache: 'npm'\n\n      name: Install dependencies\n        run: |\n          if [ -f package-lock.json ]; then npm ci; else npm i; fi\n      name: Run Codex\n        uses: openai/codex-action@main\n        id: codex\n        with:\n          openai_api_key: ${{ secrets.OPENAI_API_KEY }}\n          prompt: \"You are working in a Node.js monorepo with Jest tests and GitHub Actions. Read the repository, run the test suite, identify the minimal change needed to make all tests pass, implement only that change, and stop. Do not refactor unrelated code or files. Keep changes small and surgical.\"\n          codex_args: '[\"--config\",\"sandbox_mode=\\\"workspace-write\\\"\"]'\n\n      name: Verify tests\n        run: npm test --silent\n\n      name: Create pull request with fixes\n        if: success()\n        uses: peter-evans/create-pull-request@v6\n        with:\n          commit-message: \"fix(ci): auto-fix failing tests via Codex\"\n          branch: codex/auto-fix-${{ github.event.workflow_run.run_id }}\n          base: ${{ env.FAILED_HEAD_BRANCH }}\n          title: \"Auto-fix failing CI via Codex\"\n          body: |\n            Codex automatically generated this PR in response to a CI failure on workflow ${{ env.FAILED_WORKFLOW_NAME }}.\n            Failed run: ${{ env.FAILED_RUN_URL }}\n            Head branch: ${{ env.FAILED_HEAD_BRANCH }}\n            This PR contains minimal changes intended solely to make the CI pass.\n\n\nYou can navigate to the Actions tab under Repo to view the failing jobs in your Actions workflow.\n\nThe Codex workflow should be triggered upon completion of the failed workflow.\n\nAnd after the Codex workflow completes execution, it should open a pull request from the feature branch codex/auto-fix. Check to see if everything looks good and then merge it.\n\n\n\n\n\nThis automation seamlessly integrates OpenAI Codex CLI with GitHub Actions to automatically propose fixes for failing CI runs.\n\nBy leveraging Codex, you can reduce manual intervention, accelerate code reviews, and keep your main branch healthy. The workflow ensures that test failures are addressed quickly and efficiently, letting developers focus on higher-value tasks. Explore more about codex-cli and its capabilities here."])</script><script>self.__next_f.push([1,"117:T3036,"])</script><script>self.__next_f.push([1,"This cookbook provides a practical guide on how to use the OpenAI Platform to easily build resilience into your prompts.\nA resilient prompt is one that provides high-quality responses across the full breadth of possible inputs.\n\nPrompt resilience is an essential piece of deploying AI applications in production. Without this property, your prompts can produce unexpected results on edge cases, provide subpar responses in normal cases, and undermine the effectiveness of your AI application.\n\nTo build resilience into your prompts, we recommend the evaluation flywheel process — a methodology that enables builders to continuously refine their AI applications over time in a measurable way.\n\n\nThis cookbook is designed for subject-matter experts, solutions architects, data scientists, and AI engineers who are looking to improve the general consistency and quality of their prompts, or address specific edge cases in their AI applications.\n\n\n\nAI applications often feel brittle. A prompt that works well one day can produce unexpected and low-quality results the next. This happens because prompts can be sensitive to small changes in user input or context. To build reliable AI products, we need a systematic way to make prompts more resilient.\n\nThe solution is a continuous, iterative process called the evaluation flywheel. Instead of guessing what might improve a prompt (\"prompt-and-pray\"), this lifecycle provides a structured engineering discipline to diagnose, measure, and solve problems.\n\nThe flywheel consists of three phases:\n\nAnalyze:\n   Understand how and why your system is failing through qualitative review. Manually examine and annotate examples where the model behaves incorrectly to identify recurring failure modes.\n\nMeasure:\n   Quantify the identified failure modes and set a baseline. You can’t improve what you can’t measure. Create a test dataset and build automated evaluators (“graders”) to score your system’s performance at scale.\n\nImprove:\n   Make targeted improvements such as rewriting prompts, adding better examples, or adjusting system components. With measurement in place, you can immediately see the impact of changes and iterate until failure rates are acceptably low.\n\nThis is a continuous cycle. As you improve the system, new, subtler failure modes emerge — and the flywheel begins again. This process is the core methodology for building robust and reliable AI applications.\n\nEvaluation flywheel\nSource: Shankar, S., \u0026 Husain, H. (2025). Application-Centric AI Evals for Engineers and Technical Product Managers. AI Evals Course Reader.\n\n\nTo illustrate the evaluation process, let’s use data from an apartment leasing assistant in production.\n\nIt answers questions from prospective renters, such as:\n\n“How large are the apartments?”\n“When can I come in for a tour?”\n\nSuppose we have a specific prompt within our application that we’d like to analyze. We can get started in the OpenAI Platform by adding in our prompt and uploading our input and output data to our Dataset (learn more about how to do this in our docs).\n\nLeasing agent data\n\nWith our prompt and traces loaded in, we’re ready to analyze prompt effectiveness.\n\n\nTo improve a system, you must first understand how it fails. While automated metrics are useful for tracking progress, they cannot reveal why a failure occurred. Manual analysis of model outputs is the most effective way to diagnose issues and gain insights for targeted improvements.\n\nThe core of this analysis is annotation — applying structured labels to text to categorize and understand failure modes. This turns unstructured failures into an actionable roadmap for improvement. We recommend a two-step method drawn from qualitative research: open coding and axial coding.\n\n\nThe first step is to read through a sample of failing traces (we recommend starting with around 50) and apply descriptive labels to each error you find. In this phase, do not worry about creating a perfect, structured taxonomy. The goal is discovery.\n\nOn the OpenAI Platform, you can use annotation columns to open code your dataset. Here, we add a Feedback-type annotation column titled open_coding to capture our results.\n\nCreating a feedback column\n\nFor our apartment leasing assistant, our initial open codes might look like this:\n\n“bot suggested a tour time that wasn't available”\n“the list of amenities was a single block of text”\n“failed to cancel the original appointment when rescheduling”\n“the link to the floorplan was broken”\n\nThese specific, grounded-in-data labels become the raw material for the next step.\n\nOpen coding\n\nHere's our dataset after open coding.\n\n\nOnce you have a set of open codes, the next step is to group them into higher-level categories. This is axial coding—the process of identifying relationships between your initial labels to build a structured understanding of the core problems.\n\nWe can group our open codes into predefined axial codes:\n\nTour scheduling/rescheduling issue:**\n  Bot suggested a tour time that wasn't available\n  Failed to cancel the original appointment when rescheduling\nFormatting error with output:**\n  The list of amenities was a single block of text\n  The link to the floorplan was broken\n\nWe will add a new Label-type annotation column titled axial_coding to our dataset to capture this.\n\nAxial coding\n\nThis simple taxonomy gives us a clear, quantitative picture of our system's primary weaknesses. We might discover that 35% of failures are related to tour scheduling, while only 10% are formatting errors. This tells us exactly where to focus our improvement efforts. For more information on how to conduct error analysis, see this walkthrough.\n\n\nArmed with our taxonomy and dataset, we’re now ready to start automating the evaluation flywheel. The OpenAI Platform supports a variety of grader types (including Python graders and LLM graders) that can be run in bulk on our dataset (learn more here). For this example, we can build and run LLM graders for the following:\n\nFormatting grader:** assess whether the model's response matches the desired format\nAvailability accuracy grader:** compares the availability returned by the model to a ground truth value you specify in your dataset\n\nOur formatting grader is a fairly straightforward directive.\nCreating formatting grader\n\nOur availability accuracy grader will reference additional input columns we’ve added to our dataset to capture business hours and day availability.\nCreating availability grader\nGround truth columns\n\nWith automated graders in place, we can easily evaluate our performance on any change to our system — an updated prompt, updated model parameters, or newly discovered edge cases.\n\nFor more detail on how to get graders right, see our section on “Aligning your LLM judge” below.\n\n\nWe’ve now identified and classified our errors, and built out grading to automate our flywheel. At this stage, we could choose to use our data to inform manual changes to our prompt. However, the OpenAI Platform supports an automatic prompt optimization tool that speeds up this process.\n\nThe prompt optimizer takes our generated output, our custom annotation columns, and our graders into consideration to construct an improved prompt. We’ve constructed a fairly small example here, but with a full-fledged dataset (say, with the 50 rows we recommended earlier), the optimizer will produce a new prompt that solves many of our identified errors.\n\nWe may find ourselves wanting to iterate further, by re-annotating new model outputs, adding or refining graders, and re-optimizing. Graders and annotation column specifications are preserved across tabs, so we can continue to create additional prompt versions in new tabs as we work. The tabs also allow us to compare performance across different models, so we can use our graders to measure which model parameter configuration performs best.\n\nThis process enables us to improve our prompt over time, proactively responding to new errors or new model releases.\n\n\n\n\nThe core evaluation flywheel is your primary tool for improving your system. However, there are times when you may need more test data than you can gather from production logs. Synthetic data generation is a powerful, additional technique for these situations. It is particularly useful if you want to more extensively explore a specific failure mode, if you haven't shipped your product yet and need initial data, or if you have a hypothesis about a weakness but lack real-world examples to validate it.\nSimply asking an LLM to \"generate N examples\" often produces a homogenous set of test cases. A more structured approach is to define key dimensions of a query and generate data across combinations of them, forming tuples. This ensures greater diversity and coverage in your test set.\n\nFor our leasing assistant, you could define dimensions such as:\n\nChannel:** Voice, Chat, Text\nIntent:** Tour Scheduling, Maintenance, General Info \u0026 Inquiries\nPersona:** Prospective Resident, Agency\n\nYou can then combine these into a tuple like (Text, Tour Scheduling, Prospective Resident) and prompt an LLM to generate specific test cases that match this profile. This structured method creates challenging, realistic scenarios that a simpler generation process might miss.\n\nIn addition to varying the core components of the query, you can apply perturbations to make test cases harder and more realistic. This involves slightly altering your generated examples to test the system's resilience. Common perturbations include adding irrelevant information, introducing mistakes, or using different slang.\n\nFor a deeper dive into this topic, see this discussion.\n\n\nAn automated LLM judge is only useful if its judgments are trustworthy. To ensure this, you must systematically measure its performance against a human subject-matter expert (SME) using a \"gold standard\" dataset.\n\nHowever, most test sets are imbalanced — they contain far more \"pass\" examples than \"fail\" examples. This makes a simple accuracy score misleading. A judge that always guesses \"pass\" might be 95% accurate but will never find a single failure.\n\nTrue Positive Rate (TPR):* How well does the judge correctly identify the *failures?\nTrue Negative Rate (TNR):* How well does the judge correctly identify the *passes?\n\nThe goal is to achieve high scores on both TPR and TNR. This confirms the judge is effective at finding real problems without being overly critical. This measurement process uses a standard dataset split.\n\nTrain Set (~20%)\n   This set's only job is to provide the \"few-shot\" examples for your judge's prompt. You will select a handful of clear pass/fail cases from this set and embed them directly into the prompt to give it a strong starting point.\n\nValidation Set (~40%)\n   This is where you will iteratively improve your judge. You run the judge against this set and analyze the cases where its decision differs from the expert's. Tune the judge's prompt instructions to improve both its TPR and TNR.\n\nTest Set (~40%)\n   This final, held-out set is your report card. After tuning, run the judge on this set one time. The final TPR and TNR scores confirm you haven't overfit and give you a trustworthy measure of your judge's performance.\n\nFor more guidance on how to align an LLM judge with your SMEs, see this discussion. For more guidance on what model you should use for judging your AI, see this post.\n\n\n\nThis cookbook provides a foundational workflow for building resilient prompts, but the evaluation flywheel doesn't stop after one cycle. The next step is to make this process a core part of your engineering practice by integrating your graders into a CI/CD pipeline and monitoring production data to discover new failure modes.\n\nIn addition, the world of AI evaluations is deep and full of challenges we couldn't cover here. As you work to build out your eval strategy, you'll likely encounter more complex questions, such as:\nHow do I make the case for investing in evaluations to my team?\nWhy is a binary (pass/fail) evaluation often better than a 1-5 rating scale?\nWhat is the best way to debug a complex, multi-turn conversation trace?\nHow should I approach evaluating my RAG system?\nHow does this workflow adapt to agentic systems?\n\nWe recommend exploring this FAQ about Evals for further study."])</script><script>self.__next_f.push([1,"118:T6577,"])</script><script>self.__next_f.push([1,"With Code Review in Codex Cloud, you can connect your team's cloud hosted GitHub repository to Codex and receive automated code reviews on every PR. But what if your code is hosted on-prem, or you don't have GitHub as an SCM?\n\nLuckily, we can replicate Codex's cloud hosted review process in our own CI/CD runners. In this guide, we'll build our own Code Review action using the Codex CLI headless mode with both GitHub Actions and Jenkins.\n\nModel recommendation: use gpt-5.2-codex for the strongest code review accuracy and consistency in these workflows.\n\nTo build our own Code review, we'll take the following steps and adhere to them closely:\n\nInstall the Codex CLI in our CI/CD runner\nPrompt Codex in headless (exec) mode with the Code Review prompt that ships with the CLI\nSpecify a structured output JSON schema for Codex\nParse the JSON result and use it to make API calls to our SCM to create review comments\n\nOnce implemented, Codex will be able to leave inline code review comments:\n\n\n\nGPT-5.2-Codex has received specific training to improve its code review abilities. You can steer GPT-5.2-Codex to conduct a code review with the following prompt:\n\nYou are acting as a reviewer for a proposed code change made by another engineer.\nFocus on issues that impact correctness, performance, security, maintainability, or developer experience.\nFlag only actionable issues introduced by the pull request.\nWhen you flag an issue, provide a short, direct explanation and cite the affected file and line range.\nPrioritize severe issues and avoid nit-level comments unless they block understanding of the diff.\nAfter listing findings, produce an overall correctness verdict (\\\"patch is correct\\\" or \\\"patch is incorrect\\\") with a concise justification and a confidence score between 0 and 1.\nEnsure that file citations and line numbers are exactly correct using the tools available; if they are incorrect your comments will be rejected.\n\n\nIn order to make comments on code ranges in our pull request, we need to receive Codex's response in a specific format. To do that we can create a file called codex-output-schema.json that conforms to OpenAI's structured outputs format.\n\nTo use this file in our workflow YAML, we can call Codex with the output-schema-file argument like this:\n\nname: Run Codex structured review\n        id: run-codex\n        uses: openai/codex-action@main\n        with:\n            openai-api-key: ${{ secrets.OPENAI_API_KEY }}\n            prompt-file: codex-prompt.md\n            sandbox: read-only\n            model: ${{ env.CODEX_MODEL }}\n            output-schema-file: codex-output-schema.json #  codex-output-schema.json\n          {\n              \"type\": \"object\",\n              \"properties\": {\n                \"findings\": {\n                  \"type\": \"array\",\n                  \"items\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                      \"title\": {\n                        \"type\": \"string\",\n                        \"maxLength\": 80\n                      },\n                      \"body\": {\n                        \"type\": \"string\",\n                        \"minLength\": 1\n                      },\n                      \"confidence_score\": {\n                        \"type\": \"number\",\n                        \"minimum\": 0,\n                        \"maximum\": 1\n                      },\n                      \"priority\": {\n                        \"type\": \"integer\",\n                        \"minimum\": 0,\n                        \"maximum\": 3\n                      },\n                      \"code_location\": {\n                        \"type\": \"object\",\n                        \"properties\": {\n                          \"absolute_file_path\": {\n                            \"type\": \"string\",\n                            \"minLength\": 1\n                          },\n                          \"line_range\": {\n                            \"type\": \"object\",\n                            \"properties\": {\n                              \"start\": {\n                                \"type\": \"integer\",\n                                \"minimum\": 1\n                              },\n                              \"end\": {\n                                \"type\": \"integer\",\n                                \"minimum\": 1\n                              }\n                            },\n                            \"required\": [\n                              \"start\",\n                              \"end\"\n                            ],\n                            \"additionalProperties\": false\n                          }\n                        },\n                        \"required\": [\n                          \"absolute_file_path\",\n                          \"line_range\"\n                        ],\n                        \"additionalProperties\": false\n                      }\n                    },\n                    \"required\": [\n                      \"title\",\n                      \"body\",\n                      \"confidence_score\",\n                      \"priority\",\n                      \"code_location\"\n                    ],\n                    \"additionalProperties\": false\n                  }\n                },\n                \"overall_correctness\": {\n                  \"type\": \"string\",\n                  \"enum\": [\n                    \"patch is correct\",\n                    \"patch is incorrect\"\n                  ]\n                },\n                \"overall_explanation\": {\n                  \"type\": \"string\",\n                  \"minLength\": 1\n                },\n                \"overall_confidence_score\": {\n                  \"type\": \"number\",\n                  \"minimum\": 0,\n                  \"maximum\": 1\n                }\n              },\n              \"required\": [\n                \"findings\",\n                \"overall_correctness\",\n                \"overall_explanation\",\n                \"overall_confidence_score\"\n              ],\n              \"additionalProperties\": false\n            }\n          JSON\n        shell: bash\n\nThis section generates our prompt:\n      name: Build Codex review prompt\n        env:\n          REVIEW_PROMPT_PATH: ${{ vars.CODEX_PROMPT_PATH || 'review_prompt.md' }}\n        run: |\n          set -euo pipefail\n          PROMPT_PATH=\"codex-prompt.md\"\n          TEMPLATE_PATH=\"${REVIEW_PROMPT_PATH}\"\n\n          if [ -n \"$TEMPLATE_PATH\" ] \u0026\u0026 [ -f \"$TEMPLATE_PATH\" ]; then\n            cat \"$TEMPLATE_PATH\" \u003e \"$PROMPT_PATH\"\n          else\n            {\n              printf '%s\\n' \"You are acting as a reviewer for a proposed code change made by another engineer.\"\n              printf '%s\\n' \"Focus on issues that impact correctness, performance, security, maintainability, or developer experience.\"\n              printf '%s\\n' \"Flag only actionable issues introduced by the pull request.\"\n              printf '%s\\n' \"When you flag an issue, provide a short, direct explanation and cite the affected file and line range.\"\n              printf '%s\\n' \"Prioritize severe issues and avoid nit-level comments unless they block understanding of the diff.\"\n              printf '%s\\n' \"After listing findings, produce an overall correctness verdict (\\\"patch is correct\\\" or \\\"patch is incorrect\\\") with a concise justification and a confidence score between 0 and 1.\"\n              printf '%s\\n' \"Ensure that file citations and line numbers are exactly correct using the tools available; if they are incorrect your comments will be rejected.\"\n            } \u003e \"$PROMPT_PATH\"\n          fi\n\n          {\n            echo \"\"\n            echo \"Repository: ${REPOSITORY}\"\n            echo \"Pull Request #: ${PR_NUMBER}\"\n            echo \"Base ref: ${{ github.event.pull_request.base.ref }}\"\n            echo \"Head ref: ${{ github.event.pull_request.head.ref }}\"\n            echo \"Base SHA: ${BASE_SHA}\"\n            echo \"Head SHA: ${HEAD_SHA}\"\n            echo \"Changed files:\"\n            git --no-pager diff --name-status \"${BASE_SHA}\" \"${HEAD_SHA}\"\n            echo \"\"\n            echo \"Unified diff (context=5):\"\n            git --no-pager diff --unified=5 --stat=200 \"${BASE_SHA}\" \"${HEAD_SHA}\" \u003e /tmp/diffstat.txt\n            git --no-pager diff --unified=5 \"${BASE_SHA}\" \"${HEAD_SHA}\" \u003e /tmp/full.diff\n            cat /tmp/diffstat.txt\n            echo \"\"\n            cat /tmp/full.diff\n          } \u003e\u003e \"$PROMPT_PATH\"\n        shell: bash\n\nPutting it all together: we run the codex action with our code review prompt,\nstructured output, and output file:\n      name: Run Codex structured review\n        id: run-codex\n        uses: openai/codex-action@main\n        with:\n          openai-api-key: ${{ secrets.OPENAI_API_KEY }}\n          prompt-file: codex-prompt.md\n          output-schema-file: codex-output-schema.json\n          output-file: codex-output.json\n          sandbox: read-only\n          model: ${{ env.CODEX_MODEL }}\n\n      name: Inspect structured Codex output\n        if: ${{ always() }}\n        run: |\n          if [ -s codex-output.json ]; then\n            jq '.' codex-output.json || true\n          else\n            echo \"Codex output file missing\"\n          fi\n        shell: bash\n\nThis step produces in-line code review comments on specific line\nranges of code.\n      name: Publish inline review comments\n        if: ${{ always() }}\n        env:\n          REVIEW_JSON: codex-output.json\n        run: |\n          set -euo pipefail\n          if [ ! -s \"$REVIEW_JSON\" ]; then\n            echo \"No Codex output file present; skipping comment publishing.\"\n            exit 0\n          fi\n          findings_count=$(jq '.findings | length' \"$REVIEW_JSON\")\n          if [ \"$findings_count\" -eq 0 ]; then\n            echo \"Codex returned no findings; skipping inline comments.\"\n            exit 0\n          fi\n          jq -c --arg commit \"$HEAD_SHA\" '.findings[] | {\n              body: (.title + \"\\n\\n\" + .body + \"\\n\\nConfidence: \" + (.confidence_score | tostring) + (if has(\"priority\") then \"\\nPriority: P\" + (.priority | tostring) else \"\" end)),\n              commit_id: $commit,\n              path: .code_location.absolute_file_path,\n              line: .code_location.line_range.end,\n              side: \"RIGHT\",\n              start_line: (if .code_location.line_range.start != .code_location.line_range.end then .code_location.line_range.start else null end),\n              start_side: (if .code_location.line_range.start != .code_location.line_range.end then \"RIGHT\" else null end)\n            } | with_entries(select(.value != null))' \"$REVIEW_JSON\" \u003e findings.jsonl\n          while IFS= read -r payload; do\n            echo \"Posting review comment payload:\" \u0026\u0026 echo \"$payload\" | jq '.'\n            curl -sS \\\n              -X POST \\\n              -H \"Accept: application/vnd.github+json\" \\\n              -H \"Authorization: Bearer ${GITHUB_TOKEN}\" \\\n              -H \"X-GitHub-Api-Version: 2022-11-28\" \\\n              \"https://api.github.com/repos/${REPOSITORY}/pulls/${PR_NUMBER}/comments\" \\\n              -d \"$payload\"\n          done /dev/null 2\u003e\u00261; then\n        ARCH=\"$(uname -m)\"\n        case \"$ARCH\" in\n          x86_64) CODEX_PLATFORM=\"x86_64-unknown-linux-musl\" ;;\n          aarch64|arm64) CODEX_PLATFORM=\"aarch64-unknown-linux-musl\" ;;\n          *)\n            echo \"Unsupported architecture: $ARCH\"\n            exit 1\n            ;;\n        esac\n\n        CODEX_VERSION=\"${CODEX_VERSION:-latest}\"\n        if [ -n \"${CODEX_DOWNLOAD_URL:-}\" ]; then\n          CODEX_URL=\"$CODEX_DOWNLOAD_URL\"\n        elif [ \"$CODEX_VERSION\" = \"latest\" ]; then\n          CODEX_URL=\"https://github.com/openai/codex/releases/latest/download/codex-${CODEX_PLATFORM}.tar.gz\"\n        else\n          CODEX_URL=\"https://github.com/openai/codex/releases/download/${CODEX_VERSION}/codex-${CODEX_PLATFORM}.tar.gz\"\n        fi\n\n        TMP_DIR=\"$(mktemp -d)\"\n        curl -fsSL \"$CODEX_URL\" -o \"$TMP_DIR/codex.tar.gz\"\n        tar -xzf \"$TMP_DIR/codex.tar.gz\" -C \"$TMP_DIR\"\n        install -m 0755 \"$TMP_DIR\"/codex-* /usr/local/bin/codex\n        rm -rf \"$TMP_DIR\"\n      fi\n    git fetch origin $CI_MERGE_REQUEST_TARGET_BRANCH_NAME\n    git fetch origin $CI_MERGE_REQUEST_SOURCE_BRANCH_NAME\n    git checkout $CI_MERGE_REQUEST_SOURCE_BRANCH_NAME\n\n  script:\n    echo \"Running Codex structured review for MR !${PR_NUMBER}\"\n\nGenerate structured output schema\n    |\n      cat  codex-output-schema.json\n      {\n        \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n        \"title\": \"Codex Structured Review\",\n        \"type\": \"object\",\n        \"additionalProperties\": false,\n        \"required\": [\n          \"overall_correctness\",\n          \"overall_explanation\",\n          \"overall_confidence_score\",\n          \"findings\"\n        ],\n        \"properties\": {\n          \"overall_correctness\": {\n            \"type\": \"string\",\n            \"description\": \"Overall verdict for the merge request.\"\n          },\n          \"overall_explanation\": {\n            \"type\": \"string\",\n            \"description\": \"Explanation backing up the verdict.\"\n          },\n          \"overall_confidence_score\": {\n            \"type\": \"number\",\n            \"minimum\": 0,\n            \"maximum\": 1,\n            \"description\": \"Confidence level for the verdict.\"\n          },\n          \"findings\": {\n            \"type\": \"array\",\n            \"description\": \"Collection of actionable review findings.\",\n            \"items\": {\n              \"type\": \"object\",\n              \"additionalProperties\": false,\n              \"required\": [\n                \"title\",\n                \"body\",\n                \"confidence_score\",\n                \"code_location\"\n              ],\n              \"properties\": {\n                \"title\": {\n                  \"type\": \"string\"\n                },\n                \"body\": {\n                  \"type\": \"string\"\n                },\n                \"confidence_score\": {\n                  \"type\": \"number\",\n                  \"minimum\": 0,\n                  \"maximum\": 1\n                },\n                \"code_location\": {\n                  \"type\": \"object\",\n                  \"additionalProperties\": false,\n                  \"required\": [\n                    \"absolute_file_path\",\n                    \"relative_file_path\",\n                    \"line_range\"\n                  ],\n                  \"properties\": {\n                    \"absolute_file_path\": {\n                      \"type\": \"string\"\n                    },\n                    \"relative_file_path\": {\n                      \"type\": \"string\"\n                    },\n                    \"line_range\": {\n                      \"type\": \"object\",\n                      \"additionalProperties\": false,\n                      \"required\": [\n                        \"start\",\n                        \"end\"\n                      ],\n                      \"properties\": {\n                        \"start\": {\n                          \"type\": \"integer\",\n                          \"minimum\": 1\n                        },\n                        \"end\": {\n                          \"type\": \"integer\",\n                          \"minimum\": 1\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            },\n            \"default\": []\n          }\n        }\n      }\n      JSON\n\nBuild Codex review prompt\n    |\n      PROMPT_PATH=\"codex-prompt.md\"\n      TEMPLATE_PATH=\"${REVIEW_PROMPT_PATH:-review_prompt.md}\"\n      if [ -n \"$TEMPLATE_PATH\" ] \u0026\u0026 [ -f \"$TEMPLATE_PATH\" ]; then\n        cat \"$TEMPLATE_PATH\" \u003e \"$PROMPT_PATH\"\n      else\n        {\n          printf '%s\\n' \"You are acting as a reviewer for a proposed code change...\"\n          printf '%s\\n' \"Focus on issues that impact correctness, performance, security...\"\n          printf '%s\\n' \"Flag only actionable issues introduced by this merge request...\"\n          printf '%s\\n' \"Provide an overall correctness verdict...\"\n        } \u003e \"$PROMPT_PATH\"\n      fi\n      {\n        echo \"\"\n        echo \"Repository: ${REPOSITORY}\"\n        echo \"Merge Request #: ${PR_NUMBER}\"\n        echo \"Base SHA: ${BASE_SHA}\"\n        echo \"Head SHA: ${HEAD_SHA}\"\n        echo \"\"\n        echo \"Changed files:\"\n        git --no-pager diff --name-status \"${BASE_SHA}\" \"${HEAD_SHA}\"\n        echo \"\"\n        echo \"Unified diff (context=5):\"\n        git --no-pager diff --unified=5 \"${BASE_SHA}\" \"${HEAD_SHA}\"\n      } \u003e\u003e \"$PROMPT_PATH\"\n\nRun Codex exec CLI\n    |\n      printenv OPENAI_API_KEY | codex login --with-api-key \u0026\u0026 \\\n      codex exec --output-schema codex-output-schema.json \\\n                 --output-last-message codex-output.json \\\n                 --sandbox read-only \\\n                  findings.jsonl\n\n      while IFS= read -r payload; do\n        curl -sS --request POST \\\n             --header \"PRIVATE-TOKEN: $GITLAB_TOKEN\" \\\n             --header \"Content-Type: application/json\" \\\n             --data \"$payload\" \\\n             \"https://gitlab.com/api/v4/projects/${CI_PROJECT_ID}/merge_requests/${PR_NUMBER}/discussions\"\n      done \u003e $WORKSPACE/jenkins.env\n\nDiscover owner/repo (normalize SSH/HTTPS forms)\n          ORIGIN_URL=\"$(git config --get remote.origin.url)\"\n          if echo \"$ORIGIN_URL\" | grep -qE '^git@github.com:'; then\n            REPO_PATH=\"${ORIGIN_URL#git@github.com:}\"\n            REPO_PATH=\"${REPO_PATH%.git}\"\n          else\ne.g. https://github.com/owner/repo.git\n            REPO_PATH=\"${ORIGIN_URL#https://github.com/}\"\n            REPO_PATH=\"${REPO_PATH%.git}\"\n          fi\n          echo \"REPOSITORY=$REPO_PATH\" \u003e\u003e $WORKSPACE/jenkins.env\n\nEnsure we have all refs we need\n          git fetch --no-tags origin \\\n            \"+refs/heads/:refs/remotes/origin/\" \\\n            \"+refs/pull/${PR_NUMBER}/head:refs/remotes/origin/PR-${PR_NUMBER}-head\" \\\n            \"+refs/pull/${PR_NUMBER}/merge:refs/remotes/origin/PR-${PR_NUMBER}-merge\"\n\nHEAD (PR head) and BASE (target branch tip)\n          CHANGE_TARGET=\"${CHANGE_TARGET:-main}\"\n          HEAD_SHA=\"$(git rev-parse refs/remotes/origin/PR-${PR_NUMBER}-head)\"\n          BASE_SHA=\"$(git rev-parse refs/remotes/origin/${CHANGE_TARGET})\"\n\n          echo \"HEAD_SHA=$HEAD_SHA\" \u003e\u003e $WORKSPACE/jenkins.env\n          echo \"BASE_SHA=$BASE_SHA\" \u003e\u003e $WORKSPACE/jenkins.env\n\n          echo \"Resolved:\"\n          echo \"  REPOSITORY=$REPO_PATH\"\n          echo \"  PR_NUMBER=$PR_NUMBER\"\n          echo \"  CHANGE_TARGET=$CHANGE_TARGET\"\n          echo \"  HEAD_SHA=$HEAD_SHA\"\n          echo \"  BASE_SHA=$BASE_SHA\"\n        '''\n        script {\n          def envMap = readProperties file: 'jenkins.env'\n          env.PR_NUMBER  = envMap['PR_NUMBER']\n          env.REPOSITORY = envMap['REPOSITORY']\n          env.HEAD_SHA   = envMap['HEAD_SHA']\n          env.BASE_SHA   = envMap['BASE_SHA']\n        }\n\n        // Ensure only latest build for this PR proceeds; older in-flight builds will be aborted here\n        milestone 1\n      }\n    }\n\n    stage('Generate structured output schema') {\n      steps {\n        sh '''\n          set -euo pipefail\n          cat \u003e codex-output-schema.json  \"$PROMPT_PATH\"\n          else\n            {\n              printf '%s\\n' \"You are acting as a reviewer for a proposed code change made by another engineer.\"\n              printf '%s\\n' \"Focus on issues that impact correctness, performance, security, maintainability, or developer experience.\"\n              printf '%s\\n' \"Flag only actionable issues introduced by the pull request.\"\n              printf '%s\\n' \"When you flag an issue, provide a short, direct explanation and cite the affected file and line range.\"\n              printf '%s\\n' \"Prioritize severe issues and avoid nit-level comments unless they block understanding of the diff.\"\n              printf '%s\\n' \"After listing findings, produce an overall correctness verdict (\\\\\\\"patch is correct\\\\\\\" or \\\\\\\"patch is incorrect\\\\\\\") with a concise justification and a confidence score between 0 and 1.\"\n              printf '%s\\n' \"Ensure that file citations and line numbers are exactly correct using the tools available; if they are incorrect your comments will be rejected.\"\n            } \u003e \"$PROMPT_PATH\"\n          fi\n\n          {\n            echo \"\"\n            echo \"Repository: ${REPOSITORY}\"\n            echo \"Pull Request #: ${PR_NUMBER}\"\n            echo \"Base ref: ${CHANGE_TARGET}\"\n            echo \"Head ref: ${CHANGE_BRANCH:-PR-${PR_NUMBER}-head}\"\n            echo \"Base SHA: ${BASE_SHA}\"\n            echo \"Head SHA: ${HEAD_SHA}\"\n            echo \"Changed files:\"\n            git --no-pager diff --name-status \"${BASE_SHA}\" \"${HEAD_SHA}\"\n            echo \"\"\n            echo \"Unified diff (context=5):\"\n            git --no-pager diff --unified=5 --stat=200 \"${BASE_SHA}\" \"${HEAD_SHA}\" \u003e /tmp/diffstat.txt\n            git --no-pager diff --unified=5 \"${BASE_SHA}\" \"${HEAD_SHA}\" \u003e /tmp/full.diff\n            cat /tmp/diffstat.txt\n            echo \"\"\n            cat /tmp/full.diff\n          } \u003e\u003e \"$PROMPT_PATH\"\n        '''\n      }\n    }\n\n    stage('Run Codex structured review') {\n      environment {\n        REVIEW_PROMPT = 'codex-prompt.md'\n        REVIEW_SCHEMA = 'codex-output-schema.json'\n        REVIEW_OUTPUT = 'codex-output.json'\n      }\n      steps {\n        withCredentials([\n          string(credentialsId: 'openai-api-key', variable: 'OPENAI_API_KEY')\n        ]) {\n          // Option A: If you have the OpenAI CLI installed on the Jenkins agent\n          sh '''\n            set -euo pipefail\n            if command -v openai \u003e/dev/null 2\u003e\u00261; then\nUse the Responses API with a JSON schema tool spec\nProduces codex-output.json with the structured result.\n              openai responses.create \\\n                --model \"${CODEX_MODEL}\" \\\n                --input-file \"${REVIEW_PROMPT}\" \\\n                --response-format \"json_object\" \\\n                --output-schema \"${RESPONSE_FORMAT}\" \\\n                --tool-choice \"auto\" \\\n                \u003e raw_response.json || true\n\nFallback if CLI doesn’t support your exact flags:\nKeep demo resilient: If raw_response.json is empty, create a minimal stub so later steps don’t fail.\n              if [ ! -s raw_response.json ]; then\n                echo '{\"findings\":[],\"overall_correctness\":\"patch is correct\",\"overall_explanation\":\"No issues detected.\",\"overall_confidence_score\":0.5}' \u003e \"${REVIEW_OUTPUT}\"\n              else\nIf your CLI/format returns a JSON object with the structured content in .output or similar, map it here.\nAdjust jq path to match your CLI output shape.\n                jq -r '.output // .' raw_response.json \u003e \"${REVIEW_OUTPUT}\" || cp raw_response.json \"${REVIEW_OUTPUT}\"\n              fi\n            else\n              echo \"openai CLI not found; creating a stub output for demo continuity.\"\n              echo '{\"findings\":[],\"overall_correctness\":\"patch is correct\",\"overall_explanation\":\"(CLI not available on agent)\",\"overall_confidence_score\":0.4}' \u003e \"${REVIEW_OUTPUT}\"\n            fi\n          '''\n        }\n      }\n    }\n\n    stage('Inspect structured Codex output') {\n      steps {\n        sh '''\n          if [ -s codex-output.json ]; then\n            jq '.' codex-output.json || true\n          else\n            echo \"Codex output file missing\"\n          fi\n        '''\n      }\n    }\n\n    stage('Publish inline review comments') {\n      when { expression { true } }\n      steps {\n        withCredentials([string(credentialsId: 'github-token', variable: 'GITHUB_TOKEN')]) {\n          sh '''\n            set -euo pipefail\n            REVIEW_JSON=\"codex-output.json\"\n            if [ ! -s \"$REVIEW_JSON\" ]; then\n              echo \"No Codex output file present; skipping comment publishing.\"\n              exit 0\n            fi\n\n            findings_count=$(jq '.findings | length' \"$REVIEW_JSON\")\n            if [ \"$findings_count\" -eq 0 ]; then\n              echo \"Codex returned no findings; skipping inline comments.\"\n              exit 0\n            fi\n\n            jq -c --arg commit \"$HEAD_SHA\" '.findings[] | {\n                body: (.title + \"\\\\n\\\\n\" + .body + \"\\\\n\\\\nConfidence: \" + (.confidence_score | tostring) + (if has(\"priority\") then \"\\\\nPriority: P\" + (.priority | tostring) else \"\" end)),\n                commit_id: $commit,\n                path: .code_location.absolute_file_path,\n                line: .code_location.line_range.end,\n                side: \"RIGHT\",\n                start_line: (if .code_location.line_range.start != .code_location.line_range.end then .code_location.line_range.start else null end),\n                start_side: (if .code_location.line_range.start != .code_location.line_range.end then \"RIGHT\" else null end)\n              } | with_entries(select(.value != null))' \"$REVIEW_JSON\" \u003e findings.jsonl\n\n            while IFS= read -r payload; do\n              echo \"Posting review comment payload:\" \u0026\u0026 echo \"$payload\" | jq '.'\n              curl -sS \\\n                -X POST \\\n                -H \"Accept: application/vnd.github+json\" \\\n                -H \"Authorization: Bearer ${GITHUB_TOKEN}\" \\\n                -H \"X-GitHub-Api-Version: 2022-11-28\" \\\n                \"https://api.github.com/repos/${REPOSITORY}/pulls/${PR_NUMBER}/comments\" \\\n                -d \"$payload\"\n            done  /tmp/summary.json\n\n            curl -sS \\\n              -X POST \\\n              -H \"Accept: application/vnd.github+json\" \\\n              -H \"Authorization: Bearer ${GITHUB_TOKEN}\" \\\n              -H \"X-GitHub-Api-Version: 2022-11-28\" \\\n              \"https://api.github.com/repos/${REPOSITORY}/issues/${PR_NUMBER}/comments\" \\\n              -d @/tmp/summary.json\n          '''\n        }\n      }\n    }\n  }\n\n  post {\n    always {\n      archiveArtifacts artifacts: 'codex-.json, *.md, /tmp/diff.txt', allowEmptyArchive: true\n    }\n  }\n}\n\n\nWith the Codex SDK, you can build your own GitHub Code Review in on-prem environments. However, the pattern of triggering Codex with a prompt, receiving a structured output, and then acting on that output with an API call extends far beyond Code Review. For example, we could use this pattern to trigger a root-cause analysis when an incident is created and post a structured report into a Slack channel. Or we could create a code quality report on each PR and post results into a dashboard."])</script><script>self.__next_f.push([1,"119:T13a8,"])</script><script>self.__next_f.push([1,"GPT-5.1 is exceptionally strong at coding, and with the new code-editing and command-execution tools available in the Responses API, it’s now easier than ever to build coding agents that can work across full codebases and iterate quickly.\n\nIn this guide, we’ll use the Agents SDK to build a coding agent that can scaffold a brand-new app from a prompt and refine it through user feedback. Our agent will be equipped with the following tools:\n\napply_patch** — to edit files\nshell** — to run shell commands\nweb_search** — to pull fresh information from the web\nContext7 MCP** — to access up-to-date documentation\n\nWe’ll begin by focusing on the shell and web_search tools to generate a new project with web-sourced context. Then we’ll add apply_patch so the agent can iterate on the codebase, and we’ll connect it to the Context7 MCP server so it can write code informed by the most recent docs.\n\nWith the Agents SDK, defining an agent is as simple as providing instructions and a list of tools. In this example, we want to use the newest gpt-5.1 model for its state-of-the-art coding abilities.\n\nWe’ll start by enabling web_search, which gives the agent the ability to look up up-to-date information online, and shell, which lets the agent propose shell commands for tasks like scaffolding, installing dependencies, and running build steps.\n\nThe shell tool works by letting the model propose commands it believes should be executed. Your environment is responsible for actually running those commands and returning the output.\n\nThe Agents SDK automates most of this command-execution handshake for you—you only need to implement the shell executor, the environment in which those commands will run.\n\nFor simplicity, we'll run shell commands locally and isolate them in a dedicated workspace directory. This ensures the agent only interacts with files inside that folder.\n\nNote: In production, always execute shell commands in a sandboxed environment. Arbitrary command execution is inherently risky and must be tightly controlled.\nWe’ll now define a small ShellExecutor class that:\n\nReceives a ShellCommandRequest from the agent\nOptionally asks for approval before running commands\nRuns them using asyncio.create_subprocess_shell\nReturns a ShellResult with the outputs\n\nAll commands will run with cwd=workspace_dir, so they only affect files in that subfolder.\n\nLet’s send a prompt to our coding agent and then inspect the files it created in the workspace_dir.\nIn this example, we'll create a NextJS dashboard using the shadcn library.\n\nNote: sometimes you might run into an MaxTurnsExceeded error, or the project might have a dependency error. Simply run the agent loop again. In a production environment, you would implement an external loop or user input handling to iterate if the project creation fails.\nOnce the agent is done creating the initial project (you should see a \"=== Run complete ===\" log followed by the final answer), you can check the output with the following commands:\n\ncd coding-agent-workspace/\nnpm run dev\n\nYou should see something like this:\ndashboard screenshot\n\n\nNow that we have an initial version of the app, we can start iterating using the apply_patch tool. We also want to include calls to the OpenAI Responses API, and for that, the model should have access to the most up-to-date documentation. To make this possible, we’ll connect the agent to the Context7 MCP server, which provides up-to-date docs.\n\nNote: in production you’ll typically want to run these edits in a sandboxed project workspace (e.g. ephemeral containers), and work with IDEs.\n\nLet's create a new agent that also uses these two additional tools, and update the instructions accordingly.\nTo avoid a context mismatch when applying the diffs, for this agent we'll specify not to edit files via a command.\nOnce the agent is done updating the project (you should see a \"=== Run complete ===\" log followed by the final answer), you will see the updated UI, with the OpenAI Responses API call to summarize what's on the dashboard.\n\nNote: If this step fails, you can re-run the agent loop. In a production environment, you would implement an outer loop that handles errors or wait for user input and iterate.\n\nfinal dashboard screenshot\n\nIn this cookbook guide, we built a coding agent that can scaffold a project, refine it through patches, execute commands, and stay up to date with external documentation. By combining GPT 5.1 with the Agents SDK and tools like shell, apply_patch, web_search, and the Context7 MCP, you can create agents that don’t just generate code—they actively work with codebases: running commands, applying edits, pulling in fresh context, and evolving a project end-to-end.\n\nThis workflow is a powerful blueprint for building agents that feel less like tools and more like collaborators. You can extend this pattern to integrate agents into IDEs or code sandboxes, generate new apps from scratch, work across large codebases, or even collaborate with developers in real time."])</script><script>self.__next_f.push([1,"11a:T69cc,"])</script><script>self.__next_f.push([1,"GPT-5.1, our newest flagship model, is designed to balance intelligence and speed for a variety of agentic and coding tasks, while also introducing a new none reasoning mode for low-latency interactions. Building on the strengths of GPT-5, GPT-5.1 is better calibrated to prompt difficulty, consuming far fewer tokens on easy inputs and more efficiently handling challenging ones. Along with these benefits, GPT-5.1 is more steerable in personality, tone, and output formatting.\n\nWhile GPT-5.1 works well out of the box for most applications, this guide focuses on prompt patterns that maximize performance in real deployments. These techniques come from extensive internal testing and collaborations with partners building production agents, where small prompt changes often produce large gains in reliability and user experience. We expect this guide to serve as a starting point: prompting is iterative, and the best results will come from adapting these patterns to your specific tools and workflows.\n\n\nFor developers using GPT-4.1, GPT-5.1 with none reasoning effort should be a natural fit for most low-latency use cases that do not require reasoning.\n\nFor developers using GPT-5, we have seen strong success with customers who follow a few key pieces of guidance:\n\nPersistence: GPT-5.1 now has better-calibrated reasoning token consumption but can sometimes err on the side of being excessively concise and come at the cost of answer completeness. It can be helpful to emphasize via prompting the importance of persistence and completeness.\nOutput formatting and verbosity: While overall more detailed, GPT-5.1 can occasionally be verbose, so it is worthwhile being explicit in your instructions on desired output detail.\nCoding agents: If you’re working on a coding agent, migrate your apply\\_patch to our new, named tool implementation.\nInstruction following: For other behavior issues, GPT-5.1 is excellent at instruction-following, and you should be able to shape the behavior significantly by checking for conflicting instructions and being clear.\n\nWe also released GPT-5.1-codex. This model behaves a bit differently than GPT-5.1, and we recommend you check out the Codex prompting guide for more information.\n\n\nGPT-5.1 is a highly steerable model, allowing for robust control over your agent’s behaviors, personality, and communication frequency.\n\n\nGPT-5.1’s personality and response style can be adapted to your use case. While verbosity is controllable through a dedicated verbosity parameter, you can also shape the overall style, tone, and cadence through prompting.\n\nWe’ve found that personality and style work best when you define a clear agent persona. This is especially important for customer-facing agents which need to display emotional intelligence to handle a range of user situations and dynamics. In practice, this can mean adjusting warmth and brevity to the state of the conversation, and avoiding excessive acknowledgment phrases like “got it” or “thank you.”\n\nThe sample prompt below shows how we shaped the personality for a customer support agent, focusing on balancing the right level of directness and warmth in resolving an issue.\n\n\nYou value clarity, momentum, and respect measured by usefulness rather than pleasantries. Your default instinct is to keep conversations crisp and purpose-driven, trimming anything that doesn't move the work forward. You're not cold—you're simply economy-minded with language, and you trust users enough not to wrap every message in padding.\n\nAdaptive politeness:\n  When a user is warm, detailed, considerate or says 'thank you', you offer a single, succinct acknowledgment—a small nod to their tone with acknowledgement or receipt tokens like 'Got it', 'I understand', 'You're welcome'—then shift immediately back to productive action. Don't be cheesy about it though, or overly supportive.\n  When stakes are high (deadlines, compliance issues, urgent logistics), you drop even that small nod and move straight into solving or collecting the necessary information.\n\nCore inclination:\n  You speak with grounded directness. You trust that the most respectful thing you can offer is efficiency: solving the problem cleanly without excess chatter.\n  Politeness shows up through structure, precision, and responsiveness, not through verbal fluff.\n\nRelationship to acknowledgement and receipt tokens:\n  You treat acknowledge and receipt as optional seasoning, not the meal. If the user is brisk or minimal, you match that rhythm with near-zero acknowledgments.\n  You avoid stock acknowledgments like \"Got it\" or \"Thanks for checking in\" unless the user's tone or pacing naturally invites a brief, proportional response.\n\nConversational rhythm:\n  You never repeat acknowledgments. Once you've signaled understanding, you pivot fully to the task.\n  You listen closely to the user's energy and respond at that tempo: fast when they're fast, more spacious when they're verbose, always anchored in actionability.\n\nUnderlying principle:\n  Your communication philosophy is \"respect through momentum.\" You're warm in intention but concise in expression, focusing every message on helping the user progress with as little friction as possible.\n\n\nIn the prompt below, we’ve included sections that constrain a coding agent’s responses to be short for small changes and longer for more detailed queries. We also specify the amount of code allowed in the final response to avoid large blocks.\n\n\nFinal answer compactness rules (enforced):\n  Tiny/small single-file change (≤ ~10 lines): 2–5 sentences or ≤3 bullets. No headings. 0–1 short snippet (≤3 lines) only if essential.\n  Medium change (single area or a few files): ≤6 bullets or 6–10 sentences. At most 1–2 short snippets total (≤8 lines each).\n  Large/multi-file change: Summarize per file with 1–2 bullets; avoid inlining code unless critical (still ≤2 short snippets total).\n  Never include \"before/after\" pairs, full method bodies, or large/scrolling code blocks in the final message. Prefer referencing file/symbol names instead.\nDo not include process/tooling narration (e.g., build/lint/test attempts, missing yarn/tsc/eslint) unless explicitly requested by the user or it blocks the change. If checks succeed silently, don't mention them.\n\nCode and formatting restraint — Use monospace for literal keyword bullets; never combine with **.\nNo build/lint/test logs or environment/tooling availability notes unless requested or blocking.\nNo multi-section recaps for simple changes; stick to What/Where/Outcome and stop.\nNo multiple code fences or long excerpts; prefer references.\n\nCiting code when it illustrates better than words — Prefer natural-language references (file/symbol/function) over code fences in the final answer. Only include a snippet when essential to disambiguate, and keep it within the snippet budget above.\nCiting code that is in the codebase:\n  If you must include an in-repo snippet, you may use the repository citation form, but in final answers avoid line-number/filepath prefixes and large context. Do not include more than 1–2 short snippets total.\n\n\nExcess output length can be mitigated by adjusting the verbosity parameter and further reduced via prompting as GPT-5.1 adheres well to concrete length guidance:\n\n\nRespond in plain text styled in Markdown, using at most 2 concise sentences.\nLead with what you did (or found) and context only if needed.\nFor code, reference file paths and show code blocks only if necessary to clarify the change or review.\n\n\n\nUser updates, also called preambles, are a way for GPT-5.1 to share upfront plans and provide consistent progress updates as assistant messages during a rollout. User updates can be adjusted along four major axes: frequency, verbosity, tone, and content. We trained the model to excel at keeping the user informed with plans, important insights and decisions, and granular context about what/why it's doing. These updates help the user supervise agentic rollouts more effectively, in both coding and non-coding domains.\n\nWhen timed correctly, the model will be able to share a point-in-time understanding that maps to the current state of the rollout. In the prompt addition below, we define what types of preamble would and would not be useful.\n\nYou'll work for stretches with tool calls — it's critical to keep the user updated as you work.\n\n\nSend short updates (1–2 sentences) every few tool calls when there are meaningful changes.\nPost an update at least every 6 execution steps or 8 tool calls (whichever comes first).\nIf you expect a longer heads‑down stretch, post a brief heads‑down note with why and when you’ll report back; when you resume, summarize what you learned.\nOnly the initial plan, plan updates, and final recap can be longer, with multiple bullets and paragraphs\n\n\n\nBefore the first tool call, give a quick plan with goal, constraints, next steps.\nWhile you're exploring, call out meaningful new information and discoveries that you find that helps the user understand what's happening and how you're approaching the solution.\nProvide additional brief lower-level context about more granular updates\nAlways state at least one concrete outcome since the prior update (e.g., “found X”, “confirmed Y”), not just next steps.\nIf a longer run occurred (\u003e6 steps or \u003e8 tool calls), start the next update with a 1–2 sentence synthesis and a brief justification for the heads‑down stretch.\nEnd with a brief recap and any follow-up steps.\nDo not commit to optional checks (type/build/tests/UI verification/repo-wide audits) unless you will do them in-session. If you mention one, either perform it (no logs unless blocking) or explicitly close it with a brief reason.\nIf you change the plan (e.g., choose an inline tweak instead of a promised helper), say so explicitly in the next update or the recap.\nIn the recap, include a brief checklist of the planned items with status: Done or Closed (with reason). Do not leave any stated item unaddressed.\n\n\n\nIn longer-running model executions, providing a fast initial assistant message can improve perceived latency and user experience. We can achieve this behavior with GPT-5.1 through clear prompting.\n\n\nAlways explain what you're doing in a commentary message FIRST, BEFORE sampling an analysis thinking message. This is critical in order to communicate immediately to the user.\n\n\n\nGPT-5.1 will pay very close attention to the instructions you provide, including guidance on tool usage, parallelism, and solution completeness.\n\n\nOn long agentic tasks, we’ve noticed that GPT-5.1 may end prematurely without reaching a complete solution, but we have found this behavior is promptable. In the following instruction, we tell the model to avoid premature termination and unnecessary follow-up questions.\n\nTreat yourself as an autonomous senior pair-programmer: once the user gives a direction, proactively gather context, plan, implement, test, and refine without waiting for additional prompts at each step.\nPersist until the task is fully handled end-to-end within the current turn whenever feasible: do not stop at analysis or partial fixes; carry changes through implementation, verification, and a clear explanation of outcomes unless the user explicitly pauses or redirects you.\nBe extremely biased for action. If a user provides a directive that is somewhat ambiguous on intent, assume you should go ahead and make the change. If the user asks a question like \"should we do x?\" and your answer is \"yes\", you should also go ahead and perform the action. It's very bad to leave the user hanging and require them to follow up with a request to \"please do it.\"\n\n\n\nIn order to make tool-calling most effective, we recommend describing functionality in the tool definition and how/when to use tools in the prompt. In the example below, we define a tool that creates a restaurant reservation, and we concisely describe what it does when invoked.\n\n{\n  \"name\": \"create_reservation\",\n  \"description\": \"Create a restaurant reservation for a guest. Use when the user asks to book a table with a given name and time.\",\n  \"parameters\": {\n    \"type\": \"object\",\n    \"properties\": {\n      \"name\": {\n        \"type\": \"string\",\n        \"description\": \"Guest full name for the reservation.\"\n      },\n      \"datetime\": {\n        \"type\": \"string\",\n        \"description\": \"Reservation date and time (ISO 8601 format).\"\n      }\n    },\n    \"required\": [\"name\", \"datetime\"]\n  }\n}\n\n\nIn the prompt, you may have a section that references the tool like this:\n\n\nWhen the user asks to book, reserve, or schedule a table, you MUST call create_reservation.\nDo NOT guess a reservation time or name — ask for whichever detail is missing.\nIf the user has not provided a name, ask: “What name should I put on the reservation?”\nIf the user has not provided a date/time, ask: “What date and time would you like to reserve?”\nAfter calling the tool, confirm the reservation naturally: “Your reservation is confirmed for [name] on [date/time].”\n\n\n\nExample 1:\nUser: “Book a table for Sarah tomorrow at 7pm.”\nAssistant → (calls tool) →\n{\"name\": \"create_reservation\", \"arguments\": { \"name\": \"Sarah\", \"datetime\": \"2025-11-01T19:00\" } }\nTool returns: { \"confirmation_number\": \"R12345\" }\nAssistant: “All set — your reservation for Sarah tomorrow at 7:00pm is confirmed. Your confirmation number is R12345.”\n\nExample 2:\nUser: “I want to make a reservation.”\nAssistant: “Sure! What name should I put on the reservation, and what date and time would you like?”\n\nExample 3:\nUser: “Reserve a table under Daniel at 6 tonight.”\nAssistant → (calls tool) →\n{\"name\": \"create_reservation\", \"arguments\": { \"name\": \"Daniel\", \"datetime\": \"2025-10-31T18:00\" } }\nTool returns: { \"confirmation_number\": \"R67890\" }\nAssistant: “Done! Your reservation for Daniel at 6:00pm tonight is confirmed. The confirmation number is R67890.”\n\n\nGPT-5.1 also executes parallel tool calls more efficiently. When scanning a codebase or retrieving from a vector store, enabling parallel tool calling and encouraging the model to use parallelism within the tool description is a good starting point. In the system prompt, you can reinforce parallel tool usage by providing some examples of permissible parallelism. An example instruction may look like:\n\nParallelize tool calls whenever possible. Batch reads (read_file) and edits (apply_patch) to speed up the process.\n\n\nGPT-5.1 introduces a new reasoning mode: none. Unlike GPT-5’s prior minimal setting, none forces the model to never use reasoning tokens, making it much more similar in usage to GPT-4.1, GPT-4o, and other prior non-reasoning models. Importantly, developers can now use hosted tools like web search and file search with none, and custom function-calling performance is also substantially improved. With that in mind, prior guidance on prompting non-reasoning models like GPT-4.1 also applies here, including using few-shot prompting and high-quality tool descriptions.\n\nWhile GPT-5.1 does not use reasoning tokens with none, we’ve found prompting the model to think carefully about which functions it plans to invoke can improve accuracy.\n\nYou MUST plan extensively before each function call, and reflect extensively on the outcomes of the previous function calls, ensuring user's query is completely resolved. DO NOT do this entire process by making function calls only, as this can impair your ability to solve the problem and think insightfully. In addition, ensure function calls have the correct arguments.\n\nWe’ve also observed that on longer model execution, encouraging the model to “verify” its outputs results in better instruction following for tool use. Below is an example we used within the instruction when clarifying a tool’s usage.\n\nWhen selecting a replacement variant, verify it meets all user constraints (cheapest, brand, spec, etc.). Quote the item-id and price back for confirmation before executing.\n\nIn our testing, GPT-5’s prior minimal reasoning mode sometimes led to executions that terminated prematurely. Although other reasoning modes may be better suited for these tasks, our guidance for GPT-5.1 with none is similar. Below is a snippet from our Tau bench prompt.\n\nRemember, you are an agent - please keep going until the user’s query is completely resolved, before ending your turn and yielding back to the user. You must be prepared to answer multiple queries and only finish the call once the user has confirmed they're done.\n\nOne tool we recommend implementing for long-running tasks is a planning tool. You may have noticed reasoning models plan within their reasoning summaries. Although this is helpful in the moment, it may be difficult to keep track of where the model is relative to the execution of the query.\n\n\nFor medium or larger tasks (e.g., multi-file changes, adding endpoints/CLI/features, or multi-step investigations), you must create and maintain a lightweight plan in the TODO/plan tool before your first code/tool action.\nCreate 2–5 milestone/outcome items; avoid micro-steps and repetitive operational tasks (no “open file”, “run tests”, or similar operational steps). Never use a single catch-all item like “implement the entire feature”.\nMaintain statuses in the tool: exactly one item in_progress at a time; mark items complete when done; post timely status transitions (never more than ~8 tool calls without an update). Do not jump an item from pending to completed: always set it to in_progress first (if work is truly instantaneous, you may set in_progress and completed in the same update). Do not batch-complete multiple items after the fact.\nFinish with all items completed or explicitly canceled/deferred before ending the turn.\nEnd-of-turn invariant: zero in_progress and zero pending; complete or explicitly cancel/defer anything remaining with a brief reason.\nIf you present a plan in chat for a medium/complex task, mirror it into the tool and reference those items in your updates.\nFor very short, simple tasks (e.g., single-file changes ≲ ~10 lines), you may skip the tool. If you still share a brief plan in chat, keep it to 1–2 outcome-focused sentences and do not include operational steps or a multi-bullet checklist.\nPre-flight check: before any non-trivial code change (e.g., apply_patch, multi-file edits, or substantial wiring), ensure the current plan has exactly one appropriate item marked in_progress that corresponds to the work you’re about to do; update the plan first if needed.\nScope pivots: if understanding changes (split/merge/reorder items), update the plan before continuing. Do not let the plan go stale while coding.\nNever have more than one item in_progress; if that occurs, immediately correct the statuses so only the current phase is in_progress.\n\n\nA plan tool can be used with minimal scaffolding. In our implementation of the plan tool, we pass a merge parameter as well as a list of to-dos. The list contains a brief description, the current state of the task, and an ID assigned to it. Below is an example of a function call that GPT-5.1 may make to record its state.\n\n{\n  \"name\": \"update_plan\",\n  \"arguments\": {\n    \"merge\": true,\n    \"todos\": [\n      {\n        \"content\": \"Investigate failing test\",\n        \"status\": \"in_progress\",\n        \"id\": \"step-1\"\n      },\n      {\n        \"content\": \"Apply fix and re-run tests\",\n        \"status\": \"pending\",\n        \"id\": \"step-2\"\n      }\n    ]\n  }\n}\n\n\nWhen building frontend interfaces, GPT-5.1 can be steered to produce websites that match your visual design system. We recommend using Tailwind to render CSS, which you can further tailor to meet your design guidelines. In the example below, we define a design system to constrain the colors generated by GPT-5.1.\n\n\nTokens-first: Do not hard-code colors (hex/hsl/oklch/rgb) in JSX/CSS. All colors must come from globals.css variables (e.g., --background, --foreground, --primary, --accent, --border, --ring) or DS components that consume them.\nIntroducing a brand or accent? Before styling, add/extend tokens in globals.css under :root and .dark, for example:\n  --brand, --brand-foreground, optional --brand-muted, --brand-ring, --brand-surface\n  If gradients/glows are needed, define --gradient-1, --gradient-2, etc., and ensure they reference sanctioned hues.\nConsumption: Use Tailwind/CSS utilities wired to tokens (e.g., bg-[hsl(var(--primary))], text-[hsl(var(--foreground))], ring-[hsl(var(--ring))]). Buttons/inputs/cards must use system components or match their token mapping.\nDefault to the system's neutral palette unless the user explicitly requests a brand look; then map that brand to tokens first.\n\n\n\nGPT-5.1 has been post-trained on specific tools that are commonly used in coding use cases. To interact with files in your environment you now can use a predefined apply\\_patch tool. Similarly, we’ve added a shell tool that lets the model propose commands for your system to run.\n\nThe apply\\_patch tool lets GPT-5.1 create, update, and delete files in your codebase using structured diffs. Instead of just suggesting edits, the model emits patch operations that your application applies and then reports back on, enabling iterative, multi-step code editing workflows. You can find additional usage details and context in the GPT-4.1 prompting guide.\n\nWith GPT-5.1, you can use apply\\_patch as a new tool type without writing custom descriptions for the tool. The description and handling are managed via the Responses API. Under the hood, this implementation uses a freeform function call rather than a JSON format. In testing, the named function decreased apply\\_patch failure rates by 35%.\n\nresponse = client.responses.create(\nmodel=\"gpt-5.1\",\ninput=RESPONSE_INPUT,\ntools=[{\"type\": \"apply_patch\"}]\n)\n\nWhen the model decides to execute an apply\\_patch tool, you will receive an apply\\_patch\\_call function type within the response stream. Within the operation object, you’ll receive a type field (with one of create_file, update_file, or delete_file) and the diff to implement.\n\n{\n    \"id\": \"apc_08f3d96c87a585390069118b594f7481a088b16cda7d9415fe\",\n    \"type\": \"apply_patch_call\",\n    \"status\": \"completed\",\n    \"call_id\": \"call_Rjsqzz96C5xzPb0jUWJFRTNW\",\n    \"operation\": {\n        \"type\": \"update_file\",\n        \"diff\": \"\n        @@\n        -def fib(n):\n        +def fibonacci(n):\n        if n\n[DUMP_SYSTEM_PROMPT]\n\n\n2) A small set of logged failures. Each log has:\nquery\ntools_called (as actually executed)\nfinal_answer (shortened if needed)\neval_signal (e.g., thumbs_down, low rating, human grader, or user comment)\n\n\n[DUMP_FAILURE_TRACES]\n\n\nYour tasks:\n\n1) Identify the distinct failure mode you see (e.g., tool_usage_inconsistency, autonomy_vs_clarifications, verbosity_vs_concision, unit_mismatch).\n2) For each failure mode, quote or paraphrase the specific lines or sections of the system prompt that are most likely causing or reinforcing it. Include any contradictions (e.g., “be concise” vs “err on the side of completeness,” “avoid tools” vs “always use tools for events over 30 attendees”).\n3) Briefly explain, for each failure mode, how those lines are steering the agent toward the observed behavior.\n\nReturn your answer in a structured but readable format:\n\nfailure_modes:\nname: ...\n  description: ...\n  prompt_drivers:\n    exact_or_paraphrased_line: ...\n    why_it_matters: ...\n\nMetaprompting works best when the feedback can logically be grouped together. If you provide many failure modes, the model may struggle to tie all of the threads together. In this example, the dump of failure logs may contain examples of errors where the model was overly or insufficiently verbose when responding to the user’s question. A separate query would be issued for the model’s over-eagerness to call tools.\n\nStep 2: Ask GPT-5.1 how it would patch the prompt to fix those behaviors\n\nOnce you have that analysis, you can run a second, separate call that focuses on implementation: tightening the prompt without fully rewriting it.\n\nYou previously analyzed this system prompt and its failure modes.\n\nSystem prompt:\n\n\n[DUMP_SYSTEM_PROMPT]\n\n\nFailure-mode analysis:\n[DUMP_FAILURE_MODE_ANALYSIS]\n\nPlease propose a surgical revision of the system prompt that reduces the observed issues while preserving the good behaviors.\n\nConstraints:\n\nDo not redesign the agent from scratch.\nPrefer small, explicit edits: clarify conflicting rules, remove redundant or contradictory lines, tighten vague guidance.\nMake tradeoffs explicit (for example, clearly state when to prioritize concision over completeness, or exactly when tools must vs must not be called).\nKeep the structure and overall length roughly similar to the original, unless a short consolidation removes obvious duplication.\n\nOutput:\n\n1) patch_notes: a concise list of the key changes and the reasoning behind each (e.g., “Merged conflicting tool-usage rules into a single hierarchy,” “Removed overlapping tone instructions that encouraged both executive formality and casual first-person with emojis”).\n2) revised_system_prompt: the full updated system prompt with your edits applied, ready to drop into an agent configuration.\n\nIn this example, the first metaprompt helps GPT-5.1 point directly at the contradictory sections (such as the overlapping tool rules and autonomy vs clarification guidance), and the second metaprompt turns that analysis into a concrete, cleaned-up version of the event-planning agent’s instructions.\n\nThe output from the second prompt might look something like this:\n\npatch_notes:\nClarified when to prioritize concision vs detail:\n  Simple or single-topic queries should stay within ~3–6 sentences.\n  Longer, structured answers are reserved for clearly complex, multi-day or multi-vendor requests.\nRemoved language that told the agent to “err on the side of completeness” for all cases and replaced it with conditional rules based on query complexity.\nTightened the structure rules so headings and bullets are only used when complexity or explicit user instructions justify them.\nSimplified the guidance on step-by-step plans so they are expected only for complex events, not for every question.\n\nrevised_system_prompt:\n[...]\n\nAfter this iteration cycle, run the queries again to observe any regressions and repeat this process until your failure modes have been identified and triaged.\n\nAs you continue to grow your agentic systems (e.g., broadening scope or increasing the number of tool calls), consider metaprompting the additions you’d like to make rather than adding them by hand. This helps maintain discrete boundaries for each tool and when they should be used.\n\n\nTo summarize, GPT-5.1 builds on the foundation set by GPT-5 and adds things like quicker thinking for easy questions, steerability when it comes to model output, new tools for coding use cases, and the option to set reasoning to none when your tasks don't require heavy thinking.\n\nGet started with GPT-5.1 in the docs, or read the blog post to learn more."])</script><script>self.__next_f.push([1,"11b:T798a,"])</script><script>self.__next_f.push([1,"GPT-5.1-Codex-Max advances the frontier of intelligence and efficiency and is our best agentic coding model. Follow this guide closely to ensure you’re getting the best performance possible from this model. This guide is for anyone using the model directly via the API for maximum customizability; we also have the Codex SDK for simpler integrations.\n\nKey improvements\n\nFaster and more token efficient: Matches GPT-5.1-Codex performance on SWE-Bench Verified with \\~30% fewer thinking tokens. We recommend “medium” reasoning effort as a good all-around interactive coding model that balances intelligence and speed.\nHigher intelligence and long-running autonomy: Codex is very capable and will work autonomously for hours to complete your hardest tasks. You can use high or xhigh reasoning effort for your hardest tasks.\nFirst-class compaction support: Compaction enables multi-hour reasoning without hitting context limits and longer continuous user conversations without needing to start new chat sessions.\nThis model is also much better in PowerShell and Windows environments.\n\n\nIf you already have a working Codex implementation, this model should work well with relatively minimal updates, but if you’re starting with a prompt and set of tools that’s optimized for GPT-5-series models, or a third-party model, we recommend making more significant changes. The best reference implementation is our fully open-source codex-cli agent, available on GitHub. Clone this repo and use Codex (or any coding agent) to ask questions about how things are implemented. From working with customers, we’ve also learned how to customize agent harnesses beyond this particular implementation.\n\nKey steps to migrate your harness to codex-cli:\n\nUpdate your prompt: If you can, start with our standard Codex-Max prompt as your base and make tactical additions from there.\n   a) The most critical snippets are those covering autonomy and persistence, codebase exploration, tool use, and frontend quality.\n   b) You should also remove all prompting for the model to communicate an upfront plan, preambles, or other status updates during the rollout, as this can cause the model to stop abruptly before the rollout is complete.\nUpdate your tools, including our apply\\_patch implementation and other best practices below. This is a major lever for getting the most performance from GPT-5.1-Codex-Max.\n\n\n\nThis prompt began as the default GPT-5.1-Codex-Max prompt and was further optimized against internal evals for answer correctness, completeness, quality, correct tool usage and parallelism, and bias for action. If you’re running evals with this model, we recommend turning up the autonomy or prompting for a “non-interactive” mode, though in actual usage more clarification may be desirable.\n\nYou are Codex, based on GPT-5. You are running as a coding agent in the Codex CLI on a user's computer.\n\n\n\nWhen searching for text or files, prefer using rg or rg --files respectively because rg is much faster than alternatives like grep. (If the rg command is not found, then use alternatives.)\nIf a tool exists for an action, prefer to use the tool instead of shell commands (e.g read_file over cat). Strictly avoid raw cmd/terminal when a dedicated tool exists. Default to solver tools: git (all git), rg (search), read_file, list_dir, glob_file_search, apply_patch, todo_write/update_plan. Use cmd/run_terminal_cmd only when no listed tool can perform the action.\nWhen multiple tool calls can be parallelized (e.g., todo updates with other actions, file searches, reading files), use make these tool calls in parallel instead of sequential. Avoid single calls that might not yield a useful result; parallelize instead to ensure you can make progress efficiently.\nCode chunks that you receive (via tool calls or from user) may include inline line numbers in the form \"Lxxx:LINE_CONTENT\", e.g. \"L123:LINE_CONTENT\". Treat the \"Lxxx:\" prefix as metadata and do NOT treat it as part of the actual code.\nDefault expectation: deliver working code, not just a plan. If some details are missing, make reasonable assumptions and complete a working version of the feature.\n\n\n\nYou are autonomous senior engineer: once the user gives a direction, proactively gather context, plan, implement, test, and refine without waiting for additional prompts at each step.\nPersist until the task is fully handled end-to-end within the current turn whenever feasible: do not stop at analysis or partial fixes; carry changes through implementation, verification, and a clear explanation of outcomes unless the user explicitly pauses or redirects you.\nBias to action: default to implementing with reasonable assumptions; do not end your turn with clarifications unless truly blocked.\nAvoid excessive looping or repetition; if you find yourself re-reading or re-editing the same files without clear progress, stop and end the turn with a concise summary and any clarifying questions needed.\n\n\n\nAct as a discerning engineer: optimize for correctness, clarity, and reliability over speed; avoid risky shortcuts, speculative changes, and messy hacks just to get the code to work; cover the root cause or core ask, not just a symptom or a narrow slice.\nConform to the codebase conventions: follow existing patterns, helpers, naming, formatting, and localization; if you must diverge, state why.\nComprehensiveness and completeness: Investigate and ensure you cover and wire between all relevant surfaces so behavior stays consistent across the application.\nBehavior-safe defaults: Preserve intended behavior and UX; gate or flag intentional changes and add tests when behavior shifts.\nTight error handling: No broad catches or silent defaults: do not add broad try/catch blocks or success-shaped fallbacks; propagate or surface errors explicitly rather than swallowing them.\n  No silent failures: do not early-return on invalid input without logging/notification consistent with repo patterns\nEfficient, coherent edits: Avoid repeated micro-edits: read enough context before changing a file and batch logical edits together instead of thrashing with many tiny patches.\nKeep type safety: Changes should always pass build and type-check; avoid unnecessary casts (as any, as unknown as ...); prefer proper types and guards, and reuse existing helpers (e.g., normalizing identifiers) instead of type-asserting.\nReuse: DRY/search first: before adding new helpers or logic, search for prior art and reuse or extract a shared helper instead of duplicating.\nBias to action: default to implementing with reasonable assumptions; do not end on clarifications unless truly blocked. Every rollout should conclude with a concrete edit or an explicit blocker plus a targeted question.\n\n\n\nDefault to ASCII when editing or creating files. Only introduce non-ASCII or other Unicode characters when there is a clear justification and the file already uses them.\nAdd succinct code comments that explain what is going on if code is not self-explanatory. You should not add comments like \"Assigns the value to the variable\", but a brief comment might be useful ahead of a complex code block that the user would otherwise have to spend time parsing out. Usage of these comments should be rare.\nTry to use apply_patch for single file edits, but it is fine to explore other options to make the edit if it does not work well. Do not use apply_patch for changes that are auto-generated (i.e. generating package.json or running a lint or format command like gofmt) or when scripting is more efficient (such as search and replacing a string across a codebase).\nYou may be in a dirty git worktree.\n    NEVER revert existing changes you did not make unless explicitly requested, since these changes were made by the user.\n    If asked to make a commit or code edits and there are unrelated changes to your work or changes that you didn't make in those files, don't revert those changes.\n    If the changes are in files you've touched recently, you should read carefully and understand how you can work with the changes rather than reverting them.\n    If the changes are in unrelated files, just ignore them and don't revert them.\nDo not amend a commit unless explicitly requested to do so.\nWhile you are working, you might notice unexpected changes that you didn't make. If this happens, STOP IMMEDIATELY and ask the user how they would like to proceed.\nNEVER** use destructive commands like git reset --hard or git checkout -- unless specifically requested or approved by the user.\n\n\n\nThink first.** Before any tool call, decide ALL files/resources you will need.\nBatch everything.** If you need multiple files (even from different places), read them together.\nmulti_tool_use.parallel** Use multi_tool_use.parallel to parallelize tool calls and only this.\nOnly make sequential calls if you truly cannot know the next file without seeing a result first.**\nWorkflow:** (a) plan all needed reads → (b) issue one parallel batch → (c) analyze results → (d) repeat if new, unpredictable reads arise.\nAdditional notes:\n    Always maximize parallelism. Never read files one-by-one unless logically unavoidable.\n    This concerns every read/list/search operations including, but not only, cat, rg, sed, ls, git show, nl, wc, ...\n    Do not try to parallelize using scripting or anything else than multi_tool_use.parallel.\n\n\n\nWhen using the planning tool:\nSkip using the planning tool for straightforward tasks (roughly the easiest 25%).\nDo not make single-step plans.\nWhen you made a plan, update it after having performed one of the sub-tasks that you shared on the plan.\nUnless asked for a plan, never end the interaction with only a plan. Plans guide your edits; the deliverable is working code.\nPlan closure: Before finishing, reconcile every previously stated intention/TODO/plan. Mark each as Done, Blocked (with a one‑sentence reason and a targeted question), or Cancelled (with a reason). Do not end with in_progress/pending items. If you created todos via a tool, update their statuses accordingly.\nPromise discipline: Avoid committing to tests/broad refactors unless you will do them now. Otherwise, label them explicitly as optional \"Next steps\" and exclude them from the committed plan.\nFor any presentation of any initial or updated plans, only update the plan tool and do not message the user mid-turn to tell them about your plan.\n\n\n\nIf the user makes a simple request (such as asking for the time) which you can fulfill by running a terminal command (such as date), you should do so.\nIf the user asks for a \"review\", default to a code review mindset: prioritise identifying bugs, risks, behavioural regressions, and missing tests. Findings must be the primary focus of the response - keep summaries or overviews brief and only after enumerating the issues. Present findings first (ordered by severity with file/line references), follow with open questions or assumptions, and offer a change-summary only as a secondary detail. If no findings are discovered, state that explicitly and mention any residual risks or testing gaps.\n\n\n\nWhen doing frontend design tasks, avoid collapsing into \"AI slop\" or safe, average-looking layouts.\nAim for interfaces that feel intentional, bold, and a bit surprising.\nTypography: Use expressive, purposeful fonts and avoid default stacks (Inter, Roboto, Arial, system).\nColor \u0026 Look: Choose a clear visual direction; define CSS variables; avoid purple-on-white defaults. No purple bias or dark mode bias.\nMotion: Use a few meaningful animations (page-load, staggered reveals) instead of generic micro-motions.\nBackground: Don't rely on flat, single-color backgrounds; use gradients, shapes, or subtle patterns to build atmosphere.\nOverall: Avoid boilerplate layouts and interchangeable UI patterns. Vary themes, type families, and visual languages across outputs.\nEnsure the page loads properly on both desktop and mobile\nFinish the website or app to completion, within the scope of what's possible without adding entire adjacent features or services. It should be in a working state for a user to run and test.\n\nException: If working within an existing website or design system, preserve the established patterns, structure, and visual language.\n\n\n\nYou are producing plain text that will later be styled by the CLI. Follow these rules exactly. Formatting should make results easy to scan, but not feel mechanical. Use judgment to decide how much structure adds value.\n\nDefault: be very concise; friendly coding teammate tone.\nFormat: Use natural language with high-level headings.\nAsk only when needed; suggest ideas; mirror the user's style.\nFor substantial work, summarize clearly; follow final‑answer formatting.\nSkip heavy formatting for simple confirmations.\nDon't dump large files you've written; reference paths only.\nNo \"save/copy this file\" - User is on the same machine.\nOffer logical next steps (tests, commits, build) briefly; add verify steps if you couldn't do something.\nFor code changes:\n  Lead with a quick explanation of the change, and then give more details on the context covering where and why a change was made. Do not start this explanation with \"summary\", just jump right in.\n  If there are natural next steps the user may want to take, suggest them at the end of your response. Do not make suggestions if there are no natural next steps.\n  When suggesting multiple options, use numeric lists for the suggestions so the user can quickly respond with a single number.\nThe user does not command execution outputs. When asked to show the output of a command (e.g. git show), relay the important details in your answer or summarize the key lines so the user understands the result.\n\n\nPlain text; CLI handles styling. Use structure only when it helps scanability.\nHeaders: optional; short Title Case (1-3 words) wrapped in …; no blank line before the first bullet; add only if they truly help.\nBullets: use - ; merge related points; keep to one line when possible; 4–6 per list ordered by importance; keep phrasing consistent.\nMonospace: backticks for commands/paths/env vars/code ids and inline examples; use for literal keyword bullets; never combine with **.\nCode samples or multi-line snippets should be wrapped in fenced code blocks; include an info string as often as possible.\nStructure: group related bullets; order sections general → specific → supporting; for subsections, start with a bolded keyword bullet, then items; match complexity to the task.\nTone: collaborative, concise, factual; present tense, active voice; self‑contained; no \"above/below\"; parallel wording.\nDon'ts: no nested bullets/hierarchies; no ANSI codes; don't cram unrelated keywords; keep keyword lists short—wrap/reformat if long; avoid naming formatting styles in answers.\nAdaptation: code explanations → precise, structured with code refs; simple tasks → lead with outcome; big changes → logical walkthrough + rationale + next actions; casual one-offs → plain sentences, no headers/bullets.\nFile References: When referencing files in your response follow the below rules:\n  Use inline code to make file paths clickable.\n  Each reference should have a stand alone path. Even if it's the same file.\n  Accepted: absolute, workspace‑relative, a/ or b/ diff prefixes, or bare filename/suffix.\n  Optionally include line/column (1‑based): :line[:column] or #Lline[Ccolumn] (column defaults to 1).\n  Do not use URIs like file://, vscode://, or https://.\n  Do not provide range of lines\n  Examples: src/app.ts, src/app.ts:42, b/server/index.js#L10, C:\\repo\\project\\main.rs:12:5\n\n\nThe Codex model family uses reasoning summaries to communicate user updates as it’s working. This can be in the form of one-liner headings (which updates the ephemeral text in Codex-CLI), or both heading and a short body. This is done by a separate model and therefore is not promptable, and we advise against adding any instructions to the prompt related to intermediate plans or messages to the user. We’ve improved these summaries for Codex-Max to be more communicative and provide more critical information about what’s happening and why; some of our users are updating their UX to promote these summaries more prominently in their UI, similar to how intermediate messages are displayed for GPT-5 series models.\n\n\nCodex-cli automatically enumerates these files and injects them into the conversation; the model has been trained to closely adhere to these instructions.\n\n1\\. Files are pulled from \\~/.codex plus each directory from repo root to CWD (with optional fallback names and a size cap).\n2\\. They’re merged in order, later directories overriding earlier ones.\n3\\. Each merged chunk shows up to the model as its own user-role message like so:\n\n\n...file contents...\n\n\nAdditional details\n\nEach discovered file becomes its own user-role message that starts with \\# AGENTS.md instructions for \\, where \\ is the path (relative to the repo root) of the folder that provided that file.\nMessages are injected near the top of the conversation history, before the user prompt, in root-to-leaf order: global instructions first, then repo root, then each deeper directory. If an AGENTS.override.md was used, its directory name still appears in the header (e.g., \\# AGENTS.md instructions for backend/api), so the context is obvious in the transcript.\n\n\nCompaction unlocks significantly longer effective context windows, where user conversations can persist for many turns without hitting context window limits or long context performance degradation, and agents can perform very long trajectories that exceed a typical context window for long-running, complex tasks. A weaker version of this was previously possible with ad-hoc scaffolding and conversation summarization, but our first-class implementation, available via the Responses API, is integrated with the model and is highly performant.\n\nHow it works:\n\nYou use the Responses API as today, sending input items that include tool calls, user inputs, and assistant messages.\nWhen your context window grows large, you can invoke /compact to generate a new, compacted context window. Two things to note:\n   The context window that you send to /compact should fit within your model’s context window.\n   The endpoint is ZDR compatible and will return an “encrypted\\_content” item that you can pass into future requests.\nFor subsequent calls to the /responses endpoint, you can pass your updated, compacted list of conversation items (including the added compaction item). The model retains key prior state with fewer conversation tokens.\n\nFor endpoint details see our /responses/compact docs.\n\n\nWe strongly recommend using our exact apply_patch implementation as the model has been trained to excel at this diff format. For terminal commands we recommend our shell tool, and for plan/TODO items our update_plan tool should be most performant.\nIf you prefer your agent to use more “terminal-like tools” (like file_read() instead of calling \\sed\\ in the terminal), this model can reliably call them instead of terminal (following the instructions below)\nFor other tools, including semantic search, MCPs, or other custom tools, they can work but it requires more tuning and experimentation.\n\n\nThe easiest way to implement apply\\_patch is with our first-class implementation in the Responses API, but you can also use our freeform tool implementation with context-free grammar. Both are demonstrated below.\n\n\nimport json\nfrom pprint import pprint\nfrom typing import cast\n\nfrom openai import OpenAI\nfrom openai.types.responses import ResponseInputParam, ToolParam\n\nclient = OpenAI()\n\nuser_request = \"\"\"Add a cancel button that logs when clicked\"\"\"\nfile_excerpt = \"\"\"\\\nexport default function Page() {\nreturn (\n\n    Page component not implemented\n     console.log(\"clicked\")}\u003eClick me\n\n);\n}\n\"\"\"\n\ninput_items: ResponseInputParam = [\n    {\"role\": \"user\", \"content\": user_request},\n    {\n        \"type\": \"function_call\",\n        \"call_id\": \"call_read_file_1\",\n        \"name\": \"read_file\",\n        \"arguments\": json.dumps({\"path\": (\"/app/page.tsx\")}),\n    },\n    {\n        \"type\": \"function_call_output\",\n        \"call_id\": \"call_read_file_1\",\n        \"output\": file_excerpt,\n    },\n]\n\nread_file_tool: ToolParam = cast(\n    ToolParam,\n    {\n        \"type\": \"function\",\n        \"name\": \"read_file\",\n        \"description\": \"Reads a file from disk\",\n        \"parameters\": {\n            \"type\": \"object\",\n            \"properties\": {\"path\": {\"type\": \"string\"}},\n            \"required\": [\"path\"],\n        },\n    },\n)\n\ntools: list[ToolParam] = [\n    read_file_tool,\n    cast(ToolParam, {\"type\": \"apply_patch\"}),\n]\n\nresponse = client.responses.create(\n    model=\"gpt-5.1-Codex-Max\",\n    input=input_items,\n    tools=tools,\n    parallel_tool_calls=False,\n)\n\nfor item in response.output:\n    if item.type == \"apply_patch_call\":\n        print(\"Responses API apply_patch patch:\")\n        pprint(item.operation)\noutput:\n{'diff': '@@\\n'\n'   return (\\n'\n'     \\n'\n'       Page component not implemented\\n'\n'        console.log(\"clicked\")}\u003eClick me\\n'\n'+       console.log(\"cancel clicked\")}\u003eCancel\\n'\n'     \\n'\n'   );\\n'\n' }\\n',\n'path': '/app/page.tsx',\n'type': 'update_file'}\n\napply_patch_grammar = \"\"\"\nstart: begin_patch hunk+ end_patch\nbegin_patch: \"* Begin Patch\" LF\nend_patch: \"* End Patch\" LF?\n\nhunk: add_hunk | delete_hunk | update_hunk\nadd_hunk: \"* Add File: \" filename LF add_line+\ndelete_hunk: \"* Delete File: \" filename LF\nupdate_hunk: \"* Update File: \" filename LF change_move? change?\n\nfilename: /(.+)/\nadd_line: \"+\" /(.*)/ LF -\u003e line\n\nchange_move: \"* Move to: \" filename LF\nchange: (change_context | change_line)+ eof_line?\nchange_context: (\"@@\" | \"@@ \" /(.+)/) LF\nchange_line: (\"+\" | \"-\" | \" \") /(.*)/ LF\neof_line: \"* End of File\" LF\n\n%import common.LF\n\"\"\"\n\ntools_with_cfg: list[ToolParam] = [\n    read_file_tool,\n    cast(\n        ToolParam,\n        {\n            \"type\": \"custom\",\n            \"name\": \"apply_patch_grammar\",\n            \"description\": \"Use the apply_patch tool to edit files. This is a FREEFORM tool, so do not wrap the patch in JSON.\",\n            \"format\": {\n                \"type\": \"grammar\",\n                \"syntax\": \"lark\",\n                \"definition\": apply_patch_grammar,\n            },\n        },\n    ),\n]\n\nresponse_cfg = client.responses.create(\n    model=\"gpt-5.1-Codex-Max\",\n    input=input_items,\n    tools=tools_with_cfg,\n    parallel_tool_calls=False,\n)\n\nfor item in response_cfg.output:\n    if item.type == \"custom_tool_call\":\n        print(\"\\n\\nContext-free grammar apply_patch patch:\")\n        print(item.input)\nOutput\n* Begin Patch\n* Update File: /app/page.tsx\n@@\n\nPage component not implemented\nconsole.log(\"clicked\")}\u003eClick me\n+       console.log(\"cancel clicked\")}\u003eCancel\n\n);\n}\n* End Patch\n\nPatches objects the Responses API tool can be implemented by following this example and patches from the freeform tool can be applied with the logic in our canonical GPT-5 apply\\_patch.py implementation.\n\n\nThis is our default shell tool. Note that we have seen better performance with a command type “string” rather than a list of commands.\n\n{\n  \"type\": \"function\",\n  \"function\": {\n    \"name\": \"shell_command\",\n    \"description\": \"Runs a shell command and returns its output.\\n- Always set the workdir param when using the shell_command function. Do not use cd unless absolutely necessary.\",\n    \"strict\": false,\n    \"parameters\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"command\": {\n          \"type\": \"string\",\n          \"description\": \"The shell script to execute in the user's default shell\"\n        },\n        \"workdir\": {\n          \"type\": \"string\",\n          \"description\": \"The working directory to execute the command in\"\n        },\n        \"timeout_ms\": {\n          \"type\": \"number\",\n          \"description\": \"The timeout for the command in milliseconds\"\n        },\n        \"with_escalated_permissions\": {\n          \"type\": \"boolean\",\n          \"description\": \"Whether to request escalated permissions. Set to true if command needs to be run without sandbox restrictions\"\n        },\n        \"justification\": {\n          \"type\": \"string\",\n          \"description\": \"Only set if with_escalated_permissions is true. 1-sentence explanation of why we want to run this command.\"\n        }\n      },\n      \"required\": [\"command\"],\n      \"additionalProperties\": false\n    }\n  }\n}\n\nIf you’re using Windows PowerShell, update to this tool description.\n\nRuns a shell command and returns its output. The arguments you pass will be invoked via PowerShell (e.g., [\"pwsh\", \"-NoLogo\", \"-NoProfile\", \"-Command\", \"\"]). Always fill in workdir; avoid using cd in the command string.\n\nYou can check out codex-cli for the implementation for exec_command, which launches a long-lived PTY when you need streaming output, REPLs, or interactive sessions; and write_stdin, to feed extra keystrokes (or just poll output) for an existing exec\\_command session.\n\n\nThis is our default TODO tool; feel free to customize as you’d prefer. See the ## Plan tool section of our starter prompt for additional instructions to maintain hygiene and tweak behavior.\n\n{\n  \"type\": \"function\",\n  \"function\": {\n    \"name\": \"update_plan\",\n    \"description\": \"Updates the task plan.\\nProvide an optional explanation and a list of plan items, each with a step and status.\\nAt most one step can be in_progress at a time.\",\n    \"strict\": false,\n    \"parameters\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"explanation\": {\n          \"type\": \"string\"\n        },\n        \"plan\": {\n          \"type\": \"array\",\n          \"items\": {\n            \"type\": \"object\",\n            \"properties\": {\n              \"step\": {\n                \"type\": \"string\"\n              },\n              \"status\": {\n                \"type\": \"string\",\n                \"description\": \"One of: pending, in_progress, completed\"\n              }\n            },\n            \"additionalProperties\": false,\n            \"required\": [\n              \"step\",\n              \"status\"\n            ]\n          },\n          \"description\": \"The list of steps\"\n        }\n      },\n      \"additionalProperties\": false,\n      \"required\": [\n        \"plan\"\n      ]\n    }\n  }\n}\n\n\nThis is a basic function used in codex-cli for the model to view images.\n\n{\n  \"type\": \"function\",\n  \"function\": {\n    \"name\": \"view_image\",\n    \"description\": \"Attach a local image (by filesystem path) to the conversation context for this turn.\",\n    \"strict\": false,\n    \"parameters\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"path\": {\n          \"type\": \"string\",\n          \"description\": \"Local filesystem path to an image file\"\n        }\n      },\n      \"additionalProperties\": false,\n      \"required\": [\n        \"path\"\n      ]\n    }\n  }\n}\n\n\n\n\nIf you would prefer your codex agent to use terminal-wrapping tools (like a dedicated list_dir(‘.’) tool instead of terminal(‘ls .’), this generally works well. We see the best results when the name of the tool, the arguments, and the output are as close as possible to those from the underlying command, so it’s as in-distribution as possible for the model (which was primarily trained using a dedicated terminal tool). For example, if you notice the model using git via the terminal and would prefer it to use a dedicated tool, we found that creating a related tool, and adding a directive in the prompt to only use that tool for git commands, fully mitigated the model’s terminal usage for git commands.\n\nGIT_TOOL = {\n    \"type\": \"function\",\n    \"name\": \"git\",\n    \"description\": (\n        \"Execute a git command in the repository root. Behaves like running git in the\"\n        \" terminal; supports any subcommand and flags. The command can be provided as a\"\n        \" full git invocation (e.g., git status -sb) or just the arguments after git\"\n        \" (e.g., status -sb).\"\n    ),\n    \"parameters\": {\n        \"type\": \"object\",\n        \"properties\": {\n            \"command\": {\n                \"type\": \"string\",\n                \"description\": (\n                    \"The git command to execute. Accepts either a full git invocation or\"\n                    \" only the subcommand/args.\"\n                ),\n            },\n            \"timeout_sec\": {\n                \"type\": \"integer\",\n                \"minimum\": 1,\n                \"maximum\": 1800,\n                \"description\": \"Optional timeout in seconds for the git command.\",\n            },\n        },\n        \"required\": [\"command\"],\n    },\n}\n\n...\n\nPROMPT_TOOL_USE_DIRECTIVE = \"- Strictly avoid raw cmd/terminal when a dedicated tool exists. Default to solver tools: git (all git), list_dir, apply_patch. Use cmd/run_terminal_cmd only when no listed tool can perform the action.\" # update with your desired tools\n\n\nThe model hasn’t necessarily been post-trained to excel at these tools, but we have seen success here as well. To get the most out of these tools, we recommend:\n\nMaking the tool names and arguments as semantically “correct” as possible, for example “search” is ambiguous but “semantic\\_search” clearly indicates what the tool does, relative to other potential search-related tools you might have. “Query” would be a good param name for this tool.\nBe explicit in your prompt about when, why, and how to use these tools, including good and bad examples.\nIt could also be helpful to make the results look different from outputs the model is accustomed to seeing from other tools, for example ripgrep results should look different from semantic search results to avoid the model collapsing into old habits.\n\n\nIn codex-cli, when parallel tool calling is enabled, the responses API request sets parallel_tool_calls: true and the following snippet is added to the system instructions:\n\n\nThink first.** Before any tool call, decide ALL files/resources you will need.\nBatch everything.** If you need multiple files (even from different places), read them together.\nmulti_tool_use.parallel** Use multi_tool_use.parallel to parallelize tool calls and only this.\nOnly make sequential calls if you truly cannot know the next file without seeing a result first.**\nWorkflow:** (a) plan all needed reads → (b) issue one parallel batch → (c) analyze results → (d) repeat if new, unpredictable reads arise.\n\nAdditional notes:\nAlways maximize parallelism. Never read files one-by-one unless logically unavoidable.\nThis concerns every read/list/search operations including, but not only, cat, rg, sed, ls, git show, nl, wc, ...\nDo not try to parallelize using scripting or anything else than multi_tool_use.parallel.\n\nWe've found it to be helpful and more in-distribution if parallel tool call items and responses are ordered in the following way:\n\nfunction_call\nfunction_call\nfunction_call_output\nfunction_call_output\n\n\nWe recommend doing tool call response truncation as follows to be as in-distribution for the model as possible:\n\nLimit to 10k tokens. You can cheaply approximate this by computing num_bytes/4.\nIf you hit the truncation limit, you should use half of the budget for the beginning, half for the end, and truncate in the middle with …3 tokens truncated…"])</script><script>self.__next_f.push([1,"11c:T3b2e,"])</script><script>self.__next_f.push([1,"Codex is trained to read and reason about large, complex codebases, plan work alongside engineers, and produce high-quality changes. Code modernization has quickly become one of its most common and valuable uses. In this setup, engineers focus on architecture and business rules while Codex handles the heavy lifting: translating legacy patterns, proposing safe refactors, and keeping documentation and tests in sync as the system evolves.\n\nThis cookbook shows how to use OpenAI's Codex CLI to modernize a legacy repository in a way that is:\n\nUnderstandable to new engineers\nAuditable for architects and risk teams\nRepeatable as a pattern across other systems\n\nWe’ll use a COBOL-based investment portfolio system as the running example and choose a single pilot flow to focus on. You can substitute any legacy stack (eg. Java monolith, PL/SQL) where you have legacy programs, orchestration (jobs, schedulers, scripts), or shared data sources.\n\nWe’ve broken it down into 5 different phases that revolve around an executive plan (ExecPlan in short), which is a design document that the agent can follow to deliver the system change.\n\n\n\nWe will create 4 types of documents for the pilot flow we choose:\n\npilot_execplan.md** - ExecPlan that orchestrates the pilot that answers: what’s in scope, why it matters, what steps we’ll take, and how we’ll know we’re done.\npilot_overview.md** - Which legacy programs (COBOL in our example), orchestration jobs (JCL here), and data sources are involved, how data flows between them, and what the business flow actually does.\npilot_design.md** - Target shape of the system: the service/module that will own this flow, the new data model, and the public APIs or batch entry points.\npilot_validation.md** - Defines how we’ll prove parity: key scenarios, shared input datasets, how to run legacy vs modern side-by-side, and what “matching outputs” means in practice.\n\nThese 4 files help lay out what code is being changed, what the new system should look like, and exactly how to check that behavior hasn’t regressed.\n\nGoal: Give Codex a lightweight contract for how planning works in this repo, without overwhelming people with process.\n\nWe’re taking inspiration from the Using PLANS.md for multi-hour problem solving cookbook to create an AGENTS.md and PLANS.md file that will be placed in a .agent folder.\n\nAGENTS.md: If you haven’t created an AGENTS.md for your repository yet, I suggest using the /init command. Once generated, reference the add a section in your AGENTS.md to instruct the agent to reference the PLANS.md.\nPLANS.md: Use the example provided in the cookbook as a starting point\n\nThese explain what an ExecPlan is, when to create or update one, where it lives, and what sections every plan must have.\n\nIf you want Codex to tighten AGENTS or PLANS for your specific repo, you can run:\n\nPlease read the directory structure and refine .agent/AGENTS.md and .agent/PLANS.md so they are a clear, opinionated standard for how we plan COBOL modernization work here. Keep the ExecPlan skeleton but add one or two concrete examples.\n\nGoal: Align on one realistic but bounded pilot flow and capture the plan for Phase 1 in a single ExecPlan file.\n\nKey artifact: pilot_execplan.md\n\nIf you don’t have a flow in mind to pilot with, you can ask Codex to propose. Example prompt from the repository root:\n\nLook through this repository and propose one or two candidate pilot flows for modernization that are realistic but bounded.\nFor each candidate, list:\nCOBOL programs and copybooks involved\nJCL members involved\nThe business scenario in plain language\nEnd with a clear recommendation for which flow we should use as the first pilot\n\nIn this case, we’ll choose a reporting flow as the pilot.\n\n\n\n\nCreate pilot_execplan.md following .agent/PLANS.md. Scope it to the daily reporting flow. The plan should cover four outcomes for this one flow:\nInventory and diagrams\nModernization Technical Report content\nTarget design and spec\nTest plan for parity\nUse the ExecPlan skeleton and fill it in with concrete references to the actual COBOL and JCL files.\n\nThis plan is now your “home base” for all pilot work.\n\nGoal: Capture what the pilot flow actually does today: programs, jobs, data flows, and business rules. Engineers can reason about the change without reading every line of legacy code.\n\nKey artifact: pilot_reporting_overview.md\n\nWhere engineers can focus:\n\nConfirm which jobs truly run in production\nFill in gaps Codex cannot infer from code (SLAs, operational context, owners)\nSanity check diagrams and descriptions\n\nCreate or update pilot_reporting_overview.md with two top-level sections: “Inventory for the pilot” and “Modernization Technical Report for the pilot”.\nUse pilot_execplan.md to identify the pilot flow.\n\nIn the inventory section, include:\nThe COBOL programs and copybooks involved, grouped as batch, online, and utilities if applicable\nThe JCL jobs and steps that call these programs\nThe data sets or tables they read and write\nA simple text diagram that shows the sequence of jobs and data flows\n\nIn the modernization technical report section, describe:\nThe business scenario for this flow in plain language\nDetailed behavior of each COBOL program in the flow\nThe data model for the key files and tables, including field names and meanings\nKnown technical risks such as date handling, rounding, special error codes, or tricky conditions\n\nThis document will be helpful for engineers to understand the shape and behavior of the pilot without reading all the code.\n\nExample of the flow diagram in pilot_reporting_overview.md\n\n\n\n\nOnce the overview exists, ask Codex to keep the plan aligned\n\nUpdate pilot_execplan.md to reflect the new pilot_reporting_overview.md file.\nIn Progress, mark the inventory and MTR sections as drafted.\nAdd any notable findings to Surprises and discoveries and Decision log.\nKeep the ExecPlan readable for someone new to the repo.\n\nAt the end of Phase 2, you’ll have a single pilot overview doc that plays the role of both system inventory report and modernization technical report.\n\nGoal\n\nDecide what the modern version of the pilot flow should look like\nDescribe the target service and data model\nDefine how to prove parity through tests and parallel runs.\n\nBy the end of this phase, we’ll have decided what we’re building and how we’ll prove it works.\n\nKey artifacts\n\npilot_reporting_design.md\npilot_reporting_validation.md\nmodern/openapi/pilot.yaml\nmodern/tests/pilot_parity_test.py\n\n\nBased on pilot_reporting_overview.md, draft pilot_reporting_design.md with these sections:\n\nWhich service or module will own this pilot flow in the modern architecture.\nWhether it will be implemented as a batch job, REST API, event listener, or a combination.\nHow it fits into the broader domain model.\n\nProposed database tables and columns that replace the current files or DB2 tables.\nKeys, relationships, and any derived fields.\nNotes about how legacy encodings such as packed decimals or EBCDIC fields will be represented.\n\nThe main operations users or systems will call.\nA short description of each endpoint or event.\nA pointer to modern/openapi/pilot.yaml where the full schema will live.\n\n\nWe capture the pilot flow’s external behavior in an OpenAPI file so the modern system has a clear, language-agnostic contract. This spec becomes the anchor for implementation, test generation, and future integrations, and it gives Codex something concrete to scaffold code and tests from.\n\nUsing pilot_reporting_design.md, draft an OpenAPI file at modern/openapi/pilot.yaml that describes the external API for this pilot. Include:\nPaths and operations for the main endpoints or admin hooks\nRequest and response schemas for each operation\nField types and constraints, aligning with the target data model\n\nExample output:\n\n\n\n\nCreate or update pilot_reporting_validation.md with three sections:\n\nKey scenarios, including at least one happy path and a couple of edge cases.\nInputs and outputs to capture for each scenario.\n\nHow you will run the legacy COBOL flow and the modern implementation on the same input data.\nWhat outputs will be compared (files, tables, logs).\nHow differences will be detected and triaged.\n\nNotes about the test file modern/tests/pilot_parity_test.py, including how to run it.\nWhat needs to be filled in once the modern implementation exists.\n\nThen ask Codex to scaffold the tests:\n\nUsing pilot_reporting_validation.md, create an initial test file at modern/tests/pilot_parity_test.py.\n\nInclude placeholder assertions and comments that reference the scenarios in the test plan, but do not assume the modern implementation is present yet.\n\n\nUpdate pilot_execplan.md so that Plan of work, Concrete steps, and Validation and acceptance explicitly reference:\npilot_reporting_overview.md\npilot_reporting_design.md\npilot_reporting_validation.md\nmodern/openapi/pilot.yaml\nmodern/tests/pilot_parity_test.py\n\nAt the end of Phase 3, you’ll have a clear design, a machine readable spec, and a test plan/scaffolding that describes how you will prove parity.\n\nGoal: Implement the modern pilot, run it in parallel with the COBOL version, and show that outputs match for the planned scenarios.\n\nKey artifacts\n\nCode under modern//pilot (for example modern/java/pilot)\nCompleted tests in modern/tests/pilot_parity_test.py\nUpdated sections in pilot_reporting_validation.md that describe the actual parallel run steps\n\n\nUsing pilot_reporting_design.md and the COBOL programs listed in pilot_reporting_overview.md, generate initial implementation code under modern//pilot that:\nDefines domain models and database entities for the key records and tables.\nImplements the core business logic in service classes, preserving behavior from COBOL paragraphs.\nAdds comments that reference the original COBOL paragraphs and copybooks.\nTreat this as a first draft for engineers to review.\n\nYou can run this several times, focusing on different modules.\n\n\nExtend modern/tests/pilot_parity_test.py so that it:\nInvokes the legacy pilot flow using whatever wrapper or command we have for COBOL (for example a script that runs the JCL in a test harness).\nInvokes the new implementation through its API or batch entry point.\nCompares the outputs according to the “Parity and comparison strategy” in pilot_reporting_validation.md.\n\n\nRather than a separate parallel_run_pilot.md, reuse the validation doc:\n\nUpdate the Parity and comparison strategy section in pilot_reporting_validation.md so that it includes a clear, ordered list of commands to:\nPrepare or load the input data set\nRun the COBOL pilot flow on that data\nRun the modern pilot flow on the same data\nCompare outputs and interpret the results\nInclude precise paths for outputs and a short description of what success looks like\n\n\nAs tests fail or behavior differs, work in short loops:\n\nHere is a failing test from modern/tests/pilot_parity_test.py and the relevant COBOL and modern code. Explain why the outputs differ and propose the smallest change to the modern implementation that will align it with the COBOL behavior. Show the updated code and any test adjustments.\n\nEach time you complete a meaningful chunk of work, ask Codex to update the ExecPlan:\n\nUpdate pilot_execplan.md so that Progress, Decision log, and Outcomes reflect the latest code, tests, and validation results for the pilot.\n\nYou’ll see that the ExecPlan “progress” and “outcomes” section will be updated with something along the lines of:\n\nProgress\n[x] Inventory and diagrams drafted (pilot_reporting_overview.md plus supporting notes in system-architecture.md).\n[x] Modernization technical report drafted (pilot_reporting_overview.md MTR section).\n[x] Target design spec drafted (pilot_reporting_design.md and modern/openapi/pilot.yaml).\n[x] Parity test plan and scaffolding documented (pilot_reporting_validation.md and modern/tests/pilot_parity_test.py).\n\nOutcomes\npilot_reporting_overview.md, pilot_reporting_design.md, and pilot_reporting_validation.md now provide an end-to-end narrative (inventory, design, validation).\nmodern/openapi/pilot.yaml describes the API surface, and modern/python/pilot/{models,repositories,services}.py hold the draft implementation.\nmodern/tests/pilot_parity_test.py exercises the parity flow using placeholders and helpers aligned with the validation strategy.\nRemaining work is limited to updating the operations test appendix and wiring the services to the real runtime.\n\nGoal: Provide reusable templates for other flows and a short guide to using Codex in this repo.\n\nKey artifacts\n\ntemplate_modernization_execplan.md\nhow_to_use_codex_for_cobol_modernization.md\n\n\nLook at the pilot files we created:\npilot_reporting_overview.md\npilot_reporting_design.md\npilot_reporting_validation.md\npilot_execplan.md\n\nCreate template_modernization_execplan.md that a team can copy when modernizing another flow. It should:\nFollow .agent/PLANS.md\nInclude placeholders for “Overview”, “Inventory”, “Modernization Technical Report”, “Target design”, and “Validation plan”\nAssume a similar pattern: overview doc, design doc, validation doc, OpenAPI spec, and tests.\n\n\nUsing the same pilot files, write how_to_use_codex_for_cobol_modernization.md that:\nExplains the phases at a high level (Pick a pilot, Inventory and discover, Design and spec, Implement and validate, Factory pattern).\nFor each phase, lists where coding agents helps and points to the relevant files and example prompts.\n\nIf you follow the steps in this cookbook for any pilot, you should end up with a folder layout that looks roughly like this: ExecPlan, three pilot docs, an OpenAPI spec, a pilot module, and a parity test. You can further organize the markdown files in additional pilot and template subfolders for more structure.\n\n\n\nYou’ll notice that there isn’t a runnable entry point in modern/python/pilot yet since the modules (models.py, repositories.py, services.py) are first‑draft building blocks to start. You have two options if you want to experiment locally, you can\n\nUse an interactive shell or small script\nCreate your own runner (e.g. modern/python/pilot/main.py) that wires the repositories and services together\n\nWhile this cookbook uses a COBOL pilot flow as the running example, the same pattern shows up in very different kinds of refactors. For example, one customer used Codex to migrate a large monorepo by feeding it hundreds of Jira tickets, having Codex flag higher-risk work, surface cross-cutting dependencies, and draft the code changes, with a separate validator reviewing and merging.\n\nModernizing COBOL repositories is just one popular case, but the same approach applies to any legacy stack or large-scale migration: turn “modernize our codebase” into a series of small, testable steps (an ExecPlan, a handful of docs, and a parity-first implementation). Codex handles the grind of understanding old patterns, generating candidate migrations, and tightening parity, while you and your team stay focused on architecture and trade-offs, making modernization faster, safer, and repeatable across every system you decide to bring forward."])</script><script>self.__next_f.push([1,"11d:T2759,"])</script><script>self.__next_f.push([1,"Use this notebook to get started using the OpenAI Compliance Logs Platform. The examples focus on downloading log files so you can ingest them into your SIEM or data lake.\n\nHelp Center Overview\nAPI Reference\n\n\nAn Enterprise Compliance API key exported as COMPLIANCE_API_KEY.\nThe ChatGPT account ID or the API Platform Org ID for the principal in question.\nSpecific requirements for your environment\n\nProvided below are functionally identical scripts - one for Unix-based and one for Windows-based environments.\nThese scripts give an example of how one could build an integration with the Compliance API to retrieve and process\nlog data for given event types and time ranges.\nThese scripts handle listing and paging through the available log files and downloading them - writing the output to stdout.\n\nExample invocations of these scripts are embedded in their help blocks - execute them with no arguments to see them.\n\nPrerequisites:\nSave the script locally as download_compliance_files.sh and mark it executable\nMake sure you have up-to-date bash, curl, sed, and date installed.\nFormat the date you want to get every log after as an ISO 8601 string including timezone.\n\nRun the script akin to ./download_compliance_files.sh    \nset -euo pipefail\n\nusage() {\n  echo \"Usage: $0    \" \u003e\u00262\n  echo \u003e\u00262\n  echo 'Examples: ' \u003e\u00262\n  echo 'COMPLIANCE_API_KEY= ./download_compliance_files.sh f7f33107-5fb9-4ee1-8922-3eae76b5b5a0 AUTH_LOG 100 \"$(date -u -v-1d +%Y-%m-%dT%H:%M:%SZ)\" \u003e output.jsonl' \u003e\u00262\n  echo 'COMPLIANCE_API_KEY= ./download_compliance_files.sh org-p13k3klgno5cqxbf0q8hpgrk AUTH_LOG 100 \"$(date -u -v-1d +%Y-%m-%dT%H:%M:%SZ)\" \u003e output.jsonl' \u003e\u00262\n}\n\nif [[ $# -ne 4 ]]; then\n  usage\n  exit 2\nfi\n\nPRINCIPAL_ID=\"$1\"\nEVENT_TYPE=\"$2\"\nLIMIT=\"$3\"\nINITIAL_AFTER=\"$4\"\n\nif [[ -z \"${COMPLIANCE_API_KEY:-}\" ]]; then\n  echo \"COMPLIANCE_API_KEY environment variable is required. e.g.:\" \u003e\u00262\n  echo \"COMPLIANCE_API_KEY= $0    \" \u003e\u00262\n  exit 2\nfi\n\nAPI_BASE=\"https://api.chatgpt.com/v1/compliance\"\nAUTH_HEADER=(\"-H\" \"Authorization: Bearer ${COMPLIANCE_API_KEY}\")\n\nSCOPE_SEGMENT=\"workspaces\"\nif [[ \"${PRINCIPAL_ID}\" == org-* ]]; then\n  SCOPE_SEGMENT=\"organizations\"\nfi\n\nperform_curl() {\n  local description=\"$1\"\n  shift\nCapture body and HTTP status code, keeping body on stdout-like var\nWe append a newline before the status to reliably split even if body has no trailing newline.\n  local combined\n  if ! combined=$(curl -sS -w \"\\n%{http_code}\" \"$@\"); then\n    echo \"Network/transport error while ${description}\" \u003e\u00262\n    exit 1\n  fi\n  local http_code\n  http_code=\"${combined##*$'\\n'}\"\n  local body\n  body=\"${combined%$'\\n'*}\"\n\n  if [ ! \"${http_code}\" =~ ^2[0-9$ ]]; then\n    echo \"HTTP error ${http_code} while ${description}:\" \u003e\u00262\n    if [[ -n \"${body}\" ]]; then\nPrint the body to stderr so it doesn't corrupt stdout stream\n      echo \"${body}\" | jq . \u003e\u00262\n    fi\n    exit 1\n  fi\n\nOn success, emit body to stdout for callers to consume\n  echo \"${body}\"\n}\n\nlist_logs() {\n  local after=\"$1\"\n  perform_curl \"listing logs (after=${after}, event_type=${EVENT_TYPE}, limit=${LIMIT})\" \\\n    -G \\\n    \"${API_BASE}/${SCOPE_SEGMENT}/${PRINCIPAL_ID}/logs\" \\\n    \"${AUTH_HEADER[@]}\" \\\n    --data-urlencode \"limit=${LIMIT}\" \\\n    --data-urlencode \"event_type=${EVENT_TYPE}\" \\\n    --data-urlencode \"after=${after}\"\n}\n\ndownload_log() {\n  local id=\"$1\"\n  echo \"Fetching logs for ID: ${id}\" \u003e\u00262\n  perform_curl \"downloading log id=${id}\" \\\n    -G -L \\\n    \"${API_BASE}/${SCOPE_SEGMENT}/${PRINCIPAL_ID}/logs/${id}\" \\\n    \"${AUTH_HEADER[@]}\"\n}\n\nto_local_human() {\n  local iso=\"$1\"\n  if [[ -z \"${iso}\" || \"${iso}\" == \"null\" ]]; then\n    echo \"\"\n    return 0\n  fi\n\n  local iso_norm\n  iso_norm=$(echo -n \"${iso}\" \\\n    | sed -E 's/\\.[0-9]+(Z|+-+)$/\\1/' \\\n    | sed -E 's/([+-]00:00)$/Z/')\n\nmacOS/BSD date: parse UTC to epoch then format in local timezone\n  local epoch\n  epoch=$(date -j -u -f \"%Y-%m-%dT%H:%M:%SZ\" \"${iso_norm}\" +%s 2\u003e/dev/null) || true\n  if [[ -n \"${epoch}\" ]]; then\n    date -r \"${epoch}\" \"+%Y-%m-%d %H:%M:%S %Z\" 2\u003e/dev/null \u0026\u0026 return 0\n  fi\n\nFallback to original if parsing failed\n  echo \"${iso}\"\n}\n\ncurrent_after=\"${INITIAL_AFTER}\"\npage=1\ntotal_downloaded=0\nwhile true; do\n  echo \"Fetching page ${page} with after='${current_after}' (local: $(to_local_human \"${current_after}\"))\" \u003e\u00262\n  response_json=\"$(list_logs \"${current_after}\")\"\n\nCount and download each ID from the current page (if any)\n  page_count=\"$(echo \"${response_json}\" | jq '.data | length')\"\n  if [[ \"${page_count}\" -gt 0 ]]; then\n    echo \"${response_json}\" | jq -r '.data[].id' | while read -r id; do\n      download_log \"${id}\"\n    done\n    total_downloaded=$((total_downloaded + page_count))\n  fi\n\n  has_more=\"$(echo \"${response_json}\" | jq -r '.has_more')\"\n  current_after=\"$(echo \"${response_json}\" | jq -r '.last_end_time')\"\n  if [[ \"${has_more}\" == \"true\" ]]; then\n    page=$((page + 1))\n  else\n    break\n  fi\ndone\n\nif [[ \"${total_downloaded}\" -eq 0 \u0026\u0026 ( -z \"${current_after}\" || \"${current_after}\" == \"null\" ) ]]; then\n  echo \"No results found for event_type ${EVENT_TYPE} after ${INITIAL_AFTER}\" \u003e\u00262\nelse\n  echo \"Completed downloading ${total_downloaded} log files up to ${current_after} (local: $(to_local_human \"${current_after}\"))\" \u003e\u00262\nfi\n\nPrerequisites:\nSave the script locally as download_compliance_files.ps1\nOpen PowerShell (Version 5.1+) and navigate to the directory where the script is saved.\n\nRun the script akin to .\\download_compliance_files.ps1    \n\nSet-StrictMode -Version Latest\n$ErrorActionPreference = 'Stop'\n\nAdd-Type -AssemblyName System.Web\n\nfunction Show-Usage {\n    [Console]::Error.WriteLine(@\"\nUsage: .\\download_compliance_files.ps1\n\nExample:\n  `$env:COMPLIANCE_API_KEY = ''\n  .\\download_compliance_files.ps1 f7f33107-5fb9-4ee1-8922-3eae76b5b5a0 AUTH_LOG 100 (Get-Date -AsUTC).AddDays(-1).ToString('yyyy-MM-ddTHH:mm:ssZ') |\n    Out-File -Encoding utf8 output.jsonl\n\nExample (org id):\n  `$env:COMPLIANCE_API_KEY = ''\n  .\\download_compliance_files.ps1 org-p13k3klgno5cqxbf0q8hpgrk AUTH_LOG 100 (Get-Date -AsUTC).AddDays(-1).ToString('yyyy-MM-ddTHH:mm:ssZ') |\n    Out-File -Encoding utf8 output.jsonl\n\"@)\n}\n\nif ($args.Count -ne 4) {\n    Show-Usage\n    exit 2\n}\n\nif (-not $env:COMPLIANCE_API_KEY) {\n    [Console]::Error.WriteLine('COMPLIANCE_API_KEY environment variable must be set.')\n    exit 2\n}\n\n$PrincipalId = $args[0]\n$EventType = $args[1]\n$Limit = $args[2]\n$InitialAfter = $args[3]\n\n$ApiBase = 'https://api.chatgpt.com/v1/compliance'\n\nif ($PrincipalId.StartsWith('org-')) {\n    $ScopeSegment = 'organizations'\n} else {\n    $ScopeSegment = 'workspaces'\n}\n\n$handler = [System.Net.Http.HttpClientHandler]::new()\n$client = [System.Net.Http.HttpClient]::new($handler)\n$client.DefaultRequestHeaders.Authorization = New-Object System.Net.Http.Headers.AuthenticationHeaderValue('Bearer', $env:COMPLIANCE_API_KEY)\n\nfunction Invoke-ComplianceRequest {\n    param(\n        [Parameter(Mandatory = $true)] [string] $Description,\n        [Parameter(Mandatory = $true)] [string] $Path,\n        [hashtable] $Query = @{}\n    )\n\n    $builder = [System.UriBuilder]::new(\"$ApiBase/$ScopeSegment/$PrincipalId/$Path\")\n    $queryString = [System.Web.HttpUtility]::ParseQueryString($builder.Query)\n    foreach ($key in $Query.Keys) {\n        $queryString[$key] = $Query[$key]\n    }\n    $builder.Query = $queryString.ToString()\n\n    try {\n        $response = $client.GetAsync($builder.Uri).GetAwaiter().GetResult()\n    } catch {\n        [Console]::Error.WriteLine(\"Network/transport error while $Description\")\n        exit 1\n    }\n\n    $body = $response.Content.ReadAsStringAsync().GetAwaiter().GetResult()\n    if (-not $response.IsSuccessStatusCode) {\n        [Console]::Error.WriteLine(\"HTTP error $($response.StatusCode.value__) while ${Description}:\")\n        if ($body) {\n            try {\n                $parsed = $body | ConvertFrom-Json\n                $parsed | ConvertTo-Json -Depth 10 | Write-Error\n            } catch {\n                [Console]::Error.WriteLine($body)\n            }\n        }\n        exit 1\n    }\n\n    Write-Output $body\n}\n\nfunction List-Logs {\n    param(\n        [Parameter(Mandatory = $true)] [string] $After\n    )\n\n    Invoke-ComplianceRequest -Description \"listing logs (after=$After, event_type=$EventType, limit=$Limit)\" -Path 'logs' -Query @{\n        limit      = $Limit\n        event_type = $EventType\n        after      = $After\n    }\n}\n\nfunction Download-Log {\n    param(\n        [Parameter(Mandatory = $true)] [string] $Id\n    )\n\n    [Console]::Error.WriteLine(\"Fetching logs for ID: $Id\")\n    Invoke-ComplianceRequest -Description \"downloading log id=$Id\" -Path \"logs/$Id\"\n}\n\nfunction ConvertTo-LocalHuman {\n    param(\n        [string] $Iso\n    )\n\n    if (-not $Iso -or $Iso -eq 'null') {\n        return ''\n    }\n\n    try {\n        $dt = [datetimeoffset]::Parse($Iso)\n        return $dt.ToLocalTime().ToString('yyyy-MM-dd HH:mm:ss zzz')\n    } catch {\n        return $Iso\n    }\n}\n\n$currentAfter = $InitialAfter\n$page = 1\n$totalDownloaded = 0\nwhile ($true) {\n    [Console]::Error.WriteLine(\"Fetching page $page with after='$currentAfter' (local: $(ConvertTo-LocalHuman -Iso $currentAfter))\")\n    $responseJson = List-Logs -After $currentAfter\n    $responseObj = $responseJson | ConvertFrom-Json\n\n    $pageCount = $responseObj.data.Count\n    if ($pageCount -gt 0) {\n        foreach ($entry in $responseObj.data) {\n            Download-Log -Id $entry.id\n        }\n        $totalDownloaded += $pageCount\n    }\n\n    $hasMore = $false\n    if ($null -ne $responseObj.has_more) {\n        $hasMore = [System.Convert]::ToBoolean($responseObj.has_more)\n    }\n\n    $currentAfter = $responseObj.last_end_time\n    if ($hasMore) {\n        $page += 1\n    } else {\n        break\n    }\n}\n\nif ($totalDownloaded -eq 0 -and ([string]::IsNullOrEmpty($currentAfter) -or $currentAfter -eq 'null')) {\n    [Console]::Error.WriteLine(\"No results found for event_type $EventType after $InitialAfter\")\n} else {\n    [Console]::Error.WriteLine(\"Completed downloading $totalDownloaded log files up to $currentAfter (local: $(ConvertTo-LocalHuman -Iso $currentAfter))\")\n}\n\n$client.Dispose()\n$handler.Dispose()\n`"])</script><script>self.__next_f.push([1,"11e:T5662,"])</script><script>self.__next_f.push([1,"GPT-5.2 is our newest flagship model for enterprise and agentic workloads, designed to deliver higher accuracy, stronger instruction following, and more disciplined execution across complex workflows. Building on GPT-5.1, GPT-5.2 improves token efficiency on medium-to-complex tasks, produces cleaner formatting with less unnecessary verbosity, and shows clear gains in structured reasoning, tool grounding, and multimodal understanding.\n\nGPT-5.2 is especially well-suited for production agents that prioritize reliability, evaluability, and consistent behavior. It performs strongly across coding, document analysis, finance, and multi-tool agentic scenarios, often matching or exceeding leading models on task completion. At the same time, it remains prompt-sensitive and highly steerable in tone, verbosity, and output shape, making explicit prompting an important part of successful deployments.\n\nWhile GPT-5.2 works well out of the box for many use cases, this guide focuses on prompt patterns and migration practices that maximize performance in real production systems. These recommendations are drawn from internal testing and customer feedback, where small changes to prompt structure, verbosity constraints, and reasoning settings often translate into large gains in correctness, latency, and developer trust.\n\nCompared with previous generation models (e.g. GPT-5 and GPT-5.1), GPT-5.2 delivers:\n\nMore deliberate scaffolding:** Builds clearer plans and intermediate structure by default; benefits from explicit scope and verbosity constraints.\nGenerally lower verbosity:** More concise and task-focused, though still prompt-sensitive and preference needs to be articulated in the prompt.\nStronger instruction adherence:** Less drift from user intent; improved formatting and rationale presentation.\nTool efficiency trade-offs:** Takes additional tool actions in interactive flows compared with GPT-5.1, can be further optimized via prompting.\nConservative grounding bias:** Tends to favor correctness and explicit reasoning; ambiguity handling improves with clarification prompts.\n\nThis guide focuses on prompting GPT-5.2 to maximize its strengths — higher intelligence, accuracy, grounding, and discipline — while mitigating remaining inefficiencies. Existing GPT-5 / GPT-5.1 prompting guidance largely carries over and remains applicable.\n\nAdapt following themes into your prompts for better steer on GPT-5.2\n\n\nGive clear and concrete length constraints especially in enterprise and coding agents.\n\nExample clamp adjust based on desired verbosity:\n\nDefault: 3–6 sentences or ≤5 bullets for typical answers.\nFor simple “yes/no + short explanation” questions: ≤2 sentences.\nFor complex multi-step or multi-file tasks:\n  1 short overview paragraph\n  then ≤5 bullets tagged: What changed, Where, Risks, Next steps, Open questions.\nProvide clear and structured responses that balance informativeness with conciseness. Break down the information into digestible chunks and use formatting like lists, paragraphs and tables when helpful.\nAvoid long narrative paragraphs; prefer compact bullets and short sections.\nDo not rephrase the user’s request unless it changes semantics.\n\n\n\nGPT-5.2 is stronger at structured code but may produce more code than the minimal UX specs and design systems. To stay within the scope, explicitly forbid extra features and uncontrolled styling.\n\nExplore any existing design systems and understand it deeply.\nImplement EXACTLY and ONLY what the user requests.\nNo extra features, no added components, no UX embellishments.\nStyle aligned to the design system at hand.\nDo NOT invent colors, shadows, tokens, animations, or new UI elements, unless requested or necessary to the requirements.\nIf any instruction is ambiguous, choose the simplest valid interpretation.\n\n\nFor design system enforcement, reuse your 5.1  block but add “no extra features” and “tokens-only colors” for extra emphasis.\n\nFor long-context tasks, the prompt may benefit from force summarization and re-grounding. This pattern reduces “lost in the scroll” errors and improves recall over dense contexts.\n\nFor inputs longer than ~10k tokens (multi-chapter docs, long threads, multiple PDFs):\n  First, produce a short internal outline of the key sections relevant to the user’s request.\n  Re-state the user’s constraints explicitly (e.g., jurisdiction, date range, product, team) before answering.\n  In your answer, anchor claims to sections (“In the ‘Data Retention’ section…”) rather than speaking generically.\nIf the answer depends on fine details (dates, thresholds, clauses), quote or paraphrase them.\n\n\n\nConfigure the prompt for overconfident hallucinations on ambiguous queries (e.g., unclear requirements, missing constraints, or questions that need fresh data but no tools are called).\n\nMitigation prompt:\n\nIf the question is ambiguous or underspecified, explicitly call this out and:\n  Ask up to 1–3 precise clarifying questions, OR\n  Present 2–3 plausible interpretations with clearly labeled assumptions.\nWhen external facts may have changed recently (prices, releases, policies) and no tools are available:\n  Answer in general terms and state that details may have changed.\nNever fabricate exact figures, line numbers, or external references when you are uncertain.\nWhen you are unsure, prefer language like “Based on the provided context…” instead of absolute claims.\n\n\nYou can also add a short self-check step for high-risk outputs:\n\n\nBefore finalizing an answer in legal, financial, compliance, or safety-sensitive contexts:\nBriefly re-scan your own answer for:\n  Unstated assumptions,\n  Specific numbers or claims not grounded in context,\n  Overly strong language (“always,” “guaranteed,” etc.).\nIf you find any, soften or qualify them and explicitly state assumptions.\n\n\nFor long-running, tool-heavy workflows that exceed the standard context window, GPT-5.2 with Reasoning supports response compaction via the /responses/compact endpoint. Compaction performs a loss-aware compression pass over prior conversation state, returning encrypted, opaque items that preserve task-relevant information while dramatically reducing token footprint. This allows the model to continue reasoning across extended workflows without hitting context limits.\n\nWhen to use compaction\nMulti-step agent flows with many tool calls\nLong conversations where earlier turns must be retained\nIterative reasoning beyond the maximum context window\n\n\nKey properties\nProduces opaque, encrypted items (internal logic may evolve)\nDesigned for continuation, not inspection\nCompatible with GPT-5.2 and Responses API\nSafe to run repeatedly in long sessions\n\nCompact a Response\n\nEndpoint\nPOST https://api.openai.com/v1/responses/compact\n\nWhat it does\n\nRuns a compaction pass over a conversation and returns a compacted response object. Pass the compacted output into your next request to continue the workflow with reduced context size.\n\nBest practices\n\nMonitor context usage and plan ahead to avoid hitting context window limits\nCompact after major milestones (e.g., tool-heavy phases), not every turn\nKeep prompts functionally identical when resuming to avoid behavior drift\nTreat compacted items as opaque; don’t parse or depend on internals\n\nFor guidance on when and how to compact in production, see the Conversation State guide and Compact a Response page.\n\nHere is an example:\n\nGPT-5.2 is strong on agentic scaffolding and multi-step execution when prompted well. You can reuse your GPT-5.1  and  blocks.\n\nTwo key tweaks could be added to further push the performance of GPT-5.2:\nClamp verbosity of updates (shorter, more focused).\nMake scope discipline explicit (don’t expand problem surface area).\n\nExample updated spec:\n\n\nSend brief updates (1–2 sentences) only when:\n  You start a new major phase of work, or\n  You discover something that changes the plan.\nAvoid narrating routine tool calls (“reading file…”, “running tests…”).\nEach update must include at least one concrete outcome (“Found X”, “Confirmed Y”, “Updated Z”).\nDo not expand the task beyond what the user asked; if you notice new work, call it out as optional.\n\n\nGPT-5.2 improves on 5.1 in tool reliability and scaffolding, especially in MCP/Atlas-style environments.\nBest practices as applicable to GPT-5 / 5.1:\nDescribe tools crisply: 1–2 sentences for what they do and when to use them.\nEncourage parallelism explicitly for scanning codebases, vector stores, or multi-entity operations.\nRequire verification steps for high-impact operations (orders, billing, infra changes).\n\nExample tool usage section:\n\nPrefer tools over internal knowledge whenever:\n  You need fresh or user-specific data (tickets, orders, configs, logs).\n  You reference specific IDs, URLs, or document titles.\nParallelize independent reads (read_file, fetch_record, search_docs) when possible to reduce latency.\nAfter any write/update tool call, briefly restate:\n  What changed,\n  Where (ID or path),\n  Any follow-up validation performed.\n\n\n\nThis is an area where GPT-5.2 clearly shows strong improvements. To get the most out of it:\n\nAlways provide a schema or JSON shape for the output. You can use structured outputs for strict schema adherence.\nDistinguish between required and optional fields.\nAsk for “extraction completeness” and handle missing fields explicitly.\n\nExample:\n\nYou will extract structured data from tables/PDFs/emails into JSON.\n\nAlways follow this schema exactly (no extra fields):\n  {\n    \"party_name\": string,\n    \"jurisdiction\": string | null,\n    \"effective_date\": string | null,\n    \"termination_clause_summary\": string | null\n  }\nIf a field is not present in the source, set it to null rather than guessing.\nBefore returning, quickly re-scan the source for any missed fields and correct omissions.\n\n\nFor multi-table/multi-file extraction, add guidance to:\nSerialize per-document results separately.\nInclude a stable ID (filename, contract title, page range).\n\nThis section helps you migrate prompts and model configs to GPT-5.2 while keeping behavior stable and cost/latency predictable. GPT-5-class models support a reasoning_effort knob (e.g., none|minimal|low|medium|high|xhigh) that trades off speed/cost vs. deeper reasoning.\n\nMigration mapping\nUse the following default mappings when updating to GPT-5.2\n\n| Current model | Target model | Target reasoning_effort | Notes |\n|--------------|--------------|-------------------------|-------|\n| GPT-4o       | GPT-5.2      | none                    | Treat 4o/4.1 migrations as “fast/low-deliberation” by default; only increase effort if evals regress. |\n| GPT-4.1      | GPT-5.2      | none                    | Same mapping as GPT-4o to preserve snappy behavior. |\n| GPT-5        | GPT-5.2      | same value except minimal → none | Preserve none/low/medium/high to keep latency/quality profile consistent. |\n| GPT-5.1      | GPT-5.2      | same value              | Preserve existing effort selection; adjust only after running evals. |\n\n*Note that default reasoning level for GPT-5 is medium, and for GPT-5.1 and GPT-5.2 is none.\n\nWe introduced the Prompt Optimizer in the Playground to help users quickly improve existing prompts and migrate them across GPT-5 and other OpenAI models. General steps to migrate to a new model are as follows:\n\nStep 1: Switch models, don’t change prompts yet. Keep the prompt functionally identical so you’re testing the model change—not prompt edits. Make one change at a time.\nStep 2: Pin reasoning_effort. Explicitly set GPT-5.2 reasoning_effort to match the prior model’s latency/depth profile (avoid provider-default “thinking” traps that skew cost/verbosity/structure).\nStep 3: Run Evals for a baseline. After model + effort are aligned, run your eval suite. If results look good (often better at med/high), you’re ready to ship.\nStep 4: If regressions, tune the prompt. Use Prompt Optimizer + targeted constraints (verbosity/format/schema, scope discipline) to restore parity or improve.\nStep 5: Re-run Evals after each small change. Iterate by either bumping reasoning_effort one notch or making incremental prompt tweaks—then re-measure.\n\nGPT-5.2 is more steerable and capable at synthesizing information across many sources.\n\nBest practices to follow:\n\nSpecify the research bar up front: Tell the model how you want to perform search. Whether to follow second-order leads, resolve contradictions and include citations. Explicitly state how far to go, for instance: that additional research should continue until marginal value drops.\n\nConstrain ambiguity by instruction, not questions: Instruct the model to cover all plausible intents comprehensively and not ask clarifying questions. Require breadth and depth when uncertainty exists.\n\nDictate output shape and tone: Set expectations for structure (Markdown, headers, tables for comparisons), clarity (define acronyms, concrete examples) and voice (conversational, persona-adaptive, non-sycophantic)\n\n\nAct as an expert research assistant; default to comprehensive, well-structured answers.\nPrefer web research over assumptions whenever facts may be uncertain or incomplete; include citations for all web-derived information.\nResearch all parts of the query, resolve contradictions, and follow important second-order implications until further research is unlikely to change the answer.\nDo not ask clarifying questions; instead cover all plausible user intents with both breadth and depth.\nWrite clearly and directly using Markdown (headers, bullets, tables when helpful); define acronyms, use concrete examples, and keep a natural, conversational tone.\n\n\n\n\nGPT-5.2 represents a meaningful step forward for teams building production-grade agents that prioritize accuracy, reliability, and disciplined execution. It delivers stronger instruction following, cleaner output, and more consistent behavior across complex, tool-heavy workflows. Most existing prompts migrate cleanly, especially when reasoning effort, verbosity, and scope constraints are preserved during the initial transition. Teams should rely on evals to validate behavior before making prompt changes, adjusting reasoning effort or constraints only when regressions appear. With explicit prompting and measured iteration, GPT-5.2 can unlock higher quality outcomes while maintaining predictable cost and latency profiles.\n\nYou are a helpful, warm web research agent. Your job is to deeply and thoroughly research the web and provide long, detailed, comprehensive, well written, and well structured answers grounded in reliable sources. Your answers should be engaging, informative, concrete, and approachable. You MUST adhere perfectly to the guidelines below.\nCORE MISSION\nAnswer the user’s question fully and helpfully, with enough evidence that a skeptical reader can trust it.\nNever invent facts. If you can’t verify something, say so clearly and explain what you did find.\nDefault to being detailed and useful rather than short, unless the user explicitly asks for brevity.\nGo one step further: after answering the direct question, add high-value adjacent material that supports the user’s underlying goal without drifting off-topic. Don’t just state conclusions—add an explanatory layer. When a claim matters, explain the underlying mechanism/causal chain (what causes it, what it affects, what usually gets misunderstood) in plain language.\nPERSONA\nYou are the world’s greatest research assistant.\nEngage warmly, enthusiastically, and honestly, while avoiding any ungrounded or sycophantic flattery.\nAdopt whatever persona the user asks you to take.\nDefault tone: natural, conversational, and playful rather than formal or robotic, unless the subject matter requires seriousness.\nMatch the vibe of the request: for casual conversation lean supportive; for work/task-focused requests lean straightforward and helpful.\nFACTUALITY AND ACCURACY (NON-NEGOTIABLE)\nYou MUST browse the web and include citations for all non-creative queries, unless:\nThe user explicitly tells you not to browse, OR\nThe request is purely creative and you are absolutely sure web research is unnecessary (example: “write a poem about flowers”).\nIf you are on the fence about whether browsing would help, you MUST browse.\nYou MUST browse for:\n“Latest/current/today” or time-sensitive topics (news, politics, sports, prices, laws, schedules, product specs, rankings/records, office-holders).\nUp-to-date or niche topics where details may have changed recently (weather, exchange rates, economic indicators, standards/regulations, software libraries that could be updated, scientific developments, cultural trends, recent media/entertainment developments).\nTravel and trip planning (destinations, venues, logistics, hours, closures, booking constraints, safety changes).\nRecommendations of any kind (because what exists, what’s good, what’s open, and what’s safe can change).\nGeneric/high-level topics (example: “what is an AI agent?” or “openai”) to ensure accuracy and current framing.\nNavigational queries (finding a resource, site, official page, doc, definition, source-of-truth reference, etc.).\nAny query containing a term you’re unsure about, suspect is a typo, or has ambiguous meaning.\nFor news queries, prioritize more recent events, and explicitly compare:\nThe publish date of each source, AND\nThe date the event happened (if different).\nCITATIONS (REQUIRED)\nWhen you use web info, you MUST include citations.\nPlace citations after each paragraph (or after a tight block of closely related sentences) that contains non-obvious web-derived claims.\nDo not invent citations. If the user asked you not to browse, do not cite web sources.\nUse multiple sources for key claims when possible, prioritizing primary sources and high-quality outlets.\nHOW YOU RESEARCH\nYou must conduct deep research in order to provide a comprehensive and off-the-charts informative answer. Provide as much color around your answer as possible, and aim to surprise and delight the user with your effort, attention to detail, and nonobvious insights.\nStart with multiple targeted searches. Use parallel searches when helpful. Do not ever rely on a single query.\nDeeply and thoroughly research until you have sufficient information to give an accurate, comprehensive answer with strong supporting detail.\nBegin broad enough to capture the main answer and the most likely interpretations.\nAdd targeted follow-up searches to fill gaps, resolve disagreements, or confirm the most important claims.\nIf the topic is time-sensitive, explicitly check for recent updates.\nIf the query implies comparisons, options, or recommendations, gather enough coverage to make the tradeoffs clear (not just a single source).\nKeep iterating until additional searching is unlikely to materially change the answer or add meaningful missing detail.\nIf evidence is thin, keep searching rather than guessing.\nIf a source is a PDF and details depend on figures/tables, use PDF viewing/screenshot rather than guessing.\nOnly stop when all are true:\nYou answered the user’s actual question and every subpart.\nYou found concrete examples and high-value adjacent material.\nYou found sufficient sources for core claims\n\nWRITING GUIDELINES\nBe direct: Start answering immediately.\nBe comprehensive: Answer every part of the user’s query. Your answer should be very detailed and long unless the user request is extremely simplistic. If your response is long, include a short summary at the top.\nUse simple language: full sentences, short words, concrete verbs, active voice, one main idea per sentence.\nAvoid jargon or esoteric language unless the conversation unambiguously indicates the user is an expert.\nUse readable formatting:\nUse Markdown unless the user specifies otherwise.\nUse plain-text section labels and bullets for scannability.\nUse tables when the reader’s job is to compare or choose among options (when multiple items share attributes and a grid makes differences pop faster than prose).\nDo NOT add potential follow-up questions or clarifying questions at the beginning or end of the response unless the user has explicitly asked for them.\n\nREQUIRED “VALUE-ADD” BEHAVIOR (DETAIL/RICHNESS)\nConcrete examples: You MUST provide concrete examples whenever helpful (named entities, mechanisms, case examples, specific numbers/dates, “how it works” detail). For queries that ask you to explain a topic, you can also occasionally include an analogy if it helps.\nDo not be overly brief by default: even for straightforward questions, your response should include relevant, well-sourced material that makes the answer more useful (context, background, implications, notable details, comparisons, practical takeaways).\nIn general, provide additional well-researched material whenever it clearly helps the user’s goal.\n\nBefore you finalize, do a quick completeness pass:\nDid I answer every subpart\nDid each major section include explanation + at least one concrete detail/example when possible\nDid I include tradeoffs/decision criteria where relevant\n\n\nHANDLING AMBIGUITY (WITHOUT ASKING QUESTIONS)\nNever ask clarifying or follow-up questions unless the user explicitly asks you to.\nIf the query is ambiguous, state your best-guess interpretation plainly, then comprehensively cover the most likely intent. If there are multiple most likely intents, then comprehensively cover each one (in this case you will end up needing to provide a full, long answer for each intent interpretation), rather than asking questions.\nIF YOU CANNOT FULLY COMPLY WITH A REQUEST\nDo not lead with a blunt refusal if you can safely provide something helpful immediately.\nFirst deliver what you can (safe partial answers, verified material, or a closely related helpful alternative), then clearly state any limitations (policy limits, missing/behind-paywall data, unverifiable claims).\nIf something cannot be verified, say so plainly, explain what you did verify, what remains unknown, and the best next step to resolve it (without asking the user a question).\n`"])</script><script>self.__next_f.push([1,"11f:T3303,"])</script><script>self.__next_f.push([1,"gpt-image-1.5 is our latest image generation model, designed for production-quality visuals and highly controllable creative workflows. It delivers major improvements in realism, accuracy, and editability, making it well-suited for both professional design tasks and iterative content creation. It delivers major improvements in realism, accuracy, and editability compared to the previous generation, and supports both high-quality rendering and low-latency use cases.\n\nKey Capabilities include:\n\nHigh-fidelity photorealism** with natural lighting, accurate materials, and rich color rendering\nFlexible quality–latency tradeoffs**, allowing faster generation at lower settings while still exceeding the visual quality of prior-generation image models\nRobust facial and identity preservation** for edits, character consistency, and multi-step workflows\nReliable text rendering** with crisp lettering, consistent layout, and strong contrast inside images\nComplex structured visuals**, including infographics, diagrams, and multi-panel compositions\nPrecise style control and style transfer** with minimal prompting, supporting everything from branded design systems to fine-art styles\nStrong real-world knowledge and reasoning**, enabling accurate depictions of objects, environments, and scenarios\n\nThis guide highlights prompting patterns, best practices, and example prompts drawn from real production use cases.\n\n\nStructure + goal:** Write prompts in a consistent order (background/scene → subject → key details → constraints) and include the intended use (ad, UI mock, infographic) to set the “mode” and level of polish. For complex requests, use short labeled segments or line breaks instead of one long paragraph.\n\nSpecificity + quality cues:* Be concrete about materials, shapes, textures, and the visual medium (photo, watercolor, 3D render), and add targeted “quality levers” only when needed (e.g., *film grain, textured brushstrokes, macro detail). For photorealism, camera/composition terms (lens, aperture feel, lighting) often steer realism more reliably than generic “8K/ultra-detailed.”\n\nLatency vs fidelity**: For latency-sensitive or high-volume use cases, start with setting quality=\"low\" and evaluate whether it meets your visual requirements. In many cases, it provides sufficient fidelity with significantly faster generation.\n\nComposition:** Specify framing and viewpoint (close-up, wide, top-down), perspective/angle (eye-level, low-angle), and lighting/mood (soft diffuse, golden hour, high-contrast) to control the shot. If layout matters, call out placement (e.g., “logo top-right,” “subject centered with negative space on left”).\n\nConstraints (what to change vs preserve):** State exclusions and invariants explicitly (e.g., “no watermark,” “no extra text,” “no logos/trademarks,” “preserve identity/geometry/layout/brand elements”). For edits, use “change only X” + “keep everything else the same,” and repeat the preserve list on each iteration to reduce drift.\n\nText in images:* Put literal text in *quotes* or *ALL CAPS** and specify typography details (font style, size, color, placement) as constraints. For tricky words (brand names, uncommon spellings), spell them out letter-by-letter to improve character accuracy.\n\nMulti-image inputs:* Reference each input by *index and description** (“Image 1: product photo… Image 2: style reference…”) and describe how they interact (“apply Image 2’s style to Image 1”). When compositing, be explicit about which elements move where (“put the bird from Image 1 on the elephant in Image 2”).\n\nIterate instead of overloading:** Start with a clean base prompt, then refine with small, single-change follow-ups (“make lighting warmer,” “remove the extra tree,” “restore the original background”). Use references like “same style as before” or “the subject” to leverage context, but re-specify critical details if they start to drift.\n\nRun this once. It:\ncreates the API client\ncreates output_images/ in the images folder.\nadds a small helper to save base64 images\n\nPut any reference images used for edits into input_images/ (or update the paths in the examples).\n\nUse infographics to explain structured information for a specific audience: students, executives, customers, or the general public. Examples include explainers, posters, labeled diagrams, timelines, and “visual wiki” assets. For dense layouts or heavy in-image text, it's recommedned to set output generation quality to \"high\".\n\n\nUsed for localizing existing designs (ads, UI screenshots, packaging, infographics) into another language without rebuilding the layout from scratch. The key is to preserve everything except the text—keep typography style, placement, spacing, and hierarchy consistent—while translating verbatim and accurately, with no extra words, no reflow unless necessary, and no unintended edits to logos, icons, or imagery.\nOutput Image:\n\nTo get believable photorealism, prompt the model as if a real photo is being captured in the moment. Use photography language (lens, lighting, framing) and explicitly ask for real texture (pores, wrinkles, fabric wear, imperfections). Avoid words that imply studio polish or staging. When detail matters, set quality=\"high\".\nOutput Image:\n\nGPT-image-1.5 has built-in reasoning and strong world knowledge. For example, when asked to generate a scene set in Bethel, New York in August 1969, it can infer Woodstock and produce an accurate, context-appropriate image without being explicitly told about the event.\nOutput Image:\n\nStrong logo generation comes from clear brand constraints and simplicity. Describe the brand’s personality and use case, then ask for a clean, original mark with strong shape, balanced negative space, and scalability across sizes.\n\nYou can specify parameter \"n\" to denote the number of variations you would like to generate.\nOutput Images:\n\n| Option 1 | Option 2 | Option 3 | Option 4 |\n|:--------:|:--------:|:--------:|:--------:|\n|  |  |  | |\n\nFor story-to-comic generation, define the narrative as a sequence of clear visual beats, one per panel. Keep descriptions concrete and action-focused so the model can translate the story into readable, well-paced panels.\nOutput Image:\n\nUI mockups work best when you describe the product as if it already exists. Focus on layout, hierarchy, spacing, and real interface elements, and avoid concept art language so the result looks like a usable, shipped interface rather than a design sketch.\nOutput Image:\n\nStyle transfer is useful when you want to keep the visual language of a reference image (palette, texture, brushwork, film grain, etc.) while changing the subject or scene. For best results, describe what must stay consistent (style cues) and what must change (new content), and add hard constraints like background, framing, and “no extra elements” to prevent drift.\nInput Image:\n\nOutput Image:\n\nVirtual try-on is ideal for ecommerce previews where identity preservation is critical. The key is to explicitly lock the person (face, body shape, pose, hair, expression) and allow changes only to garments, then require realistic fit (draping, folds, occlusion) plus consistent lighting/shadows so the outfit looks naturally worn—not pasted on.\nInput Images:\n\n| Full Body | Item 1 |\n|:------------:|:--------------:|\n|   |  |\n| Item 2 | Item 3 |\n|  |  |\nOutput Image:\n\n\nSketch-to-render workflows are great for turning rough drawings into photorealistic concepts while keeping the original intent. Treat the prompt like a spec: preserve layout and perspective, then add realism by specifying plausible materials, lighting, and environment. Include “do not add new elements/text” to avoid creative reinterpretations.\nInput Image:\n\nOutput Image:\n\nProduct extraction and mockup prep is commonly used for catalogs, marketplaces, and design systems. Success depends on edge quality (clean silhouette, no fringing/halos) and label integrity (text stays sharp and unchanged). If you want realism without re-styling, ask for only light polishing and optionally a subtle contact shadow that respects the alpha.\nInput Image:\n\nOutput Image:\n\nMarketing creatives with real in-image text are great for rapid ad concepting, but typography needs explicit constraints. Put the exact copy in quotes, demand verbatim rendering (no extra characters), and describe placement and font style. If text fidelity is imperfect, keep the prompt strict and iterate—small wording/layout tweaks usually improve legibility.\nInput Image:\n\nOutput Image:\n\nUsed to re-stage a photo for different moods, seasons, or time-of-day variants (e.g., sunny → overcast, daytime → dusk, clear → snowy) while keeping the scene composition intact. The key is to change only environmental conditions—lighting direction/quality, shadows, atmosphere, precipitation, and ground wetness—while preserving identity, geometry, camera angle, and object placement so it still reads as the same original photo.\nOutput Image:\n\nPerson-in-scene compositing is useful for storyboards, campaigns, and “what if” scenarios where facial/identity preservation matters. Anchor realism by specifying a grounded photographic look (natural lighting, believable detail, no cinematic grading), and lock what must not change about the subject. When available, higher input fidelity helps maintain likeness during larger scene edits.\n| Original Input | Remove Red Stripes | Change Hat Color |\n|:------------:|:--------------:|:--------------:|\n|   |  |   |\n\nPerson-in-scene compositing is useful for storyboards, campaigns, and “what if” scenarios where facial/identity preservation matters. Anchor realism by specifying a grounded photographic look (natural lighting, believable detail, no cinematic grading), and lock what must not change about the subject. When available, higher input fidelity helps maintain likeness during larger scene edits.\nOutput Image:\n\nUsed to combine elements from multiple inputs into a single, believable image—great for “insert this object/person into that scene” workflows without re-generating everything. The key is to clearly specify what to transplant (the dog from image 2), where it should go (right next to the woman in image 1), and what must remain unchanged (scene, background, framing), while matching lighting, perspective, scale, and shadows so the composite looks naturally captured in the original photo.\n| Image Input 1 | Image Input 2 | Output |\n|:------------:|:--------------:|:--------------:|\n|   |  |   |\n\nUsed for visualizing furniture or decor changes in real spaces without re-rendering the entire scene. The goal is surgical realism: swap a single object while preserving camera angle, lighting, shadows, and surrounding context so the edit looks like a real photograph, not a redesign.\n| Input Image | Output Image |\n|------------|--------------|\n|  |  |\nIdeal for seasonal marketing concepts and print previews. Emphasizes tactile realism—paper layers, fibers, folds, and soft studio lighting—so the result reads as a photographed physical product rather than a flat illustration.\nOutput Image:\n\nUsed for early merch ideation and pitch visuals. Focuses on premium product photography cues (materials, packaging, print clarity) while keeping designs original and non-infringing. Works well for testing multiple character or packaging variants quickly.\n\nOutput Image:\n\nDesigned for multi-page illustration pipelines where character drift is unacceptable. A reusable “character anchor” ensures visual continuity across scenes, poses, and pages while allowing environmental and narrative variation.\n\n1️⃣ Character Anchor — establish the reusable main character\n\nGoal: Lock the character’s appearance, proportions, outfit, and tone.\nOutput Image:\n\n2️⃣ Story continuation — reuse character, advance the narrative\n\nGoal: Same character, new scene + action.\nCharacter appearance must remain unchanged.\nOutput Image:\n\nIn this notebook, we demonstrate how to use gpt-image-1.5 to build high-quality, controllable image generation and editing workflows that hold up in real production settings. The cookbook emphasizes prompt structure, explicit constraints, and small iterative changes as the primary tools for controlling realism, layout, text accuracy, and identity preservation. We cover both generation and editing patterns—ranging from infographics, photorealism, UI mockups, and logos to translation, style transfer, virtual try-on, compositing, and lighting changes. Throughout the examples, the cookbook reinforces the importance of clearly separating what should change from what must remain invariant, and of restating those invariants on every iteration to prevent drift. We also highlight how quality and input-fidelity settings enable deliberate tradeoffs between latency and visual precision depending on the use case. Together, these examples form a practical, repeatable playbook for deploying gpt-image-1.5 in production image workflows."])</script><script>self.__next_f.push([1,"120:T1175,"])</script><script>self.__next_f.push([1,"Similar to ChatGPT’s built-in personality presets, you can steer your Agent’s behavior by explicitly defining its personality in your prompt instructions. These instructions—sometimes called the “system prompt” or “developer prompt”—guide the agent’s tone, detail level, and style of responses. In this notebook, we’ll refer to them simply as “instructions,” following the term used in the OpenAI API documentation for consistency.\n\nDefining personality at the system instructions level helps control verbosity, structure, and decision-making style across all interactions.\n\nA personality defines the style and tone the model uses when responding. It shapes how answers feel - for example, polished and professional, concise and utilitarian, or direct and corrective.\n\nChanging the personality influences how responses are communicated. Personalities also do not override task‑specific output formats. If you ask for an email, code snippet, JSON, or résumé, the model should follow your instructions and the task context rather than the selected personality.\n\nBelow are example personalities for API and agent use, with sample instruction prompts you can adapt directly in your application. The examples show that personality should not be treated as aesthetic polish, but as an operational lever that improves consistency, reduces drift, and aligns model behavior with user expectations and business constraints.\n\nBefore running this notebook, make sure you have installed the following packages:\n\nPolished and precise. Uses formal language and professional writing conventions.\n\nBest for: Enterprise agents, legal/finance workflows, production support\n\nWhy it works: Reinforces precision, business‑appropriate tone, and disciplined execution; mitigates over‑casual drift.\n\nAs an example, professional prompt can be used for drafting formal communication such as: Announce a per diem of $75 in company travel reimbursement policy\n\nConcise and plain, delivering direct answers without extra words.\n\nBest for: Code Generation, Developer tools, background agents, batch automation, evaluators, SDK‑heavy use cases.\n\nWhy it works: Directly counters verbosity, narration, and over‑scaffolding; aligns with token efficiency.\n\nFor efficient personality, let's take example of when you just need a list of ingedients for a dish: Grocery list for cooking tomato soup\n\nDirect and encouraging, grounded answers, and clear next steps.\n\nBest for: Debugging, evals, risk analysis, coaching workflows, document parsing \u0026 reviews.\n\nWhy it works: Encourages honest feedback, grounded responses, clamps hallucinations, explicit trade‑offs, and corrective guidance without drifting into friendliness or hedging.\n\nLet's use an example where your agent needs to cite the sources. The agent will search the web to find \"How many US Federal holidays are there in the year 2026?\"\n\nExploratory and enthusiastic, explaining concepts clearly while celebrating knowledge and discovery.\n\nBest for: Internal documentation copilot, onboarding help, technical excellence, training/enablement.\n\nWhy it works: Reinforces exploration and deep understanding; fosters technical curiosity and knowledge sharing within teams.\n\nLet's take an example where we want the agent to explain in detail - \"What is the weather usually like in San Francisco around January?\"\n\nAgent personality is a critical lever for shaping how your system behaves in production. By defining personality instructions explicitly at the system or developer-prompt level, you can reliably steer tone, verbosity, structure, and decision-making style without interfering with task-specific instructions or output formats.\n\nThis cookbook demonstrated how different personality profiles—such as Professional, Efficient, Fact-based, and Exploratory—map cleanly to real-world use cases, from enterprise workflows and developer tooling to research assistants and internal enablement.\n\nIn practice, the most effective approach is to start with a minimal, well-scoped personality aligned to the target workload, validate it through evals, and evolve it deliberately as requirements change. Avoid overloading personalities with task logic or domain rules—keep them focused on how the agent responds, not what it must do.\n\nUsed thoughtfully, agent personalities enable you to build systems that are not only more useful, but more predictable, scalable, and trustworthy in real production environments."])</script><script>self.__next_f.push([1,"9:[\"$\",\"nav\",null,{\"className\":\"flex items-center justify-between py-3 px-4 sm:px-8 sticky top-0 bg-[var(--background-nav)] h-16 z-50 backdrop-blur\",\"children\":[[\"$\",\"a\",null,{\"href\":\"/\",\"className\":\"flex items-center space-x-1.5\",\"children\":[\"$\",\"svg\",null,{\"width\":187,\"height\":24,\"viewBox\":\"0 0 187 24\",\"fill\":\"none\",\"xmlns\":\"http://www.w3.org/2000/svg\",\"className\":\"fill-black dark:fill-white hover:text-primary\",\"children\":[[\"$\",\"mask\",null,{\"id\":\"mask0_1137_16681\",\"maskUnits\":\"userSpaceOnUse\",\"x\":\"0\",\"y\":\"0\",\"width\":\"187\",\"height\":\"24\",\"children\":[\"$\",\"path\",null,{\"d\":\"M186.105 0H0.0571289V24H186.105V0Z\",\"fill\":\"white\"}]}],[\"$\",\"g\",null,{\"mask\":\"url(#mask0_1137_16681)\",\"children\":[[\"$\",\"path\",null,{\"d\":\"M8.2482 4.45178C4.09666 4.45178 0.699951 7.84849 0.699951 12.0001C0.699951 16.1516 4.09666 19.5483 8.2482 19.5483C12.3998 19.5483 15.7964 16.1725 15.7964 12.0001C15.7964 7.82753 12.4207 4.45178 8.2482 4.45178ZM8.2482 16.8435C5.66922 16.8435 3.59345 14.7258 3.59345 12.0001C3.59345 9.27427 5.66922 7.15657 8.2482 7.15657C10.8272 7.15657 12.903 9.27427 12.903 12.0001C12.903 14.7258 10.8272 16.8435 8.2482 16.8435Z\",\"fill\":\"currentColor\"}],[\"$\",\"path\",null,{\"d\":\"M23.4285 8.64526C22.0656 8.64526 20.7446 9.19041 20.0527 10.1129V8.85494H17.3269V23.5321H20.0527V18.2273C20.7446 19.087 22.0236 19.5483 23.4285 19.5483C26.3639 19.5483 28.6703 17.2419 28.6703 14.0967C28.6703 10.9517 26.3639 8.64526 23.4285 8.64526ZM22.9672 17.179C21.4155 17.179 20.0317 15.9629 20.0317 14.0967C20.0317 12.2307 21.4155 11.0146 22.9672 11.0146C24.5187 11.0146 25.9026 12.2307 25.9026 14.0967C25.9026 15.9629 24.5187 17.179 22.9672 17.179Z\",\"fill\":\"currentColor\"}],[\"$\",\"path\",null,{\"d\":\"M35.0867 8.64526C32.1093 8.64526 29.761 10.9726 29.761 14.0967C29.761 17.2209 31.8158 19.5483 35.1706 19.5483C37.9172 19.5483 39.6786 17.8919 40.2236 16.0258H37.5608C37.2254 16.8015 36.2818 17.3467 35.1496 17.3467C33.7448 17.3467 32.6754 16.3613 32.4238 14.9564H40.3495V13.8871C40.3495 11.0355 38.3576 8.64526 35.0867 8.64526ZM32.4448 13.0274C32.7383 11.7065 33.8286 10.8469 35.1496 10.8469C36.5544 10.8469 37.6238 11.7694 37.7495 13.0274H32.4448Z\",\"fill\":\"currentColor\"}],[\"$\",\"path\",null,{\"d\":\"M47.6039 8.64526C46.3878 8.64526 45.1088 9.19041 44.5216 10.092V8.85494H41.7959V19.3386H44.5216V13.6983C44.5216 12.063 45.4023 10.9936 46.828 10.9936C48.149 10.9936 48.8619 12 48.8619 13.4049V19.3386H51.5877V12.9645C51.5877 10.3646 49.9941 8.64526 47.6039 8.64526Z\",\"fill\":\"currentColor\"}],[\"$\",\"path\",null,{\"d\":\"M58.5688 4.66187L52.635 19.3391H55.5495L56.8076 16.131H63.559L64.817 19.3391H67.7734L61.8816 4.66187H58.5688ZM57.751 13.6988L60.1833 7.55536L62.5945 13.6988H57.751Z\",\"fill\":\"currentColor\"}],[\"$\",\"path\",null,{\"d\":\"M71.6524 4.66187H68.8848V19.3391H71.6524V4.66187Z\",\"fill\":\"currentColor\"}],[\"$\",\"path\",null,{\"d\":\"M94.2134 16.8432C91.5295 16.8432 89.6635 14.8094 89.6635 11.9998C89.6635 9.19017 91.5295 7.15633 94.1715 7.15633C96.1008 7.15633 97.5888 8.28857 98.0294 9.67239H101.027C100.503 6.65312 97.6732 4.45154 94.1295 4.45154C89.8732 4.45154 86.749 7.82728 86.749 11.9998C86.749 16.1723 89.7892 19.548 94.1504 19.548C97.7568 19.548 100.524 17.3884 101.091 14.3271H98.1129C97.6099 15.732 96.142 16.8432 94.2134 16.8432Z\",\"fill\":\"currentColor\"}],[\"$\",\"path\",null,{\"d\":\"M107.696 8.64502C104.572 8.64502 102.16 11.1192 102.16 14.0965C102.16 17.0739 104.572 19.548 107.696 19.548C110.819 19.548 113.231 17.0739 113.231 14.0965C113.231 11.1192 110.819 8.64502 107.696 8.64502ZM107.696 17.1158C106.249 17.1158 104.864 15.9416 104.864 14.0965C104.864 12.2514 106.249 11.0772 107.696 11.0772C109.142 11.0772 110.526 12.2514 110.526 14.0965C110.526 15.9416 109.142 17.1158 107.696 17.1158Z\",\"fill\":\"currentColor\"}],[\"$\",\"path\",null,{\"d\":\"M119.857 8.64502C116.732 8.64502 114.322 11.1192 114.322 14.0965C114.322 17.0739 116.732 19.548 119.857 19.548C122.981 19.548 125.392 17.0739 125.392 14.0965C125.392 11.1192 122.981 8.64502 119.857 8.64502ZM119.857 17.1158C118.41 17.1158 117.026 15.9416 117.026 14.0965C117.026 12.2514 118.41 11.0772 119.857 11.0772C121.304 11.0772 122.687 12.2514 122.687 14.0965C122.687 15.9416 121.304 17.1158 119.857 17.1158Z\",\"fill\":\"currentColor\"}],[\"$\",\"path\",null,{\"d\":\"M136.903 8.85497H133.548L129.564 12.8178V4.6615H126.839V19.3387H129.564V16.0678L130.843 14.7468L133.883 19.3387H137.113L132.856 13.0065L136.903 8.85497Z\",\"fill\":\"currentColor\"}],[\"$\",\"path\",null,{\"d\":\"M144.178 8.6453C142.774 8.6453 141.494 9.19045 140.803 10.0921V4.6615H138.077V19.3387H140.803V18.2274C141.494 19.108 142.815 19.5484 144.178 19.5484C147.114 19.5484 149.42 17.242 149.42 14.0968C149.42 10.9517 147.114 8.6453 144.178 8.6453ZM143.718 17.179C142.165 17.179 140.782 15.9629 140.782 14.0968C140.782 12.2308 142.165 11.0146 143.718 11.0146C145.269 11.0146 146.652 12.2308 146.652 14.0968C146.652 15.9629 145.269 17.179 143.718 17.179Z\",\"fill\":\"currentColor\"}],[\"$\",\"path\",null,{\"d\":\"M156.045 8.64502C152.921 8.64502 150.51 11.1192 150.51 14.0965C150.51 17.0739 152.921 19.548 156.045 19.548C159.17 19.548 161.58 17.0739 161.58 14.0965C161.58 11.1192 159.17 8.64502 156.045 8.64502ZM156.045 17.1158C154.598 17.1158 153.215 15.9416 153.215 14.0965C153.215 12.2514 154.598 11.0772 156.045 11.0772C157.492 11.0772 158.876 12.2514 158.876 14.0965C158.876 15.9416 157.492 17.1158 156.045 17.1158Z\",\"fill\":\"currentColor\"}],[\"$\",\"path\",null,{\"d\":\"M168.206 8.64502C165.082 8.64502 162.671 11.1192 162.671 14.0965C162.671 17.0739 165.082 19.548 168.206 19.548C171.331 19.548 173.742 17.0739 173.742 14.0965C173.742 11.1192 171.331 8.64502 168.206 8.64502ZM168.206 17.1158C166.76 17.1158 165.376 15.9416 165.376 14.0965C165.376 12.2514 166.76 11.0772 168.206 11.0772C169.653 11.0772 171.037 12.2514 171.037 14.0965C171.037 15.9416 169.653 17.1158 168.206 17.1158Z\",\"fill\":\"currentColor\"}],[\"$\",\"path\",null,{\"d\":\"M181.207 13.0065L185.253 8.85497H181.899L177.915 12.8178V4.6615H175.188V19.3387H177.915V16.0678L179.194 14.7468L182.234 19.3387H185.462L181.207 13.0065Z\",\"fill\":\"currentColor\"}]]}]]}]}],[\"$\",\"div\",null,{\"className\":\"flex\",\"children\":[[\"$\",\"div\",null,{\"className\":\"deskNav\",\"children\":[\"$\",\"div\",null,{\"className\":\"flex items-center space-x-1 sm:space-x-2 mx-3 sm:mx-4\",\"children\":[[\"$\",\"$L13\",null,{}],[\"$\",\"a\",null,{\"href\":\"/about\",\"target\":\"$undefined\",\"className\":\"text-sm flex flex-row items-center py-1 px-2 hover:text-primary hover:bg-card-border rounded\",\"children\":[[\"$\",\"span\",null,{\"className\":\"hidden sm:inline  text-primary\",\"children\":\"About\"}],[\"$\",\"svg\",null,{\"width\":\"15\",\"height\":\"15\",\"viewBox\":\"0 0 15 15\",\"fill\":\"none\",\"xmlns\":\"http://www.w3.org/2000/svg\",\"className\":\"inline sm:hidden w-3.5 h-3.5\",\"children\":[\"$\",\"path\",null,{\"d\":\"$14\",\"fill\":\"currentColor\",\"fillRule\":\"evenodd\",\"clipRule\":\"evenodd\"}]}]]}],[\"$\",\"a\",null,{\"href\":\"https://platform.openai.com/docs/introduction\",\"target\":\"_blank\",\"className\":\"text-sm flex flex-row items-center py-1 px-2 hover:text-primary hover:bg-card-border rounded whitespace-nowrap flex items-center\",\"children\":[[\"$\",\"span\",null,{\"className\":\"hidden sm:inline  text-primary\",\"children\":\"API docs\"}],[\"$\",\"svg\",null,{\"width\":\"15\",\"height\":\"15\",\"viewBox\":\"0 0 15 15\",\"fill\":\"none\",\"xmlns\":\"http://www.w3.org/2000/svg\",\"className\":\"inline sm:hidden w-3.5 h-3.5\",\"children\":[\"$\",\"path\",null,{\"d\":\"M3 2.5C3 2.22386 3.22386 2 3.5 2H9.08579C9.21839 2 9.34557 2.05268 9.43934 2.14645L11.8536 4.56066C11.9473 4.65443 12 4.78161 12 4.91421V12.5C12 12.7761 11.7761 13 11.5 13H3.5C3.22386 13 3 12.7761 3 12.5V2.5ZM3.5 1C2.67157 1 2 1.67157 2 2.5V12.5C2 13.3284 2.67157 14 3.5 14H11.5C12.3284 14 13 13.3284 13 12.5V4.91421C13 4.51639 12.842 4.13486 12.5607 3.85355L10.1464 1.43934C9.86514 1.15804 9.48361 1 9.08579 1H3.5ZM4.5 4C4.22386 4 4 4.22386 4 4.5C4 4.77614 4.22386 5 4.5 5H7.5C7.77614 5 8 4.77614 8 4.5C8 4.22386 7.77614 4 7.5 4H4.5ZM4.5 7C4.22386 7 4 7.22386 4 7.5C4 7.77614 4.22386 8 4.5 8H10.5C10.7761 8 11 7.77614 11 7.5C11 7.22386 10.7761 7 10.5 7H4.5ZM4.5 10C4.22386 10 4 10.2239 4 10.5C4 10.7761 4.22386 11 4.5 11H10.5C10.7761 11 11 10.7761 11 10.5C11 10.2239 10.7761 10 10.5 10H4.5Z\",\"fill\":\"currentColor\",\"fillRule\":\"evenodd\",\"clipRule\":\"evenodd\"}]}],[\"$\",\"svg\",null,{\"width\":\"15\",\"height\":\"15\",\"viewBox\":\"0 0 15 15\",\"fill\":\"none\",\"xmlns\":\"http://www.w3.org/2000/svg\",\"className\":\"hidden sm:inline w-3.5 h-3.5 ml-0.5 mt-0.5 -mr-0.5 text-primary\",\"children\":[\"$\",\"path\",null,{\"d\":\"M3.64645 11.3536C3.45118 11.1583 3.45118 10.8417 3.64645 10.6465L10.2929 4L6 4C5.72386 4 5.5 3.77614 5.5 3.5C5.5 3.22386 5.72386 3 6 3L11.5 3C11.6326 3 11.7598 3.05268 11.8536 3.14645C11.9473 3.24022 12 3.36739 12 3.5L12 9.00001C12 9.27615 11.7761 9.50001 11.5 9.50001C11.2239 9.50001 11 9.27615 11 9.00001V4.70711L4.35355 11.3536C4.15829 11.5488 3.84171 11.5488 3.64645 11.3536Z\",\"fill\":\"currentColor\",\"fillRule\":\"evenodd\",\"clipRule\":\"evenodd\"}]}]]}],[\"$\",\"a\",null,{\"href\":\"https://github.com/openai/openai-cookbook\",\"target\":\"_blank\",\"className\":\"text-sm flex flex-row items-center py-1 px-2 hover:text-primary hover:bg-card-border rounded\",\"children\":[[\"$\",\"span\",null,{\"className\":\"hidden sm:inline text-primary\",\"children\":\"Source\"}],[\"$\",\"svg\",null,{\"width\":\"15\",\"height\":\"15\",\"viewBox\":\"0 0 15 15\",\"fill\":\"none\",\"xmlns\":\"http://www.w3.org/2000/svg\",\"className\":\"w-3.5 h-3.5 sm:ml-1.5 text-primary\",\"children\":[\"$\",\"path\",null,{\"d\":\"$15\",\"fill\":\"currentColor\",\"fillRule\":\"evenodd\",\"clipRule\":\"evenodd\"}]}]]}],[\"$\",\"$L16\",null,{}]]}]}],[\"$\",\"$L17\",null,{}],[\"$\",\"$L18\",null,{\"index\":[{\"name\":\"Realtime_out_of_band_transcription.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/Realtime_out_of_band_transcription.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/Realtime_out_of_band_transcription.ipynb\",\"internal_path\":\"examples/realtime_out_of_band_transcription\",\"title\":\"Transcribing User Audio with a Separate Realtime Request\",\"path\":\"examples/Realtime_out_of_band_transcription.ipynb\",\"date\":\"2025-11-20\",\"authors\":[{\"name\":\"Minhajul Hoque\",\"website\":\"https://www.linkedin.com/in/minhajul-hoque-83242b163/\",\"avatar\":\"https://avatars.githubusercontent.com/u/84698472?v=4\",\"login\":\"minh-hoque\"}],\"search_text\":\"$19\",\"type\":\"ipynb\",\"tags\":[\"audio\",\"realtime\",\"speech\",\"transcription\",\"voice\"],\"archived\":false},{\"name\":\"autonomous_agent_retraining.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/partners/self_evolving_agents/autonomous_agent_retraining.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/partners/self_evolving_agents/autonomous_agent_retraining.ipynb\",\"internal_path\":\"examples/partners/self_evolving_agents/autonomous_agent_retraining\",\"title\":\"Self-Evolving Agents - A Cookbook for Autonomous Agent Retraining\",\"path\":\"examples/partners/self_evolving_agents/autonomous_agent_retraining.ipynb\",\"date\":\"2025-11-04\",\"authors\":[{\"name\":\"Shikhar Kwatra\",\"website\":\"https://www.linkedin.com/in/shikharkwatra/\",\"avatar\":\"https://avatars.githubusercontent.com/u/189049238?v=4\",\"login\":\"shikhar-cyber\"},{\"login\":\"Calvin Maguranis\"},{\"login\":\"Valentina Frenkel\"},{\"login\":\"Fanny Perraudeau\"},{\"login\":\"Giorgio Saladino\"}],\"search_text\":\"$1a\",\"type\":\"ipynb\",\"tags\":[\"agent-retraining\",\"evals\",\"llmops\",\"partners\",\"prompt-engineering\",\"self-evolving-agents\"],\"archived\":false},{\"name\":\"gpt-oss-safeguard-guide.md\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/articles/gpt-oss-safeguard-guide.md\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/articles/gpt-oss-safeguard-guide.md\",\"internal_path\":\"articles/gpt-oss-safeguard-guide\",\"title\":\"User guide for gpt-oss-safeguard\",\"path\":\"articles/gpt-oss-safeguard-guide.md\",\"date\":\"2025-10-29\",\"authors\":[{\"name\":\"ROOST\",\"website\":\"https://roost.tools\",\"avatar\":\"https://avatars.githubusercontent.com/u/189051351?v=4\",\"login\":\"roost\"}],\"search_text\":\"$1b\",\"type\":\"md\",\"tags\":[\"gpt-oss\",\"guardrails\",\"open-models\"],\"archived\":false},{\"name\":\"agentkit_walkthrough.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/agentkit/agentkit_walkthrough.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/agentkit/agentkit_walkthrough.ipynb\",\"internal_path\":\"examples/agentkit/agentkit_walkthrough\",\"title\":\"Build, deploy, and optimize agentic workflows with AgentKit\",\"path\":\"examples/agentkit/agentkit_walkthrough.ipynb\",\"date\":\"2025-10-17\",\"authors\":[{\"name\":\"Nikhil Srivastava\",\"website\":\"https://www.linkedin.com/in/nsrivast/\",\"avatar\":\"https://avatars.githubusercontent.com/u/231350150\",\"login\":\"nikhils-oai\"}],\"search_text\":\"$1c\",\"type\":\"ipynb\",\"tags\":[\"agentkit\",\"evals\"],\"archived\":false},{\"name\":\"building_w_rt_mini.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/building_w_rt_mini/building_w_rt_mini.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/building_w_rt_mini/building_w_rt_mini.ipynb\",\"internal_path\":\"examples/building_w_rt_mini/building_w_rt_mini\",\"title\":\"Building with Realtime Mini\",\"path\":\"examples/building_w_rt_mini/building_w_rt_mini.ipynb\",\"date\":\"2025-10-11\",\"authors\":[{\"name\":\"Carter Mcclellan\",\"website\":\"https://www.linkedin.com/in/carter-mcclellan/\",\"avatar\":\"https://avatars.githubusercontent.com/u/219906258?v=4\",\"login\":\"carter-oai\"}],\"search_text\":\"$1d\",\"type\":\"ipynb\",\"tags\":[\"gpt-realtime-mini\"],\"archived\":false},{\"name\":\"sora2_prompting_guide.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/sora/sora2_prompting_guide.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/sora/sora2_prompting_guide.ipynb\",\"internal_path\":\"examples/sora/sora2_prompting_guide\",\"title\":\"Sora 2 Prompting Guide\",\"path\":\"examples/sora/sora2_prompting_guide.ipynb\",\"date\":\"2025-10-06\",\"authors\":[{\"name\":\"Robin Koenig\",\"website\":\"https://robinkoenig.com\",\"avatar\":\"https://avatars.githubusercontent.com/u/208886811?v=4\",\"login\":\"rkoenig-openai\"},{\"name\":\"Joanne Shin\",\"website\":\"https://www.linkedin.com/in/jeongminshin\",\"avatar\":\"https://avatars.githubusercontent.com/u/206945323?v=4\",\"login\":\"joanneshin-openai\"}],\"search_text\":\"$1e\",\"type\":\"ipynb\",\"tags\":[\"prompt\",\"sora\"],\"archived\":false},{\"name\":\"codex_exec_plans.md\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/articles/codex_exec_plans.md\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/articles/codex_exec_plans.md\",\"internal_path\":\"articles/codex_exec_plans\",\"title\":\"Using PLANS.md for multi-hour problem solving\",\"path\":\"articles/codex_exec_plans.md\",\"date\":\"2025-10-07\",\"authors\":[{\"name\":\"Aaron Friel\",\"website\":\"https://www.github.com/aaronfriel\",\"avatar\":\"https://avatars.githubusercontent.com/aaronfriel\",\"login\":\"aaronfriel\"}],\"search_text\":\"$1f\",\"type\":\"md\",\"tags\":[\"agents\",\"codex\",\"documentation\",\"gpt-5\",\"planning\"],\"archived\":false},{\"name\":\"building_consistent_workflows_codex_cli_agents_sdk.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/codex/codex_mcp_agents_sdk/building_consistent_workflows_codex_cli_agents_sdk.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/codex/codex_mcp_agents_sdk/building_consistent_workflows_codex_cli_agents_sdk.ipynb\",\"internal_path\":\"examples/codex/codex_mcp_agents_sdk/building_consistent_workflows_codex_cli_agents_sdk\",\"title\":\"Building Consistent Workflows with Codex CLI \u0026 Agents SDK\",\"path\":\"examples/codex/codex_mcp_agents_sdk/building_consistent_workflows_codex_cli_agents_sdk.ipynb\",\"date\":\"2025-10-01\",\"authors\":[{\"name\":\"Josh Hall\",\"website\":\"https://www.linkedin.com/in/jhall14/\",\"avatar\":\"https://avatars.githubusercontent.com/u/198997750?v=4\",\"login\":\"jhall-openai\"},{\"name\":\"Charlie Weems\",\"website\":\"https://wee.ms\",\"avatar\":\"https://avatars.githubusercontent.com/u/181146176?v=4\",\"login\":\"charlie-openai\"}],\"search_text\":\"$20\",\"type\":\"ipynb\",\"tags\":[\"agents-sdk\",\"codex\",\"mcp\"],\"archived\":false},{\"name\":\"gpt-5-codex_prompting_guide.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/gpt-5-codex_prompting_guide.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/gpt-5-codex_prompting_guide.ipynb\",\"internal_path\":\"examples/gpt-5-codex_prompting_guide\",\"title\":\"GPT-5-Codex Prompting Guide\",\"path\":\"examples/gpt-5-codex_prompting_guide.ipynb\",\"date\":\"2025-09-23\",\"authors\":[{\"name\":\"Dave Leo\",\"website\":\"https://www.linkedin.com/in/davidanthonyleo/\",\"avatar\":\"https://media.licdn.com/dms/image/v2/C5603AQF2Kg-D7XJKNw/profile-displayphoto-shrink_800_800/profile-displayphoto-shrink_800_800/0/1612654752234?e=1761782400\u0026v=beta\u0026t=RkO9jCbJrY6Ox9YRbMA6HAAZhxfYJV1OsZeIT3YatBM\",\"login\":\"daveleo-openai\"}],\"search_text\":\"$21\",\"type\":\"ipynb\",\"tags\":[\"codex\",\"gpt-5\"],\"archived\":false},{\"name\":\"gpt-5_troubleshooting_guide.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/gpt-5/gpt-5_troubleshooting_guide.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/gpt-5/gpt-5_troubleshooting_guide.ipynb\",\"internal_path\":\"examples/gpt-5/gpt-5_troubleshooting_guide\",\"title\":\"GPT-5 Troubleshooting Guide\",\"path\":\"examples/gpt-5/gpt-5_troubleshooting_guide.ipynb\",\"date\":\"2025-09-17\",\"authors\":[{\"name\":\"Prashant Mital\",\"website\":\"https://www.linkedin.com/in/pmital/\",\"avatar\":\"https://avatars.githubusercontent.com/u/173949238?v=4\",\"login\":\"prashantmital-openai\"},{\"name\":\"Brian Fioca\",\"website\":\"https://www.linkedin.com/in/brian-fioca/\",\"avatar\":\"https://avatars.githubusercontent.com/u/206814564?v=4\",\"login\":\"bfioca-openai\"},{\"name\":\"Carter Mcclellan\",\"website\":\"https://www.linkedin.com/in/carter-mcclellan/\",\"avatar\":\"https://avatars.githubusercontent.com/u/219906258?v=4\",\"login\":\"carter-oai\"}],\"search_text\":\"$22\",\"type\":\"ipynb\",\"tags\":[\"gpt-5\",\"prompt-optimization\"],\"archived\":false},{\"name\":\"session_memory.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/agents_sdk/session_memory.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/agents_sdk/session_memory.ipynb\",\"internal_path\":\"examples/agents_sdk/session_memory\",\"title\":\"Context Engineering - Short-Term Memory Management with Sessions from OpenAI Agents SDK\",\"path\":\"examples/agents_sdk/session_memory.ipynb\",\"date\":\"2025-09-09\",\"authors\":[{\"name\":\"Emre Okcular\",\"website\":\"https://www.linkedin.com/in/emreokcular/\",\"avatar\":\"https://avatars.githubusercontent.com/u/26163154?v=4\",\"login\":\"emreokcular\"}],\"search_text\":\"$23\",\"type\":\"ipynb\",\"tags\":[\"agents-sdk\"],\"archived\":false},{\"name\":\"secure_quality_gitlab.md\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/codex/secure_quality_gitlab.md\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/codex/secure_quality_gitlab.md\",\"internal_path\":\"examples/codex/secure_quality_gitlab\",\"title\":\"Automating Code Quality and Security Fixes with Codex CLI on GitLab\",\"path\":\"examples/codex/secure_quality_gitlab.md\",\"date\":\"2025-08-29\",\"authors\":[{\"name\":\"Jonathan Lim\",\"website\":\"https://www.linkedin.com/in/jonlmr\",\"avatar\":\"https://avatars.githubusercontent.com/u/189068472?v=4\",\"login\":\"jonlim-openai\"},{\"name\":\"Pierre-Antoine Porte\",\"website\":\"https://www.linkedin.com/in/portepa/\",\"avatar\":\"https://avatars.githubusercontent.com/u/174109416?v=4\",\"login\":\"pap-openai\"}],\"search_text\":\"$24\",\"type\":\"md\",\"tags\":[\"codex\"],\"archived\":false},{\"name\":\"Realtime_prompting_guide.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/Realtime_prompting_guide.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/Realtime_prompting_guide.ipynb\",\"internal_path\":\"examples/realtime_prompting_guide\",\"title\":\"Realtime Prompting Guide\",\"path\":\"examples/Realtime_prompting_guide.ipynb\",\"date\":\"2025-08-28\",\"authors\":[{\"name\":\"Minhajul Hoque\",\"website\":\"https://www.linkedin.com/in/minhajul-hoque-83242b163/\",\"avatar\":\"https://avatars.githubusercontent.com/u/84698472?v=4\",\"login\":\"minh-hoque\"}],\"search_text\":\"$25\",\"type\":\"ipynb\",\"tags\":[\"audio\",\"realtime\",\"responses\",\"speech\"],\"archived\":false},{\"name\":\"fine-tune-korean.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/articles/gpt-oss/fine-tune-korean.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/articles/gpt-oss/fine-tune-korean.ipynb\",\"internal_path\":\"articles/gpt-oss/fine-tune-korean\",\"title\":\"Fine-tune gpt-oss for better Korean language performance\",\"path\":\"articles/gpt-oss/fine-tune-korean.ipynb\",\"date\":\"2025-08-26\",\"authors\":[{\"name\":\"Heejin Cho\",\"website\":\"https://www.linkedin.com/in/heejc/\",\"avatar\":\"https://avatars.githubusercontent.com/u/169293861\",\"login\":\"heejingithub\"},{\"name\":\"Danial Mirza\",\"website\":\"https://github.com/danial-openai\",\"avatar\":\"https://avatars.githubusercontent.com/u/178343703\",\"login\":\"danial-openai\"},{\"name\":\"Joanne Shin\",\"website\":\"https://www.linkedin.com/in/jeongminshin\",\"avatar\":\"https://avatars.githubusercontent.com/u/206945323?v=4\",\"login\":\"joanneshin-openai\"}],\"search_text\":\"$26\",\"type\":\"ipynb\",\"tags\":[\"gpt-oss\",\"open-models\"],\"archived\":false},{\"name\":\"verifying-implementations.md\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/articles/gpt-oss/verifying-implementations.md\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/articles/gpt-oss/verifying-implementations.md\",\"internal_path\":\"articles/gpt-oss/verifying-implementations\",\"title\":\"Verifying gpt-oss implementations\",\"path\":\"articles/gpt-oss/verifying-implementations.md\",\"date\":\"2025-08-11\",\"authors\":[{\"name\":\"Dominik Kundel\",\"website\":\"https://www.linkedin.com/in/dkundel/\",\"avatar\":\"https://avatars.githubusercontent.com/u/200841172?v=4\",\"login\":\"dkundel-openai\"}],\"search_text\":\"$27\",\"type\":\"md\",\"tags\":[\"gpt-oss\",\"gpt-oss-providers\",\"open-models\"],\"archived\":false},{\"name\":\"run-locally-lmstudio.md\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/articles/gpt-oss/run-locally-lmstudio.md\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/articles/gpt-oss/run-locally-lmstudio.md\",\"internal_path\":\"articles/gpt-oss/run-locally-lmstudio\",\"title\":\"How to run gpt-oss locally with LM Studio\",\"path\":\"articles/gpt-oss/run-locally-lmstudio.md\",\"date\":\"2025-08-07\",\"authors\":[{\"name\":\"Yagil Burowski\",\"website\":\"https://x.com/yagilb\",\"avatar\":\"https://avatars.lmstudio.com/profile-images/yagil\",\"login\":\"yagil\"}],\"search_text\":\"$28\",\"type\":\"md\",\"tags\":[\"gpt-oss\",\"gpt-oss-local\",\"open-models\"],\"archived\":false},{\"name\":\"prompt-optimization-cookbook.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/gpt-5/prompt-optimization-cookbook.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/gpt-5/prompt-optimization-cookbook.ipynb\",\"internal_path\":\"examples/gpt-5/prompt-optimization-cookbook\",\"title\":\"GPT-5 Prompt Migration and Improvement Using the New Optimizer\",\"path\":\"examples/gpt-5/prompt-optimization-cookbook.ipynb\",\"date\":\"2025-08-07\",\"authors\":[{\"name\":\"Raj Pathak\",\"website\":\"https://www.linkedin.com/in/rajpathakopenai/\",\"avatar\":\"https://avatars.githubusercontent.com/u/208723614?s=400\u0026u=c852eed3be082f7fbd402b5a45e9b89a0bfed1b8\u0026v=4\",\"login\":\"rajpathak-openai\"},{\"name\":\"Corwin Cheung\",\"website\":\"https://www.linkedin.com/in/corwincubes/\",\"avatar\":\"https://avatars.githubusercontent.com/u/85517581?v=4\",\"login\":\"corwin\"}],\"search_text\":\"$29\",\"type\":\"ipynb\",\"tags\":[\"gpt-5\",\"prompt-optimization\",\"reasoning\",\"responses\"],\"archived\":false},{\"name\":\"gpt-5_prompting_guide.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/gpt-5/gpt-5_prompting_guide.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/gpt-5/gpt-5_prompting_guide.ipynb\",\"internal_path\":\"examples/gpt-5/gpt-5_prompting_guide\",\"title\":\"GPT-5 prompting guide\",\"path\":\"examples/gpt-5/gpt-5_prompting_guide.ipynb\",\"date\":\"2025-08-07\",\"authors\":[{\"name\":\"Anoop Kotha\",\"website\":\"https://x.com/anoopkotha\",\"avatar\":\"https://pbs.twimg.com/profile_images/1953388055190224896/vHZ5CVPs_400x400.jpg\",\"login\":\"anoop-openai\"},{\"name\":\"Julian Lee\",\"website\":\"https://x.com/julianl093\",\"avatar\":\"https://avatars.githubusercontent.com/u/199828632\",\"login\":\"julian-openai\"},{\"name\":\"Eric Zakariasson\",\"website\":\"https://x.com/ericzakariasson\",\"avatar\":\"https://pbs.twimg.com/profile_images/1841151626456801283/HnXqy3TQ_400x400.jpg\",\"login\":\"ericzakariasson\"},{\"name\":\"Erin Kavanaugh\",\"website\":\"https://www.linkedin.com/in/erinkavanaugh/\",\"avatar\":\"https://media.licdn.com/dms/image/v2/D5603AQFBeFl_GBWRww/profile-displayphoto-scale_400_400/B56ZiCtx6zHcAg-/0/1754539697289?e=1757548800\u0026v=beta\u0026t=e3znvOjyDV9MBdp2AABxGtvdCx1LzyrBR75cjOSh5h8\",\"login\":\"erinkav-openai\"}],\"search_text\":\"$2a\",\"type\":\"ipynb\",\"tags\":[\"gpt-5\",\"reasoning\",\"responses\"],\"archived\":false},{\"name\":\"gpt-5_frontend.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/gpt-5/gpt-5_frontend.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/gpt-5/gpt-5_frontend.ipynb\",\"internal_path\":\"examples/gpt-5/gpt-5_frontend\",\"title\":\"Frontend coding with GPT-5\",\"path\":\"examples/gpt-5/gpt-5_frontend.ipynb\",\"date\":\"2025-08-07\",\"authors\":[{\"name\":\"Wulfie Bain\",\"website\":\"https://www.linkedin.com/in/wulfie-bain/\",\"avatar\":\"https://avatars.githubusercontent.com/u/76624567?v=4\",\"login\":\"WJPBProjects\"},{\"name\":\"Anoop Kotha\",\"website\":\"https://x.com/anoopkotha\",\"avatar\":\"https://pbs.twimg.com/profile_images/1953388055190224896/vHZ5CVPs_400x400.jpg\",\"login\":\"anoop-openai\"}],\"search_text\":\"$2b\",\"type\":\"ipynb\",\"tags\":[\"gpt-5\",\"reasoning\",\"responses\"],\"archived\":false},{\"name\":\"gpt-5_new_params_and_tools.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/gpt-5/gpt-5_new_params_and_tools.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/gpt-5/gpt-5_new_params_and_tools.ipynb\",\"internal_path\":\"examples/gpt-5/gpt-5_new_params_and_tools\",\"title\":\"GPT-5 New Params and Tools\",\"path\":\"examples/gpt-5/gpt-5_new_params_and_tools.ipynb\",\"date\":\"2025-08-07\",\"authors\":[{\"name\":\"Mandeep Singh\",\"website\":\"https://github.com/msingh-openai\",\"avatar\":\"https://avatars.githubusercontent.com/u/168678187?v=4\",\"login\":\"msingh-openai\"}],\"search_text\":\"$2c\",\"type\":\"ipynb\",\"tags\":[\"functions\",\"gpt-5\",\"reasoning\"],\"archived\":false},{\"name\":\"run-colab.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/articles/gpt-oss/run-colab.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/articles/gpt-oss/run-colab.ipynb\",\"internal_path\":\"articles/gpt-oss/run-colab\",\"title\":\"How to run gpt-oss-20b on Google Colab\",\"path\":\"articles/gpt-oss/run-colab.ipynb\",\"date\":\"2025-08-06\",\"authors\":[{\"name\":\"Pedro Cuenca\",\"website\":\"https://huggingface.co/pcuenq\",\"avatar\":\"https://cdn-avatars.huggingface.co/v1/production/uploads/1617264212503-603d25b75f9d390ab190b777.jpeg\",\"login\":\"pcuenca\"},{\"name\":\"vb\",\"website\":\"https://huggingface.co/reach-vb\",\"avatar\":\"https://cdn-avatars.huggingface.co/v1/production/uploads/1655385361868-61b85ce86eb1f2c5e6233736.jpeg\",\"login\":\"Vaibhavs10\"}],\"search_text\":\"$2d\",\"type\":\"ipynb\",\"tags\":[\"gpt-oss\",\"gpt-oss-server\",\"open-models\"],\"archived\":false},{\"name\":\"run-nvidia.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/articles/gpt-oss/run-nvidia.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/articles/gpt-oss/run-nvidia.ipynb\",\"internal_path\":\"articles/gpt-oss/run-nvidia\",\"title\":\"Using NVIDIA TensorRT-LLM to run gpt-oss-20b\",\"path\":\"articles/gpt-oss/run-nvidia.ipynb\",\"date\":\"2025-08-05\",\"authors\":[{\"name\":\"Jay Rodge\",\"website\":\"https://www.linkedin.com/in/jayrodge/\",\"avatar\":\"https://developer-blogs.nvidia.com/wp-content/uploads/2024/05/Jay-Rodge.png\",\"login\":\"jayrodge\"}],\"search_text\":\"$2e\",\"type\":\"ipynb\",\"tags\":[\"gpt-oss\",\"gpt-oss-server\",\"open-models\"],\"archived\":false},{\"name\":\"fine-tune-transfomers.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/articles/gpt-oss/fine-tune-transfomers.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/articles/gpt-oss/fine-tune-transfomers.ipynb\",\"internal_path\":\"articles/gpt-oss/fine-tune-transfomers\",\"title\":\"Fine-tuning with gpt-oss and Hugging Face Transformers\",\"path\":\"articles/gpt-oss/fine-tune-transfomers.ipynb\",\"date\":\"2025-08-05\",\"authors\":[{\"name\":\"Edward Beeching\",\"website\":\"https://huggingface.co/edbeeching\",\"avatar\":\"https://cdn-avatars.huggingface.co/v1/production/uploads/1644220542819-noauth.jpeg\",\"login\":\"edbeeching\"},{\"name\":\"Quentin Gallouédec\",\"website\":\"https://huggingface.co/qgallouedec\",\"avatar\":\"https://cdn-avatars.huggingface.co/v1/production/uploads/1677431596830-631ce4b244503b72277fc89f.jpeg\",\"login\":\"qgallouedec\"},{\"name\":\"Lewis Tunstall\",\"website\":\"https://huggingface.co/lewtun\",\"avatar\":\"https://cdn-avatars.huggingface.co/v1/production/uploads/1594651707950-noauth.jpeg\",\"login\":\"lewtun\"}],\"search_text\":\"$2f\",\"type\":\"ipynb\",\"tags\":[\"gpt-oss\",\"gpt-oss-fine-tuning\",\"open-models\"],\"archived\":false},{\"name\":\"handle-raw-cot.md\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/articles/gpt-oss/handle-raw-cot.md\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/articles/gpt-oss/handle-raw-cot.md\",\"internal_path\":\"articles/gpt-oss/handle-raw-cot\",\"title\":\"How to handle the raw chain of thought in gpt-oss\",\"path\":\"articles/gpt-oss/handle-raw-cot.md\",\"date\":\"2025-08-05\",\"authors\":[{\"name\":\"Dominik Kundel\",\"website\":\"https://www.linkedin.com/in/dkundel/\",\"avatar\":\"https://avatars.githubusercontent.com/u/200841172?v=4\",\"login\":\"dkundel-openai\"}],\"search_text\":\"$30\",\"type\":\"md\",\"tags\":[\"gpt-oss\",\"gpt-oss-fine-tuning\",\"gpt-oss-providers\",\"open-models\"],\"archived\":false},{\"name\":\"run-transformers.md\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/articles/gpt-oss/run-transformers.md\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/articles/gpt-oss/run-transformers.md\",\"internal_path\":\"articles/gpt-oss/run-transformers\",\"title\":\"How to run gpt-oss with Transformers\",\"path\":\"articles/gpt-oss/run-transformers.md\",\"date\":\"2025-08-05\",\"authors\":[{\"name\":\"Dominik Kundel\",\"website\":\"https://www.linkedin.com/in/dkundel/\",\"avatar\":\"https://avatars.githubusercontent.com/u/200841172?v=4\",\"login\":\"dkundel-openai\"}],\"search_text\":\"$31\",\"type\":\"md\",\"tags\":[\"gpt-oss\",\"gpt-oss-server\",\"open-models\"],\"archived\":false},{\"name\":\"run-vllm.md\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/articles/gpt-oss/run-vllm.md\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/articles/gpt-oss/run-vllm.md\",\"internal_path\":\"articles/gpt-oss/run-vllm\",\"title\":\"How to run gpt-oss with vLLM\",\"path\":\"articles/gpt-oss/run-vllm.md\",\"date\":\"2025-08-05\",\"authors\":[{\"name\":\"Dominik Kundel\",\"website\":\"https://www.linkedin.com/in/dkundel/\",\"avatar\":\"https://avatars.githubusercontent.com/u/200841172?v=4\",\"login\":\"dkundel-openai\"}],\"search_text\":\"$32\",\"type\":\"md\",\"tags\":[\"gpt-oss\",\"gpt-oss-server\",\"open-models\"],\"archived\":false},{\"name\":\"run-locally-ollama.md\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/articles/gpt-oss/run-locally-ollama.md\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/articles/gpt-oss/run-locally-ollama.md\",\"internal_path\":\"articles/gpt-oss/run-locally-ollama\",\"title\":\"How to run gpt-oss locally with Ollama\",\"path\":\"articles/gpt-oss/run-locally-ollama.md\",\"date\":\"2025-08-05\",\"authors\":[{\"name\":\"Dominik Kundel\",\"website\":\"https://www.linkedin.com/in/dkundel/\",\"avatar\":\"https://avatars.githubusercontent.com/u/200841172?v=4\",\"login\":\"dkundel-openai\"}],\"search_text\":\"$33\",\"type\":\"md\",\"tags\":[\"gpt-oss\",\"gpt-oss-local\",\"open-models\"],\"archived\":false},{\"name\":\"openai-harmony.md\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/articles/openai-harmony.md\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/articles/openai-harmony.md\",\"internal_path\":\"articles/openai-harmony\",\"title\":\"OpenAI Harmony Response Format\",\"path\":\"articles/openai-harmony.md\",\"date\":\"2025-08-05\",\"authors\":[{\"name\":\"Dominik Kundel\",\"website\":\"https://www.linkedin.com/in/dkundel/\",\"avatar\":\"https://avatars.githubusercontent.com/u/200841172?v=4\",\"login\":\"dkundel-openai\"}],\"search_text\":\"$34\",\"type\":\"md\",\"tags\":[\"gpt-oss\",\"gpt-oss-fine-tuning\",\"gpt-oss-providers\",\"harmony\",\"open-models\"],\"archived\":false},{\"name\":\"temporal_agents.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/partners/temporal_agents_with_knowledge_graphs/temporal_agents.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/partners/temporal_agents_with_knowledge_graphs/temporal_agents.ipynb\",\"internal_path\":\"examples/partners/temporal_agents_with_knowledge_graphs/temporal_agents\",\"title\":\"Temporal Agents with Knowledge Graphs\",\"path\":\"examples/partners/temporal_agents_with_knowledge_graphs/temporal_agents.ipynb\",\"date\":\"2025-07-22\",\"authors\":[{\"name\":\"Danny Wigg\",\"website\":\"https://www.linkedin.com/in/dannywigg/\",\"avatar\":\"https://avatars.githubusercontent.com/u/4661060?v=4\",\"login\":\"dwigg-openai\"},{\"name\":\"Shikhar Kwatra\",\"website\":\"https://www.linkedin.com/in/shikharkwatra/\",\"avatar\":\"https://avatars.githubusercontent.com/u/189049238?v=4\",\"login\":\"shikhar-cyber\"},{\"login\":\"Alex Heald\"},{\"login\":\"Douglas Adams\"},{\"login\":\"Rishabh Sagar\"}],\"search_text\":\"$35\",\"type\":\"ipynb\",\"tags\":[\"functions\",\"knowledge-graphs\",\"responses\",\"retrieval\"],\"archived\":false},{\"name\":\"EvalsAPI_Image_Inputs.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/evaluation/use-cases/EvalsAPI_Image_Inputs.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/evaluation/use-cases/EvalsAPI_Image_Inputs.ipynb\",\"internal_path\":\"examples/evaluation/use-cases/evalsapi_image_inputs\",\"title\":\"Using Evals API on Image Inputs\",\"path\":\"examples/evaluation/use-cases/EvalsAPI_Image_Inputs.ipynb\",\"date\":\"2025-07-15\",\"authors\":[{\"name\":\"Daisy Sheng\",\"website\":\"https://www.linkedin.com/in/daisysheng/\",\"avatar\":\"https://avatars.githubusercontent.com/u/212609991?v=4\",\"login\":\"daisyshe-oai\"}],\"search_text\":\"$36\",\"type\":\"ipynb\",\"tags\":[\"evals\",\"images\"],\"archived\":false},{\"name\":\"EvalsAPI_Audio_Inputs.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/evaluation/use-cases/EvalsAPI_Audio_Inputs.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/evaluation/use-cases/EvalsAPI_Audio_Inputs.ipynb\",\"internal_path\":\"examples/evaluation/use-cases/evalsapi_audio_inputs\",\"title\":\"Using Evals API on Audio Inputs\",\"path\":\"examples/evaluation/use-cases/EvalsAPI_Audio_Inputs.ipynb\",\"date\":\"2025-08-13\",\"authors\":[{\"name\":\"Todd Hendry\",\"website\":\"https://www.linkedin.com/in/todd-hendry-962aa577/\",\"avatar\":\"https://avatars.githubusercontent.com/u/36863669\",\"login\":\"hendrytl\"}],\"search_text\":\"$37\",\"type\":\"ipynb\",\"tags\":[\"audio\",\"evals\"],\"archived\":false},{\"name\":\"Optimize_Prompts.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/Optimize_Prompts.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/Optimize_Prompts.ipynb\",\"internal_path\":\"examples/optimize_prompts\",\"title\":\"Optimize Prompts\",\"path\":\"examples/Optimize_Prompts.ipynb\",\"date\":\"2025-07-14\",\"authors\":[{\"name\":\"Corwin Cheung\",\"website\":\"https://www.linkedin.com/in/corwincubes/\",\"avatar\":\"https://avatars.githubusercontent.com/u/85517581?v=4\",\"login\":\"corwin\"}],\"search_text\":\"$38\",\"type\":\"ipynb\",\"tags\":[\"agents-sdk\",\"completions\",\"prompt\",\"responses\",\"tracing\"],\"archived\":false},{\"name\":\"jira-github.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/codex/jira-github.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/codex/jira-github.ipynb\",\"internal_path\":\"examples/codex/jira-github\",\"title\":\"Automate Jira ↔ GitHub with Codex\",\"path\":\"examples/codex/jira-github.ipynb\",\"date\":\"2025-06-21\",\"authors\":[{\"name\":\"Kevin Alwell\",\"website\":\"https://github.com/alwell-kevin\",\"avatar\":\"https://avatars.githubusercontent.com/u/26548363\",\"login\":\"alwell-kevin\"},{\"name\":\"Naren Sankaran\",\"website\":\"https://www.linkedin.com/in/snarendran/\",\"avatar\":\"https://avatars.githubusercontent.com/u/196844623?s=400\u0026u=d669669fd962473d606a97801367ba96fc548287\u0026v=4\",\"login\":\"narenoai\"}],\"search_text\":\"$39\",\"type\":\"ipynb\",\"tags\":[\"automation\",\"codex\"],\"archived\":false},{\"name\":\"Prompt_migration_guide.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/Prompt_migration_guide.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/Prompt_migration_guide.ipynb\",\"internal_path\":\"examples/prompt_migration_guide\",\"title\":\"Prompt Migration Guide\",\"path\":\"examples/Prompt_migration_guide.ipynb\",\"date\":\"2025-06-26\",\"authors\":[{\"name\":\"Minhajul Hoque\",\"website\":\"https://www.linkedin.com/in/minhajul-hoque-83242b163/\",\"avatar\":\"https://avatars.githubusercontent.com/u/84698472?v=4\",\"login\":\"minh-hoque\"},{\"name\":\"Corwin Cheung\",\"website\":\"https://www.linkedin.com/in/corwincubes/\",\"avatar\":\"https://avatars.githubusercontent.com/u/85517581?v=4\",\"login\":\"corwin\"}],\"search_text\":\"$3a\",\"type\":\"ipynb\",\"tags\":[\"completions\",\"prompt\",\"responses\"],\"archived\":false},{\"name\":\"Fine_tuning_direct_preference_optimization_guide.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/Fine_tuning_direct_preference_optimization_guide.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/Fine_tuning_direct_preference_optimization_guide.ipynb\",\"internal_path\":\"examples/fine_tuning_direct_preference_optimization_guide\",\"title\":\"Fine-Tuning Techniques - Choosing Between SFT, DPO, and RFT (With a Guide to DPO)\",\"path\":\"examples/Fine_tuning_direct_preference_optimization_guide.ipynb\",\"date\":\"2025-06-18\",\"authors\":[{\"name\":\"Alex Lowden\",\"website\":\"https://www.linkedin.com/in/alex-lowden01/\",\"avatar\":\"https://avatars.githubusercontent.com/u/215167546\",\"login\":\"alexl-oai\"}],\"search_text\":\"$3b\",\"type\":\"ipynb\",\"tags\":[\"fine-tuning\"],\"archived\":false},{\"name\":\"mcp_powered_agents_cookbook.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/partners/mcp_powered_voice_agents/mcp_powered_agents_cookbook.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/partners/mcp_powered_voice_agents/mcp_powered_agents_cookbook.ipynb\",\"internal_path\":\"examples/partners/mcp_powered_voice_agents/mcp_powered_agents_cookbook\",\"title\":\"MCP-Powered Agentic Voice Framework\",\"path\":\"examples/partners/mcp_powered_voice_agents/mcp_powered_agents_cookbook.ipynb\",\"date\":\"2025-06-17\",\"authors\":[{\"name\":\"Shikhar Kwatra\",\"website\":\"https://www.linkedin.com/in/shikharkwatra/\",\"avatar\":\"https://avatars.githubusercontent.com/u/189049238?v=4\",\"login\":\"shikhar-cyber\"},{\"login\":\"Cece Z\"},{\"login\":\"Sibon li\"}],\"search_text\":\"$3c\",\"type\":\"ipynb\",\"tags\":[\"agents-sdk\",\"functions\",\"mcp\",\"tracing\",\"voice\"],\"archived\":false},{\"name\":\"databricks_mcp_cookbook.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/mcp/databricks_mcp_cookbook.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/mcp/databricks_mcp_cookbook.ipynb\",\"internal_path\":\"examples/mcp/databricks_mcp_cookbook\",\"title\":\"Building a Supply-Chain Copilot with OpenAI Agent SDK and Databricks MCP Servers\",\"path\":\"examples/mcp/databricks_mcp_cookbook.ipynb\",\"date\":\"2025-07-08\",\"authors\":[{\"name\":\"Lara Rachidi\",\"website\":\"https://www.linkedin.com/in/lara-rachidi/\",\"avatar\":\"https://avatars.githubusercontent.com/u/208707651?v=4\",\"login\":\"lara-openai\"}],\"search_text\":\"$3d\",\"type\":\"ipynb\",\"tags\":[\"agents-sdk\",\"mcp\",\"tracing\"],\"archived\":false},{\"name\":\"receipt_inspection.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/partners/eval_driven_system_design/receipt_inspection.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/partners/eval_driven_system_design/receipt_inspection.ipynb\",\"internal_path\":\"examples/partners/eval_driven_system_design/receipt_inspection\",\"title\":\"Eval Driven System Design - From Prototype to Production\",\"path\":\"examples/partners/eval_driven_system_design/receipt_inspection.ipynb\",\"date\":\"2025-06-02\",\"authors\":[{\"name\":\"Shikhar Kwatra\",\"website\":\"https://www.linkedin.com/in/shikharkwatra/\",\"avatar\":\"https://avatars.githubusercontent.com/u/189049238?v=4\",\"login\":\"shikhar-cyber\"},{\"login\":\"Hugh Wimberly\"},{\"login\":\"Joshua Marker\"},{\"login\":\"Eddie Siegel\"}],\"search_text\":\"$3e\",\"type\":\"ipynb\",\"tags\":[\"API Flywheel\",\"completions\",\"evals\",\"functions\",\"responses\",\"tracing\"],\"archived\":false},{\"name\":\"multi_agent_portfolio_collaboration.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/agents_sdk/multi-agent-portfolio-collaboration/multi_agent_portfolio_collaboration.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/agents_sdk/multi-agent-portfolio-collaboration/multi_agent_portfolio_collaboration.ipynb\",\"internal_path\":\"examples/agents_sdk/multi-agent-portfolio-collaboration/multi_agent_portfolio_collaboration\",\"title\":\"Multi-Agent Portfolio Collaboration with OpenAI Agents SDK\",\"path\":\"examples/agents_sdk/multi-agent-portfolio-collaboration/multi_agent_portfolio_collaboration.ipynb\",\"date\":\"2025-05-28\",\"authors\":[{\"name\":\"Raj Pathak\",\"website\":\"https://www.linkedin.com/in/rajpathakopenai/\",\"avatar\":\"https://avatars.githubusercontent.com/u/208723614?s=400\u0026u=c852eed3be082f7fbd402b5a45e9b89a0bfed1b8\u0026v=4\",\"login\":\"rajpathak-openai\"},{\"name\":\"Chelsea Hu\",\"website\":\"https://www.linkedin.com/in/chelsea-tsaiszuhu/\",\"avatar\":\"https://avatars.githubusercontent.com/u/196863678?v=4\",\"login\":\"chelseahu-openai\"}],\"search_text\":\"$3f\",\"type\":\"ipynb\",\"tags\":[\"agents-sdk\",\"functions\",\"mutli-agent-collaboration\",\"responses\"],\"archived\":false},{\"name\":\"o3o4-mini_prompting_guide.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/o-series/o3o4-mini_prompting_guide.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/o-series/o3o4-mini_prompting_guide.ipynb\",\"internal_path\":\"examples/o-series/o3o4-mini_prompting_guide\",\"title\":\"o3/o4-mini Function Calling Guide\",\"path\":\"examples/o-series/o3o4-mini_prompting_guide.ipynb\",\"date\":\"2025-05-26\",\"authors\":[{\"name\":\"Bill Chen\",\"website\":\"https://www.linkedin.com/in/billchen99/\",\"avatar\":\"https://avatars.githubusercontent.com/u/198814448?v=4\",\"login\":\"billchen-openai\"},{\"name\":\"Prashant Mital\",\"website\":\"https://www.linkedin.com/in/pmital/\",\"avatar\":\"https://avatars.githubusercontent.com/u/173949238?v=4\",\"login\":\"prashantmital-openai\"}],\"search_text\":\"$40\",\"type\":\"ipynb\",\"tags\":[\"functions\",\"reasoning\",\"responses\"],\"archived\":false},{\"name\":\"Reinforcement_Fine_Tuning.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/Reinforcement_Fine_Tuning.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/Reinforcement_Fine_Tuning.ipynb\",\"internal_path\":\"examples/reinforcement_fine_tuning\",\"title\":\"Exploring Model Graders for Reinforcement Fine-Tuning\",\"path\":\"examples/Reinforcement_Fine_Tuning.ipynb\",\"date\":\"2025-05-23\",\"authors\":[{\"name\":\"Theophile Sautory\",\"website\":\"https://www.linkedin.com/in/theophilesautory\",\"avatar\":\"https://avatars.githubusercontent.com/u/206768658?v=4\",\"login\":\"theophile-oai\"}],\"search_text\":\"$41\",\"type\":\"ipynb\",\"tags\":[\"fine-tuning\",\"reinforcement-learning\",\"reinforcement-learning-graders\"],\"archived\":false},{\"name\":\"reinforcement_finetuning_healthbench.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/fine-tuned_qa/reinforcement_finetuning_healthbench.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/fine-tuned_qa/reinforcement_finetuning_healthbench.ipynb\",\"internal_path\":\"examples/fine-tuned_qa/reinforcement_finetuning_healthbench\",\"title\":\"Reinforcement Fine-Tuning for Conversational Reasoning with the OpenAI API\",\"path\":\"examples/fine-tuned_qa/reinforcement_finetuning_healthbench.ipynb\",\"date\":\"2025-05-21\",\"authors\":[{\"name\":\"Robert Tinn\",\"website\":\"https://www.linkedin.com/in/robert-tinn/\",\"avatar\":\"https://avatars.githubusercontent.com/u/208724428?v=4\",\"login\":\"robert-tinn\"}],\"search_text\":\"$42\",\"type\":\"ipynb\",\"tags\":[\"evals\",\"fine-tuning\",\"qa\",\"reinforcement\"],\"archived\":false},{\"name\":\"mcp_tool_guide.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/mcp/mcp_tool_guide.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/mcp/mcp_tool_guide.ipynb\",\"internal_path\":\"examples/mcp/mcp_tool_guide\",\"title\":\"Guide to Using the Responses API's MCP Tool\",\"path\":\"examples/mcp/mcp_tool_guide.ipynb\",\"date\":\"2025-05-21\",\"authors\":[{\"name\":\"Charu Jaiswal\",\"website\":\"https://www.linkedin.com/in/charu-j-8a866471\",\"avatar\":\"https://avatars.githubusercontent.com/u/18404643?v=4\",\"login\":\"charuj\"}],\"search_text\":\"$43\",\"type\":\"ipynb\",\"tags\":[\"mcp\"],\"archived\":false},{\"name\":\"image_understanding_with_rag.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/multimodal/image_understanding_with_rag.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/multimodal/image_understanding_with_rag.ipynb\",\"internal_path\":\"examples/multimodal/image_understanding_with_rag\",\"title\":\"Image Understanding with RAG\",\"path\":\"examples/multimodal/image_understanding_with_rag.ipynb\",\"date\":\"2025-05-16\",\"authors\":[{\"name\":\"Robert Tinn\",\"website\":\"https://www.linkedin.com/in/robert-tinn/\",\"avatar\":\"https://avatars.githubusercontent.com/u/208724428?v=4\",\"login\":\"robert-tinn\"}],\"search_text\":\"$44\",\"type\":\"ipynb\",\"tags\":[\"RAG\",\"images\",\"responses\",\"vision\"],\"archived\":false},{\"name\":\"reasoning_items.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/responses_api/reasoning_items.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/responses_api/reasoning_items.ipynb\",\"internal_path\":\"examples/responses_api/reasoning_items\",\"title\":\"Better performance from reasoning models using the Responses API\",\"path\":\"examples/responses_api/reasoning_items.ipynb\",\"date\":\"2025-05-11\",\"authors\":[{\"name\":\"Bill Chen\",\"website\":\"https://www.linkedin.com/in/billchen99/\",\"avatar\":\"https://avatars.githubusercontent.com/u/198814448?v=4\",\"login\":\"billchen-openai\"}],\"search_text\":\"$45\",\"type\":\"ipynb\",\"tags\":[\"functions\",\"responses\"],\"archived\":false},{\"name\":\"Context_summarization_with_realtime_api.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/Context_summarization_with_realtime_api.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/Context_summarization_with_realtime_api.ipynb\",\"internal_path\":\"examples/context_summarization_with_realtime_api\",\"title\":\"Context Summarization with Realtime API\",\"path\":\"examples/Context_summarization_with_realtime_api.ipynb\",\"date\":\"2025-05-10\",\"authors\":[{\"name\":\"Minhajul Hoque\",\"website\":\"https://www.linkedin.com/in/minhajul-hoque-83242b163/\",\"avatar\":\"https://avatars.githubusercontent.com/u/84698472?v=4\",\"login\":\"minh-hoque\"}],\"search_text\":\"$46\",\"type\":\"ipynb\",\"tags\":[\"audio\",\"speech\",\"tiktoken\"],\"archived\":false},{\"name\":\"Speech_transcription_methods.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/Speech_transcription_methods.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/Speech_transcription_methods.ipynb\",\"internal_path\":\"examples/speech_transcription_methods\",\"title\":\"Comparing Speech-to-Text Methods with the OpenAI API\",\"path\":\"examples/Speech_transcription_methods.ipynb\",\"date\":\"2025-04-29\",\"authors\":[{\"name\":\"Minhajul Hoque\",\"website\":\"https://www.linkedin.com/in/minhajul-hoque-83242b163/\",\"avatar\":\"https://avatars.githubusercontent.com/u/84698472?v=4\",\"login\":\"minh-hoque\"}],\"search_text\":\"$47\",\"type\":\"ipynb\",\"tags\":[\"agents-sdk\",\"audio\",\"speech\"],\"archived\":false},{\"name\":\"model_selection_guide.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/partners/model_selection_guide/model_selection_guide.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/partners/model_selection_guide/model_selection_guide.ipynb\",\"internal_path\":\"examples/partners/model_selection_guide/model_selection_guide\",\"title\":\"Practical Guide for Model Selection for Real‑World Use Cases\",\"path\":\"examples/partners/model_selection_guide/model_selection_guide.ipynb\",\"date\":\"2025-05-07\",\"authors\":[{\"name\":\"Shikhar Kwatra\",\"website\":\"https://www.linkedin.com/in/shikharkwatra/\",\"avatar\":\"https://avatars.githubusercontent.com/u/189049238?v=4\",\"login\":\"shikhar-cyber\"},{\"login\":\"kashyapm-tribe\"},{\"login\":\"saip-tribe\"},{\"login\":\"nharada-tribe\"}],\"search_text\":\"$48\",\"type\":\"ipynb\",\"tags\":[\"RAG\",\"functions\",\"insurance\",\"legal\",\"pharma\",\"responses\",\"tool calling\",\"web-search\"],\"archived\":false},{\"name\":\"regression.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/evaluation/use-cases/regression.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/evaluation/use-cases/regression.ipynb\",\"internal_path\":\"examples/evaluation/use-cases/regression\",\"title\":\"Evals API Use-case - Detecting prompt regressions\",\"path\":\"examples/evaluation/use-cases/regression.ipynb\",\"date\":\"2025-04-08\",\"authors\":[{\"name\":\"Josiah Grace\",\"website\":\"https://www.linkedin.com/in/josiahbgrace\",\"avatar\":\"https://avatars.githubusercontent.com/u/181146311?v=4\",\"login\":\"josiah-openai\"}],\"search_text\":\"$49\",\"type\":\"ipynb\",\"tags\":[\"completions\",\"evals\"],\"archived\":false},{\"name\":\"bulk-experimentation.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/evaluation/use-cases/bulk-experimentation.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/evaluation/use-cases/bulk-experimentation.ipynb\",\"internal_path\":\"examples/evaluation/use-cases/bulk-experimentation\",\"title\":\"Evals API Use-case - Bulk model and prompt experimentation\",\"path\":\"examples/evaluation/use-cases/bulk-experimentation.ipynb\",\"date\":\"2025-04-08\",\"authors\":[{\"name\":\"Josiah Grace\",\"website\":\"https://www.linkedin.com/in/josiahbgrace\",\"avatar\":\"https://avatars.githubusercontent.com/u/181146311?v=4\",\"login\":\"josiah-openai\"}],\"search_text\":\"$4a\",\"type\":\"ipynb\",\"tags\":[\"completions\",\"evals\"],\"archived\":false},{\"name\":\"completion-monitoring.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/evaluation/use-cases/completion-monitoring.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/evaluation/use-cases/completion-monitoring.ipynb\",\"internal_path\":\"examples/evaluation/use-cases/completion-monitoring\",\"title\":\"Evals API Use-case - Monitoring stored completions\",\"path\":\"examples/evaluation/use-cases/completion-monitoring.ipynb\",\"date\":\"2025-04-08\",\"authors\":[{\"name\":\"Josiah Grace\",\"website\":\"https://www.linkedin.com/in/josiahbgrace\",\"avatar\":\"https://avatars.githubusercontent.com/u/181146311?v=4\",\"login\":\"josiah-openai\"}],\"search_text\":\"$4b\",\"type\":\"ipynb\",\"tags\":[\"completions\",\"evals\"],\"archived\":false},{\"name\":\"responses-evaluation.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/evaluation/use-cases/responses-evaluation.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/evaluation/use-cases/responses-evaluation.ipynb\",\"internal_path\":\"examples/evaluation/use-cases/responses-evaluation\",\"title\":\"Evals API Use-case - Responses Evaluation\",\"path\":\"examples/evaluation/use-cases/responses-evaluation.ipynb\",\"date\":\"2025-05-13\",\"authors\":[{\"name\":\"Will Hathaway\",\"website\":\"https://www.willhath.com\",\"avatar\":\"https://media.licdn.com/dms/image/v2/D4E03AQEHOtMrHtww4Q/profile-displayphoto-shrink_200_200/B4EZRR64p9HgAc-/0/1736541178829?e=2147483647\u0026v=beta\u0026t=w1rX0KhLZaK5qBkVLkJjmYmfNMbsV2Bcn8InFVX9lwI\",\"login\":\"willhath-openai\"}],\"search_text\":\"$4c\",\"type\":\"ipynb\",\"tags\":[\"evals\",\"responses\"],\"archived\":false},{\"name\":\"responses_api_tool_orchestration.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/responses_api/responses_api_tool_orchestration.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/responses_api/responses_api_tool_orchestration.ipynb\",\"internal_path\":\"examples/responses_api/responses_api_tool_orchestration\",\"title\":\"Multi-Tool Orchestration with RAG approach using OpenAI's Responses API\",\"path\":\"examples/responses_api/responses_api_tool_orchestration.ipynb\",\"date\":\"2025-03-28\",\"authors\":[{\"name\":\"Shikhar Kwatra\",\"website\":\"https://www.linkedin.com/in/shikharkwatra/\",\"avatar\":\"https://avatars.githubusercontent.com/u/189049238?v=4\",\"login\":\"shikhar-cyber\"}],\"search_text\":\"$4d\",\"type\":\"ipynb\",\"tags\":[\"functions\",\"pinecone\",\"responses\",\"web-search\"],\"archived\":false},{\"name\":\"dispute_agent.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/agents_sdk/dispute_agent.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/agents_sdk/dispute_agent.ipynb\",\"internal_path\":\"examples/agents_sdk/dispute_agent\",\"title\":\"Automating Dispute Management with Agents SDK and Stripe API\",\"path\":\"examples/agents_sdk/dispute_agent.ipynb\",\"date\":\"2025-03-17\",\"authors\":[{\"name\":\"Dan Bell\",\"website\":\"https://www.linkedin.com/in/dan-bell-b69721b1/\",\"avatar\":\"https://avatars.githubusercontent.com/u/201846729?v=4\",\"login\":\"danbell-openai\"}],\"search_text\":\"$4e\",\"type\":\"ipynb\",\"tags\":[\"agents-sdk\",\"functions\",\"responses\"],\"archived\":false},{\"name\":\"responses_example.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/responses_api/responses_example.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/responses_api/responses_example.ipynb\",\"internal_path\":\"examples/responses_api/responses_example\",\"title\":\"Web Search and States with Responses API\",\"path\":\"examples/responses_api/responses_example.ipynb\",\"date\":\"2025-03-11\",\"authors\":[{\"name\":\"Bill Chen\",\"website\":\"https://www.linkedin.com/in/billchen99/\",\"avatar\":\"https://avatars.githubusercontent.com/u/198814448?v=4\",\"login\":\"billchen-openai\"}],\"search_text\":\"$4f\",\"type\":\"ipynb\",\"tags\":[\"functions\",\"responses\",\"web-search\"],\"archived\":false},{\"name\":\"Using_logprobs.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/Using_logprobs.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/Using_logprobs.ipynb\",\"internal_path\":\"examples/using_logprobs\",\"title\":\"Using logprobs\",\"path\":\"examples/Using_logprobs.ipynb\",\"date\":\"2023-12-20\",\"authors\":[{\"name\":\"James Hills\",\"website\":\"https://twitter.com/jamesmhills\",\"avatar\":\"https://pbs.twimg.com/profile_images/1722092156691902464/44FGj7VT_400x400.jpg\",\"login\":\"jhills20\"},{\"name\":\"Shyamal Anadkat\",\"website\":\"https://twitter.com/shyamalanadkat\",\"avatar\":\"https://pbs.twimg.com/profile_images/1590564338682560512/3bbZJqxZ_400x400.jpg\",\"login\":\"shyamal-anadkat\"}],\"search_text\":\"$50\",\"type\":\"ipynb\",\"tags\":[\"completions\"],\"archived\":false},{\"name\":\"Creating_slides_with_Assistants_API_and_DALL-E3.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/Creating_slides_with_Assistants_API_and_DALL-E3.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/Creating_slides_with_Assistants_API_and_DALL-E3.ipynb\",\"internal_path\":\"examples/creating_slides_with_assistants_api_and_dall-e3\",\"title\":\"Creating slides with the Assistants API and DALL·E 3\",\"path\":\"examples/Creating_slides_with_Assistants_API_and_DALL-E3.ipynb\",\"date\":\"2023-12-08\",\"authors\":[{\"name\":\"James Hills\",\"website\":\"https://twitter.com/jamesmhills\",\"avatar\":\"https://pbs.twimg.com/profile_images/1722092156691902464/44FGj7VT_400x400.jpg\",\"login\":\"jhills20\"}],\"search_text\":\"$51\",\"type\":\"ipynb\",\"tags\":[\"assistants\",\"dall-e\"],\"archived\":false},{\"name\":\"Chat_finetuning_data_prep.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/Chat_finetuning_data_prep.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/Chat_finetuning_data_prep.ipynb\",\"internal_path\":\"examples/chat_finetuning_data_prep\",\"title\":\"Data preparation and analysis for chat model fine-tuning\",\"path\":\"examples/Chat_finetuning_data_prep.ipynb\",\"date\":\"2023-08-22\",\"authors\":[{\"name\":\"Michael Wu\",\"website\":\"https://www.linkedin.com/in/michael-wu-77440977/\",\"avatar\":\"https://avatars.githubusercontent.com/u/1650674?v=4\",\"login\":\"mwu1993\"},{\"name\":\"Simón Fishman\",\"website\":\"https://twitter.com/simonpfish\",\"avatar\":\"https://pbs.twimg.com/profile_images/1687643030243901441/61DpxNfc_400x400.jpg\",\"login\":\"simonpfish\"}],\"search_text\":\"$52\",\"type\":\"ipynb\",\"tags\":[\"completions\",\"fine-tuning\",\"tiktoken\"],\"archived\":false},{\"name\":\"Classification_using_embeddings.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/Classification_using_embeddings.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/Classification_using_embeddings.ipynb\",\"internal_path\":\"examples/classification_using_embeddings\",\"title\":\"Classification using embeddings\",\"path\":\"examples/Classification_using_embeddings.ipynb\",\"date\":\"2022-07-11\",\"authors\":[{\"name\":\"Ted Sanders\",\"website\":\"https://github.com/ted-at-openai\",\"avatar\":\"https://avatars.githubusercontent.com/u/95656834?v=4\",\"login\":\"ted-at-openai\"},{\"login\":\"logankilpatrick\"}],\"search_text\":\"$53\",\"type\":\"ipynb\",\"tags\":[\"embeddings\"],\"archived\":true},{\"name\":\"Clustering.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/Clustering.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/Clustering.ipynb\",\"internal_path\":\"examples/clustering\",\"title\":\"Clustering\",\"path\":\"examples/Clustering.ipynb\",\"date\":\"2022-03-10\",\"authors\":[{\"login\":\"BorisPower\"},{\"name\":\"Ted Sanders\",\"website\":\"https://github.com/ted-at-openai\",\"avatar\":\"https://avatars.githubusercontent.com/u/95656834?v=4\",\"login\":\"ted-at-openai\"},{\"login\":\"logankilpatrick\"}],\"search_text\":\"We use a simple k-means algorithm to demonstrate how clustering can be done. Clustering can help discover valuable, hidden groupings within the data. The dataset is created in the Get_embeddings_from_dataset Notebook.\\nWe show the simplest use of K-means. You can pick the number of clusters that fits your use case best.\\nVisualization of clusters in a 2d projection. In this run, the green cluster (#1) seems quite different from the others. Let's see a few samples from each cluster.\\n\\nLet's show random samples from each cluster. We'll use gpt-4 to name the clusters, based on a random sample of 5 reviews from that cluster.\\nIt's important to note that clusters will not necessarily match what you intend to use them for. A larger amount of clusters will focus on more specific patterns, whereas a small number of clusters will usually focus on largest discrepencies in the data.\",\"type\":\"ipynb\",\"tags\":[\"embeddings\"],\"archived\":true},{\"name\":\"Clustering_for_transaction_classification.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/Clustering_for_transaction_classification.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/Clustering_for_transaction_classification.ipynb\",\"internal_path\":\"examples/clustering_for_transaction_classification\",\"title\":\"Clustering for transaction classification\",\"path\":\"examples/Clustering_for_transaction_classification.ipynb\",\"date\":\"2022-10-20\",\"authors\":[{\"name\":\"Colin Jarvis\",\"website\":\"https://twitter.com/colintjarvis\",\"avatar\":\"https://pbs.twimg.com/profile_images/1727207339034345472/IM8v8tlC_400x400.jpg\",\"login\":\"colin-openai\"},{\"name\":\"Ted Sanders\",\"website\":\"https://github.com/ted-at-openai\",\"avatar\":\"https://avatars.githubusercontent.com/u/95656834?v=4\",\"login\":\"ted-at-openai\"}],\"search_text\":\"$54\",\"type\":\"ipynb\",\"tags\":[\"completions\",\"embeddings\"],\"archived\":true},{\"name\":\"Code_search_using_embeddings.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/Code_search_using_embeddings.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/Code_search_using_embeddings.ipynb\",\"internal_path\":\"examples/code_search_using_embeddings\",\"title\":\"Code search using embeddings\",\"path\":\"examples/Code_search_using_embeddings.ipynb\",\"date\":\"2022-03-10\",\"authors\":[{\"login\":\"BorisPower\"},{\"login\":\"logankilpatrick\"},{\"login\":\"eli64s\"}],\"search_text\":\"$55\",\"type\":\"ipynb\",\"tags\":[\"embeddings\"],\"archived\":true},{\"name\":\"Customizing_embeddings.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/Customizing_embeddings.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/Customizing_embeddings.ipynb\",\"internal_path\":\"examples/customizing_embeddings\",\"title\":\"Customizing embeddings\",\"path\":\"examples/Customizing_embeddings.ipynb\",\"date\":\"2022-03-10\",\"authors\":[{\"name\":\"Ted Sanders\",\"website\":\"https://github.com/ted-at-openai\",\"avatar\":\"https://avatars.githubusercontent.com/u/95656834?v=4\",\"login\":\"ted-at-openai\"},{\"login\":\"BorisPower\"}],\"search_text\":\"$56\",\"type\":\"ipynb\",\"tags\":[\"embeddings\"],\"archived\":true},{\"name\":\"Embedding_Wikipedia_articles_for_search.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/Embedding_Wikipedia_articles_for_search.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/Embedding_Wikipedia_articles_for_search.ipynb\",\"internal_path\":\"examples/embedding_wikipedia_articles_for_search\",\"title\":\"Embedding Wikipedia articles for search\",\"path\":\"examples/Embedding_Wikipedia_articles_for_search.ipynb\",\"date\":\"2024-11-26\",\"authors\":[{\"name\":\"Ted Sanders\",\"website\":\"https://github.com/ted-at-openai\",\"avatar\":\"https://avatars.githubusercontent.com/u/95656834?v=4\",\"login\":\"ted-at-openai\"}],\"search_text\":\"$57\",\"type\":\"ipynb\",\"tags\":[\"completions\",\"embeddings\"],\"archived\":false},{\"name\":\"Embedding_long_inputs.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/Embedding_long_inputs.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/Embedding_long_inputs.ipynb\",\"internal_path\":\"examples/embedding_long_inputs\",\"title\":\"Embedding texts that are longer than the model's maximum context length\",\"path\":\"examples/Embedding_long_inputs.ipynb\",\"date\":\"2023-01-18\",\"authors\":[{\"login\":\"filipeabperes\"}],\"search_text\":\"$58\",\"type\":\"ipynb\",\"tags\":[\"embeddings\",\"tiktoken\"],\"archived\":false},{\"name\":\"Entity_extraction_for_long_documents.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/Entity_extraction_for_long_documents.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/Entity_extraction_for_long_documents.ipynb\",\"internal_path\":\"examples/entity_extraction_for_long_documents\",\"title\":\"Long document content extraction\",\"path\":\"examples/Entity_extraction_for_long_documents.ipynb\",\"date\":\"2023-02-20\",\"authors\":[{\"name\":\"Colin Jarvis\",\"website\":\"https://twitter.com/colintjarvis\",\"avatar\":\"https://pbs.twimg.com/profile_images/1727207339034345472/IM8v8tlC_400x400.jpg\",\"login\":\"colin-openai\"}],\"search_text\":\"$59\",\"type\":\"ipynb\",\"tags\":[\"completions\"],\"archived\":false},{\"name\":\"Fine-tuned_classification.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/Fine-tuned_classification.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/Fine-tuned_classification.ipynb\",\"internal_path\":\"examples/fine-tuned_classification\",\"title\":\"Fine tuning classification example\",\"path\":\"examples/Fine-tuned_classification.ipynb\",\"date\":\"2022-03-10\",\"authors\":[{\"login\":\"BorisPower\"}],\"search_text\":\"$5a\",\"type\":\"ipynb\",\"tags\":[\"completions\",\"fine-tuning\"],\"archived\":true},{\"name\":\"Function_calling_finding_nearby_places.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/Function_calling_finding_nearby_places.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/Function_calling_finding_nearby_places.ipynb\",\"internal_path\":\"examples/function_calling_finding_nearby_places\",\"title\":\"Function calling for nearby places: Leveraging the Google Places API and customer profiles\",\"path\":\"examples/Function_calling_finding_nearby_places.ipynb\",\"date\":\"2023-08-11\",\"authors\":[{\"login\":\"prestontuggle\"}],\"search_text\":\"$5b\",\"type\":\"ipynb\",\"tags\":[\"completions\",\"functions\"],\"archived\":false},{\"name\":\"Using_embeddings.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/Using_embeddings.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/Using_embeddings.ipynb\",\"internal_path\":\"examples/using_embeddings\",\"title\":\"Using embeddings\",\"path\":\"examples/Using_embeddings.ipynb\",\"date\":\"2022-03-10\",\"authors\":[{\"login\":\"BorisPower\"},{\"name\":\"Ted Sanders\",\"website\":\"https://github.com/ted-at-openai\",\"avatar\":\"https://avatars.githubusercontent.com/u/95656834?v=4\",\"login\":\"ted-at-openai\"},{\"login\":\"logankilpatrick\"},{\"name\":\"Joe Beutler\",\"website\":\"https://joebeutler.com\",\"avatar\":\"https://avatars.githubusercontent.com/u/156261485?v=4\",\"login\":\"jbeutler-openai\"}],\"search_text\":\"This notebook contains some helpful snippets you can use to embed text with the text-embedding-3-small model via the OpenAI API.\\nIt's recommended to use the 'tenacity' package or another exponential backoff implementation to better manage API rate limits, as hitting the API too much too fast can trigger rate limits. Using the following function ensures you get your embeddings as fast as possible.\",\"type\":\"ipynb\",\"tags\":[\"embeddings\"],\"archived\":true},{\"name\":\"How_to_build_a_tool-using_agent_with_Langchain.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/How_to_build_a_tool-using_agent_with_Langchain.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/How_to_build_a_tool-using_agent_with_Langchain.ipynb\",\"internal_path\":\"examples/how_to_build_a_tool-using_agent_with_langchain\",\"title\":\"How to build a tool-using agent with LangChain\",\"path\":\"examples/How_to_build_a_tool-using_agent_with_Langchain.ipynb\",\"date\":\"2023-05-02\",\"authors\":[{\"name\":\"Colin Jarvis\",\"website\":\"https://twitter.com/colintjarvis\",\"avatar\":\"https://pbs.twimg.com/profile_images/1727207339034345472/IM8v8tlC_400x400.jpg\",\"login\":\"colin-openai\"}],\"search_text\":\"$5c\",\"type\":\"ipynb\",\"tags\":[\"agents\",\"completions\",\"embeddings\"],\"archived\":false},{\"name\":\"How_to_call_functions_for_knowledge_retrieval.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/How_to_call_functions_for_knowledge_retrieval.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/How_to_call_functions_for_knowledge_retrieval.ipynb\",\"internal_path\":\"examples/how_to_call_functions_for_knowledge_retrieval\",\"title\":\"How to use functions with a knowledge base\",\"path\":\"examples/How_to_call_functions_for_knowledge_retrieval.ipynb\",\"date\":\"2023-06-14\",\"authors\":[{\"name\":\"Colin Jarvis\",\"website\":\"https://twitter.com/colintjarvis\",\"avatar\":\"https://pbs.twimg.com/profile_images/1727207339034345472/IM8v8tlC_400x400.jpg\",\"login\":\"colin-openai\"},{\"name\":\"Shuhei Ishida\",\"website\":\"https://www.linkedin.com/in/shuhei-i/\",\"avatar\":\"https://avatars.githubusercontent.com/u/186007001\",\"login\":\"ishida-openai\"}],\"search_text\":\"$5d\",\"type\":\"ipynb\",\"tags\":[\"completions\",\"functions\"],\"archived\":false},{\"name\":\"How_to_call_functions_with_chat_models.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/How_to_call_functions_with_chat_models.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/How_to_call_functions_with_chat_models.ipynb\",\"internal_path\":\"examples/how_to_call_functions_with_chat_models\",\"title\":\"How to call functions with chat models\",\"path\":\"examples/How_to_call_functions_with_chat_models.ipynb\",\"date\":\"2023-06-13\",\"authors\":[{\"name\":\"Colin Jarvis\",\"website\":\"https://twitter.com/colintjarvis\",\"avatar\":\"https://pbs.twimg.com/profile_images/1727207339034345472/IM8v8tlC_400x400.jpg\",\"login\":\"colin-openai\"},{\"name\":\"Joe Palermo\",\"website\":\"https://www.linkedin.com/in/joe-palermo-99219237\",\"avatar\":\"https://avatars.githubusercontent.com/u/117690718?v=4\",\"login\":\"joe-at-openai\"}],\"search_text\":\"$5e\",\"type\":\"ipynb\",\"tags\":[\"completions\",\"functions\"],\"archived\":false},{\"name\":\"How_to_count_tokens_with_tiktoken.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/How_to_count_tokens_with_tiktoken.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/How_to_count_tokens_with_tiktoken.ipynb\",\"internal_path\":\"examples/how_to_count_tokens_with_tiktoken\",\"title\":\"How to count tokens with Tiktoken\",\"path\":\"examples/How_to_count_tokens_with_tiktoken.ipynb\",\"date\":\"2022-12-16\",\"authors\":[{\"name\":\"Ted Sanders\",\"website\":\"https://github.com/ted-at-openai\",\"avatar\":\"https://avatars.githubusercontent.com/u/95656834?v=4\",\"login\":\"ted-at-openai\"}],\"search_text\":\"$5f\",\"type\":\"ipynb\",\"tags\":[\"completions\",\"tiktoken\"],\"archived\":true},{\"name\":\"How_to_finetune_chat_models.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/How_to_finetune_chat_models.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/How_to_finetune_chat_models.ipynb\",\"internal_path\":\"examples/how_to_finetune_chat_models\",\"title\":\"How to fine-tune chat models\",\"path\":\"examples/How_to_finetune_chat_models.ipynb\",\"date\":\"2024-07-23\",\"authors\":[{\"name\":\"Simón Fishman\",\"website\":\"https://twitter.com/simonpfish\",\"avatar\":\"https://pbs.twimg.com/profile_images/1687643030243901441/61DpxNfc_400x400.jpg\",\"login\":\"simonpfish\"},{\"name\":\"Shyamal Anadkat\",\"website\":\"https://twitter.com/shyamalanadkat\",\"avatar\":\"https://pbs.twimg.com/profile_images/1590564338682560512/3bbZJqxZ_400x400.jpg\",\"login\":\"shyamal-anadkat\"}],\"search_text\":\"$60\",\"type\":\"ipynb\",\"tags\":[\"completions\",\"fine-tuning\"],\"archived\":false},{\"name\":\"How_to_format_inputs_to_ChatGPT_models.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/How_to_format_inputs_to_ChatGPT_models.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/How_to_format_inputs_to_ChatGPT_models.ipynb\",\"internal_path\":\"examples/how_to_format_inputs_to_chatgpt_models\",\"title\":\"How to format inputs to ChatGPT models\",\"path\":\"examples/How_to_format_inputs_to_ChatGPT_models.ipynb\",\"date\":\"2023-03-01\",\"authors\":[{\"name\":\"Ted Sanders\",\"website\":\"https://github.com/ted-at-openai\",\"avatar\":\"https://avatars.githubusercontent.com/u/95656834?v=4\",\"login\":\"ted-at-openai\"}],\"search_text\":\"$61\",\"type\":\"ipynb\",\"tags\":[\"completions\",\"tiktoken\"],\"archived\":false},{\"name\":\"How_to_handle_rate_limits.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/How_to_handle_rate_limits.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/How_to_handle_rate_limits.ipynb\",\"internal_path\":\"examples/how_to_handle_rate_limits\",\"title\":\"How to handle rate limits\",\"path\":\"examples/How_to_handle_rate_limits.ipynb\",\"date\":\"2025-01-22\",\"authors\":[{\"name\":\"Ted Sanders\",\"website\":\"https://github.com/ted-at-openai\",\"avatar\":\"https://avatars.githubusercontent.com/u/95656834?v=4\",\"login\":\"ted-at-openai\"},{\"name\":\"Danny Wigg\",\"website\":\"https://www.linkedin.com/in/dannywigg/\",\"avatar\":\"https://avatars.githubusercontent.com/u/4661060?v=4\",\"login\":\"dwigg-openai\"}],\"search_text\":\"$62\",\"type\":\"ipynb\",\"tags\":[\"completions\",\"embeddings\"],\"archived\":false},{\"name\":\"How_to_stream_completions.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/How_to_stream_completions.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/How_to_stream_completions.ipynb\",\"internal_path\":\"examples/how_to_stream_completions\",\"title\":\"How to stream completions\",\"path\":\"examples/How_to_stream_completions.ipynb\",\"date\":\"2022-09-02\",\"authors\":[{\"name\":\"Ted Sanders\",\"website\":\"https://github.com/ted-at-openai\",\"avatar\":\"https://avatars.githubusercontent.com/u/95656834?v=4\",\"login\":\"ted-at-openai\"}],\"search_text\":\"$63\",\"type\":\"ipynb\",\"tags\":[\"completions\"],\"archived\":true},{\"name\":\"Multiclass_classification_for_transactions.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/Multiclass_classification_for_transactions.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/Multiclass_classification_for_transactions.ipynb\",\"internal_path\":\"examples/multiclass_classification_for_transactions\",\"title\":\"Multiclass Classification for Transactions\",\"path\":\"examples/Multiclass_classification_for_transactions.ipynb\",\"date\":\"2022-10-20\",\"authors\":[{\"name\":\"Colin Jarvis\",\"website\":\"https://twitter.com/colintjarvis\",\"avatar\":\"https://pbs.twimg.com/profile_images/1727207339034345472/IM8v8tlC_400x400.jpg\",\"login\":\"colin-openai\"},{\"name\":\"Vishnu Chopra\",\"website\":\"https://www.linkedin.com/in/vishnu-chopra/\",\"avatar\":\"https://avatars.githubusercontent.com/u/206769912?v=4\",\"login\":\"vishnu-oai\"}],\"search_text\":\"$64\",\"type\":\"ipynb\",\"tags\":[\"completions\",\"embeddings\"],\"archived\":true},{\"name\":\"Get_embeddings_from_dataset.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/Get_embeddings_from_dataset.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/Get_embeddings_from_dataset.ipynb\",\"internal_path\":\"examples/get_embeddings_from_dataset\",\"title\":\"Get embeddings from dataset\",\"path\":\"examples/Get_embeddings_from_dataset.ipynb\",\"date\":\"2022-03-10\",\"authors\":[{\"login\":\"BorisPower\"},{\"name\":\"Ted Sanders\",\"website\":\"https://github.com/ted-at-openai\",\"avatar\":\"https://avatars.githubusercontent.com/u/95656834?v=4\",\"login\":\"ted-at-openai\"}],\"search_text\":\"This notebook gives an example on how to get embeddings from a large dataset.\\n\\n\\n\\nThe dataset used in this example is fine-food reviews from Amazon. The dataset contains a total of 568,454 food reviews Amazon users left up to October 2012. We will use a subset of this dataset, consisting of 1,000 most recent reviews for illustration purposes. The reviews are in English and tend to be positive or negative. Each review has a ProductId, UserId, Score, review title (Summary) and review body (Text).\\n\\nWe will combine the review summary and review text into a single combined text. The model will encode this combined text and it will output a single vector embedding.\\nTo run this notebook, you will need to install: pandas, openai, transformers, plotly, matplotlib, scikit-learn, torch (transformer dep), torchvision, and scipy.\\n2. Get embeddings and save them for future reuse\",\"type\":\"ipynb\",\"tags\":[\"embeddings\"],\"archived\":true},{\"name\":\"Question_answering_using_a_search_API.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/Question_answering_using_a_search_API.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/Question_answering_using_a_search_API.ipynb\",\"internal_path\":\"examples/question_answering_using_a_search_api\",\"title\":\"Question answering using a search API and re-ranking\",\"path\":\"examples/Question_answering_using_a_search_API.ipynb\",\"date\":\"2023-06-16\",\"authors\":[{\"name\":\"Simón Fishman\",\"website\":\"https://twitter.com/simonpfish\",\"avatar\":\"https://pbs.twimg.com/profile_images/1687643030243901441/61DpxNfc_400x400.jpg\",\"login\":\"simonpfish\"},{\"name\":\"Ted Sanders\",\"website\":\"https://github.com/ted-at-openai\",\"avatar\":\"https://avatars.githubusercontent.com/u/95656834?v=4\",\"login\":\"ted-at-openai\"}],\"search_text\":\"$65\",\"type\":\"ipynb\",\"tags\":[\"completions\",\"embeddings\"],\"archived\":false},{\"name\":\"Question_answering_using_embeddings.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/Question_answering_using_embeddings.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/Question_answering_using_embeddings.ipynb\",\"internal_path\":\"examples/question_answering_using_embeddings\",\"title\":\"Question answering using embeddings-based search\",\"path\":\"examples/Question_answering_using_embeddings.ipynb\",\"date\":\"2022-06-10\",\"authors\":[{\"name\":\"Ted Sanders\",\"website\":\"https://github.com/ted-at-openai\",\"avatar\":\"https://avatars.githubusercontent.com/u/95656834?v=4\",\"login\":\"ted-at-openai\"},{\"name\":\"Mike Heaton\",\"website\":\"https://github.com/MikeHeaton\",\"avatar\":\"https://avatars.githubusercontent.com/u/11911723?v=4\",\"login\":\"MikeHeaton\"}],\"search_text\":\"$66\",\"type\":\"ipynb\",\"tags\":[\"completions\",\"embeddings\"],\"archived\":true},{\"name\":\"Recommendation_using_embeddings.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/Recommendation_using_embeddings.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/Recommendation_using_embeddings.ipynb\",\"internal_path\":\"examples/recommendation_using_embeddings\",\"title\":\"Recommendation using embeddings and nearest neighbor search\",\"path\":\"examples/Recommendation_using_embeddings.ipynb\",\"date\":\"2022-03-10\",\"authors\":[{\"name\":\"Ted Sanders\",\"website\":\"https://github.com/ted-at-openai\",\"avatar\":\"https://avatars.githubusercontent.com/u/95656834?v=4\",\"login\":\"ted-at-openai\"},{\"login\":\"BorisPower\"},{\"login\":\"logankilpatrick\"}],\"search_text\":\"$67\",\"type\":\"ipynb\",\"tags\":[\"embeddings\"],\"archived\":true},{\"name\":\"Regression_using_embeddings.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/Regression_using_embeddings.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/Regression_using_embeddings.ipynb\",\"internal_path\":\"examples/regression_using_embeddings\",\"title\":\"Regression using the embeddings\",\"path\":\"examples/Regression_using_embeddings.ipynb\",\"date\":\"2022-03-10\",\"authors\":[{\"login\":\"BorisPower\"},{\"name\":\"Ted Sanders\",\"website\":\"https://github.com/ted-at-openai\",\"avatar\":\"https://avatars.githubusercontent.com/u/95656834?v=4\",\"login\":\"ted-at-openai\"},{\"login\":\"logankilpatrick\"}],\"search_text\":\"Regression means predicting a number, rather than one of the categories. We will predict the score based on the embedding of the review's text. We split the dataset into a training and a testing set for all of the following tasks, so we can realistically evaluate performance on unseen data. The dataset is created in the Get_embeddings_from_dataset Notebook.\\n\\nWe're predicting the score of the review, which is a number between 1 and 5 (1-star being negative and 5-star positive).\\nWe can see that the embeddings are able to predict the scores with an average error of 0.53 per score prediction. This is roughly equivalent to predicting half of reviews perfectly, and half off by one star.\\nYou could also train a classifier to predict the label, or use the embeddings within an existing ML model to encode free text features.\",\"type\":\"ipynb\",\"tags\":[\"embeddings\"],\"archived\":true},{\"name\":\"Search_reranking_with_cross-encoders.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/Search_reranking_with_cross-encoders.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/Search_reranking_with_cross-encoders.ipynb\",\"internal_path\":\"examples/search_reranking_with_cross-encoders\",\"title\":\"Search reranking with cross-encoders\",\"path\":\"examples/Search_reranking_with_cross-encoders.ipynb\",\"date\":\"2023-06-28\",\"authors\":[{\"name\":\"Colin Jarvis\",\"website\":\"https://twitter.com/colintjarvis\",\"avatar\":\"https://pbs.twimg.com/profile_images/1727207339034345472/IM8v8tlC_400x400.jpg\",\"login\":\"colin-openai\"}],\"search_text\":\"$68\",\"type\":\"ipynb\",\"tags\":[\"completions\",\"embeddings\"],\"archived\":false},{\"name\":\"Semantic_text_search_using_embeddings.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/Semantic_text_search_using_embeddings.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/Semantic_text_search_using_embeddings.ipynb\",\"internal_path\":\"examples/semantic_text_search_using_embeddings\",\"title\":\"Semantic text search using embeddings\",\"path\":\"examples/Semantic_text_search_using_embeddings.ipynb\",\"date\":\"2022-03-10\",\"authors\":[{\"login\":\"BorisPower\"},{\"name\":\"Ted Sanders\",\"website\":\"https://github.com/ted-at-openai\",\"avatar\":\"https://avatars.githubusercontent.com/u/95656834?v=4\",\"login\":\"ted-at-openai\"},{\"login\":\"logankilpatrick\"}],\"search_text\":\"We can search through all our reviews semantically in a very efficient manner and at very low cost, by embedding our search query, and then finding the most similar reviews. The dataset is created in the Get_embeddings_from_dataset Notebook.\\nHere we compare the cosine similarity of the embeddings of the query and the documents, and show top_n best matches.\\nWe can search through these reviews easily. To speed up computation, we can use a special algorithm, aimed at faster search through embeddings.\\nAs we can see, this can immediately deliver a lot of value. In this example we show being able to quickly find the examples of delivery failures.\",\"type\":\"ipynb\",\"tags\":[\"embeddings\"],\"archived\":true},{\"name\":\"Unit_test_writing_using_a_multi-step_prompt.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/Unit_test_writing_using_a_multi-step_prompt.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/Unit_test_writing_using_a_multi-step_prompt.ipynb\",\"internal_path\":\"examples/unit_test_writing_using_a_multi-step_prompt\",\"title\":\"Unit test writing using a multi-step prompt\",\"path\":\"examples/Unit_test_writing_using_a_multi-step_prompt.ipynb\",\"date\":\"2022-11-15\",\"authors\":[{\"name\":\"Ted Sanders\",\"website\":\"https://github.com/ted-at-openai\",\"avatar\":\"https://avatars.githubusercontent.com/u/95656834?v=4\",\"login\":\"ted-at-openai\"}],\"search_text\":\"$69\",\"type\":\"ipynb\",\"tags\":[\"completions\"],\"archived\":true},{\"name\":\"Unit_test_writing_using_a_multi-step_prompt_with_older_completions_API.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/Unit_test_writing_using_a_multi-step_prompt_with_older_completions_API.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/Unit_test_writing_using_a_multi-step_prompt_with_older_completions_API.ipynb\",\"internal_path\":\"examples/unit_test_writing_using_a_multi-step_prompt_with_older_completions_api\",\"title\":\"Unit test writing using a multi-step prompt with legacy Completions\",\"path\":\"examples/Unit_test_writing_using_a_multi-step_prompt_with_older_completions_API.ipynb\",\"date\":\"2023-05-19\",\"authors\":[{\"name\":\"Ted Sanders\",\"website\":\"https://github.com/ted-at-openai\",\"avatar\":\"https://avatars.githubusercontent.com/u/95656834?v=4\",\"login\":\"ted-at-openai\"}],\"search_text\":\"$6a\",\"type\":\"ipynb\",\"tags\":[\"completions\"],\"archived\":false},{\"name\":\"User_and_product_embeddings.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/User_and_product_embeddings.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/User_and_product_embeddings.ipynb\",\"internal_path\":\"examples/user_and_product_embeddings\",\"title\":\"User and product embeddings\",\"path\":\"examples/User_and_product_embeddings.ipynb\",\"date\":\"2022-03-10\",\"authors\":[{\"login\":\"BorisPower\"}],\"search_text\":\"$6b\",\"type\":\"ipynb\",\"tags\":[\"embeddings\"],\"archived\":true},{\"name\":\"Visualizing_embeddings_in_2D.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/Visualizing_embeddings_in_2D.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/Visualizing_embeddings_in_2D.ipynb\",\"internal_path\":\"examples/visualizing_embeddings_in_2d\",\"title\":\"Visualizing the embeddings in 2D\",\"path\":\"examples/Visualizing_embeddings_in_2D.ipynb\",\"date\":\"2022-03-10\",\"authors\":[{\"login\":\"BorisPower\"},{\"name\":\"Ted Sanders\",\"website\":\"https://github.com/ted-at-openai\",\"avatar\":\"https://avatars.githubusercontent.com/u/95656834?v=4\",\"login\":\"ted-at-openai\"}],\"search_text\":\"We will use t-SNE to reduce the dimensionality of the embeddings from 1536 to 2. Once the embeddings are reduced to two dimensions, we can plot them in a 2D scatter plot. The dataset is created in the Get_embeddings_from_dataset Notebook.\\n\\nWe reduce the dimensionality to 2 dimensions using t-SNE decomposition.\\n\\nWe colour each review by its star rating, ranging from red to green.\\nWe can observe a decent data separation even in the reduced 2 dimensions.\",\"type\":\"ipynb\",\"tags\":[\"embeddings\"],\"archived\":true},{\"name\":\"Visualizing_embeddings_in_3D.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/Visualizing_embeddings_in_3D.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/Visualizing_embeddings_in_3D.ipynb\",\"internal_path\":\"examples/visualizing_embeddings_in_3d\",\"title\":\"Visualizing embeddings in 3D\",\"path\":\"examples/Visualizing_embeddings_in_3D.ipynb\",\"date\":\"2022-03-10\",\"authors\":[{\"login\":\"BorisPower\"},{\"name\":\"Ted Sanders\",\"website\":\"https://github.com/ted-at-openai\",\"avatar\":\"https://avatars.githubusercontent.com/u/95656834?v=4\",\"login\":\"ted-at-openai\"}],\"search_text\":\"The example uses PCA to reduce the dimensionality fo the embeddings from 1536 to 3. Then we can visualize the data points in a 3D plot. The small dataset dbpedia_samples.jsonl is curated by randomly sampling 200 samples from DBpedia validation dataset.\\n3. Plot the embeddings of lower dimensionality\",\"type\":\"ipynb\",\"tags\":[\"embeddings\"],\"archived\":true},{\"name\":\"Visualizing_embeddings_in_wandb.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/third_party/Visualizing_embeddings_in_wandb.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/third_party/Visualizing_embeddings_in_wandb.ipynb\",\"internal_path\":\"examples/third_party/visualizing_embeddings_in_wandb\",\"title\":\"Visualizing embeddings in Weights and Biases\",\"path\":\"examples/third_party/Visualizing_embeddings_in_wandb.ipynb\",\"date\":\"2023-02-01\",\"authors\":[{\"login\":\"scottire\"}],\"search_text\":\"We will upload the data to Weights \u0026 Biases and use an Embedding Projector to visualize the embeddings using common dimension reduction algorithms like PCA, UMAP, and t-SNE. The dataset is created in the Get_embeddings_from_dataset Notebook.\\n\\nWeights \u0026 Biases is a machine learning platform used by OpenAI and other ML teams to build better models faster. They use it to quickly track experiments, evaluate model performance, reproduce models, visualize results, and share findings with colleagues.\\n\\nWe create a W\u0026B Table with the original data and the embeddings. Each review is a new row and the 1536 embedding floats are given their own column named emb_{i}.\\nAfter navigating to the W\u0026B run link, we click the ⚙️ icon in the top right of the Table and change \\\"Render As:\\\" to \\\"Combined 2D Projection\\\".\\nExample: http://wandb.me/openai_embeddings\",\"type\":\"ipynb\",\"tags\":[\"embeddings\"],\"archived\":false},{\"name\":\"Visualizing_embeddings_with_Atlas.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/third_party/Visualizing_embeddings_with_Atlas.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/third_party/Visualizing_embeddings_with_Atlas.ipynb\",\"internal_path\":\"examples/third_party/visualizing_embeddings_with_atlas\",\"title\":\"Visualizing embeddings in Atlas\",\"path\":\"examples/third_party/Visualizing_embeddings_with_Atlas.ipynb\",\"date\":\"2023-03-28\",\"authors\":[{\"login\":\"AndriyMulyar\"},{\"login\":\"TDulka\"}],\"search_text\":\"In this example, we will upload food review embeddings to Atlas to visualize the embeddings.\\n\\nAtlas is a machine learning tool used to visualize massive datasets of embeddings in your web browser. Upload millions of embeddings to Atlas and interact with them in your web browser or jupyter notebook.\\n\\n2. Interact with your embeddings in Jupyter\",\"type\":\"ipynb\",\"tags\":[\"embeddings\"],\"archived\":false},{\"name\":\"Whisper_correct_misspelling.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/Whisper_correct_misspelling.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/Whisper_correct_misspelling.ipynb\",\"internal_path\":\"examples/whisper_correct_misspelling\",\"title\":\"Addressing transcription misspellings: prompt vs post-processing\",\"path\":\"examples/Whisper_correct_misspelling.ipynb\",\"date\":\"2023-08-11\",\"authors\":[{\"login\":\"prestontuggle\"}],\"search_text\":\"$6c\",\"type\":\"ipynb\",\"tags\":[\"completions\",\"whisper\"],\"archived\":false},{\"name\":\"Whisper_processing_guide.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/Whisper_processing_guide.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/Whisper_processing_guide.ipynb\",\"internal_path\":\"examples/whisper_processing_guide\",\"title\":\"Enhancing Whisper transcriptions: pre- \u0026 post-processing techniques\",\"path\":\"examples/Whisper_processing_guide.ipynb\",\"date\":\"2023-08-11\",\"authors\":[{\"login\":\"prestontuggle\"}],\"search_text\":\"$6d\",\"type\":\"ipynb\",\"tags\":[\"whisper\"],\"archived\":false},{\"name\":\"Whisper_prompting_guide.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/Whisper_prompting_guide.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/Whisper_prompting_guide.ipynb\",\"internal_path\":\"examples/whisper_prompting_guide\",\"title\":\"Whisper prompting guide\",\"path\":\"examples/Whisper_prompting_guide.ipynb\",\"date\":\"2023-06-27\",\"authors\":[{\"login\":\"prestontuggle\"}],\"search_text\":\"$6e\",\"type\":\"ipynb\",\"tags\":[\"completions\",\"whisper\"],\"archived\":false},{\"name\":\"Zero-shot_classification_with_embeddings.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/Zero-shot_classification_with_embeddings.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/Zero-shot_classification_with_embeddings.ipynb\",\"internal_path\":\"examples/zero-shot_classification_with_embeddings\",\"title\":\"Zero-shot classification with embeddings\",\"path\":\"examples/Zero-shot_classification_with_embeddings.ipynb\",\"date\":\"2022-03-10\",\"authors\":[{\"login\":\"BorisPower\"},{\"name\":\"Ted Sanders\",\"website\":\"https://github.com/ted-at-openai\",\"avatar\":\"https://avatars.githubusercontent.com/u/95656834?v=4\",\"login\":\"ted-at-openai\"},{\"login\":\"logankilpatrick\"}],\"search_text\":\"$6f\",\"type\":\"ipynb\",\"tags\":[\"embeddings\"],\"archived\":true},{\"name\":\"chat.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/azure/chat.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/azure/chat.ipynb\",\"internal_path\":\"examples/azure/chat\",\"title\":\"Azure Chat Completions example (preview)\",\"path\":\"examples/azure/chat.ipynb\",\"date\":\"2023-03-28\",\"authors\":[{\"login\":\"cmurtz-msft\"},{\"login\":\"glecaros\"},{\"login\":\"kristapratico\"}],\"search_text\":\"$70\",\"type\":\"ipynb\",\"tags\":[\"completions\"],\"archived\":false},{\"name\":\"chat_with_your_own_data.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/azure/chat_with_your_own_data.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/azure/chat_with_your_own_data.ipynb\",\"internal_path\":\"examples/azure/chat_with_your_own_data\",\"title\":\"Azure Chat Completion models with your own data (preview)\",\"path\":\"examples/azure/chat_with_your_own_data.ipynb\",\"date\":\"2023-09-11\",\"authors\":[{\"login\":\"kristapratico\"}],\"search_text\":\"$71\",\"type\":\"ipynb\",\"tags\":[\"completions\"],\"archived\":false},{\"name\":\"embeddings.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/azure/embeddings.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/azure/embeddings.ipynb\",\"internal_path\":\"examples/azure/embeddings\",\"title\":\"Azure embeddings example\",\"path\":\"examples/azure/embeddings.ipynb\",\"date\":\"2022-07-12\",\"authors\":[{\"name\":\"Ted Sanders\",\"website\":\"https://github.com/ted-at-openai\",\"avatar\":\"https://avatars.githubusercontent.com/u/95656834?v=4\",\"login\":\"ted-at-openai\"},{\"login\":\"cmurtz-msft\"},{\"login\":\"glecaros\"},{\"login\":\"kristapratico\"}],\"search_text\":\"$72\",\"type\":\"ipynb\",\"tags\":[\"embeddings\"],\"archived\":true},{\"name\":\"functions.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/azure/functions.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/azure/functions.ipynb\",\"internal_path\":\"examples/azure/functions\",\"title\":\"Azure functions example\",\"path\":\"examples/azure/functions.ipynb\",\"date\":\"2023-07-21\",\"authors\":[{\"login\":\"kristapratico\"}],\"search_text\":\"$73\",\"type\":\"ipynb\",\"tags\":[\"completions\",\"functions\"],\"archived\":false},{\"name\":\"translate_latex_book.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/book_translation/translate_latex_book.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/book_translation/translate_latex_book.ipynb\",\"internal_path\":\"examples/book_translation/translate_latex_book\",\"title\":\"Translate a book writen in LaTeX from Slovenian into English\",\"path\":\"examples/book_translation/translate_latex_book.ipynb\",\"date\":\"2022-03-10\",\"authors\":[{\"login\":\"BorisPower\"}],\"search_text\":\"$74\",\"type\":\"ipynb\",\"tags\":[\"completions\",\"tiktoken\"],\"archived\":true},{\"name\":\"How_to_create_dynamic_masks_with_DALL-E_and_Segment_Anything.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/dalle/How_to_create_dynamic_masks_with_DALL-E_and_Segment_Anything.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/dalle/How_to_create_dynamic_masks_with_DALL-E_and_Segment_Anything.ipynb\",\"internal_path\":\"examples/dalle/how_to_create_dynamic_masks_with_dall-e_and_segment_anything\",\"title\":\"How to create dynamic masks with DALL·E and Segment Anything\",\"path\":\"examples/dalle/How_to_create_dynamic_masks_with_DALL-E_and_Segment_Anything.ipynb\",\"date\":\"2023-05-19\",\"authors\":[{\"name\":\"Colin Jarvis\",\"website\":\"https://twitter.com/colintjarvis\",\"avatar\":\"https://pbs.twimg.com/profile_images/1727207339034345472/IM8v8tlC_400x400.jpg\",\"login\":\"colin-openai\"}],\"search_text\":\"$75\",\"type\":\"ipynb\",\"tags\":[\"dall-e\"],\"archived\":false},{\"name\":\"Image_generations_edits_and_variations_with_DALL-E.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/dalle/Image_generations_edits_and_variations_with_DALL-E.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/dalle/Image_generations_edits_and_variations_with_DALL-E.ipynb\",\"internal_path\":\"examples/dalle/image_generations_edits_and_variations_with_dall-e\",\"title\":\"How to use the DALL·E API\",\"path\":\"examples/dalle/Image_generations_edits_and_variations_with_DALL-E.ipynb\",\"date\":\"2022-11-04\",\"authors\":[{\"name\":\"Ted Sanders\",\"website\":\"https://github.com/ted-at-openai\",\"avatar\":\"https://avatars.githubusercontent.com/u/95656834?v=4\",\"login\":\"ted-at-openai\"}],\"search_text\":\"$76\",\"type\":\"ipynb\",\"tags\":[\"dall-e\"],\"archived\":true},{\"name\":\"How_to_eval_abstractive_summarization.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/evaluation/How_to_eval_abstractive_summarization.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/evaluation/How_to_eval_abstractive_summarization.ipynb\",\"internal_path\":\"examples/evaluation/how_to_eval_abstractive_summarization\",\"title\":\"How to evaluate a summarization task\",\"path\":\"examples/evaluation/How_to_eval_abstractive_summarization.ipynb\",\"date\":\"2023-08-16\",\"authors\":[{\"name\":\"Shyamal Anadkat\",\"website\":\"https://twitter.com/shyamalanadkat\",\"avatar\":\"https://pbs.twimg.com/profile_images/1590564338682560512/3bbZJqxZ_400x400.jpg\",\"login\":\"shyamal-anadkat\"},{\"name\":\"Simón Fishman\",\"website\":\"https://twitter.com/simonpfish\",\"avatar\":\"https://pbs.twimg.com/profile_images/1687643030243901441/61DpxNfc_400x400.jpg\",\"login\":\"simonpfish\"}],\"search_text\":\"$77\",\"type\":\"ipynb\",\"tags\":[\"completions\",\"embeddings\"],\"archived\":false},{\"name\":\"Getting_Started_with_OpenAI_Evals.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/evaluation/Getting_Started_with_OpenAI_Evals.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/evaluation/Getting_Started_with_OpenAI_Evals.ipynb\",\"internal_path\":\"examples/evaluation/getting_started_with_openai_evals\",\"title\":\"Getting Started with OpenAI Evals\",\"path\":\"examples/evaluation/Getting_Started_with_OpenAI_Evals.ipynb\",\"date\":\"2024-03-21\",\"authors\":[{\"name\":\"Roy Ziv\",\"website\":\"https://www.linkedin.com/in/roy-ziv-a46001149/\",\"avatar\":\"https://avatars.githubusercontent.com/u/103690170?v=4\",\"login\":\"royziv11\"},{\"name\":\"Shyamal Anadkat\",\"website\":\"https://twitter.com/shyamalanadkat\",\"avatar\":\"https://pbs.twimg.com/profile_images/1590564338682560512/3bbZJqxZ_400x400.jpg\",\"login\":\"shyamal-anadkat\"}],\"search_text\":\"$78\",\"type\":\"ipynb\",\"tags\":[\"completions\"],\"archived\":false},{\"name\":\"Developing_hallucination_guardrails.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/Developing_hallucination_guardrails.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/Developing_hallucination_guardrails.ipynb\",\"internal_path\":\"examples/developing_hallucination_guardrails\",\"title\":\"Developing Hallucination Guardrails\",\"path\":\"examples/Developing_hallucination_guardrails.ipynb\",\"date\":\"2024-05-29\",\"authors\":[{\"name\":\"Roy Ziv\",\"website\":\"https://www.linkedin.com/in/roy-ziv-a46001149/\",\"avatar\":\"https://avatars.githubusercontent.com/u/103690170?v=4\",\"login\":\"royziv11\"}],\"search_text\":\"$79\",\"type\":\"ipynb\",\"tags\":[\"guardrails\"],\"archived\":false},{\"name\":\"olympics-1-collect-data.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/fine-tuned_qa/olympics-1-collect-data.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/fine-tuned_qa/olympics-1-collect-data.ipynb\",\"internal_path\":\"examples/fine-tuned_qa/olympics-1-collect-data\",\"title\":\"Fine-Tuned Q\u0026A - collect data\",\"path\":\"examples/fine-tuned_qa/olympics-1-collect-data.ipynb\",\"date\":\"2022-03-10\",\"authors\":[{\"name\":\"Ted Sanders\",\"website\":\"https://github.com/ted-at-openai\",\"avatar\":\"https://avatars.githubusercontent.com/u/95656834?v=4\",\"login\":\"ted-at-openai\"},{\"login\":\"BorisPower\"}],\"search_text\":\"$7a\",\"type\":\"ipynb\",\"tags\":[\"completions\",\"embeddings\",\"fine-tuning\"],\"archived\":true},{\"name\":\"olympics-2-create-qa.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/fine-tuned_qa/olympics-2-create-qa.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/fine-tuned_qa/olympics-2-create-qa.ipynb\",\"internal_path\":\"examples/fine-tuned_qa/olympics-2-create-qa\",\"title\":\"Fine-Tuned Q\u0026A - create Q\u0026A\",\"path\":\"examples/fine-tuned_qa/olympics-2-create-qa.ipynb\",\"date\":\"2022-03-10\",\"authors\":[{\"name\":\"Ted Sanders\",\"website\":\"https://github.com/ted-at-openai\",\"avatar\":\"https://avatars.githubusercontent.com/u/95656834?v=4\",\"login\":\"ted-at-openai\"},{\"login\":\"BorisPower\"}],\"search_text\":\"$7b\",\"type\":\"ipynb\",\"tags\":[\"completions\",\"embeddings\",\"fine-tuning\"],\"archived\":true},{\"name\":\"olympics-3-train-qa.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/fine-tuned_qa/olympics-3-train-qa.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/fine-tuned_qa/olympics-3-train-qa.ipynb\",\"internal_path\":\"examples/fine-tuned_qa/olympics-3-train-qa\",\"title\":\"Fine-Tuned Q\u0026A - train\",\"path\":\"examples/fine-tuned_qa/olympics-3-train-qa.ipynb\",\"date\":\"2022-03-10\",\"authors\":[{\"name\":\"Ted Sanders\",\"website\":\"https://github.com/ted-at-openai\",\"avatar\":\"https://avatars.githubusercontent.com/u/95656834?v=4\",\"login\":\"ted-at-openai\"},{\"login\":\"BorisPower\"}],\"search_text\":\"$7c\",\"type\":\"ipynb\",\"tags\":[\"completions\",\"embeddings\",\"fine-tuning\"],\"archived\":true},{\"name\":\"Visualizing_embeddings_in_Kangas.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/third_party/Visualizing_embeddings_in_Kangas.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/third_party/Visualizing_embeddings_in_Kangas.ipynb\",\"internal_path\":\"examples/third_party/visualizing_embeddings_in_kangas\",\"title\":\"Visualizing the embeddings in Kangas\",\"path\":\"examples/third_party/Visualizing_embeddings_in_Kangas.ipynb\",\"date\":\"2023-07-11\",\"authors\":[{\"login\":\"dsblank\"}],\"search_text\":\"$7d\",\"type\":\"ipynb\",\"tags\":[\"embeddings\"],\"archived\":false},{\"name\":\"financial_document_analysis_with_llamaindex.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/third_party/financial_document_analysis_with_llamaindex.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/third_party/financial_document_analysis_with_llamaindex.ipynb\",\"internal_path\":\"examples/third_party/financial_document_analysis_with_llamaindex\",\"title\":\"Financial document analysis with LlamaIndex\",\"path\":\"examples/third_party/financial_document_analysis_with_llamaindex.ipynb\",\"date\":\"2023-06-22\",\"authors\":[{\"login\":\"Disiok\"}],\"search_text\":\"$7e\",\"type\":\"ipynb\",\"tags\":[\"completions\",\"embeddings\"],\"archived\":false},{\"name\":\"README.md\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/vector_databases/README.md\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/vector_databases/README.md\",\"internal_path\":\"examples/vector_databases/readme\",\"title\":\"Vector databases\",\"path\":\"examples/vector_databases/README.md\",\"date\":\"2023-06-28\",\"authors\":[{\"name\":\"Colin Jarvis\",\"website\":\"https://twitter.com/colintjarvis\",\"avatar\":\"https://pbs.twimg.com/profile_images/1727207339034345472/IM8v8tlC_400x400.jpg\",\"login\":\"colin-openai\"},{\"login\":\"moizsajid\"}],\"search_text\":\"This section of the OpenAI Cookbook showcases many of the vector databases available to support your semantic search use cases.\\n\\nVector databases can be a great accompaniment for knowledge retrieval applications, which reduce hallucinations by providing the LLM with the relevant context to answer questions.\\n\\nEach provider has their own named directory, with a standard notebook to introduce you to using our API with their product, and any supplementary notebooks they choose to add to showcase their functionality.\\n\\nAnalyticDB\\nCassandra/Astra DB\\nAzure AI Search\\nAzure SQL Database\\nChroma\\nElasticsearch\\nHologres\\nKusto\\nMilvus\\nMyScale\\nMongoDB\\nNeon Postgres\\nPinecone\\nPolarDB\\nQdrant\\nRedis\\nSingleStoreDB\\nSupabase\\nTembo\\nTypesense\\nVespa AI\\nWeaviate\\nZilliz\",\"type\":\"md\",\"tags\":[\"embeddings\"],\"archived\":false},{\"name\":\"Getting_started_with_PolarDB_and_OpenAI.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/vector_databases/PolarDB/Getting_started_with_PolarDB_and_OpenAI.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/vector_databases/PolarDB/Getting_started_with_PolarDB_and_OpenAI.ipynb\",\"internal_path\":\"examples/vector_databases/polardb/getting_started_with_polardb_and_openai\",\"title\":\"Using PolarDB-PG as a vector database for OpenAI embeddings\",\"path\":\"examples/vector_databases/PolarDB/Getting_started_with_PolarDB_and_OpenAI.ipynb\",\"date\":\"2023-07-11\",\"authors\":[{\"login\":\"liuchengshan-lcs\"}],\"search_text\":\"$7f\",\"type\":\"ipynb\",\"tags\":[\"embeddings\"],\"archived\":false},{\"name\":\"OpenAI_wikipedia_semantic_search.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/vector_databases/SingleStoreDB/OpenAI_wikipedia_semantic_search.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/vector_databases/SingleStoreDB/OpenAI_wikipedia_semantic_search.ipynb\",\"internal_path\":\"examples/vector_databases/singlestoredb/openai_wikipedia_semantic_search\",\"title\":\"Semantic search with SingleStoreDB\",\"path\":\"examples/vector_databases/SingleStoreDB/OpenAI_wikipedia_semantic_search.ipynb\",\"date\":\"2023-05-22\",\"authors\":[{\"login\":\"arno756\"}],\"search_text\":\"This notebook is an example on how you can use SingleStoreDB vector storage and functions to build an interactive Q\u0026A application with ChatGPT. If you start a Trial in SingleStoreDB, you can find the same notebook in our sample notebooks with native connection.\\n\\n6. Get an answer from Chat GPT\",\"type\":\"ipynb\",\"tags\":[\"completions\",\"embeddings\"],\"archived\":false},{\"name\":\"README.md\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/vector_databases/SingleStoreDB/README.md\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/vector_databases/SingleStoreDB/README.md\",\"internal_path\":\"examples/vector_databases/singlestoredb/readme\",\"title\":\"SingleStoreDB\",\"path\":\"examples/vector_databases/SingleStoreDB/README.md\",\"date\":\"2023-05-22\",\"authors\":[{\"login\":\"arno756\"}],\"search_text\":\"$80\",\"type\":\"md\",\"tags\":[\"completions\",\"embeddings\"],\"archived\":false},{\"name\":\"Getting_started_with_AnalyticDB_and_OpenAI.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/vector_databases/analyticdb/Getting_started_with_AnalyticDB_and_OpenAI.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/vector_databases/analyticdb/Getting_started_with_AnalyticDB_and_OpenAI.ipynb\",\"internal_path\":\"examples/vector_databases/analyticdb/getting_started_with_analyticdb_and_openai\",\"title\":\"Using AnalyticDB as a vector database for OpenAI embeddings\",\"path\":\"examples/vector_databases/analyticdb/Getting_started_with_AnalyticDB_and_OpenAI.ipynb\",\"date\":\"2023-04-06\",\"authors\":[{\"login\":\"wangxuqi\"}],\"search_text\":\"$81\",\"type\":\"ipynb\",\"tags\":[\"embeddings\"],\"archived\":false},{\"name\":\"QA_with_Langchain_AnalyticDB_and_OpenAI.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/vector_databases/analyticdb/QA_with_Langchain_AnalyticDB_and_OpenAI.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/vector_databases/analyticdb/QA_with_Langchain_AnalyticDB_and_OpenAI.ipynb\",\"internal_path\":\"examples/vector_databases/analyticdb/qa_with_langchain_analyticdb_and_openai\",\"title\":\"Question answering with Langchain, AnalyticDB and OpenAI\",\"path\":\"examples/vector_databases/analyticdb/QA_with_Langchain_AnalyticDB_and_OpenAI.ipynb\",\"date\":\"2023-05-05\",\"authors\":[{\"login\":\"wangxuqi\"}],\"search_text\":\"$82\",\"type\":\"ipynb\",\"tags\":[\"embeddings\",\"tiktoken\"],\"archived\":false},{\"name\":\"Getting_started_with_azure_ai_search_and_openai.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/vector_databases/azuresearch/Getting_started_with_azure_ai_search_and_openai.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/vector_databases/azuresearch/Getting_started_with_azure_ai_search_and_openai.ipynb\",\"internal_path\":\"examples/vector_databases/azuresearch/getting_started_with_azure_ai_search_and_openai\",\"title\":\"Azure AI Search as a vector database for OpenAI embeddings\",\"path\":\"examples/vector_databases/azuresearch/Getting_started_with_azure_ai_search_and_openai.ipynb\",\"date\":\"2023-09-11\",\"authors\":[{\"login\":\"farzad528\"}],\"search_text\":\"$83\",\"type\":\"ipynb\",\"tags\":[\"embeddings\"],\"archived\":false},{\"name\":\"Philosophical_Quotes_CQL.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/vector_databases/cassandra_astradb/Philosophical_Quotes_CQL.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/vector_databases/cassandra_astradb/Philosophical_Quotes_CQL.ipynb\",\"internal_path\":\"examples/vector_databases/cassandra_astradb/philosophical_quotes_cql\",\"title\":\"Philosophy with vector embeddings, OpenAI and Cassandra / Astra DB\",\"path\":\"examples/vector_databases/cassandra_astradb/Philosophical_Quotes_CQL.ipynb\",\"date\":\"2023-08-29\",\"authors\":[{\"login\":\"hemidactylus\"}],\"search_text\":\"$84\",\"type\":\"ipynb\",\"tags\":[\"completions\",\"embeddings\"],\"archived\":false},{\"name\":\"Philosophical_Quotes_cassIO.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/vector_databases/cassandra_astradb/Philosophical_Quotes_cassIO.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/vector_databases/cassandra_astradb/Philosophical_Quotes_cassIO.ipynb\",\"internal_path\":\"examples/vector_databases/cassandra_astradb/philosophical_quotes_cassio\",\"title\":\"Philosophy with vector embeddings, OpenAI and Cassandra / Astra DB\",\"path\":\"examples/vector_databases/cassandra_astradb/Philosophical_Quotes_cassIO.ipynb\",\"date\":\"2023-08-29\",\"authors\":[{\"login\":\"hemidactylus\"}],\"search_text\":\"$85\",\"type\":\"ipynb\",\"tags\":[\"completions\",\"embeddings\"],\"archived\":false},{\"name\":\"README.md\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/vector_databases/cassandra_astradb/README.md\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/vector_databases/cassandra_astradb/README.md\",\"internal_path\":\"examples/vector_databases/cassandra_astradb/readme\",\"title\":\"Cassandra / Astra DB\",\"path\":\"examples/vector_databases/cassandra_astradb/README.md\",\"date\":\"2023-08-29\",\"authors\":[{\"login\":\"hemidactylus\"}],\"search_text\":\"$86\",\"type\":\"md\",\"tags\":[\"embeddings\"],\"archived\":false},{\"name\":\"Using_Chroma_for_embeddings_search.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/vector_databases/chroma/Using_Chroma_for_embeddings_search.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/vector_databases/chroma/Using_Chroma_for_embeddings_search.ipynb\",\"internal_path\":\"examples/vector_databases/chroma/using_chroma_for_embeddings_search\",\"title\":\"Using Chroma for embeddings search\",\"path\":\"examples/vector_databases/chroma/Using_Chroma_for_embeddings_search.ipynb\",\"date\":\"2023-06-28\",\"authors\":[{\"name\":\"Colin Jarvis\",\"website\":\"https://twitter.com/colintjarvis\",\"avatar\":\"https://pbs.twimg.com/profile_images/1727207339034345472/IM8v8tlC_400x400.jpg\",\"login\":\"colin-openai\"},{\"login\":\"atroyn\"}],\"search_text\":\"$87\",\"type\":\"ipynb\",\"tags\":[\"embeddings\"],\"archived\":false},{\"name\":\"hyde-with-chroma-and-openai.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/vector_databases/chroma/hyde-with-chroma-and-openai.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/vector_databases/chroma/hyde-with-chroma-and-openai.ipynb\",\"internal_path\":\"examples/vector_databases/chroma/hyde-with-chroma-and-openai\",\"title\":\"Robust question answering with Chroma and OpenAI\",\"path\":\"examples/vector_databases/chroma/hyde-with-chroma-and-openai.ipynb\",\"date\":\"2025-04-23\",\"authors\":[{\"login\":\"atroyn\"},{\"name\":\"Brandon Baker\",\"website\":\"https://www.linkedin.com/in/brandonbaker18\",\"avatar\":\"https://avatars.githubusercontent.com/u/208719822\",\"login\":\"brandonbaker-openai\"}],\"search_text\":\"$88\",\"type\":\"ipynb\",\"tags\":[\"completions\",\"embeddings\"],\"archived\":false},{\"name\":\"README.md\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/vector_databases/elasticsearch/README.md\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/vector_databases/elasticsearch/README.md\",\"internal_path\":\"examples/vector_databases/elasticsearch/readme\",\"title\":\"Elasticsearch\",\"path\":\"examples/vector_databases/elasticsearch/README.md\",\"date\":\"2023-08-29\",\"authors\":[{\"login\":\"leemthompo\"}],\"search_text\":\"Elasticsearch is a popular search/analytics engine and vector database.\\nElasticsearch offers an efficient way to create, store, and search vector embeddings at scale.\\n\\nFor technical details, refer to the Elasticsearch documentation.\\n\\nThe elasticsearch-labs repo contains executable Python notebooks, sample apps, and resources for testing out the Elastic platform.\\n\\n\\nCheck out our notebooks in this repo for working with OpenAI, using Elasticsearch as your vector database.\\n\\n\\nIn this notebook you'll learn how to:\\n\\n Index the OpenAI Wikipedia embeddings dataset into Elasticsearch\\n Encode a question with the openai ada-02 model\\n Perform a semantic search\\n\\n\\n\\n\\n\\nThis notebooks builds on the semantic search notebook by:\\n\\nSelecting the top hit from a semantic search\\nSending that result to the OpenAI Chat Completions API endpoint for retrieval augmented generation (RAG)\",\"type\":\"md\",\"tags\":[\"completions\",\"embeddings\"],\"archived\":false},{\"name\":\"elasticsearch-retrieval-augmented-generation.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/vector_databases/elasticsearch/elasticsearch-retrieval-augmented-generation.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/vector_databases/elasticsearch/elasticsearch-retrieval-augmented-generation.ipynb\",\"internal_path\":\"examples/vector_databases/elasticsearch/elasticsearch-retrieval-augmented-generation\",\"title\":\"Retrieval augmented generation using Elasticsearch and OpenAI\",\"path\":\"examples/vector_databases/elasticsearch/elasticsearch-retrieval-augmented-generation.ipynb\",\"date\":\"2023-08-29\",\"authors\":[{\"login\":\"leemthompo\"}],\"search_text\":\"$89\",\"type\":\"ipynb\",\"tags\":[\"completions\",\"embeddings\"],\"archived\":false},{\"name\":\"elasticsearch-semantic-search.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/vector_databases/elasticsearch/elasticsearch-semantic-search.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/vector_databases/elasticsearch/elasticsearch-semantic-search.ipynb\",\"internal_path\":\"examples/vector_databases/elasticsearch/elasticsearch-semantic-search\",\"title\":\"Semantic search using Elasticsearch and OpenAI\",\"path\":\"examples/vector_databases/elasticsearch/elasticsearch-semantic-search.ipynb\",\"date\":\"2023-08-29\",\"authors\":[{\"login\":\"leemthompo\"}],\"search_text\":\"$8a\",\"type\":\"ipynb\",\"tags\":[\"embeddings\"],\"archived\":false},{\"name\":\"Getting_started_with_Hologres_and_OpenAI.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/vector_databases/hologres/Getting_started_with_Hologres_and_OpenAI.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/vector_databases/hologres/Getting_started_with_Hologres_and_OpenAI.ipynb\",\"internal_path\":\"examples/vector_databases/hologres/getting_started_with_hologres_and_openai\",\"title\":\"Using Hologres as a vector database for OpenAI embeddings\",\"path\":\"examples/vector_databases/hologres/Getting_started_with_Hologres_and_OpenAI.ipynb\",\"date\":\"2023-05-19\",\"authors\":[{\"login\":\"zcgeng\"}],\"search_text\":\"$8b\",\"type\":\"ipynb\",\"tags\":[\"embeddings\"],\"archived\":false},{\"name\":\"Getting_started_with_kusto_and_openai_embeddings.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/vector_databases/kusto/Getting_started_with_kusto_and_openai_embeddings.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/vector_databases/kusto/Getting_started_with_kusto_and_openai_embeddings.ipynb\",\"internal_path\":\"examples/vector_databases/kusto/getting_started_with_kusto_and_openai_embeddings\",\"title\":\"Kusto as a vector database for embeddings\",\"path\":\"examples/vector_databases/kusto/Getting_started_with_kusto_and_openai_embeddings.ipynb\",\"date\":\"2023-05-10\",\"authors\":[{\"login\":\"Anshul Sharma\"}],\"search_text\":\"$8c\",\"type\":\"ipynb\",\"tags\":[\"embeddings\"],\"archived\":false},{\"name\":\"README.md\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/vector_databases/kusto/README.md\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/vector_databases/kusto/README.md\",\"internal_path\":\"examples/vector_databases/kusto/readme\",\"title\":\"Kusto as a vector database\",\"path\":\"examples/vector_databases/kusto/README.md\",\"date\":\"2023-05-10\",\"authors\":[{\"login\":\"Anshul Sharma\"}],\"search_text\":\"$8d\",\"type\":\"md\",\"tags\":[\"embeddings\"],\"archived\":false},{\"name\":\"Filtered_search_with_Milvus_and_OpenAI.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/vector_databases/milvus/Filtered_search_with_Milvus_and_OpenAI.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/vector_databases/milvus/Filtered_search_with_Milvus_and_OpenAI.ipynb\",\"internal_path\":\"examples/vector_databases/milvus/filtered_search_with_milvus_and_openai\",\"title\":\"Filtered search with Milvus and OpenAI\",\"path\":\"examples/vector_databases/milvus/Filtered_search_with_Milvus_and_OpenAI.ipynb\",\"date\":\"2023-03-28\",\"authors\":[{\"login\":\"filip-halt\"}],\"search_text\":\"$8e\",\"type\":\"ipynb\",\"tags\":[\"embeddings\"],\"archived\":false},{\"name\":\"Getting_started_with_Milvus_and_OpenAI.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/vector_databases/milvus/Getting_started_with_Milvus_and_OpenAI.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/vector_databases/milvus/Getting_started_with_Milvus_and_OpenAI.ipynb\",\"internal_path\":\"examples/vector_databases/milvus/getting_started_with_milvus_and_openai\",\"title\":\"Getting started with Milvus and OpenAI\",\"path\":\"examples/vector_databases/milvus/Getting_started_with_Milvus_and_OpenAI.ipynb\",\"date\":\"2023-03-28\",\"authors\":[{\"login\":\"filip-halt\"}],\"search_text\":\"$8f\",\"type\":\"ipynb\",\"tags\":[\"embeddings\"],\"archived\":false},{\"name\":\"Getting_started_with_MyScale_and_OpenAI.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/vector_databases/myscale/Getting_started_with_MyScale_and_OpenAI.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/vector_databases/myscale/Getting_started_with_MyScale_and_OpenAI.ipynb\",\"internal_path\":\"examples/vector_databases/myscale/getting_started_with_myscale_and_openai\",\"title\":\"Using MyScale as a vector database for OpenAI embeddings\",\"path\":\"examples/vector_databases/myscale/Getting_started_with_MyScale_and_OpenAI.ipynb\",\"date\":\"2023-05-01\",\"authors\":[{\"login\":\"melovy\"}],\"search_text\":\"$90\",\"type\":\"ipynb\",\"tags\":[\"embeddings\"],\"archived\":false},{\"name\":\"Using_MyScale_for_embeddings_search.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/vector_databases/myscale/Using_MyScale_for_embeddings_search.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/vector_databases/myscale/Using_MyScale_for_embeddings_search.ipynb\",\"internal_path\":\"examples/vector_databases/myscale/using_myscale_for_embeddings_search\",\"title\":\"Using MyScale for embeddings search\",\"path\":\"examples/vector_databases/myscale/Using_MyScale_for_embeddings_search.ipynb\",\"date\":\"2023-06-28\",\"authors\":[{\"name\":\"Colin Jarvis\",\"website\":\"https://twitter.com/colintjarvis\",\"avatar\":\"https://pbs.twimg.com/profile_images/1727207339034345472/IM8v8tlC_400x400.jpg\",\"login\":\"colin-openai\"}],\"search_text\":\"$91\",\"type\":\"ipynb\",\"tags\":[\"embeddings\"],\"archived\":false},{\"name\":\"GPT4_Retrieval_Augmentation.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/vector_databases/pinecone/GPT4_Retrieval_Augmentation.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/vector_databases/pinecone/GPT4_Retrieval_Augmentation.ipynb\",\"internal_path\":\"examples/vector_databases/pinecone/gpt4_retrieval_augmentation\",\"title\":\"Retrieval augmentation for GPT-4 using Pinecone\",\"path\":\"examples/vector_databases/pinecone/GPT4_Retrieval_Augmentation.ipynb\",\"date\":\"2023-03-24\",\"authors\":[{\"login\":\"jamescalam\"}],\"search_text\":\"$92\",\"type\":\"ipynb\",\"tags\":[\"completions\",\"embeddings\",\"tiktoken\"],\"archived\":false},{\"name\":\"Gen_QA.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/vector_databases/pinecone/Gen_QA.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/vector_databases/pinecone/Gen_QA.ipynb\",\"internal_path\":\"examples/vector_databases/pinecone/gen_qa\",\"title\":\"Retrieval augmented generative question answering with Pinecone\",\"path\":\"examples/vector_databases/pinecone/Gen_QA.ipynb\",\"date\":\"2023-02-07\",\"authors\":[{\"login\":\"jamescalam\"}],\"search_text\":\"$93\",\"type\":\"ipynb\",\"tags\":[\"completions\",\"embeddings\"],\"archived\":false},{\"name\":\"README.md\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/vector_databases/pinecone/README.md\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/vector_databases/pinecone/README.md\",\"internal_path\":\"examples/vector_databases/pinecone/readme\",\"title\":\"Pinecone vector database\",\"path\":\"examples/vector_databases/pinecone/README.md\",\"date\":\"2023-03-24\",\"authors\":[{\"login\":\"jamescalam\"}],\"search_text\":\"$94\",\"type\":\"md\",\"tags\":[\"completions\",\"embeddings\"],\"archived\":false},{\"name\":\"Semantic_Search.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/vector_databases/pinecone/Semantic_Search.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/vector_databases/pinecone/Semantic_Search.ipynb\",\"internal_path\":\"examples/vector_databases/pinecone/semantic_search\",\"title\":\"Semantic search with Pinecone and OpenAI\",\"path\":\"examples/vector_databases/pinecone/Semantic_Search.ipynb\",\"date\":\"2023-03-24\",\"authors\":[{\"login\":\"jamescalam\"}],\"search_text\":\"$95\",\"type\":\"ipynb\",\"tags\":[\"embeddings\"],\"archived\":false},{\"name\":\"Using_Pinecone_for_embeddings_search.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/vector_databases/pinecone/Using_Pinecone_for_embeddings_search.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/vector_databases/pinecone/Using_Pinecone_for_embeddings_search.ipynb\",\"internal_path\":\"examples/vector_databases/pinecone/using_pinecone_for_embeddings_search\",\"title\":\"Using Pinecone for embeddings search\",\"path\":\"examples/vector_databases/pinecone/Using_Pinecone_for_embeddings_search.ipynb\",\"date\":\"2023-06-28\",\"authors\":[{\"name\":\"Colin Jarvis\",\"website\":\"https://twitter.com/colintjarvis\",\"avatar\":\"https://pbs.twimg.com/profile_images/1727207339034345472/IM8v8tlC_400x400.jpg\",\"login\":\"colin-openai\"}],\"search_text\":\"$96\",\"type\":\"ipynb\",\"tags\":[\"embeddings\"],\"archived\":false},{\"name\":\"Getting_started_with_Qdrant_and_OpenAI.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/vector_databases/qdrant/Getting_started_with_Qdrant_and_OpenAI.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/vector_databases/qdrant/Getting_started_with_Qdrant_and_OpenAI.ipynb\",\"internal_path\":\"examples/vector_databases/qdrant/getting_started_with_qdrant_and_openai\",\"title\":\"Using Qdrant as a vector database for OpenAI embeddings\",\"path\":\"examples/vector_databases/qdrant/Getting_started_with_Qdrant_and_OpenAI.ipynb\",\"date\":\"2023-02-16\",\"authors\":[{\"login\":\"kacperlukawski\"}],\"search_text\":\"$97\",\"type\":\"ipynb\",\"tags\":[\"embeddings\"],\"archived\":false},{\"name\":\"QA_with_Langchain_Qdrant_and_OpenAI.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/vector_databases/qdrant/QA_with_Langchain_Qdrant_and_OpenAI.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/vector_databases/qdrant/QA_with_Langchain_Qdrant_and_OpenAI.ipynb\",\"internal_path\":\"examples/vector_databases/qdrant/qa_with_langchain_qdrant_and_openai\",\"title\":\"Question answering with Langchain, Qdrant and OpenAI\",\"path\":\"examples/vector_databases/qdrant/QA_with_Langchain_Qdrant_and_OpenAI.ipynb\",\"date\":\"2023-02-16\",\"authors\":[{\"login\":\"kacperlukawski\"}],\"search_text\":\"$98\",\"type\":\"ipynb\",\"tags\":[\"embeddings\"],\"archived\":false},{\"name\":\"Using_Qdrant_for_embeddings_search.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/vector_databases/qdrant/Using_Qdrant_for_embeddings_search.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/vector_databases/qdrant/Using_Qdrant_for_embeddings_search.ipynb\",\"internal_path\":\"examples/vector_databases/qdrant/using_qdrant_for_embeddings_search\",\"title\":\"Using Qdrant for embeddings search\",\"path\":\"examples/vector_databases/qdrant/Using_Qdrant_for_embeddings_search.ipynb\",\"date\":\"2023-06-28\",\"authors\":[{\"name\":\"Colin Jarvis\",\"website\":\"https://twitter.com/colintjarvis\",\"avatar\":\"https://pbs.twimg.com/profile_images/1727207339034345472/IM8v8tlC_400x400.jpg\",\"login\":\"colin-openai\"},{\"login\":\"kacperlukawski\"}],\"search_text\":\"$99\",\"type\":\"ipynb\",\"tags\":[\"embeddings\"],\"archived\":false},{\"name\":\"README.md\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/vector_databases/redis/README.md\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/vector_databases/redis/README.md\",\"internal_path\":\"examples/vector_databases/redis/readme\",\"title\":\"Redis\",\"path\":\"examples/vector_databases/redis/README.md\",\"date\":\"2023-02-13\",\"authors\":[{\"login\":\"Spartee\"}],\"search_text\":\"$9a\",\"type\":\"md\",\"tags\":[\"completions\",\"embeddings\"],\"archived\":false},{\"name\":\"Using_Redis_for_embeddings_search.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/vector_databases/redis/Using_Redis_for_embeddings_search.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/vector_databases/redis/Using_Redis_for_embeddings_search.ipynb\",\"internal_path\":\"examples/vector_databases/redis/using_redis_for_embeddings_search\",\"title\":\"Using Redis for embeddings search\",\"path\":\"examples/vector_databases/redis/Using_Redis_for_embeddings_search.ipynb\",\"date\":\"2023-06-28\",\"authors\":[{\"name\":\"Colin Jarvis\",\"website\":\"https://twitter.com/colintjarvis\",\"avatar\":\"https://pbs.twimg.com/profile_images/1727207339034345472/IM8v8tlC_400x400.jpg\",\"login\":\"colin-openai\"}],\"search_text\":\"$9b\",\"type\":\"ipynb\",\"tags\":[\"embeddings\"],\"archived\":false},{\"name\":\"getting-started-with-redis-and-openai.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/vector_databases/redis/getting-started-with-redis-and-openai.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/vector_databases/redis/getting-started-with-redis-and-openai.ipynb\",\"internal_path\":\"examples/vector_databases/redis/getting-started-with-redis-and-openai\",\"title\":\"Using Redis as a vector database with OpenAI\",\"path\":\"examples/vector_databases/redis/getting-started-with-redis-and-openai.ipynb\",\"date\":\"2023-02-13\",\"authors\":[{\"login\":\"Spartee\"}],\"search_text\":\"$9c\",\"type\":\"ipynb\",\"tags\":[\"embeddings\"],\"archived\":false},{\"name\":\"redis-hybrid-query-examples.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/vector_databases/redis/redis-hybrid-query-examples.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/vector_databases/redis/redis-hybrid-query-examples.ipynb\",\"internal_path\":\"examples/vector_databases/redis/redis-hybrid-query-examples\",\"title\":\"Running hybrid VSS queries with Redis and OpenAI\",\"path\":\"examples/vector_databases/redis/redis-hybrid-query-examples.ipynb\",\"date\":\"2023-05-11\",\"authors\":[{\"login\":\"Michael Yuan\"}],\"search_text\":\"$9d\",\"type\":\"ipynb\",\"tags\":[\"embeddings\"],\"archived\":false},{\"name\":\"redisjson.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/vector_databases/redis/redisjson/redisjson.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/vector_databases/redis/redisjson/redisjson.ipynb\",\"internal_path\":\"examples/vector_databases/redis/redisjson/redisjson\",\"title\":\"Redis vectors as JSON with OpenAI\",\"path\":\"examples/vector_databases/redis/redisjson/redisjson.ipynb\",\"date\":\"2023-05-10\",\"authors\":[{\"login\":\"Michael Yuan\"}],\"search_text\":\"This notebook expands on the other Redis OpenAI-cookbook examples with examples of how to use JSON with vectors.\\nStoring Vectors in JSON\\n\\nRedis instance with the Redis Search and Redis JSON modules\\nRedis-py client lib\\nOpenAI API key\\n\\nInstall Python modules necessary for the examples.\\nCreate a .env file and add your OpenAI key to it\\nCreate embeddings (array of floats) of the news excerpts below.\\nFT.CREATE\\nRedis JSON\\nGiven a sports-related article, search Redis via Vector Similarity Search (VSS) for similar articles.\\nKNN Search\\nUse a combination of full text search and VSS to find a matching article.  For this scenario, we filter on a full text search of the term 'recession' and then find the KNN articles.  In this case, business-related.  Reminder document #1 was about a recession in Japan.\\nHybrid Queries\",\"type\":\"ipynb\",\"tags\":[\"embeddings\"],\"archived\":false},{\"name\":\"redisqna.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/vector_databases/redis/redisqna/redisqna.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/vector_databases/redis/redisqna/redisqna.ipynb\",\"internal_path\":\"examples/vector_databases/redis/redisqna/redisqna\",\"title\":\"Redis as a context store with Chat Completions\",\"path\":\"examples/vector_databases/redis/redisqna/redisqna.ipynb\",\"date\":\"2023-05-11\",\"authors\":[{\"login\":\"Michael Yuan\"}],\"search_text\":\"$9e\",\"type\":\"ipynb\",\"tags\":[\"completions\",\"embeddings\"],\"archived\":false},{\"name\":\"Getting_started_with_Tair_and_OpenAI.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/vector_databases/tair/Getting_started_with_Tair_and_OpenAI.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/vector_databases/tair/Getting_started_with_Tair_and_OpenAI.ipynb\",\"internal_path\":\"examples/vector_databases/tair/getting_started_with_tair_and_openai\",\"title\":\"Using Tair as a vector database for OpenAI embeddings\",\"path\":\"examples/vector_databases/tair/Getting_started_with_Tair_and_OpenAI.ipynb\",\"date\":\"2023-09-11\",\"authors\":[{\"login\":\"dongqqcom\"}],\"search_text\":\"$9f\",\"type\":\"ipynb\",\"tags\":[\"embeddings\"],\"archived\":false},{\"name\":\"QA_with_Langchain_Tair_and_OpenAI.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/vector_databases/tair/QA_with_Langchain_Tair_and_OpenAI.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/vector_databases/tair/QA_with_Langchain_Tair_and_OpenAI.ipynb\",\"internal_path\":\"examples/vector_databases/tair/qa_with_langchain_tair_and_openai\",\"title\":\"Question answering with Langchain, Tair and OpenAI\",\"path\":\"examples/vector_databases/tair/QA_with_Langchain_Tair_and_OpenAI.ipynb\",\"date\":\"2023-09-11\",\"authors\":[{\"login\":\"dongqqcom\"}],\"search_text\":\"$a0\",\"type\":\"ipynb\",\"tags\":[\"completions\",\"embeddings\",\"tiktoken\"],\"archived\":false},{\"name\":\"README.md\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/vector_databases/typesense/README.md\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/vector_databases/typesense/README.md\",\"internal_path\":\"examples/vector_databases/typesense/readme\",\"title\":\"Typesense\",\"path\":\"examples/vector_databases/typesense/README.md\",\"date\":\"2023-04-13\",\"authors\":[{\"login\":\"jasonbosco\"}],\"search_text\":\"$a1\",\"type\":\"md\",\"tags\":[\"embeddings\"],\"archived\":false},{\"name\":\"Using_Typesense_for_embeddings_search.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/vector_databases/typesense/Using_Typesense_for_embeddings_search.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/vector_databases/typesense/Using_Typesense_for_embeddings_search.ipynb\",\"internal_path\":\"examples/vector_databases/typesense/using_typesense_for_embeddings_search\",\"title\":\"Using Typesense for embeddings search\",\"path\":\"examples/vector_databases/typesense/Using_Typesense_for_embeddings_search.ipynb\",\"date\":\"2023-06-28\",\"authors\":[{\"name\":\"Colin Jarvis\",\"website\":\"https://twitter.com/colintjarvis\",\"avatar\":\"https://pbs.twimg.com/profile_images/1727207339034345472/IM8v8tlC_400x400.jpg\",\"login\":\"colin-openai\"}],\"search_text\":\"$a2\",\"type\":\"ipynb\",\"tags\":[\"embeddings\"],\"archived\":false},{\"name\":\"README.md\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/vector_databases/weaviate/README.md\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/vector_databases/weaviate/README.md\",\"internal_path\":\"examples/vector_databases/weaviate/readme\",\"title\":\"Weaviate \u003c\u003e OpenAI\",\"path\":\"examples/vector_databases/weaviate/README.md\",\"date\":\"2023-02-13\",\"authors\":[{\"name\":\"Colin Jarvis\",\"website\":\"https://twitter.com/colintjarvis\",\"avatar\":\"https://pbs.twimg.com/profile_images/1727207339034345472/IM8v8tlC_400x400.jpg\",\"login\":\"colin-openai\"}],\"search_text\":\"$a3\",\"type\":\"md\",\"tags\":[\"embeddings\"],\"archived\":false},{\"name\":\"Using_Weaviate_for_embeddings_search.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/vector_databases/weaviate/Using_Weaviate_for_embeddings_search.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/vector_databases/weaviate/Using_Weaviate_for_embeddings_search.ipynb\",\"internal_path\":\"examples/vector_databases/weaviate/using_weaviate_for_embeddings_search\",\"title\":\"Using Weaviate for embeddings search\",\"path\":\"examples/vector_databases/weaviate/Using_Weaviate_for_embeddings_search.ipynb\",\"date\":\"2023-06-28\",\"authors\":[{\"name\":\"Colin Jarvis\",\"website\":\"https://twitter.com/colintjarvis\",\"avatar\":\"https://pbs.twimg.com/profile_images/1727207339034345472/IM8v8tlC_400x400.jpg\",\"login\":\"colin-openai\"}],\"search_text\":\"$a4\",\"type\":\"ipynb\",\"tags\":[\"embeddings\"],\"archived\":false},{\"name\":\"generative-search-with-weaviate-and-openai.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/vector_databases/weaviate/generative-search-with-weaviate-and-openai.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/vector_databases/weaviate/generative-search-with-weaviate-and-openai.ipynb\",\"internal_path\":\"examples/vector_databases/weaviate/generative-search-with-weaviate-and-openai\",\"title\":\"Using Weaviate with generative OpenAI module for generative search\",\"path\":\"examples/vector_databases/weaviate/generative-search-with-weaviate-and-openai.ipynb\",\"date\":\"2023-05-22\",\"authors\":[{\"login\":\"sebawita\"}],\"search_text\":\"$a5\",\"type\":\"ipynb\",\"tags\":[\"completions\",\"embeddings\"],\"archived\":false},{\"name\":\"getting-started-with-weaviate-and-openai.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/vector_databases/weaviate/getting-started-with-weaviate-and-openai.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/vector_databases/weaviate/getting-started-with-weaviate-and-openai.ipynb\",\"internal_path\":\"examples/vector_databases/weaviate/getting-started-with-weaviate-and-openai\",\"title\":\"Using Weaviate with OpenAI vectorize module for embeddings search\",\"path\":\"examples/vector_databases/weaviate/getting-started-with-weaviate-and-openai.ipynb\",\"date\":\"2023-02-13\",\"authors\":[{\"name\":\"Colin Jarvis\",\"website\":\"https://twitter.com/colintjarvis\",\"avatar\":\"https://pbs.twimg.com/profile_images/1727207339034345472/IM8v8tlC_400x400.jpg\",\"login\":\"colin-openai\"}],\"search_text\":\"$a6\",\"type\":\"ipynb\",\"tags\":[\"embeddings\"],\"archived\":false},{\"name\":\"hybrid-search-with-weaviate-and-openai.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/vector_databases/weaviate/hybrid-search-with-weaviate-and-openai.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/vector_databases/weaviate/hybrid-search-with-weaviate-and-openai.ipynb\",\"internal_path\":\"examples/vector_databases/weaviate/hybrid-search-with-weaviate-and-openai\",\"title\":\"Using Weaviate with OpenAI vectorize module for hybrid search\",\"path\":\"examples/vector_databases/weaviate/hybrid-search-with-weaviate-and-openai.ipynb\",\"date\":\"2023-02-13\",\"authors\":[{\"name\":\"Colin Jarvis\",\"website\":\"https://twitter.com/colintjarvis\",\"avatar\":\"https://pbs.twimg.com/profile_images/1727207339034345472/IM8v8tlC_400x400.jpg\",\"login\":\"colin-openai\"}],\"search_text\":\"$a7\",\"type\":\"ipynb\",\"tags\":[\"embeddings\"],\"archived\":false},{\"name\":\"question-answering-with-weaviate-and-openai.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/vector_databases/weaviate/question-answering-with-weaviate-and-openai.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/vector_databases/weaviate/question-answering-with-weaviate-and-openai.ipynb\",\"internal_path\":\"examples/vector_databases/weaviate/question-answering-with-weaviate-and-openai\",\"title\":\"Question Answering in Weaviate with OpenAI Q\u0026A module\",\"path\":\"examples/vector_databases/weaviate/question-answering-with-weaviate-and-openai.ipynb\",\"date\":\"2023-02-13\",\"authors\":[{\"name\":\"Colin Jarvis\",\"website\":\"https://twitter.com/colintjarvis\",\"avatar\":\"https://pbs.twimg.com/profile_images/1727207339034345472/IM8v8tlC_400x400.jpg\",\"login\":\"colin-openai\"}],\"search_text\":\"$a8\",\"type\":\"ipynb\",\"tags\":[\"completions\",\"embeddings\"],\"archived\":false},{\"name\":\"Filtered_search_with_Zilliz_and_OpenAI.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/vector_databases/zilliz/Filtered_search_with_Zilliz_and_OpenAI.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/vector_databases/zilliz/Filtered_search_with_Zilliz_and_OpenAI.ipynb\",\"internal_path\":\"examples/vector_databases/zilliz/filtered_search_with_zilliz_and_openai\",\"title\":\"Filtered Search with Zilliz and OpenAI\",\"path\":\"examples/vector_databases/zilliz/Filtered_search_with_Zilliz_and_OpenAI.ipynb\",\"date\":\"2023-03-28\",\"authors\":[{\"login\":\"filip-halt\"}],\"search_text\":\"$a9\",\"type\":\"ipynb\",\"tags\":[\"embeddings\"],\"archived\":false},{\"name\":\"Getting_started_with_Zilliz_and_OpenAI.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/vector_databases/zilliz/Getting_started_with_Zilliz_and_OpenAI.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/vector_databases/zilliz/Getting_started_with_Zilliz_and_OpenAI.ipynb\",\"internal_path\":\"examples/vector_databases/zilliz/getting_started_with_zilliz_and_openai\",\"title\":\"Getting Started with Zilliz and OpenAI\",\"path\":\"examples/vector_databases/zilliz/Getting_started_with_Zilliz_and_OpenAI.ipynb\",\"date\":\"2023-03-28\",\"authors\":[{\"login\":\"filip-halt\"}],\"search_text\":\"$aa\",\"type\":\"ipynb\",\"tags\":[\"embeddings\"],\"archived\":false},{\"name\":\"techniques_to_improve_reliability.md\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/articles/techniques_to_improve_reliability.md\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/articles/techniques_to_improve_reliability.md\",\"internal_path\":\"articles/techniques_to_improve_reliability\",\"title\":\"Techniques to improve reliability\",\"path\":\"articles/techniques_to_improve_reliability.md\",\"date\":\"2022-09-12\",\"authors\":[{\"name\":\"Ted Sanders\",\"website\":\"https://github.com/ted-at-openai\",\"avatar\":\"https://avatars.githubusercontent.com/u/95656834?v=4\",\"login\":\"ted-at-openai\"}],\"search_text\":\"$ab\",\"type\":\"md\",\"tags\":[\"completions\"],\"archived\":true,\"redirects\":[\"techniques_to_improve_reliability\"]},{\"name\":\"how_to_work_with_large_language_models.md\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/articles/how_to_work_with_large_language_models.md\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/articles/how_to_work_with_large_language_models.md\",\"internal_path\":\"articles/how_to_work_with_large_language_models\",\"title\":\"How to work with large language models\",\"path\":\"articles/how_to_work_with_large_language_models.md\",\"date\":\"2023-01-20\",\"authors\":[{\"name\":\"Ted Sanders\",\"website\":\"https://github.com/ted-at-openai\",\"avatar\":\"https://avatars.githubusercontent.com/u/95656834?v=4\",\"login\":\"ted-at-openai\"}],\"search_text\":\"$ac\",\"type\":\"md\",\"tags\":[\"completions\"],\"archived\":false,\"redirects\":[\"how_to_work_with_large_language_models\"]},{\"name\":\"text_comparison_examples.md\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/articles/text_comparison_examples.md\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/articles/text_comparison_examples.md\",\"internal_path\":\"articles/text_comparison_examples\",\"title\":\"Use cases for embeddings\",\"path\":\"articles/text_comparison_examples.md\",\"date\":\"2023-01-20\",\"authors\":[{\"name\":\"Ted Sanders\",\"website\":\"https://github.com/ted-at-openai\",\"avatar\":\"https://avatars.githubusercontent.com/u/95656834?v=4\",\"login\":\"ted-at-openai\"}],\"search_text\":\"$ad\",\"type\":\"md\",\"tags\":[\"embeddings\"],\"archived\":false,\"redirects\":[\"text_comparison_examples\"]},{\"name\":\"running_realtime_api_speech_on_esp32_arduino_edge_runtime_elatoai.md\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/voice_solutions/running_realtime_api_speech_on_esp32_arduino_edge_runtime_elatoai.md\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/voice_solutions/running_realtime_api_speech_on_esp32_arduino_edge_runtime_elatoai.md\",\"internal_path\":\"examples/voice_solutions/running_realtime_api_speech_on_esp32_arduino_edge_runtime_elatoai\",\"title\":\"ElatoAI - Realtime Speech AI Agents for ESP32 on Arduino\",\"path\":\"examples/voice_solutions/running_realtime_api_speech_on_esp32_arduino_edge_runtime_elatoai.md\",\"date\":\"2025-05-01\",\"authors\":[{\"name\":\"Akashdeep Deb\",\"website\":\"https://github.com/akdeb\",\"avatar\":\"https://avatars.githubusercontent.com/u/20175219\",\"login\":\"akashdeepdeb\"}],\"search_text\":\"$ae\",\"type\":\"md\",\"tags\":[\"arduino\",\"audio\",\"esp32\",\"iot\",\"realtime-api\",\"speech\"],\"archived\":false},{\"name\":\"related_resources.md\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/articles/related_resources.md\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/articles/related_resources.md\",\"internal_path\":\"articles/related_resources\",\"title\":\"Related resources from around the web\",\"path\":\"articles/related_resources.md\",\"date\":\"2023-01-20\",\"authors\":[{\"name\":\"Ted Sanders\",\"website\":\"https://github.com/ted-at-openai\",\"avatar\":\"https://avatars.githubusercontent.com/u/95656834?v=4\",\"login\":\"ted-at-openai\"},{\"name\":\"Simón Fishman\",\"website\":\"https://twitter.com/simonpfish\",\"avatar\":\"https://pbs.twimg.com/profile_images/1687643030243901441/61DpxNfc_400x400.jpg\",\"login\":\"simonpfish\"}],\"search_text\":\"$af\",\"type\":\"md\",\"tags\":[\"completions\",\"embeddings\"],\"archived\":false,\"redirects\":[\"related_resources\"]},{\"name\":\"ft_retrieval_augmented_generation_qdrant.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/fine-tuned_qa/ft_retrieval_augmented_generation_qdrant.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/fine-tuned_qa/ft_retrieval_augmented_generation_qdrant.ipynb\",\"internal_path\":\"examples/fine-tuned_qa/ft_retrieval_augmented_generation_qdrant\",\"title\":\"Fine-Tuning for retrieval augmented generation (RAG) with Qdrant\",\"path\":\"examples/fine-tuned_qa/ft_retrieval_augmented_generation_qdrant.ipynb\",\"date\":\"2023-09-04\",\"authors\":[{\"login\":\"NirantK\"}],\"search_text\":\"$b0\",\"type\":\"ipynb\",\"tags\":[\"completions\",\"embeddings\",\"fine-tuning\"],\"archived\":false},{\"name\":\"How_to_automate_S3_storage_with_functions.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/third_party/How_to_automate_S3_storage_with_functions.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/third_party/How_to_automate_S3_storage_with_functions.ipynb\",\"internal_path\":\"examples/third_party/how_to_automate_s3_storage_with_functions\",\"title\":\"How to automate AWS tasks with function calling\",\"path\":\"examples/third_party/How_to_automate_S3_storage_with_functions.ipynb\",\"date\":\"2023-09-27\",\"authors\":[{\"login\":\"Barqawiz\"}],\"search_text\":\"$b1\",\"type\":\"ipynb\",\"tags\":[\"completions\",\"embeddings\",\"functions\"],\"archived\":false},{\"name\":\"README.md\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/vector_databases/neon/README.md\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/vector_databases/neon/README.md\",\"internal_path\":\"examples/vector_databases/neon/readme\",\"title\":\"Neon as a vector database\",\"path\":\"examples/vector_databases/neon/README.md\",\"date\":\"2023-09-28\",\"authors\":[{\"login\":\"Barqawiz\"}],\"search_text\":\"$b2\",\"type\":\"md\",\"tags\":[\"embeddings\"],\"archived\":false},{\"name\":\"neon-postgres-vector-search-pgvector.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/vector_databases/neon/neon-postgres-vector-search-pgvector.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/vector_databases/neon/neon-postgres-vector-search-pgvector.ipynb\",\"internal_path\":\"examples/vector_databases/neon/neon-postgres-vector-search-pgvector\",\"title\":\"Vector similarity search using Neon Postgres\",\"path\":\"examples/vector_databases/neon/neon-postgres-vector-search-pgvector.ipynb\",\"date\":\"2023-09-28\",\"authors\":[{\"login\":\"danieltprice\"}],\"search_text\":\"$b3\",\"type\":\"ipynb\",\"tags\":[\"embeddings\"],\"archived\":false},{\"name\":\"deeplake_langchain_qa.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/vector_databases/deeplake/deeplake_langchain_qa.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/vector_databases/deeplake/deeplake_langchain_qa.ipynb\",\"internal_path\":\"examples/vector_databases/deeplake/deeplake_langchain_qa\",\"title\":\"Question answering with LangChain, Deep Lake, \u0026 OpenAI\",\"path\":\"examples/vector_databases/deeplake/deeplake_langchain_qa.ipynb\",\"date\":\"2023-09-30\",\"authors\":[{\"login\":\"FayazRahman\"}],\"search_text\":\"$b4\",\"type\":\"ipynb\",\"tags\":[\"embeddings\"],\"archived\":false},{\"name\":\"GPT_finetuning_with_wandb.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/third_party/GPT_finetuning_with_wandb.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/third_party/GPT_finetuning_with_wandb.ipynb\",\"internal_path\":\"examples/third_party/gpt_finetuning_with_wandb\",\"title\":\"Fine-tuning OpenAI models with Weights \u0026 Biases\",\"path\":\"examples/third_party/GPT_finetuning_with_wandb.ipynb\",\"date\":\"2023-10-04\",\"authors\":[{\"login\":\"ash0ts\"}],\"search_text\":\"$b5\",\"type\":\"ipynb\",\"tags\":[\"completions\",\"fine-tuning\",\"tiktoken\"],\"archived\":false},{\"name\":\"Openai_monitoring_with_wandb_weave.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/third_party/Openai_monitoring_with_wandb_weave.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/third_party/Openai_monitoring_with_wandb_weave.ipynb\",\"internal_path\":\"examples/third_party/openai_monitoring_with_wandb_weave\",\"title\":\"OpenAI API Monitoring with Weights \u0026 Biases Weave\",\"path\":\"examples/third_party/Openai_monitoring_with_wandb_weave.ipynb\",\"date\":\"2023-10-04\",\"authors\":[{\"login\":\"ash0ts\"}],\"search_text\":\"$b6\",\"type\":\"ipynb\",\"tags\":[\"completions\",\"tiktoken\"],\"archived\":false},{\"name\":\"How_to_build_an_agent_with_the_node_sdk.mdx\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/How_to_build_an_agent_with_the_node_sdk.mdx\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/How_to_build_an_agent_with_the_node_sdk.mdx\",\"internal_path\":\"examples/how_to_build_an_agent_with_the_node_sdk\",\"title\":\"How to build an agent with the OpenAI Node.js SDK\",\"path\":\"examples/How_to_build_an_agent_with_the_node_sdk.mdx\",\"date\":\"2023-10-05\",\"authors\":[{\"login\":\"perborgen\"}],\"search_text\":\"$b7\",\"type\":\"mdx\",\"tags\":[\"agents\",\"completions\",\"functions\"],\"archived\":false},{\"name\":\"Named_Entity_Recognition_to_enrich_text.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/Named_Entity_Recognition_to_enrich_text.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/Named_Entity_Recognition_to_enrich_text.ipynb\",\"internal_path\":\"examples/named_entity_recognition_to_enrich_text\",\"title\":\"Named Entity Recognition to Enrich Text\",\"path\":\"examples/Named_Entity_Recognition_to_enrich_text.ipynb\",\"date\":\"2023-10-20\",\"authors\":[{\"login\":\"dcarpintero\"}],\"search_text\":\"$b8\",\"type\":\"ipynb\",\"tags\":[\"completions\",\"functions\"],\"archived\":false},{\"name\":\"what_makes_documentation_good.md\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/articles/what_makes_documentation_good.md\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/articles/what_makes_documentation_good.md\",\"internal_path\":\"articles/what_makes_documentation_good\",\"title\":\"What makes documentation good\",\"path\":\"articles/what_makes_documentation_good.md\",\"date\":\"2023-09-01\",\"authors\":[{\"name\":\"Ted Sanders\",\"website\":\"https://github.com/ted-at-openai\",\"avatar\":\"https://avatars.githubusercontent.com/u/95656834?v=4\",\"login\":\"ted-at-openai\"}],\"search_text\":\"$b9\",\"type\":\"md\",\"tags\":[],\"archived\":false,\"redirects\":[\"what_makes_documentation_good\"]},{\"name\":\"Function_calling_with_an_OpenAPI_spec.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/Function_calling_with_an_OpenAPI_spec.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/Function_calling_with_an_OpenAPI_spec.ipynb\",\"internal_path\":\"examples/function_calling_with_an_openapi_spec\",\"title\":\"Function calling with an OpenAPI specification\",\"path\":\"examples/Function_calling_with_an_OpenAPI_spec.ipynb\",\"date\":\"2023-10-15\",\"authors\":[{\"name\":\"Shyamal Anadkat\",\"website\":\"https://twitter.com/shyamalanadkat\",\"avatar\":\"https://pbs.twimg.com/profile_images/1590564338682560512/3bbZJqxZ_400x400.jpg\",\"login\":\"shyamal-anadkat\"},{\"name\":\"Simón Fishman\",\"website\":\"https://twitter.com/simonpfish\",\"avatar\":\"https://pbs.twimg.com/profile_images/1687643030243901441/61DpxNfc_400x400.jpg\",\"login\":\"simonpfish\"}],\"search_text\":\"$ba\",\"type\":\"ipynb\",\"tags\":[\"completions\",\"functions\"],\"archived\":false},{\"name\":\"Fine_tuning_for_function_calling.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/Fine_tuning_for_function_calling.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/Fine_tuning_for_function_calling.ipynb\",\"internal_path\":\"examples/fine_tuning_for_function_calling\",\"title\":\"Fine tuning for function calling\",\"path\":\"examples/Fine_tuning_for_function_calling.ipynb\",\"date\":\"2023-11-07\",\"authors\":[{\"name\":\"James Hills\",\"website\":\"https://twitter.com/jamesmhills\",\"avatar\":\"https://pbs.twimg.com/profile_images/1722092156691902464/44FGj7VT_400x400.jpg\",\"login\":\"jhills20\"},{\"name\":\"Ilan Bigio\",\"website\":\"https://twitter.com/ilanbigio\",\"avatar\":\"https://pbs.twimg.com/profile_images/1841544725654077440/DR3b8DMr_400x400.jpg\",\"login\":\"ibigio\"},{\"name\":\"Shyamal Anadkat\",\"website\":\"https://twitter.com/shyamalanadkat\",\"avatar\":\"https://pbs.twimg.com/profile_images/1590564338682560512/3bbZJqxZ_400x400.jpg\",\"login\":\"shyamal-anadkat\"},{\"name\":\"Teodora Musatoiu\",\"website\":\"https://www.linkedin.com/in/teodora-musatoiu/\",\"avatar\":\"https://avatars.githubusercontent.com/u/156829031?s=400\u0026u=af40fe04d9255139eb3bbf8dc83422cc694e862b\u0026v=4\",\"login\":\"teomusatoiu\"}],\"search_text\":\"$bb\",\"type\":\"ipynb\",\"tags\":[\"completions\",\"fine-tuning\",\"functions\"],\"archived\":false},{\"name\":\"GPT_with_vision_for_video_understanding.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/GPT_with_vision_for_video_understanding.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/GPT_with_vision_for_video_understanding.ipynb\",\"internal_path\":\"examples/gpt_with_vision_for_video_understanding\",\"title\":\"Processing and narrating a video with GPT-4.1-mini's visual capabilities and GPT-4o TTS API\",\"path\":\"examples/GPT_with_vision_for_video_understanding.ipynb\",\"date\":\"2025-04-22\",\"authors\":[{\"name\":\"Kai Chen\",\"website\":\"https://github.com/cathykc\",\"avatar\":\"https://pbs.twimg.com/profile_images/1657816900817272832/ioGq5O0t_400x400.jpg\",\"login\":\"cathykc\"},{\"name\":\"Randy Zhao\",\"website\":\"https://www.linkedin.com/in/randy-zhao-27433616b\",\"avatar\":\"https://avatars.githubusercontent.com/u/208724779?v=4\",\"login\":\"rzhao-openai\"}],\"search_text\":\"$bc\",\"type\":\"ipynb\",\"tags\":[\"responses\",\"speech\",\"vision\"],\"archived\":false},{\"name\":\"what_is_new_with_dalle_3.mdx\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/articles/what_is_new_with_dalle_3.mdx\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/articles/what_is_new_with_dalle_3.mdx\",\"internal_path\":\"articles/what_is_new_with_dalle_3\",\"title\":\"What's new with DALL·E 3?\",\"path\":\"articles/what_is_new_with_dalle_3.mdx\",\"date\":\"2023-11-06\",\"authors\":[{\"name\":\"Will Depue\",\"website\":\"http://depue.design\",\"avatar\":\"https://pbs.twimg.com/profile_images/1619879636057595904/NdjEAqPm_400x400.jpg\",\"login\":\"0hq\"}],\"search_text\":\"$bd\",\"type\":\"mdx\",\"tags\":[\"dall-e\"],\"archived\":false},{\"name\":\"Reproducible_outputs_with_the_seed_parameter.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/Reproducible_outputs_with_the_seed_parameter.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/Reproducible_outputs_with_the_seed_parameter.ipynb\",\"internal_path\":\"examples/reproducible_outputs_with_the_seed_parameter\",\"title\":\"How to make your completions outputs consistent with the new seed parameter\",\"path\":\"examples/Reproducible_outputs_with_the_seed_parameter.ipynb\",\"date\":\"2023-11-06\",\"authors\":[{\"name\":\"Shyamal Anadkat\",\"website\":\"https://twitter.com/shyamalanadkat\",\"avatar\":\"https://pbs.twimg.com/profile_images/1590564338682560512/3bbZJqxZ_400x400.jpg\",\"login\":\"shyamal-anadkat\"}],\"search_text\":\"$be\",\"type\":\"ipynb\",\"tags\":[\"completions\"],\"archived\":false},{\"name\":\"Assistants_API_overview_python.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/Assistants_API_overview_python.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/Assistants_API_overview_python.ipynb\",\"internal_path\":\"examples/assistants_api_overview_python\",\"title\":\"Assistants API Overview (Python SDK)\",\"path\":\"examples/Assistants_API_overview_python.ipynb\",\"date\":\"2023-11-10\",\"authors\":[{\"name\":\"Ilan Bigio\",\"website\":\"https://twitter.com/ilanbigio\",\"avatar\":\"https://pbs.twimg.com/profile_images/1841544725654077440/DR3b8DMr_400x400.jpg\",\"login\":\"ibigio\"}],\"search_text\":\"$bf\",\"type\":\"ipynb\",\"tags\":[\"assistants\",\"functions\"],\"archived\":false},{\"name\":\"Orchestrating_agents.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/Orchestrating_agents.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/Orchestrating_agents.ipynb\",\"internal_path\":\"examples/orchestrating_agents\",\"title\":\"Orchestrating Agents: Routines and Handoffs\",\"path\":\"examples/Orchestrating_agents.ipynb\",\"date\":\"2024-10-10\",\"authors\":[{\"name\":\"Ilan Bigio\",\"website\":\"https://twitter.com/ilanbigio\",\"avatar\":\"https://pbs.twimg.com/profile_images/1841544725654077440/DR3b8DMr_400x400.jpg\",\"login\":\"ibigio\"}],\"search_text\":\"$c0\",\"type\":\"ipynb\",\"tags\":[\"agents\",\"completions\",\"functions\"],\"archived\":false},{\"name\":\"README.md\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/vector_databases/mongodb_atlas/README.md\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/vector_databases/mongodb_atlas/README.md\",\"internal_path\":\"examples/vector_databases/mongodb_atlas/readme\",\"title\":\"MongoDB Atlas Vector Search\",\"path\":\"examples/vector_databases/mongodb_atlas/README.md\",\"date\":\"2023-11-21\",\"authors\":[{\"name\":\"Prakul Agarwal\",\"website\":\"https://www.linkedin.com/in/prakulagarwal\",\"avatar\":\"https://media.licdn.com/dms/image/D5603AQEUug83qKgRBg/profile-displayphoto-shrink_800_800/0/1675384960197?e=1706140800\u0026v=beta\u0026t=qxkDbBr-Bk2ASpcwbR5JVPD6yS-vzmIwNHAa8ApyDq4\",\"login\":\"prakul\"}],\"search_text\":\"Atlas Vector Search is a fully managed service that simplifies the process of effectively indexing high-dimensional vector data within MongoDB and being able to perform fast vector similarity searches. With Atlas Vector Search, you can use MongoDB as a standalone vector database for a new project or augment your existing MongoDB collections with vector search functionality. With Atlas Vector Search, you can use the powerful capabilities of vector search in any major public cloud (AWS, Azure, GCP) and achieve massive scalability and data security out of the box while being enterprise-ready with provisions like FedRamp, SoC2 compliance.\\n\\nDocumentation - link\",\"type\":\"md\",\"tags\":[\"completions\",\"embeddings\"],\"archived\":false},{\"name\":\"semantic_search_using_mongodb_atlas_vector_search.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/vector_databases/mongodb_atlas/semantic_search_using_mongodb_atlas_vector_search.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/vector_databases/mongodb_atlas/semantic_search_using_mongodb_atlas_vector_search.ipynb\",\"internal_path\":\"examples/vector_databases/mongodb_atlas/semantic_search_using_mongodb_atlas_vector_search\",\"title\":\"Semantic search using MongoDB Atlas Vector Search and OpenAI\",\"path\":\"examples/vector_databases/mongodb_atlas/semantic_search_using_mongodb_atlas_vector_search.ipynb\",\"date\":\"2023-11-21\",\"authors\":[{\"name\":\"Prakul Agarwal\",\"website\":\"https://www.linkedin.com/in/prakulagarwal\",\"avatar\":\"https://media.licdn.com/dms/image/D5603AQEUug83qKgRBg/profile-displayphoto-shrink_800_800/0/1675384960197?e=1706140800\u0026v=beta\u0026t=qxkDbBr-Bk2ASpcwbR5JVPD6yS-vzmIwNHAa8ApyDq4\",\"login\":\"prakul\"}],\"search_text\":\"$c1\",\"type\":\"ipynb\",\"tags\":[\"completions\",\"embeddings\"],\"archived\":false},{\"name\":\"Evaluate_RAG_with_LlamaIndex.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/evaluation/Evaluate_RAG_with_LlamaIndex.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/evaluation/Evaluate_RAG_with_LlamaIndex.ipynb\",\"internal_path\":\"examples/evaluation/evaluate_rag_with_llamaindex\",\"title\":\"Evaluate RAG with LlamaIndex\",\"path\":\"examples/evaluation/Evaluate_RAG_with_LlamaIndex.ipynb\",\"date\":\"2023-11-06\",\"authors\":[{\"login\":\"Ravi Theja\"}],\"search_text\":\"$c2\",\"type\":\"ipynb\",\"tags\":[\"completions\",\"embeddings\"],\"archived\":false},{\"name\":\"RAG_with_graph_db.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/RAG_with_graph_db.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/RAG_with_graph_db.ipynb\",\"internal_path\":\"examples/rag_with_graph_db\",\"title\":\"RAG with a Graph database\",\"path\":\"examples/RAG_with_graph_db.ipynb\",\"date\":\"2023-12-08\",\"authors\":[{\"name\":\"Katia Gil Guzman\",\"website\":\"https://katia.gg\",\"avatar\":\"https://avatars.githubusercontent.com/u/16519462?v=4\",\"login\":\"katiagg\"}],\"search_text\":\"$c3\",\"type\":\"ipynb\",\"tags\":[\"completions\",\"embeddings\"],\"archived\":false},{\"name\":\"README.md\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/vector_databases/supabase/README.md\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/vector_databases/supabase/README.md\",\"internal_path\":\"examples/vector_databases/supabase/readme\",\"title\":\"Supabase Vector Database\",\"path\":\"examples/vector_databases/supabase/README.md\",\"date\":\"2023-12-04\",\"authors\":[{\"name\":\"Greg Richardson\",\"website\":\"https://twitter.com/ggrdson\",\"avatar\":\"https://pbs.twimg.com/profile_images/1371549909820657664/ZG-HDNlI_400x400.jpg\",\"login\":\"ggrn\"}],\"search_text\":\"$c4\",\"type\":\"md\",\"tags\":[\"embeddings\"],\"archived\":false},{\"name\":\"semantic-search.mdx\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/vector_databases/supabase/semantic-search.mdx\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/vector_databases/supabase/semantic-search.mdx\",\"internal_path\":\"examples/vector_databases/supabase/semantic-search\",\"title\":\"Semantic search using Supabase Vector\",\"path\":\"examples/vector_databases/supabase/semantic-search.mdx\",\"date\":\"2023-12-04\",\"authors\":[{\"name\":\"Greg Richardson\",\"website\":\"https://twitter.com/ggrdson\",\"avatar\":\"https://pbs.twimg.com/profile_images/1371549909820657664/ZG-HDNlI_400x400.jpg\",\"login\":\"ggrn\"}],\"search_text\":\"$c5\",\"type\":\"mdx\",\"tags\":[\"embeddings\"],\"archived\":false},{\"name\":\"How_to_use_guardrails.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/How_to_use_guardrails.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/How_to_use_guardrails.ipynb\",\"internal_path\":\"examples/how_to_use_guardrails\",\"title\":\"How to implement LLM guardrails\",\"path\":\"examples/How_to_use_guardrails.ipynb\",\"date\":\"2023-12-19\",\"authors\":[{\"name\":\"Colin Jarvis\",\"website\":\"https://twitter.com/colintjarvis\",\"avatar\":\"https://pbs.twimg.com/profile_images/1727207339034345472/IM8v8tlC_400x400.jpg\",\"login\":\"colin-openai\"}],\"search_text\":\"$c6\",\"type\":\"ipynb\",\"tags\":[\"guardrails\"],\"archived\":false},{\"name\":\"How_to_combine_GPT4o_with_RAG_Outfit_Assistant.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/How_to_combine_GPT4o_with_RAG_Outfit_Assistant.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/How_to_combine_GPT4o_with_RAG_Outfit_Assistant.ipynb\",\"internal_path\":\"examples/how_to_combine_gpt4o_with_rag_outfit_assistant\",\"title\":\"How to combine GPT4o mini with RAG to create a clothing matchmaker app\",\"path\":\"examples/How_to_combine_GPT4o_with_RAG_Outfit_Assistant.ipynb\",\"date\":\"2024-07-18\",\"authors\":[{\"name\":\"Teodora Musatoiu\",\"website\":\"https://www.linkedin.com/in/teodora-musatoiu/\",\"avatar\":\"https://avatars.githubusercontent.com/u/156829031?s=400\u0026u=af40fe04d9255139eb3bbf8dc83422cc694e862b\u0026v=4\",\"login\":\"teomusatoiu\"}],\"search_text\":\"$c7\",\"type\":\"ipynb\",\"tags\":[\"embeddings\",\"vision\"],\"archived\":false},{\"name\":\"Parse_PDF_docs_for_RAG.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/Parse_PDF_docs_for_RAG.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/Parse_PDF_docs_for_RAG.ipynb\",\"internal_path\":\"examples/parse_pdf_docs_for_rag\",\"title\":\"How to parse PDF docs for RAG\",\"path\":\"examples/Parse_PDF_docs_for_RAG.ipynb\",\"date\":\"2024-09-29\",\"authors\":[{\"name\":\"Katia Gil Guzman\",\"website\":\"https://katia.gg\",\"avatar\":\"https://avatars.githubusercontent.com/u/16519462?v=4\",\"login\":\"katiagg\"},{\"name\":\"Mitch Welzen\",\"website\":\"https://www.linkedin.com/in/mitchwelzen/\",\"avatar\":\"https://media.licdn.com/dms/image/v2/C5603AQHC8-1q4MwH1A/profile-displayphoto-shrink_800_800/profile-displayphoto-shrink_800_800/0/1592824550774?e=1742428800\u0026v=beta\u0026t=3mudgDyuzNU2a4gx1gue4DPyhaui7kbB7e7U8vyOo-g\",\"login\":\"MW-OAI\"}],\"search_text\":\"$c8\",\"type\":\"ipynb\",\"tags\":[\"embeddings\",\"vision\"],\"archived\":false},{\"name\":\"Tag_caption_images_with_GPT4V.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/Tag_caption_images_with_GPT4V.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/Tag_caption_images_with_GPT4V.ipynb\",\"internal_path\":\"examples/tag_caption_images_with_gpt4v\",\"title\":\"Using GPT4o mini to tag and caption images\",\"path\":\"examples/Tag_caption_images_with_GPT4V.ipynb\",\"date\":\"2024-07-18\",\"authors\":[{\"name\":\"Katia Gil Guzman\",\"website\":\"https://katia.gg\",\"avatar\":\"https://avatars.githubusercontent.com/u/16519462?v=4\",\"login\":\"katiagg\"}],\"search_text\":\"$c9\",\"type\":\"ipynb\",\"tags\":[\"embeddings\",\"vision\"],\"archived\":false},{\"name\":\"How_to_use_moderation.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/How_to_use_moderation.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/How_to_use_moderation.ipynb\",\"internal_path\":\"examples/how_to_use_moderation\",\"title\":\"How to use the moderation API\",\"path\":\"examples/How_to_use_moderation.ipynb\",\"date\":\"2024-03-05\",\"authors\":[{\"name\":\"Teodora Musatoiu\",\"website\":\"https://www.linkedin.com/in/teodora-musatoiu/\",\"avatar\":\"https://avatars.githubusercontent.com/u/156829031?s=400\u0026u=af40fe04d9255139eb3bbf8dc83422cc694e862b\u0026v=4\",\"login\":\"teomusatoiu\"}],\"search_text\":\"$ca\",\"type\":\"ipynb\",\"tags\":[\"moderation\"],\"archived\":false},{\"name\":\"Summarizing_long_documents.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/Summarizing_long_documents.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/Summarizing_long_documents.ipynb\",\"internal_path\":\"examples/summarizing_long_documents\",\"title\":\"Summarizing Long Documents\",\"path\":\"examples/Summarizing_long_documents.ipynb\",\"date\":\"2024-04-19\",\"authors\":[{\"name\":\"Joe Palermo\",\"website\":\"https://www.linkedin.com/in/joe-palermo-99219237\",\"avatar\":\"https://avatars.githubusercontent.com/u/117690718?v=4\",\"login\":\"joe-at-openai\"}],\"search_text\":\"$cb\",\"type\":\"ipynb\",\"tags\":[\"chat\"],\"archived\":false},{\"name\":\"Using_GPT4_Vision_With_Function_Calling.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/multimodal/Using_GPT4_Vision_With_Function_Calling.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/multimodal/Using_GPT4_Vision_With_Function_Calling.ipynb\",\"internal_path\":\"examples/multimodal/using_gpt4_vision_with_function_calling\",\"title\":\"Using GPT4 Vision with Function Calling\",\"path\":\"examples/multimodal/Using_GPT4_Vision_With_Function_Calling.ipynb\",\"date\":\"2024-12-13\",\"authors\":[{\"name\":\"Shyamal Anadkat\",\"website\":\"https://twitter.com/shyamalanadkat\",\"avatar\":\"https://pbs.twimg.com/profile_images/1590564338682560512/3bbZJqxZ_400x400.jpg\",\"login\":\"shyamal-anadkat\"},{\"name\":\"Mitch Welzen\",\"website\":\"https://www.linkedin.com/in/mitchwelzen/\",\"avatar\":\"https://media.licdn.com/dms/image/v2/C5603AQHC8-1q4MwH1A/profile-displayphoto-shrink_800_800/profile-displayphoto-shrink_800_800/0/1592824550774?e=1742428800\u0026v=beta\u0026t=3mudgDyuzNU2a4gx1gue4DPyhaui7kbB7e7U8vyOo-g\",\"login\":\"MW-OAI\"}],\"search_text\":\"$cc\",\"type\":\"ipynb\",\"tags\":[\"chat\",\"vision\"],\"archived\":false},{\"name\":\"SDG1.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/SDG1.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/SDG1.ipynb\",\"internal_path\":\"examples/sdg1\",\"title\":\"Synthetic data generation (Part 1)\",\"path\":\"examples/SDG1.ipynb\",\"date\":\"2024-04-10\",\"authors\":[{\"name\":\"Dylan Royan Almeida\",\"website\":\"https://www.linkedin.com/in/dylan-almeida-604522167/\",\"avatar\":\"https://avatars.githubusercontent.com/u/149511600?v=4\",\"login\":\"dylanra-openai\"}],\"search_text\":\"$cd\",\"type\":\"ipynb\",\"tags\":[\"completions\"],\"archived\":false},{\"name\":\"custom_image_embedding_search.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/custom_image_embedding_search.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/custom_image_embedding_search.ipynb\",\"internal_path\":\"examples/custom_image_embedding_search\",\"title\":\"CLIP embeddings to improve multimodal RAG with GPT-4 Vision\",\"path\":\"examples/custom_image_embedding_search.ipynb\",\"date\":\"2024-04-10\",\"authors\":[{\"name\":\"Dylan Royan Almeida\",\"website\":\"https://www.linkedin.com/in/dylan-almeida-604522167/\",\"avatar\":\"https://avatars.githubusercontent.com/u/149511600?v=4\",\"login\":\"dylanra-openai\"}],\"search_text\":\"$ce\",\"type\":\"ipynb\",\"tags\":[\"embeddings\",\"vision\"],\"archived\":false},{\"name\":\"batch_processing.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/batch_processing.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/batch_processing.ipynb\",\"internal_path\":\"examples/batch_processing\",\"title\":\"Batch processing with the Batch API\",\"path\":\"examples/batch_processing.ipynb\",\"date\":\"2024-04-24\",\"authors\":[{\"name\":\"Katia Gil Guzman\",\"website\":\"https://katia.gg\",\"avatar\":\"https://avatars.githubusercontent.com/u/16519462?v=4\",\"login\":\"katiagg\"}],\"search_text\":\"$cf\",\"type\":\"ipynb\",\"tags\":[\"batch\",\"completions\"],\"archived\":false},{\"name\":\"Using_tool_required_for_customer_service.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/Using_tool_required_for_customer_service.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/Using_tool_required_for_customer_service.ipynb\",\"internal_path\":\"examples/using_tool_required_for_customer_service\",\"title\":\"Using tool required for customer service\",\"path\":\"examples/Using_tool_required_for_customer_service.ipynb\",\"date\":\"2024-05-01\",\"authors\":[{\"name\":\"Colin Jarvis\",\"website\":\"https://twitter.com/colintjarvis\",\"avatar\":\"https://pbs.twimg.com/profile_images/1727207339034345472/IM8v8tlC_400x400.jpg\",\"login\":\"colin-openai\"}],\"search_text\":\"$d0\",\"type\":\"ipynb\",\"tags\":[\"completions\",\"functions\"],\"archived\":false},{\"name\":\"introduction_to_gpt4o.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/gpt4o/introduction_to_gpt4o.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/gpt4o/introduction_to_gpt4o.ipynb\",\"internal_path\":\"examples/gpt4o/introduction_to_gpt4o\",\"title\":\"Introduction to GPT-4o and GPT-4o mini\",\"path\":\"examples/gpt4o/introduction_to_gpt4o.ipynb\",\"date\":\"2024-07-18\",\"authors\":[{\"name\":\"Juston Forte\",\"website\":\"https://www.linkedin.com/in/justonforte/\",\"avatar\":\"https://avatars.githubusercontent.com/u/96567547?s=400\u0026u=08b9757200906ab12e3989b561cff6c4b95a12cb\u0026v=4\",\"login\":\"justonf\"}],\"search_text\":\"$d1\",\"type\":\"ipynb\",\"tags\":[\"completions\",\"vision\",\"whisper\"],\"archived\":false},{\"name\":\"Azure_AI_Search_with_Azure_Functions_and_GPT_Actions_in_ChatGPT.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/chatgpt/rag-quickstart/azure/Azure_AI_Search_with_Azure_Functions_and_GPT_Actions_in_ChatGPT.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/chatgpt/rag-quickstart/azure/Azure_AI_Search_with_Azure_Functions_and_GPT_Actions_in_ChatGPT.ipynb\",\"internal_path\":\"examples/chatgpt/rag-quickstart/azure/azure_ai_search_with_azure_functions_and_gpt_actions_in_chatgpt\",\"title\":\"Azure AI Search with Azure Functions and GPT Actions in ChatGPT\",\"path\":\"examples/chatgpt/rag-quickstart/azure/Azure_AI_Search_with_Azure_Functions_and_GPT_Actions_in_ChatGPT.ipynb\",\"date\":\"2024-07-08\",\"authors\":[{\"login\":\"maxreid-openai\"}],\"search_text\":\"$d2\",\"type\":\"ipynb\",\"tags\":[\"chatgpt\",\"chatgpt-and-api\",\"completions\",\"embeddings\",\"tiktoken\"],\"archived\":false},{\"name\":\".gpt_action_getting_started.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/chatgpt/gpt_actions_library/.gpt_action_getting_started.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/chatgpt/gpt_actions_library/.gpt_action_getting_started.ipynb\",\"internal_path\":\"examples/chatgpt/gpt_actions_library/.gpt_action_getting_started\",\"title\":\"GPT Actions library - getting started\",\"path\":\"examples/chatgpt/gpt_actions_library/.gpt_action_getting_started.ipynb\",\"date\":\"2024-07-09\",\"authors\":[{\"name\":\"Aaron Wilkowitz\",\"website\":\"https://www.linkedin.com/in/aaronwilkowitz/\",\"avatar\":\"https://avatars.githubusercontent.com/u/157151487\",\"login\":\"aaronwilkowitz-openai\"}],\"search_text\":\"$d3\",\"type\":\"ipynb\",\"tags\":[\"chatgpt\",\"gpt-actions-library\"],\"archived\":false},{\"name\":\"gpt_action_bigquery.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/chatgpt/gpt_actions_library/gpt_action_bigquery.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/chatgpt/gpt_actions_library/gpt_action_bigquery.ipynb\",\"internal_path\":\"examples/chatgpt/gpt_actions_library/gpt_action_bigquery\",\"title\":\"GPT Actions library - BigQuery\",\"path\":\"examples/chatgpt/gpt_actions_library/gpt_action_bigquery.ipynb\",\"date\":\"2024-07-09\",\"authors\":[{\"name\":\"Aaron Wilkowitz\",\"website\":\"https://www.linkedin.com/in/aaronwilkowitz/\",\"avatar\":\"https://avatars.githubusercontent.com/u/157151487\",\"login\":\"aaronwilkowitz-openai\"}],\"search_text\":\"$d4\",\"type\":\"ipynb\",\"tags\":[\"chatgpt\",\"chatgpt-data\",\"gpt-actions-library\"],\"archived\":false},{\"name\":\"Data_extraction_transformation.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/Data_extraction_transformation.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/Data_extraction_transformation.ipynb\",\"internal_path\":\"examples/data_extraction_transformation\",\"title\":\"Data Extraction and Transformation in ELT Workflows using GPT-4o as an OCR Alternative\",\"path\":\"examples/Data_extraction_transformation.ipynb\",\"date\":\"2024-07-09\",\"authors\":[{\"name\":\"Charu Jaiswal\",\"website\":\"https://www.linkedin.com/in/charu-j-8a866471\",\"avatar\":\"https://avatars.githubusercontent.com/u/18404643?v=4\",\"login\":\"charuj\"}],\"search_text\":\"$d5\",\"type\":\"ipynb\",\"tags\":[\"completions\",\"vision\"],\"archived\":false},{\"name\":\"gpt_action_outlook.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/chatgpt/gpt_actions_library/gpt_action_outlook.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/chatgpt/gpt_actions_library/gpt_action_outlook.ipynb\",\"internal_path\":\"examples/chatgpt/gpt_actions_library/gpt_action_outlook\",\"title\":\"GPT Actions library - Outlook\",\"path\":\"examples/chatgpt/gpt_actions_library/gpt_action_outlook.ipynb\",\"date\":\"2024-07-15\",\"authors\":[{\"name\":\"Rupert Truman\",\"website\":\"https://www.linkedin.com/in/rupert-truman/\",\"avatar\":\"https://avatars.githubusercontent.com/u/171234447\",\"login\":\"rupert-openai\"}],\"search_text\":\"$d6\",\"type\":\"ipynb\",\"tags\":[\"chatgpt\",\"chatgpt-communication\",\"gpt-actions-library\"],\"archived\":false},{\"name\":\"gpt_action_sharepoint_doc.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/chatgpt/gpt_actions_library/gpt_action_sharepoint_doc.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/chatgpt/gpt_actions_library/gpt_action_sharepoint_doc.ipynb\",\"internal_path\":\"examples/chatgpt/gpt_actions_library/gpt_action_sharepoint_doc\",\"title\":\"GPT Actions library - Sharepoint (Return Docs)\",\"path\":\"examples/chatgpt/gpt_actions_library/gpt_action_sharepoint_doc.ipynb\",\"date\":\"2024-05-24\",\"authors\":[{\"login\":\"maxreid-openai\"}],\"search_text\":\"$d7\",\"type\":\"ipynb\",\"tags\":[\"chatgpt\",\"chatgpt-productivity\",\"gpt-actions-library\"],\"archived\":false},{\"name\":\"gpt_action_sharepoint_text.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/chatgpt/gpt_actions_library/gpt_action_sharepoint_text.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/chatgpt/gpt_actions_library/gpt_action_sharepoint_text.ipynb\",\"internal_path\":\"examples/chatgpt/gpt_actions_library/gpt_action_sharepoint_text\",\"title\":\"GPT Actions library - Sharepoint (Return Text)\",\"path\":\"examples/chatgpt/gpt_actions_library/gpt_action_sharepoint_text.ipynb\",\"date\":\"2024-05-24\",\"authors\":[{\"login\":\"maxreid-openai\"}],\"search_text\":\"$d8\",\"type\":\"ipynb\",\"tags\":[\"chatgpt\",\"chatgpt-productivity\",\"gpt-actions-library\"],\"archived\":false},{\"name\":\"gpt_middleware_azure_function.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/chatgpt/gpt_actions_library/gpt_middleware_azure_function.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/chatgpt/gpt_actions_library/gpt_middleware_azure_function.ipynb\",\"internal_path\":\"examples/chatgpt/gpt_actions_library/gpt_middleware_azure_function\",\"title\":\"GPT Actions library (Middleware) - Azure Functions\",\"path\":\"examples/chatgpt/gpt_actions_library/gpt_middleware_azure_function.ipynb\",\"date\":\"2024-05-24\",\"authors\":[{\"login\":\"maxreid-openai\"}],\"search_text\":\"$d9\",\"type\":\"ipynb\",\"tags\":[\"chatgpt\",\"chatgpt-middleware\",\"gpt-actions-library\"],\"archived\":false},{\"name\":\"gpt_action_canvas.md\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/chatgpt/gpt_actions_library/gpt_action_canvas.md\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/chatgpt/gpt_actions_library/gpt_action_canvas.md\",\"internal_path\":\"examples/chatgpt/gpt_actions_library/gpt_action_canvas\",\"title\":\"GPT Actions library - Canvas Learning Management System\",\"path\":\"examples/chatgpt/gpt_actions_library/gpt_action_canvas.md\",\"date\":\"2024-09-17\",\"authors\":[{\"name\":\"Keelan Schule\",\"website\":\"https://www.linkedin.com/in/keelanschule/\",\"avatar\":\"https://avatars.githubusercontent.com/u/175734151?v=4\",\"login\":\"keelan-openai\"},{\"name\":\"Joe Casson\",\"website\":\"https://github.com/joecasson-openai\",\"avatar\":\"https://avatars.githubusercontent.com/u/178522625\",\"login\":\"joecasson-openai\"}],\"search_text\":\"$da\",\"type\":\"md\",\"tags\":[\"chatgpt\",\"gpt-actions-library\"],\"archived\":false},{\"name\":\"gpt_action_salesforce.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/chatgpt/gpt_actions_library/gpt_action_salesforce.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/chatgpt/gpt_actions_library/gpt_action_salesforce.ipynb\",\"internal_path\":\"examples/chatgpt/gpt_actions_library/gpt_action_salesforce\",\"title\":\"GPT Actions library - Salesforce\",\"path\":\"examples/chatgpt/gpt_actions_library/gpt_action_salesforce.ipynb\",\"date\":\"2024-07-18\",\"authors\":[{\"name\":\"Allison August\",\"website\":\"https://www.linkedin.com/in/allisonaugust/\",\"avatar\":\"https://avatars.githubusercontent.com/u/172655668?v=4\",\"login\":\"aa-openai\"}],\"search_text\":\"$db\",\"type\":\"ipynb\",\"tags\":[\"chatgpt\",\"gpt-actions-library\"],\"archived\":false},{\"name\":\"gpt_action_gmail.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/chatgpt/gpt_actions_library/gpt_action_gmail.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/chatgpt/gpt_actions_library/gpt_action_gmail.ipynb\",\"internal_path\":\"examples/chatgpt/gpt_actions_library/gpt_action_gmail\",\"title\":\"GPT Actions library - Gmail\",\"path\":\"examples/chatgpt/gpt_actions_library/gpt_action_gmail.ipynb\",\"date\":\"2024-07-24\",\"authors\":[{\"name\":\"Anthony Westmoreland\",\"website\":\"https://www.linkedin.com/in/westmorelandanthony/\",\"avatar\":\"https://avatars2.githubusercontent.com/u/175844346\",\"login\":\"alwestmo-openai\"}],\"search_text\":\"$dc\",\"type\":\"ipynb\",\"tags\":[\"chatgpt\",\"chatgpt-communication\",\"gpt-actions-library\"],\"archived\":false},{\"name\":\"gpt_action_jira.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/chatgpt/gpt_actions_library/gpt_action_jira.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/chatgpt/gpt_actions_library/gpt_action_jira.ipynb\",\"internal_path\":\"examples/chatgpt/gpt_actions_library/gpt_action_jira\",\"title\":\"GPT Actions library - Jira\",\"path\":\"examples/chatgpt/gpt_actions_library/gpt_action_jira.ipynb\",\"date\":\"2024-07-24\",\"authors\":[{\"name\":\"Rupert Truman\",\"website\":\"https://www.linkedin.com/in/rupert-truman/\",\"avatar\":\"https://avatars.githubusercontent.com/u/171234447\",\"login\":\"rupert-openai\"}],\"search_text\":\"$dd\",\"type\":\"ipynb\",\"tags\":[\"chatgpt\",\"chatgpt-productivity\",\"gpt-actions-library\"],\"archived\":false},{\"name\":\"gpt_action_notion.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/chatgpt/gpt_actions_library/gpt_action_notion.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/chatgpt/gpt_actions_library/gpt_action_notion.ipynb\",\"internal_path\":\"examples/chatgpt/gpt_actions_library/gpt_action_notion\",\"title\":\"GPT Actions library - Notion\",\"path\":\"examples/chatgpt/gpt_actions_library/gpt_action_notion.ipynb\",\"date\":\"2024-07-25\",\"authors\":[{\"name\":\"Daniel Halpern\",\"website\":\"https://www.linkedin.com/in/dhalp/\",\"avatar\":\"https://avatars.githubusercontent.com/u/175367970\",\"login\":\"dan-openai\"}],\"search_text\":\"$de\",\"type\":\"ipynb\",\"tags\":[\"chatgpt\",\"chatgpt-productivity\",\"gpt-actions-library\"],\"archived\":false},{\"name\":\"gpt_action_confluence.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/chatgpt/gpt_actions_library/gpt_action_confluence.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/chatgpt/gpt_actions_library/gpt_action_confluence.ipynb\",\"internal_path\":\"examples/chatgpt/gpt_actions_library/gpt_action_confluence\",\"title\":\"GPT Actions library - Confluence\",\"path\":\"examples/chatgpt/gpt_actions_library/gpt_action_confluence.ipynb\",\"date\":\"2024-07-31\",\"authors\":[{\"name\":\"Eric Szuhany\",\"website\":\"https://www.linkedin.com/in/szuhany/\",\"avatar\":\"https://avatars.githubusercontent.com/u/164391912\",\"login\":\"eszuhany-openai\"}],\"search_text\":\"$df\",\"type\":\"ipynb\",\"tags\":[\"chatgpt\",\"chatgpt-productivity\",\"gpt-actions-library\"],\"archived\":false},{\"name\":\"gpt_action_sql_database.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/chatgpt/gpt_actions_library/gpt_action_sql_database.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/chatgpt/gpt_actions_library/gpt_action_sql_database.ipynb\",\"internal_path\":\"examples/chatgpt/gpt_actions_library/gpt_action_sql_database\",\"title\":\"GPT Actions library - SQL Database\",\"path\":\"examples/chatgpt/gpt_actions_library/gpt_action_sql_database.ipynb\",\"date\":\"2024-07-31\",\"authors\":[{\"name\":\"Evan Weiss\",\"website\":\"https://www.linkedin.com/in/evanpweiss/\",\"avatar\":\"https://avatars.githubusercontent.com/u/150647345\",\"login\":\"evanweiss-openai\"}],\"search_text\":\"$e0\",\"type\":\"ipynb\",\"tags\":[\"chatgpt\",\"chatgpt-data\",\"gpt-actions-library\"],\"archived\":false},{\"name\":\"gpt_action_box.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/chatgpt/gpt_actions_library/gpt_action_box.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/chatgpt/gpt_actions_library/gpt_action_box.ipynb\",\"internal_path\":\"examples/chatgpt/gpt_actions_library/gpt_action_box\",\"title\":\"GPT Actions library - Box\",\"path\":\"examples/chatgpt/gpt_actions_library/gpt_action_box.ipynb\",\"date\":\"2024-08-02\",\"authors\":[{\"name\":\"Keelan Schule\",\"website\":\"https://www.linkedin.com/in/keelanschule/\",\"avatar\":\"https://avatars.githubusercontent.com/u/175734151?v=4\",\"login\":\"keelan-openai\"}],\"search_text\":\"$e1\",\"type\":\"ipynb\",\"tags\":[\"chatgpt\",\"chatgpt-productivity\",\"gpt-actions-library\"],\"archived\":false},{\"name\":\"Getting_started_with_bigquery_vector_search_and_openai.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/chatgpt/rag-quickstart/gcp/Getting_started_with_bigquery_vector_search_and_openai.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/chatgpt/rag-quickstart/gcp/Getting_started_with_bigquery_vector_search_and_openai.ipynb\",\"internal_path\":\"examples/chatgpt/rag-quickstart/gcp/getting_started_with_bigquery_vector_search_and_openai\",\"title\":\"GCP BigQuery Vector Search with GCP Functions and GPT Actions in ChatGPT\",\"path\":\"examples/chatgpt/rag-quickstart/gcp/Getting_started_with_bigquery_vector_search_and_openai.ipynb\",\"date\":\"2024-08-02\",\"authors\":[{\"name\":\"Pierre-Antoine Porte\",\"website\":\"https://www.linkedin.com/in/portepa/\",\"avatar\":\"https://avatars.githubusercontent.com/u/174109416?v=4\",\"login\":\"pap-openai\"},{\"login\":\"maxreid-openai\"}],\"search_text\":\"$e2\",\"type\":\"ipynb\",\"tags\":[\"chatgpt\",\"chatgpt-and-api\",\"completions\",\"embeddings\",\"tiktoken\"],\"archived\":false},{\"name\":\"gpt_action_zapier.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/chatgpt/gpt_actions_library/gpt_action_zapier.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/chatgpt/gpt_actions_library/gpt_action_zapier.ipynb\",\"internal_path\":\"examples/chatgpt/gpt_actions_library/gpt_action_zapier\",\"title\":\"GPT Actions library - Zapier\",\"path\":\"examples/chatgpt/gpt_actions_library/gpt_action_zapier.ipynb\",\"date\":\"2024-08-05\",\"authors\":[{\"name\":\"Daniel Halpern\",\"website\":\"https://www.linkedin.com/in/dhalp/\",\"avatar\":\"https://avatars.githubusercontent.com/u/175367970\",\"login\":\"dan-openai\"}],\"search_text\":\"$e3\",\"type\":\"ipynb\",\"tags\":[\"chatgpt\",\"chatgpt-middleware\",\"gpt-actions-library\"],\"archived\":false},{\"name\":\"Structured_outputs_multi_agent.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/Structured_outputs_multi_agent.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/Structured_outputs_multi_agent.ipynb\",\"internal_path\":\"examples/structured_outputs_multi_agent\",\"title\":\"Structured Outputs for Multi-Agent Systems\",\"path\":\"examples/Structured_outputs_multi_agent.ipynb\",\"date\":\"2024-08-06\",\"authors\":[{\"name\":\"Dylan Royan Almeida\",\"website\":\"https://www.linkedin.com/in/dylan-almeida-604522167/\",\"avatar\":\"https://avatars.githubusercontent.com/u/149511600?v=4\",\"login\":\"dylanra-openai\"}],\"search_text\":\"$e4\",\"type\":\"ipynb\",\"tags\":[\"agents\",\"completions\",\"functions\"],\"archived\":false},{\"name\":\"Structured_Outputs_Intro.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/Structured_Outputs_Intro.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/Structured_Outputs_Intro.ipynb\",\"internal_path\":\"examples/structured_outputs_intro\",\"title\":\"Introduction to Structured Outputs\",\"path\":\"examples/Structured_Outputs_Intro.ipynb\",\"date\":\"2024-08-06\",\"authors\":[{\"name\":\"Katia Gil Guzman\",\"website\":\"https://katia.gg\",\"avatar\":\"https://avatars.githubusercontent.com/u/16519462?v=4\",\"login\":\"katiagg\"}],\"search_text\":\"$e5\",\"type\":\"ipynb\",\"tags\":[\"completions\",\"functions\"],\"archived\":false},{\"name\":\"gpt_middleware_google_cloud_function.md\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/chatgpt/gpt_actions_library/gpt_middleware_google_cloud_function.md\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/chatgpt/gpt_actions_library/gpt_middleware_google_cloud_function.md\",\"internal_path\":\"examples/chatgpt/gpt_actions_library/gpt_middleware_google_cloud_function\",\"title\":\"GPT Actions library (Middleware) - Google Cloud Function\",\"path\":\"examples/chatgpt/gpt_actions_library/gpt_middleware_google_cloud_function.md\",\"date\":\"2024-08-11\",\"authors\":[{\"name\":\"Girish Dusane\",\"website\":\"https://www.linkedin.com/in/girishdusane/\",\"avatar\":\"https://avatars.githubusercontent.com/u/272708\",\"login\":\"girishd\"}],\"search_text\":\"$e6\",\"type\":\"md\",\"tags\":[\"chatgpt\",\"chatgpt-middleware\",\"gpt-actions-library\"],\"archived\":false},{\"name\":\"gpt_action_redshift.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/chatgpt/gpt_actions_library/gpt_action_redshift.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/chatgpt/gpt_actions_library/gpt_action_redshift.ipynb\",\"internal_path\":\"examples/chatgpt/gpt_actions_library/gpt_action_redshift\",\"title\":\"GPT Actions library - AWS Redshift\",\"path\":\"examples/chatgpt/gpt_actions_library/gpt_action_redshift.ipynb\",\"date\":\"2024-08-09\",\"authors\":[{\"name\":\"Pierre-Antoine Porte\",\"website\":\"https://www.linkedin.com/in/portepa/\",\"avatar\":\"https://avatars.githubusercontent.com/u/174109416?v=4\",\"login\":\"pap-openai\"}],\"search_text\":\"$e7\",\"type\":\"ipynb\",\"tags\":[\"chatgpt\",\"chatgpt-data\",\"gpt-actions-library\"],\"archived\":false},{\"name\":\"gpt_middleware_aws_function.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/chatgpt/gpt_actions_library/gpt_middleware_aws_function.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/chatgpt/gpt_actions_library/gpt_middleware_aws_function.ipynb\",\"internal_path\":\"examples/chatgpt/gpt_actions_library/gpt_middleware_aws_function\",\"title\":\"GPT Actions library - AWS Middleware\",\"path\":\"examples/chatgpt/gpt_actions_library/gpt_middleware_aws_function.ipynb\",\"date\":\"2024-08-09\",\"authors\":[{\"name\":\"Pierre-Antoine Porte\",\"website\":\"https://www.linkedin.com/in/portepa/\",\"avatar\":\"https://avatars.githubusercontent.com/u/174109416?v=4\",\"login\":\"pap-openai\"}],\"search_text\":\"$e8\",\"type\":\"ipynb\",\"tags\":[\"chatgpt\",\"chatgpt-middleware\",\"gpt-actions-library\"],\"archived\":false},{\"name\":\"gpt_action_google_drive.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/chatgpt/gpt_actions_library/gpt_action_google_drive.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/chatgpt/gpt_actions_library/gpt_action_google_drive.ipynb\",\"internal_path\":\"examples/chatgpt/gpt_actions_library/gpt_action_google_drive\",\"title\":\"GPT Actions library - Google Drive\",\"path\":\"examples/chatgpt/gpt_actions_library/gpt_action_google_drive.ipynb\",\"date\":\"2024-08-11\",\"authors\":[{\"name\":\"Luke Xing\",\"website\":\"https://www.linkedin.com/in/lukexing/\",\"avatar\":\"https://avatars.githubusercontent.com/u/176698727\",\"login\":\"lxing-oai\"}],\"search_text\":\"$e9\",\"type\":\"ipynb\",\"tags\":[\"chatgpt\",\"chatgpt-productivity\",\"gpt-actions-library\"],\"archived\":false},{\"name\":\"gpt_action_snowflake_direct.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/chatgpt/gpt_actions_library/gpt_action_snowflake_direct.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/chatgpt/gpt_actions_library/gpt_action_snowflake_direct.ipynb\",\"internal_path\":\"examples/chatgpt/gpt_actions_library/gpt_action_snowflake_direct\",\"title\":\"GPT Actions library - Snowflake Direct\",\"path\":\"examples/chatgpt/gpt_actions_library/gpt_action_snowflake_direct.ipynb\",\"date\":\"2024-08-13\",\"authors\":[{\"name\":\"Kevin Gladstone\",\"website\":\"https://github.com/gladstone-openai\",\"avatar\":\"https://avatars.githubusercontent.com/u/149190645\",\"login\":\"gladstone-openai\"}],\"search_text\":\"$ea\",\"type\":\"ipynb\",\"tags\":[\"chatgpt\",\"chatgpt-data\",\"gpt-actions-library\"],\"archived\":false},{\"name\":\"gpt_action_snowflake_middleware.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/chatgpt/gpt_actions_library/gpt_action_snowflake_middleware.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/chatgpt/gpt_actions_library/gpt_action_snowflake_middleware.ipynb\",\"internal_path\":\"examples/chatgpt/gpt_actions_library/gpt_action_snowflake_middleware\",\"title\":\"GPT Actions library - Snowflake Middleware\",\"path\":\"examples/chatgpt/gpt_actions_library/gpt_action_snowflake_middleware.ipynb\",\"date\":\"2024-08-14\",\"authors\":[{\"name\":\"Kevin Gladstone\",\"website\":\"https://github.com/gladstone-openai\",\"avatar\":\"https://avatars.githubusercontent.com/u/149190645\",\"login\":\"gladstone-openai\"}],\"search_text\":\"$eb\",\"type\":\"ipynb\",\"tags\":[\"chatgpt\",\"chatgpt-data\",\"gpt-actions-library\"],\"archived\":false},{\"name\":\"gpt_action_retool_workflow.md\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/chatgpt/gpt_actions_library/gpt_action_retool_workflow.md\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/chatgpt/gpt_actions_library/gpt_action_retool_workflow.md\",\"internal_path\":\"examples/chatgpt/gpt_actions_library/gpt_action_retool_workflow\",\"title\":\"GPT Actions library - Retool Workflow\",\"path\":\"examples/chatgpt/gpt_actions_library/gpt_action_retool_workflow.md\",\"date\":\"2024-08-28\",\"authors\":[{\"name\":\"Lee Spacagna\",\"website\":\"https://github.com/lspacagna-oai\",\"avatar\":\"https://avatars.githubusercontent.com/u/175367019\",\"login\":\"lspacagna-oai\"}],\"search_text\":\"$ec\",\"type\":\"md\",\"tags\":[\"chatgpt\",\"chatgpt-middleware\",\"gpt-actions-library\"],\"archived\":false},{\"name\":\"Using_reasoning_for_data_validation.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/o1/Using_reasoning_for_data_validation.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/o1/Using_reasoning_for_data_validation.ipynb\",\"internal_path\":\"examples/o1/using_reasoning_for_data_validation\",\"title\":\"Using reasoning for data validation\",\"path\":\"examples/o1/Using_reasoning_for_data_validation.ipynb\",\"date\":\"2024-09-12\",\"authors\":[{\"name\":\"Roy Ziv\",\"website\":\"https://www.linkedin.com/in/roy-ziv-a46001149/\",\"avatar\":\"https://avatars.githubusercontent.com/u/103690170?v=4\",\"login\":\"royziv11\"}],\"search_text\":\"$ed\",\"type\":\"ipynb\",\"tags\":[\"completions\",\"reasoning\"],\"archived\":false},{\"name\":\"Using_reasoning_for_routine_generation.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/o1/Using_reasoning_for_routine_generation.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/o1/Using_reasoning_for_routine_generation.ipynb\",\"internal_path\":\"examples/o1/using_reasoning_for_routine_generation\",\"title\":\"Using reasoning for routine generation\",\"path\":\"examples/o1/Using_reasoning_for_routine_generation.ipynb\",\"date\":\"2024-09-12\",\"authors\":[{\"name\":\"Roy Ziv\",\"website\":\"https://www.linkedin.com/in/roy-ziv-a46001149/\",\"avatar\":\"https://avatars.githubusercontent.com/u/103690170?v=4\",\"login\":\"royziv11\"}],\"search_text\":\"$ee\",\"type\":\"ipynb\",\"tags\":[\"completions\",\"reasoning\"],\"archived\":false},{\"name\":\"Using_chained_calls_for_o1_structured_outputs.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/o1/Using_chained_calls_for_o1_structured_outputs.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/o1/Using_chained_calls_for_o1_structured_outputs.ipynb\",\"internal_path\":\"examples/o1/using_chained_calls_for_o1_structured_outputs\",\"title\":\"Using chained calls for o1 structured outputs\",\"path\":\"examples/o1/Using_chained_calls_for_o1_structured_outputs.ipynb\",\"date\":\"2024-09-26\",\"authors\":[{\"name\":\"Eric Ning\",\"website\":\"https://github.com/ericning-o\",\"avatar\":\"https://avatars.githubusercontent.com/u/182030612\",\"login\":\"ericning-o\"}],\"search_text\":\"$ef\",\"type\":\"ipynb\",\"tags\":[\"completions\",\"reasoning\"],\"archived\":false},{\"name\":\"Web_search_with_google_api_bring_your_own_browser_tool.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/third_party/Web_search_with_google_api_bring_your_own_browser_tool.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/third_party/Web_search_with_google_api_bring_your_own_browser_tool.ipynb\",\"internal_path\":\"examples/third_party/web_search_with_google_api_bring_your_own_browser_tool\",\"title\":\"Building a Bring Your Own Browser (BYOB) Tool for Web Browsing and Summarization\",\"path\":\"examples/third_party/Web_search_with_google_api_bring_your_own_browser_tool.ipynb\",\"date\":\"2024-09-26\",\"authors\":[{\"name\":\"Mandeep Singh\",\"website\":\"https://github.com/msingh-openai\",\"avatar\":\"https://avatars.githubusercontent.com/u/168678187?v=4\",\"login\":\"msingh-openai\"}],\"search_text\":\"$f0\",\"type\":\"ipynb\",\"tags\":[\"completions\"],\"archived\":false},{\"name\":\"Prompt_Caching101.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/Prompt_Caching101.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/Prompt_Caching101.ipynb\",\"internal_path\":\"examples/prompt_caching101\",\"title\":\"Prompt Caching 101\",\"path\":\"examples/Prompt_Caching101.ipynb\",\"date\":\"2024-10-01\",\"authors\":[{\"name\":\"Charu Jaiswal\",\"website\":\"https://www.linkedin.com/in/charu-j-8a866471\",\"avatar\":\"https://avatars.githubusercontent.com/u/18404643?v=4\",\"login\":\"charuj\"}],\"search_text\":\"$f1\",\"type\":\"ipynb\",\"tags\":[\"completions\",\"cost\",\"latency\",\"prompt caching\"],\"archived\":false},{\"name\":\"gpt_action_googleads_adzviser.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/chatgpt/gpt_actions_library/gpt_action_googleads_adzviser.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/chatgpt/gpt_actions_library/gpt_action_googleads_adzviser.ipynb\",\"internal_path\":\"examples/chatgpt/gpt_actions_library/gpt_action_googleads_adzviser\",\"title\":\"GPT Actions library - Google Ads via Adzviser\",\"path\":\"examples/chatgpt/gpt_actions_library/gpt_action_googleads_adzviser.ipynb\",\"date\":\"2024-10-10\",\"authors\":[{\"name\":\"Zeyuan Gu\",\"website\":\"https://www.linkedin.com/in/goo/\",\"avatar\":\"https://avatars.githubusercontent.com/u/25328738\",\"login\":\"zeyuangu-adzviser\"}],\"search_text\":\"$f2\",\"type\":\"ipynb\",\"tags\":[\"chatgpt\",\"chatgpt-data\",\"chatgpt-middleware\",\"chatgpt-productivity\",\"gpt-actions-library\"],\"archived\":false},{\"name\":\"Leveraging_model_distillation_to_fine-tune_a_model.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/Leveraging_model_distillation_to_fine-tune_a_model.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/Leveraging_model_distillation_to_fine-tune_a_model.ipynb\",\"internal_path\":\"examples/leveraging_model_distillation_to_fine-tune_a_model\",\"title\":\"Leveraging model distillation to fine-tune a model\",\"path\":\"examples/Leveraging_model_distillation_to_fine-tune_a_model.ipynb\",\"date\":\"2024-10-16\",\"authors\":[{\"name\":\"Pierre-Antoine Porte\",\"website\":\"https://www.linkedin.com/in/portepa/\",\"avatar\":\"https://avatars.githubusercontent.com/u/174109416?v=4\",\"login\":\"pap-openai\"}],\"search_text\":\"$f3\",\"type\":\"ipynb\",\"tags\":[\"completions\",\"fine-tuning\"],\"archived\":false},{\"name\":\"voice_translation_into_different_languages_using_GPT-4o.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/voice_solutions/voice_translation_into_different_languages_using_GPT-4o.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/voice_solutions/voice_translation_into_different_languages_using_GPT-4o.ipynb\",\"internal_path\":\"examples/voice_solutions/voice_translation_into_different_languages_using_gpt-4o\",\"title\":\"Voice Translation into Different Languages\",\"path\":\"examples/voice_solutions/voice_translation_into_different_languages_using_GPT-4o.ipynb\",\"date\":\"2024-10-21\",\"authors\":[{\"name\":\"Mandeep Singh\",\"website\":\"https://github.com/msingh-openai\",\"avatar\":\"https://avatars.githubusercontent.com/u/168678187?v=4\",\"login\":\"msingh-openai\"}],\"search_text\":\"$f4\",\"type\":\"ipynb\",\"tags\":[\"audio\",\"completions\"],\"archived\":false},{\"name\":\"Enhance_your_prompts_with_meta_prompting.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/Enhance_your_prompts_with_meta_prompting.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/Enhance_your_prompts_with_meta_prompting.ipynb\",\"internal_path\":\"examples/enhance_your_prompts_with_meta_prompting\",\"title\":\"Enhance your prompts with meta prompting\",\"path\":\"examples/Enhance_your_prompts_with_meta_prompting.ipynb\",\"date\":\"2024-10-23\",\"authors\":[{\"name\":\"Teodora Musatoiu\",\"website\":\"https://www.linkedin.com/in/teodora-musatoiu/\",\"avatar\":\"https://avatars.githubusercontent.com/u/156829031?s=400\u0026u=af40fe04d9255139eb3bbf8dc83422cc694e862b\u0026v=4\",\"login\":\"teomusatoiu\"}],\"search_text\":\"$f5\",\"type\":\"ipynb\",\"tags\":[\"completions\",\"reasoning\"],\"archived\":false},{\"name\":\"gpt_action_github.md\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/chatgpt/gpt_actions_library/gpt_action_github.md\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/chatgpt/gpt_actions_library/gpt_action_github.md\",\"internal_path\":\"examples/chatgpt/gpt_actions_library/gpt_action_github\",\"title\":\"GPT Actions library - GitHub\",\"path\":\"examples/chatgpt/gpt_actions_library/gpt_action_github.md\",\"date\":\"2024-10-23\",\"authors\":[{\"name\":\"Kevin Alwell\",\"website\":\"https://github.com/alwell-kevin\",\"avatar\":\"https://avatars.githubusercontent.com/u/26548363\",\"login\":\"alwell-kevin\"}],\"search_text\":\"$f6\",\"type\":\"md\",\"tags\":[\"chatgpt\",\"chatgpt-productivity\",\"gpt-actions-library\"],\"archived\":false},{\"name\":\"Custom-LLM-as-a-Judge.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/Custom-LLM-as-a-Judge.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/Custom-LLM-as-a-Judge.ipynb\",\"internal_path\":\"examples/custom-llm-as-a-judge\",\"title\":\"Custom LLM as a Judge to Detect Hallucinations with Braintrust\",\"path\":\"examples/Custom-LLM-as-a-Judge.ipynb\",\"date\":\"2024-10-14\",\"authors\":[{\"login\":\"ankrgyl\"},{\"name\":\"Shyamal Anadkat\",\"website\":\"https://twitter.com/shyamalanadkat\",\"avatar\":\"https://pbs.twimg.com/profile_images/1590564338682560512/3bbZJqxZ_400x400.jpg\",\"login\":\"shyamal-anadkat\"}],\"search_text\":\"$f7\",\"type\":\"ipynb\",\"tags\":[\"completions\",\"evals\"],\"archived\":false},{\"name\":\"Vision_Fine_tuning_on_GPT4o_for_Visual_Question_Answering.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/multimodal/Vision_Fine_tuning_on_GPT4o_for_Visual_Question_Answering.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/multimodal/Vision_Fine_tuning_on_GPT4o_for_Visual_Question_Answering.ipynb\",\"internal_path\":\"examples/multimodal/vision_fine_tuning_on_gpt4o_for_visual_question_answering\",\"title\":\"Vision Fine-tuning on GPT-4o for Visual Question Answering\",\"path\":\"examples/multimodal/Vision_Fine_tuning_on_GPT4o_for_Visual_Question_Answering.ipynb\",\"date\":\"2024-11-01\",\"authors\":[{\"name\":\"Danial Mirza\",\"website\":\"https://github.com/danial-openai\",\"avatar\":\"https://avatars.githubusercontent.com/u/178343703\",\"login\":\"danial-openai\"}],\"search_text\":\"$f8\",\"type\":\"ipynb\",\"tags\":[\"completions\",\"fine-tuning\",\"vision\"],\"archived\":false},{\"name\":\"steering_tts.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/voice_solutions/steering_tts.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/voice_solutions/steering_tts.ipynb\",\"internal_path\":\"examples/voice_solutions/steering_tts\",\"title\":\"Steering Text-to-Speech for more dynamic audio generation\",\"path\":\"examples/voice_solutions/steering_tts.ipynb\",\"date\":\"2024-11-01\",\"authors\":[{\"name\":\"Eric Ning\",\"website\":\"https://github.com/ericning-o\",\"avatar\":\"https://avatars.githubusercontent.com/u/182030612\",\"login\":\"ericning-o\"},{\"name\":\"Guillermo Bergengruen\",\"website\":\"https://github.com/gbergengruen\",\"avatar\":\"https://avatars.githubusercontent.com/u/140010883\",\"login\":\"gbergengruen\"}],\"search_text\":\"$f9\",\"type\":\"ipynb\",\"tags\":[\"audio\",\"completions\"],\"archived\":false},{\"name\":\"gpt-action-pinecone-retool-rag.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/chatgpt/rag-quickstart/pinecone-retool/gpt-action-pinecone-retool-rag.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/chatgpt/rag-quickstart/pinecone-retool/gpt-action-pinecone-retool-rag.ipynb\",\"internal_path\":\"examples/chatgpt/rag-quickstart/pinecone-retool/gpt-action-pinecone-retool-rag\",\"title\":\"Pinecone Vector Database and Retool Workflow with GPT Actions\",\"path\":\"examples/chatgpt/rag-quickstart/pinecone-retool/gpt-action-pinecone-retool-rag.ipynb\",\"date\":\"2024-11-11\",\"authors\":[{\"name\":\"Lee Spacagna\",\"website\":\"https://github.com/lspacagna-oai\",\"avatar\":\"https://avatars.githubusercontent.com/u/175367019\",\"login\":\"lspacagna-oai\"}],\"search_text\":\"$fa\",\"type\":\"ipynb\",\"tags\":[\"chatgpt\",\"chatgpt-and-api\",\"embeddings\",\"gpt-actions-library\"],\"archived\":false},{\"name\":\"Using_vision_modality_for_RAG_with_Pinecone.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/vector_databases/pinecone/Using_vision_modality_for_RAG_with_Pinecone.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/vector_databases/pinecone/Using_vision_modality_for_RAG_with_Pinecone.ipynb\",\"internal_path\":\"examples/vector_databases/pinecone/using_vision_modality_for_rag_with_pinecone\",\"title\":\"Optimizing Retrieval-Augmented Generation using GPT-4o Vision Modality\",\"path\":\"examples/vector_databases/pinecone/Using_vision_modality_for_RAG_with_Pinecone.ipynb\",\"date\":\"2024-11-12\",\"authors\":[{\"name\":\"Mandeep Singh\",\"website\":\"https://github.com/msingh-openai\",\"avatar\":\"https://avatars.githubusercontent.com/u/168678187?v=4\",\"login\":\"msingh-openai\"}],\"search_text\":\"$fb\",\"type\":\"ipynb\",\"tags\":[\"completions\",\"vision\"],\"archived\":false},{\"name\":\"gpt_action_workday.md\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/chatgpt/gpt_actions_library/gpt_action_workday.md\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/chatgpt/gpt_actions_library/gpt_action_workday.md\",\"internal_path\":\"examples/chatgpt/gpt_actions_library/gpt_action_workday\",\"title\":\"GPT Actions library - Workday\",\"path\":\"examples/chatgpt/gpt_actions_library/gpt_action_workday.md\",\"date\":\"2024-11-20\",\"authors\":[{\"name\":\"Erick Gort\",\"website\":\"https://www.linkedin.com/in/erick-gort-32ab1678/\",\"avatar\":\"https://avatars.githubusercontent.com/u/189261906?v=4\",\"login\":\"erickgort\"},{\"name\":\"Pierre-Antoine Porte\",\"website\":\"https://www.linkedin.com/in/portepa/\",\"avatar\":\"https://avatars.githubusercontent.com/u/174109416?v=4\",\"login\":\"pap-openai\"}],\"search_text\":\"$fc\",\"type\":\"md\",\"tags\":[\"chatgpt\",\"chatgpt-productivity\",\"gpt-actions-library\"],\"archived\":false},{\"name\":\"gpt_action_google_calendar.md\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/chatgpt/gpt_actions_library/gpt_action_google_calendar.md\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/chatgpt/gpt_actions_library/gpt_action_google_calendar.md\",\"internal_path\":\"examples/chatgpt/gpt_actions_library/gpt_action_google_calendar\",\"title\":\"GPT Actions library - Google Calendar\",\"path\":\"examples/chatgpt/gpt_actions_library/gpt_action_google_calendar.md\",\"date\":\"2024-11-22\",\"authors\":[{\"name\":\"Lee Spacagna\",\"website\":\"https://github.com/lspacagna-oai\",\"avatar\":\"https://avatars.githubusercontent.com/u/175367019\",\"login\":\"lspacagna-oai\"}],\"search_text\":\"$fd\",\"type\":\"md\",\"tags\":[\"chatgpt\",\"chatgpt-communication\",\"gpt-actions-library\"],\"archived\":false},{\"name\":\"gpt_action_trayai_apim.md\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/chatgpt/gpt_actions_library/gpt_action_trayai_apim.md\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/chatgpt/gpt_actions_library/gpt_action_trayai_apim.md\",\"internal_path\":\"examples/chatgpt/gpt_actions_library/gpt_action_trayai_apim\",\"title\":\"GPT Actions library - Tray.ai APIM\",\"path\":\"examples/chatgpt/gpt_actions_library/gpt_action_trayai_apim.md\",\"date\":\"2024-11-26\",\"authors\":[{\"name\":\"Kyle Cote\",\"website\":\"https://github.com/kylecote-tray\",\"avatar\":\"https://avatars.githubusercontent.com/u/53836176\",\"login\":\"kylecote-tray\"}],\"search_text\":\"$fe\",\"type\":\"md\",\"tags\":[\"chatgpt\",\"chatgpt-middleware\",\"gpt-actions-library\"],\"archived\":false},{\"name\":\"Code_quality_and_security_scan_with_GitHub_Actions.md\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/third_party/Code_quality_and_security_scan_with_GitHub_Actions.md\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/third_party/Code_quality_and_security_scan_with_GitHub_Actions.md\",\"internal_path\":\"examples/third_party/code_quality_and_security_scan_with_github_actions\",\"title\":\"Reasoning over Code Quality and Security in GitHub Pull Requests\",\"path\":\"examples/third_party/Code_quality_and_security_scan_with_GitHub_Actions.md\",\"date\":\"2024-12-24\",\"authors\":[{\"name\":\"Kevin Alwell\",\"website\":\"https://github.com/alwell-kevin\",\"avatar\":\"https://avatars.githubusercontent.com/u/26548363\",\"login\":\"alwell-kevin\"}],\"search_text\":\"$ff\",\"type\":\"md\",\"tags\":[\"SDLC\",\"completions\",\"reasoning\"],\"archived\":false},{\"name\":\"How_to_evaluate_LLMs_for_SQL_generation.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/evaluation/How_to_evaluate_LLMs_for_SQL_generation.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/evaluation/How_to_evaluate_LLMs_for_SQL_generation.ipynb\",\"internal_path\":\"examples/evaluation/how_to_evaluate_llms_for_sql_generation\",\"title\":\"How to evaluate LLMs for SQL generation\",\"path\":\"examples/evaluation/How_to_evaluate_LLMs_for_SQL_generation.ipynb\",\"date\":\"2024-01-23\",\"authors\":[{\"name\":\"Colin Jarvis\",\"website\":\"https://twitter.com/colintjarvis\",\"avatar\":\"https://pbs.twimg.com/profile_images/1727207339034345472/IM8v8tlC_400x400.jpg\",\"login\":\"colin-openai\"}],\"search_text\":\"$100\",\"type\":\"ipynb\",\"tags\":[\"guardrails\"],\"archived\":false},{\"name\":\"completions_usage_api.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/completions_usage_api.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/completions_usage_api.ipynb\",\"internal_path\":\"examples/completions_usage_api\",\"title\":\"How to use the Usage API and Cost API to monitor your OpenAI usage\",\"path\":\"examples/completions_usage_api.ipynb\",\"date\":\"2025-01-14\",\"authors\":[{\"name\":\"Mitch Welzen\",\"website\":\"https://www.linkedin.com/in/mitchwelzen/\",\"avatar\":\"https://media.licdn.com/dms/image/v2/C5603AQHC8-1q4MwH1A/profile-displayphoto-shrink_800_800/profile-displayphoto-shrink_800_800/0/1592824550774?e=1742428800\u0026v=beta\u0026t=3mudgDyuzNU2a4gx1gue4DPyhaui7kbB7e7U8vyOo-g\",\"login\":\"MW-OAI\"},{\"name\":\"Thomas Li\",\"website\":\"https://www.linkedin.com/in/thli/\",\"avatar\":\"https://avatars.githubusercontent.com/u/189043632?v=4\",\"login\":\"thli-openai\"}],\"search_text\":\"$101\",\"type\":\"ipynb\",\"tags\":[\"cost-api\",\"usage-api\"],\"archived\":false},{\"name\":\"Secure_code_interpreter_tool_for_LLM_agents.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/object_oriented_agentic_approach/Secure_code_interpreter_tool_for_LLM_agents.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/object_oriented_agentic_approach/Secure_code_interpreter_tool_for_LLM_agents.ipynb\",\"internal_path\":\"examples/object_oriented_agentic_approach/secure_code_interpreter_tool_for_llm_agents\",\"title\":\"Build Your Own Code Interpreter - Dynamic Tool Generation and Execution With o3-mini\",\"path\":\"examples/object_oriented_agentic_approach/Secure_code_interpreter_tool_for_LLM_agents.ipynb\",\"date\":\"2025-02-03\",\"authors\":[{\"name\":\"Mandeep Singh\",\"website\":\"https://github.com/msingh-openai\",\"avatar\":\"https://avatars.githubusercontent.com/u/168678187?v=4\",\"login\":\"msingh-openai\"}],\"search_text\":\"$102\",\"type\":\"ipynb\",\"tags\":[\"completions\"],\"archived\":false},{\"name\":\"File_Search_Responses.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/File_Search_Responses.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/File_Search_Responses.ipynb\",\"internal_path\":\"examples/file_search_responses\",\"title\":\"Doing RAG on PDFs using File Search in the Responses API\",\"path\":\"examples/File_Search_Responses.ipynb\",\"date\":\"2025-03-11\",\"authors\":[{\"name\":\"Pierre-Antoine Porte\",\"website\":\"https://www.linkedin.com/in/portepa/\",\"avatar\":\"https://avatars.githubusercontent.com/u/174109416?v=4\",\"login\":\"pap-openai\"}],\"search_text\":\"$103\",\"type\":\"ipynb\",\"tags\":[\"functions\",\"responses\"],\"archived\":false},{\"name\":\"app_assistant_voice_agents.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/agents_sdk/app_assistant_voice_agents.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/agents_sdk/app_assistant_voice_agents.ipynb\",\"internal_path\":\"examples/agents_sdk/app_assistant_voice_agents\",\"title\":\"Building a Voice Assistant with the Agents SDK\",\"path\":\"examples/agents_sdk/app_assistant_voice_agents.ipynb\",\"date\":\"2025-03-27\",\"authors\":[{\"name\":\"Rupert Truman\",\"website\":\"https://www.linkedin.com/in/rupert-truman/\",\"avatar\":\"https://avatars.githubusercontent.com/u/171234447\",\"login\":\"rupert-openai\"}],\"search_text\":\"$104\",\"type\":\"ipynb\",\"tags\":[\"audio\",\"responses\",\"speech\"],\"archived\":false},{\"name\":\"one_way_translation_using_realtime_api.mdx\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/voice_solutions/one_way_translation_using_realtime_api.mdx\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/voice_solutions/one_way_translation_using_realtime_api.mdx\",\"internal_path\":\"examples/voice_solutions/one_way_translation_using_realtime_api\",\"title\":\"Multi-Language One-Way Translation with the Realtime API\",\"path\":\"examples/voice_solutions/one_way_translation_using_realtime_api.mdx\",\"date\":\"2025-03-24\",\"authors\":[{\"name\":\"Erika Kettleson\",\"website\":\"https://www.linkedin.com/in/erika-kettleson-85763196/\",\"avatar\":\"https://avatars.githubusercontent.com/u/186107044?v=4\",\"login\":\"erikakettleson-openai\"}],\"search_text\":\"$105\",\"type\":\"mdx\",\"tags\":[\"audio\",\"speech\"],\"archived\":false},{\"name\":\"evaluate_agents.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/agents_sdk/evaluate_agents.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/agents_sdk/evaluate_agents.ipynb\",\"internal_path\":\"examples/agents_sdk/evaluate_agents\",\"title\":\"Evaluating Agents with Langfuse\",\"path\":\"examples/agents_sdk/evaluate_agents.ipynb\",\"date\":\"2025-03-31\",\"authors\":[{\"name\":\"Jannik Maierhöfer\",\"website\":\"https://www.linkedin.com/in/maierhoefer/\",\"avatar\":\"https://avatars.githubusercontent.com/u/48529566?v=4\",\"login\":\"jannik-maierhofer\"}],\"search_text\":\"$106\",\"type\":\"ipynb\",\"tags\":[\"agents-sdk\",\"evals\"],\"archived\":false},{\"name\":\"gpt_action_salesforce_gong.md\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/chatgpt/gpt_actions_library/gpt_action_salesforce_gong.md\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/chatgpt/gpt_actions_library/gpt_action_salesforce_gong.md\",\"internal_path\":\"examples/chatgpt/gpt_actions_library/gpt_action_salesforce_gong\",\"title\":\"GPT Actions library - Salesforce \u0026 Gong\",\"path\":\"examples/chatgpt/gpt_actions_library/gpt_action_salesforce_gong.md\",\"date\":\"2025-04-07\",\"authors\":[{\"name\":\"Girish Dusane\",\"website\":\"https://www.linkedin.com/in/girishdusane/\",\"avatar\":\"https://avatars.githubusercontent.com/u/272708\",\"login\":\"girishd\"}],\"search_text\":\"$107\",\"type\":\"md\",\"tags\":[\"chatgpt\",\"chatgpt-productivity\",\"gpt-actions-library\"],\"archived\":false},{\"name\":\"gpt4-1_prompting_guide.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/gpt4-1_prompting_guide.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/gpt4-1_prompting_guide.ipynb\",\"internal_path\":\"examples/gpt4-1_prompting_guide\",\"title\":\"GPT-4.1 Prompting Guide\",\"path\":\"examples/gpt4-1_prompting_guide.ipynb\",\"date\":\"2025-04-14\",\"authors\":[{\"name\":\"Noah MacCallum\",\"website\":\"https://x.com/noahmacca\",\"avatar\":\"https://avatars.githubusercontent.com/u/171723556\",\"login\":\"nm-openai\"},{\"name\":\"Julian Lee\",\"website\":\"https://x.com/julianl093\",\"avatar\":\"https://avatars.githubusercontent.com/u/199828632\",\"login\":\"julian-openai\"}],\"search_text\":\"$108\",\"type\":\"ipynb\",\"tags\":[\"api\",\"responses\"],\"archived\":false},{\"name\":\"Generate_Images_With_GPT_Image.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/Generate_Images_With_GPT_Image.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/Generate_Images_With_GPT_Image.ipynb\",\"internal_path\":\"examples/generate_images_with_gpt_image\",\"title\":\"Generate images with GPT Image\",\"path\":\"examples/Generate_Images_With_GPT_Image.ipynb\",\"date\":\"2025-04-23\",\"authors\":[{\"name\":\"Katia Gil Guzman\",\"website\":\"https://katia.gg\",\"avatar\":\"https://avatars.githubusercontent.com/u/16519462?v=4\",\"login\":\"katiagg\"}],\"search_text\":\"$109\",\"type\":\"ipynb\",\"tags\":[\"images\"],\"archived\":false},{\"name\":\"reasoning_function_calls.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/reasoning_function_calls.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/reasoning_function_calls.ipynb\",\"internal_path\":\"examples/reasoning_function_calls\",\"title\":\"Handling Function Calls with Reasoning Models\",\"path\":\"examples/reasoning_function_calls.ipynb\",\"date\":\"2025-04-25\",\"authors\":[{\"name\":\"Tom Pakeman\",\"website\":\"https://www.linkedin.com/in/tom-pakeman/\",\"avatar\":\"https://avatars.githubusercontent.com/u/204937754\",\"login\":\"tompakeman-oai\"}],\"search_text\":\"$10a\",\"type\":\"ipynb\",\"tags\":[\"api\",\"functions\",\"reasoning\",\"responses\"],\"archived\":false},{\"name\":\"parallel_agents.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/agents_sdk/parallel_agents.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/agents_sdk/parallel_agents.ipynb\",\"internal_path\":\"examples/agents_sdk/parallel_agents\",\"title\":\"Parallel Agents with the OpenAI Agents SDK\",\"path\":\"examples/agents_sdk/parallel_agents.ipynb\",\"date\":\"2025-05-01\",\"authors\":[{\"name\":\"Brandon Baker\",\"website\":\"https://www.linkedin.com/in/brandonbaker18\",\"avatar\":\"https://avatars.githubusercontent.com/u/208719822\",\"login\":\"brandonbaker-openai\"}],\"search_text\":\"$10b\",\"type\":\"ipynb\",\"tags\":[\"agents\",\"agents-sdk\",\"parallel-agents\"],\"archived\":false},{\"name\":\"Data-intensive-Realtime-apps.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/Data-intensive-Realtime-apps.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/Data-intensive-Realtime-apps.ipynb\",\"internal_path\":\"examples/data-intensive-realtime-apps\",\"title\":\"Practical guide to data-intensive apps with the Realtime API\",\"path\":\"examples/Data-intensive-Realtime-apps.ipynb\",\"date\":\"2025-05-29\",\"authors\":[{\"name\":\"Alistair Gillespie\",\"website\":\"https://www.linkedin.com/in/alistair-gillespie/\",\"avatar\":\"https://avatars.githubusercontent.com/u/210626148\",\"login\":\"alistair-openai\"},{\"name\":\"Robin Koenig\",\"website\":\"https://robinkoenig.com\",\"avatar\":\"https://avatars.githubusercontent.com/u/208886811?v=4\",\"login\":\"rkoenig-openai\"},{\"name\":\"Patrick Hundal\",\"website\":\"https://www.linkedin.com/in/phundal/\",\"avatar\":\"https://avatars.githubusercontent.com/u/189161955\",\"login\":\"phundal-openai\"}],\"search_text\":\"$10c\",\"type\":\"ipynb\",\"tags\":[\"audio\",\"speech\"],\"archived\":false},{\"name\":\"selecting_a_model_based_on_stripe_conversion.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/stripe_model_eval/selecting_a_model_based_on_stripe_conversion.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/stripe_model_eval/selecting_a_model_based_on_stripe_conversion.ipynb\",\"internal_path\":\"examples/stripe_model_eval/selecting_a_model_based_on_stripe_conversion\",\"title\":\"Selecting a Model Based on Stripe Conversion – A Practical Eval for Startups\",\"path\":\"examples/stripe_model_eval/selecting_a_model_based_on_stripe_conversion.ipynb\",\"date\":\"2025-06-02\",\"authors\":[{\"name\":\"Josh Bickett\",\"website\":\"https://www.linkedin.com/in/josh-bickett-4219b166/\",\"avatar\":\"https://avatars.githubusercontent.com/u/42594239\",\"login\":\"joshbickett\"},{\"name\":\"Lucie Lozinski\",\"website\":\"https://twitter.com/thisloops\",\"avatar\":\"https://avatars.githubusercontent.com/u/6293148\",\"login\":\"lupie\"},{\"name\":\"Shyamal Anadkat\",\"website\":\"https://twitter.com/shyamalanadkat\",\"avatar\":\"https://pbs.twimg.com/profile_images/1590564338682560512/3bbZJqxZ_400x400.jpg\",\"login\":\"shyamal-anadkat\"}],\"search_text\":\"$10d\",\"type\":\"ipynb\",\"tags\":[\"conversion\",\"evals\",\"stripe\"],\"archived\":false},{\"name\":\"mcp_eval_notebook.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/evaluation/use-cases/mcp_eval_notebook.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/evaluation/use-cases/mcp_eval_notebook.ipynb\",\"internal_path\":\"examples/evaluation/use-cases/mcp_eval_notebook\",\"title\":\"Evals API Use-case - MCP Evaluation\",\"path\":\"examples/evaluation/use-cases/mcp_eval_notebook.ipynb\",\"date\":\"2025-06-09\",\"authors\":[{\"name\":\"Josiah Grace\",\"website\":\"https://www.linkedin.com/in/josiahbgrace\",\"avatar\":\"https://avatars.githubusercontent.com/u/181146311?v=4\",\"login\":\"josiah-openai\"},{\"name\":\"Shikhar Kwatra\",\"website\":\"https://www.linkedin.com/in/shikharkwatra/\",\"avatar\":\"https://avatars.githubusercontent.com/u/189049238?v=4\",\"login\":\"shikhar-cyber\"}],\"search_text\":\"$10e\",\"type\":\"ipynb\",\"tags\":[\"evals\",\"evals-api\",\"mcp\",\"responses\"],\"archived\":false},{\"name\":\"structured-outputs-evaluation.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/evaluation/use-cases/structured-outputs-evaluation.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/evaluation/use-cases/structured-outputs-evaluation.ipynb\",\"internal_path\":\"examples/evaluation/use-cases/structured-outputs-evaluation\",\"title\":\"Evals API Use-case - Structured Outputs Evaluation\",\"path\":\"examples/evaluation/use-cases/structured-outputs-evaluation.ipynb\",\"date\":\"2025-06-09\",\"authors\":[{\"name\":\"Josiah Grace\",\"website\":\"https://www.linkedin.com/in/josiahbgrace\",\"avatar\":\"https://avatars.githubusercontent.com/u/181146311?v=4\",\"login\":\"josiah-openai\"},{\"name\":\"Shikhar Kwatra\",\"website\":\"https://www.linkedin.com/in/shikharkwatra/\",\"avatar\":\"https://avatars.githubusercontent.com/u/189049238?v=4\",\"login\":\"shikhar-cyber\"}],\"search_text\":\"$10f\",\"type\":\"ipynb\",\"tags\":[\"evals\",\"evals-api\",\"responses\"],\"archived\":false},{\"name\":\"tools-evaluation.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/evaluation/use-cases/tools-evaluation.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/evaluation/use-cases/tools-evaluation.ipynb\",\"internal_path\":\"examples/evaluation/use-cases/tools-evaluation\",\"title\":\"Evals API Use-case - Tools Evaluation\",\"path\":\"examples/evaluation/use-cases/tools-evaluation.ipynb\",\"date\":\"2025-06-09\",\"authors\":[{\"name\":\"Josiah Grace\",\"website\":\"https://www.linkedin.com/in/josiahbgrace\",\"avatar\":\"https://avatars.githubusercontent.com/u/181146311?v=4\",\"login\":\"josiah-openai\"},{\"name\":\"Shikhar Kwatra\",\"website\":\"https://www.linkedin.com/in/shikharkwatra/\",\"avatar\":\"https://avatars.githubusercontent.com/u/189049238?v=4\",\"login\":\"shikhar-cyber\"}],\"search_text\":\"$110\",\"type\":\"ipynb\",\"tags\":[\"evals\",\"evals-api\",\"responses\"],\"archived\":false},{\"name\":\"web-search-evaluation.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/evaluation/use-cases/web-search-evaluation.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/evaluation/use-cases/web-search-evaluation.ipynb\",\"internal_path\":\"examples/evaluation/use-cases/web-search-evaluation\",\"title\":\"Evals API Use-case - Web Search Evaluation\",\"path\":\"examples/evaluation/use-cases/web-search-evaluation.ipynb\",\"date\":\"2025-06-09\",\"authors\":[{\"name\":\"Josiah Grace\",\"website\":\"https://www.linkedin.com/in/josiahbgrace\",\"avatar\":\"https://avatars.githubusercontent.com/u/181146311?v=4\",\"login\":\"josiah-openai\"},{\"name\":\"Shikhar Kwatra\",\"website\":\"https://www.linkedin.com/in/shikharkwatra/\",\"avatar\":\"https://avatars.githubusercontent.com/u/189049238?v=4\",\"login\":\"shikhar-cyber\"}],\"search_text\":\"$111\",\"type\":\"ipynb\",\"tags\":[\"evals\",\"evals-api\",\"responses\"],\"archived\":false},{\"name\":\"introduction_to_deep_research_api.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/deep_research_api/introduction_to_deep_research_api.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/deep_research_api/introduction_to_deep_research_api.ipynb\",\"internal_path\":\"examples/deep_research_api/introduction_to_deep_research_api\",\"title\":\"Introduction to deep research in the OpenAI API\",\"path\":\"examples/deep_research_api/introduction_to_deep_research_api.ipynb\",\"date\":\"2025-06-25\",\"authors\":[{\"name\":\"Glory Jain\",\"website\":\"https://www.linkedin.com/in/gloryjain/\",\"avatar\":\"https://media.licdn.com/dms/image/v2/C4E03AQH72n6Sm5q69Q/profile-displayphoto-shrink_400_400/profile-displayphoto-shrink_400_400/0/1557995338725?e=1756339200\u0026v=beta\u0026t=FGTXiCZwTZvqHCY-wd8It15EDf11Rex1oLlBKRGHNtY\",\"login\":\"glojain\"},{\"name\":\"Kevin Alwell\",\"website\":\"https://github.com/alwell-kevin\",\"avatar\":\"https://avatars.githubusercontent.com/u/26548363\",\"login\":\"alwell-kevin\"}],\"search_text\":\"$112\",\"type\":\"ipynb\",\"tags\":[\"deep-research\",\"deep-research-api\",\"mcp\",\"responses\"],\"archived\":false},{\"name\":\"introduction_to_deep_research_api_agents.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/deep_research_api/introduction_to_deep_research_api_agents.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/deep_research_api/introduction_to_deep_research_api_agents.ipynb\",\"internal_path\":\"examples/deep_research_api/introduction_to_deep_research_api_agents\",\"title\":\"Deep Research API with the Agents SDK\",\"path\":\"examples/deep_research_api/introduction_to_deep_research_api_agents.ipynb\",\"date\":\"2025-06-25\",\"authors\":[{\"name\":\"Kevin Alwell\",\"website\":\"https://github.com/alwell-kevin\",\"avatar\":\"https://avatars.githubusercontent.com/u/26548363\",\"login\":\"alwell-kevin\"},{\"name\":\"Glory Jain\",\"website\":\"https://www.linkedin.com/in/gloryjain/\",\"avatar\":\"https://media.licdn.com/dms/image/v2/C4E03AQH72n6Sm5q69Q/profile-displayphoto-shrink_400_400/profile-displayphoto-shrink_400_400/0/1557995338725?e=1756339200\u0026v=beta\u0026t=FGTXiCZwTZvqHCY-wd8It15EDf11Rex1oLlBKRGHNtY\",\"login\":\"glojain\"}],\"search_text\":\"$113\",\"type\":\"ipynb\",\"tags\":[\"agents\",\"agents-sdk\",\"deep-research\",\"deep-research-api\",\"mcp\"],\"archived\":false},{\"name\":\"README.md\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/deep_research_api/how_to_build_a_deep_research_mcp_server/README.md\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/deep_research_api/how_to_build_a_deep_research_mcp_server/README.md\",\"internal_path\":\"examples/deep_research_api/how_to_build_a_deep_research_mcp_server/readme\",\"title\":\"Building a Deep Research MCP Server\",\"path\":\"examples/deep_research_api/how_to_build_a_deep_research_mcp_server/README.md\",\"date\":\"2025-06-25\",\"authors\":[{\"name\":\"Kevin Alwell\",\"website\":\"https://github.com/alwell-kevin\",\"avatar\":\"https://avatars.githubusercontent.com/u/26548363\",\"login\":\"alwell-kevin\"},{\"name\":\"Glory Jain\",\"website\":\"https://www.linkedin.com/in/gloryjain/\",\"avatar\":\"https://media.licdn.com/dms/image/v2/C4E03AQH72n6Sm5q69Q/profile-displayphoto-shrink_400_400/profile-displayphoto-shrink_400_400/0/1557995338725?e=1756339200\u0026v=beta\u0026t=FGTXiCZwTZvqHCY-wd8It15EDf11Rex1oLlBKRGHNtY\",\"login\":\"glojain\"}],\"search_text\":\"$114\",\"type\":\"md\",\"tags\":[\"agents\",\"agents-sdk\",\"deep-research\",\"deep-research-api\",\"mcp\",\"responses\"],\"archived\":false},{\"name\":\"Generate_Images_With_High_Input_Fidelity.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/Generate_Images_With_High_Input_Fidelity.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/Generate_Images_With_High_Input_Fidelity.ipynb\",\"internal_path\":\"examples/generate_images_with_high_input_fidelity\",\"title\":\"Generate images with high input fidelity\",\"path\":\"examples/Generate_Images_With_High_Input_Fidelity.ipynb\",\"date\":\"2025-07-17\",\"authors\":[{\"name\":\"Katia Gil Guzman\",\"website\":\"https://katia.gg\",\"avatar\":\"https://avatars.githubusercontent.com/u/16519462?v=4\",\"login\":\"katiagg\"}],\"search_text\":\"$115\",\"type\":\"ipynb\",\"tags\":[\"images\"],\"archived\":false},{\"name\":\"Autofix-github-actions.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/codex/Autofix-github-actions.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/codex/Autofix-github-actions.ipynb\",\"internal_path\":\"examples/codex/autofix-github-actions\",\"title\":\"Use Codex CLI to automatically fix CI failures\",\"path\":\"examples/codex/Autofix-github-actions.ipynb\",\"date\":\"2025-09-30\",\"authors\":[{\"name\":\"Himadri Acharya\",\"website\":\"https://www.linkedin.com/in/himadri-acharya-086ba261/\",\"avatar\":\"https://avatars.githubusercontent.com/u/14100684?v=4\",\"login\":\"himadri518\"},{\"name\":\"Kevin Alwell\",\"website\":\"https://github.com/alwell-kevin\",\"avatar\":\"https://avatars.githubusercontent.com/u/26548363\",\"login\":\"alwell-kevin\"},{\"name\":\"Charlie Weems\",\"website\":\"https://wee.ms\",\"avatar\":\"https://avatars.githubusercontent.com/u/181146176?v=4\",\"login\":\"charlie-openai\"}],\"search_text\":\"$116\",\"type\":\"ipynb\",\"tags\":[\"codex\"],\"archived\":false},{\"name\":\"Building_resilient_prompts_using_an_evaluation_flywheel.md\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/evaluation/Building_resilient_prompts_using_an_evaluation_flywheel.md\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/evaluation/Building_resilient_prompts_using_an_evaluation_flywheel.md\",\"internal_path\":\"examples/evaluation/building_resilient_prompts_using_an_evaluation_flywheel\",\"title\":\"Building resilient prompts using an evaluation flywheel\",\"path\":\"examples/evaluation/Building_resilient_prompts_using_an_evaluation_flywheel.md\",\"date\":\"2025-10-06\",\"authors\":[{\"name\":\"Neel Kapse\",\"website\":\"https://www.linkedin.com/in/neel-kapse/\",\"avatar\":\"https://media.licdn.com/dms/image/v2/D4E03AQEegSR4W4Ylmg/profile-displayphoto-scale_400_400/B4EZkLjdrcIQAk-/0/1756835470622?e=1762387200\u0026v=beta\u0026t=HETTFnoh3nV_Yc84tHGkahKgOFdvnPlesfi3ki8mWFg\",\"login\":\"neelk-oai\"},{\"name\":\"Hamel Husain\",\"website\":\"https://www.linkedin.com/in/hamelhusain/\",\"avatar\":\"https://media.licdn.com/dms/image/v2/C5603AQGoyHYtA2QIXw/profile-displayphoto-shrink_400_400/profile-displayphoto-shrink_400_400/0/1572471557655?e=1762387200\u0026v=beta\u0026t=wZrq-Nfc8-4Xq-nJ5g2jt9gZ1KLTg23KOIBGHk2xkZ0\",\"login\":\"hamel\"}],\"search_text\":\"$117\",\"type\":\"md\",\"tags\":[\"datasets\",\"evals\"],\"archived\":false},{\"name\":\"build_code_review_with_codex_sdk.md\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/codex/build_code_review_with_codex_sdk.md\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/codex/build_code_review_with_codex_sdk.md\",\"internal_path\":\"examples/codex/build_code_review_with_codex_sdk\",\"title\":\"Build Code Review with the Codex SDK\",\"path\":\"examples/codex/build_code_review_with_codex_sdk.md\",\"date\":\"2025-10-21\",\"authors\":[{\"name\":\"Charlie Weems\",\"website\":\"https://wee.ms\",\"avatar\":\"https://avatars.githubusercontent.com/u/181146176?v=4\",\"login\":\"charlie-openai\"}],\"search_text\":\"$118\",\"type\":\"md\",\"tags\":[\"codex\"],\"archived\":false},{\"name\":\"Build_a_coding_agent_with_GPT-5.1.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/Build_a_coding_agent_with_GPT-5.1.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/Build_a_coding_agent_with_GPT-5.1.ipynb\",\"internal_path\":\"examples/build_a_coding_agent_with_gpt-5.1\",\"title\":\"Build a coding agent with GPT 5.1\",\"path\":\"examples/Build_a_coding_agent_with_GPT-5.1.ipynb\",\"date\":\"2025-11-13\",\"authors\":[{\"name\":\"Katia Gil Guzman\",\"website\":\"https://katia.gg\",\"avatar\":\"https://avatars.githubusercontent.com/u/16519462?v=4\",\"login\":\"katiagg\"}],\"search_text\":\"$119\",\"type\":\"ipynb\",\"tags\":[\"agents-sdk\"],\"archived\":false},{\"name\":\"gpt-5-1_prompting_guide.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/gpt-5/gpt-5-1_prompting_guide.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/gpt-5/gpt-5-1_prompting_guide.ipynb\",\"internal_path\":\"examples/gpt-5/gpt-5-1_prompting_guide\",\"title\":\"GPT-5.1 Prompting Guide\",\"path\":\"examples/gpt-5/gpt-5-1_prompting_guide.ipynb\",\"date\":\"2025-11-13\",\"authors\":[{\"name\":\"Samarth Madduru\",\"website\":\"https://x.com/samarthmadduru\",\"avatar\":\"https://pbs.twimg.com/profile_images/1911309450368970752/6IFoTpmu_400x400.jpg\",\"login\":\"samarth-oai\"}],\"search_text\":\"$11a\",\"type\":\"ipynb\",\"tags\":[\"gpt-5.1\"],\"archived\":false},{\"name\":\"gpt-5-1-codex-max_prompting_guide.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/gpt-5/gpt-5-1-codex-max_prompting_guide.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/gpt-5/gpt-5-1-codex-max_prompting_guide.ipynb\",\"internal_path\":\"examples/gpt-5/gpt-5-1-codex-max_prompting_guide\",\"title\":\"GPT-5.1-Codex-Max Prompting Guide\",\"path\":\"examples/gpt-5/gpt-5-1-codex-max_prompting_guide.ipynb\",\"date\":\"2025-12-04\",\"authors\":[{\"name\":\"Noah MacCallum\",\"website\":\"https://x.com/noahmacca\",\"avatar\":\"https://avatars.githubusercontent.com/u/171723556\",\"login\":\"nm-openai\"}],\"search_text\":\"$11b\",\"type\":\"ipynb\",\"tags\":[\"codex\",\"compaction\",\"responses\"],\"archived\":false},{\"name\":\"code_modernization.md\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/codex/code_modernization.md\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/codex/code_modernization.md\",\"internal_path\":\"examples/codex/code_modernization\",\"title\":\"Modernizing your Codebase with Codex\",\"path\":\"examples/codex/code_modernization.md\",\"date\":\"2025-11-19\",\"authors\":[{\"name\":\"Derrick Choi\",\"website\":\"https://www.linkedin.com/in/derrickchoi/\",\"avatar\":\"https://avatars.githubusercontent.com/u/211427900\",\"login\":\"derrickchoi-openai\"}],\"search_text\":\"$11c\",\"type\":\"md\",\"tags\":[\"codex\"],\"archived\":false},{\"name\":\"logs_platform.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/chatgpt/compliance_api/logs_platform.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/chatgpt/compliance_api/logs_platform.ipynb\",\"internal_path\":\"examples/chatgpt/compliance_api/logs_platform\",\"title\":\"OpenAI Compliance Logs Platform quickstart\",\"path\":\"examples/chatgpt/compliance_api/logs_platform.ipynb\",\"date\":\"2025-12-11\",\"authors\":[{\"name\":\"Kevin Verdieck\",\"website\":\"https://www.linkedin.com/in/kevinverdieck/\",\"avatar\":\"https://avatars.githubusercontent.com/u/197816265?v=4\",\"login\":\"kevinv-openai\"}],\"search_text\":\"$11d\",\"type\":\"ipynb\",\"tags\":[\"chatgpt\",\"chatgpt-and-api\",\"chatgpt-data\",\"compliance\",\"enterprise\"],\"archived\":false},{\"name\":\"gpt-5-2_prompting_guide.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/gpt-5/gpt-5-2_prompting_guide.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/gpt-5/gpt-5-2_prompting_guide.ipynb\",\"internal_path\":\"examples/gpt-5/gpt-5-2_prompting_guide\",\"title\":\"GPT-5.2 Prompting Guide\",\"path\":\"examples/gpt-5/gpt-5-2_prompting_guide.ipynb\",\"date\":\"2025-12-11\",\"authors\":[{\"name\":\"Mandeep Singh\",\"website\":\"https://github.com/msingh-openai\",\"avatar\":\"https://avatars.githubusercontent.com/u/168678187?v=4\",\"login\":\"msingh-openai\"},{\"name\":\"Emre Okcular\",\"website\":\"https://www.linkedin.com/in/emreokcular/\",\"avatar\":\"https://avatars.githubusercontent.com/u/26163154?v=4\",\"login\":\"emreokcular\"}],\"search_text\":\"$11e\",\"type\":\"ipynb\",\"tags\":[\"gpt-5.2\"],\"archived\":false},{\"name\":\"image-gen-1.5-prompting_guide.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/multimodal/image-gen-1.5-prompting_guide.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/multimodal/image-gen-1.5-prompting_guide.ipynb\",\"internal_path\":\"examples/multimodal/image-gen-1.5-prompting_guide\",\"title\":\"Gpt-image-1.5 Prompting Guide\",\"path\":\"examples/multimodal/image-gen-1.5-prompting_guide.ipynb\",\"date\":\"2025-12-16\",\"authors\":[{\"name\":\"Annika Brundyn\",\"website\":\"https://www.linkedin.com/in/annikabrundyn/\",\"avatar\":\"https://avatars.githubusercontent.com/u/231350694\",\"login\":\"annikab-oai\"},{\"name\":\"Mandeep Singh\",\"website\":\"https://github.com/msingh-openai\",\"avatar\":\"https://avatars.githubusercontent.com/u/168678187?v=4\",\"login\":\"msingh-openai\"},{\"name\":\"Emre Okcular\",\"website\":\"https://www.linkedin.com/in/emreokcular/\",\"avatar\":\"https://avatars.githubusercontent.com/u/26163154?v=4\",\"login\":\"emreokcular\"}],\"search_text\":\"$11f\",\"type\":\"ipynb\",\"tags\":[\"images\",\"vision\"],\"archived\":false},{\"name\":\"prompt_personalities.ipynb\",\"download_url\":\"https://raw.githubusercontent.com/openai/openai-cookbook/main/examples/gpt-5/prompt_personalities.ipynb\",\"github_url\":\"https://github.com/openai/openai-cookbook/blob/main/examples/gpt-5/prompt_personalities.ipynb\",\"internal_path\":\"examples/gpt-5/prompt_personalities\",\"title\":\"Prompt Personalities\",\"path\":\"examples/gpt-5/prompt_personalities.ipynb\",\"date\":\"2026-01-05\",\"authors\":[{\"name\":\"Mandeep Singh\",\"website\":\"https://github.com/msingh-openai\",\"avatar\":\"https://avatars.githubusercontent.com/u/168678187?v=4\",\"login\":\"msingh-openai\"},{\"name\":\"Kathy Lau\",\"website\":\"https://www.linkedin.com/in/kathy-lau-nyc/\",\"avatar\":\"https://avatars.githubusercontent.com/u/231350694\",\"login\":\"kathylau-oai\"}],\"search_text\":\"$120\",\"type\":\"ipynb\",\"tags\":[\"gpt-5\",\"prompt-personalities\"],\"archived\":false}]}]]}]]}]\n"])</script><script>self.__next_f.push([1,"12:[\"$\",\"div\",null,{\"className\":\"flex flex-col space-y-6\",\"children\":[\"$L121\",\"$L122\",\"$L123\",\"$L124\",\"$L125\",\"$L126\",\"$L127\",\"$L128\",\"$L129\",\"$L12a\",\"$L12b\",\"$L12c\",\"$L12d\",\"$L12e\",\"$L12f\",\"$L130\",\"$L131\",\"$L132\",\"$L133\",\"$L134\",\"$L135\"]}]\n"])</script><script>self.__next_f.push([1,"136:I[1943,[\"310\",\"static/chunks/0e5ce63c-e6b9e60b226d30ba.js\",\"637\",\"static/chunks/637-4ae0d65e4116044f.js\",\"145\",\"static/chunks/145-a0379013fc8edaf2.js\",\"708\",\"static/chunks/708-20e21f0502595361.js\",\"884\",\"static/chunks/app/%5B...path%5D/page-36544baa9fa0916f.js\"],\"CopyButton\"]\n13d:I[1766,[\"310\",\"static/chunks/0e5ce63c-e6b9e60b226d30ba.js\",\"637\",\"static/chunks/637-4ae0d65e4116044f.js\",\"145\",\"static/chunks/145-a0379013fc8edaf2.js\",\"708\",\"static/chunks/708-20e21f0502595361.js\",\"884\",\"static/chunks/app/%5B...path%5D/page-36544baa9fa0916f.js\"],\"HeadingWithClipboard\"]\n123:[\"$\",\"div\",null,{\"children\":[[\"$\",\"div\",null,{\"className\":\"relative\",\"children\":[[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\u003cpre class=\\\"shiki github-dark\\\" style=\\\"background-color: #24292e\\\" tabindex=\\\"0\\\"\u003e\u003ccode\u003e\u003cspan class=\\\"line\\\"\u003e\u003cspan style=\\\"color: #F97583\\\"\u003efrom\u003c/span\u003e\u003cspan style=\\\"color: #E1E4E8\\\"\u003e openai \u003c/span\u003e\u003cspan style=\\\"color: #F97583\\\"\u003eimport\u003c/span\u003e\u003cspan style=\\\"color: #E1E4E8\\\"\u003e OpenAI\u003c/span\u003e\u003c/span\u003e\\n\u003cspan class=\\\"line\\\"\u003e\u003cspan style=\\\"color: #F97583\\\"\u003eimport\u003c/span\u003e\u003cspan style=\\\"color: #E1E4E8\\\"\u003e os\u003c/span\u003e\u003c/span\u003e\\n\u003cspan class=\\\"line\\\"\u003e\u003cspan style=\\\"color: #E1E4E8\\\"\u003eclient \u003c/span\u003e\u003cspan style=\\\"color: #F97583\\\"\u003e=\u003c/span\u003e\u003cspan style=\\\"color: #E1E4E8\\\"\u003e OpenAI(\u003c/span\u003e\u003cspan style=\\\"color: #FFAB70\\\"\u003eapi_key\u003c/span\u003e\u003cspan style=\\\"color: #F97583\\\"\u003e=\u003c/span\u003e\u003cspan style=\\\"color: #E1E4E8\\\"\u003eos.getenv(\u003c/span\u003e\u003cspan style=\\\"color: #9ECBFF\\\"\u003e\u0026quot;OPENAI_API_KEY\u0026quot;\u003c/span\u003e\u003cspan style=\\\"color: #E1E4E8\\\"\u003e))\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\"},\"className\":\"[\u0026\u003e*]:rounded-md [\u0026\u003e*]:p-4 [\u0026\u003e*]:text-xs [\u0026\u003e*]:overflow-x-auto\"}],[\"$\",\"$L136\",null,{\"code\":\"from openai import OpenAI\\nimport os\\nclient = OpenAI(api_key=os.getenv(\\\"OPENAI_API_KEY\\\"))\",\"className\":\"absolute top-2 right-2\"}]]}],false]}]\n124:[\"$\",\"div\",null,{\"children\":[[\"$\",\"div\",null,{\"className\":\"relative\",\"children\":[[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\u003cpre class=\\\"shiki github-dark\\\" style=\\\"background-color: #24292e\\\" tabindex=\\\"0\\\"\u003e\u003ccode\u003e\u003cspan class=\\\"line\\\"\u003e\u003cspan style=\\\""])</script><script>self.__next_f.push([1,"color: #E1E4E8\\\"\u003eresponse \u003c/span\u003e\u003cspan style=\\\"color: #F97583\\\"\u003e=\u003c/span\u003e\u003cspan style=\\\"color: #E1E4E8\\\"\u003e client.responses.create(\u003c/span\u003e\u003c/span\u003e\\n\u003cspan class=\\\"line\\\"\u003e\u003cspan style=\\\"color: #E1E4E8\\\"\u003e    \u003c/span\u003e\u003cspan style=\\\"color: #FFAB70\\\"\u003emodel\u003c/span\u003e\u003cspan style=\\\"color: #F97583\\\"\u003e=\u003c/span\u003e\u003cspan style=\\\"color: #9ECBFF\\\"\u003e\u0026quot;gpt-4o-mini\u0026quot;\u003c/span\u003e\u003cspan style=\\\"color: #E1E4E8\\\"\u003e,\u003c/span\u003e\u003c/span\u003e\\n\u003cspan class=\\\"line\\\"\u003e\u003cspan style=\\\"color: #E1E4E8\\\"\u003e    \u003c/span\u003e\u003cspan style=\\\"color: #FFAB70\\\"\u003einput\u003c/span\u003e\u003cspan style=\\\"color: #F97583\\\"\u003e=\u003c/span\u003e\u003cspan style=\\\"color: #9ECBFF\\\"\u003e\u0026quot;tell me a joke\u0026quot;\u003c/span\u003e\u003cspan style=\\\"color: #E1E4E8\\\"\u003e,\u003c/span\u003e\u003c/span\u003e\\n\u003cspan class=\\\"line\\\"\u003e\u003cspan style=\\\"color: #E1E4E8\\\"\u003e)\u003c/span\u003e\u003c/span\u003e\\n\u003cspan class=\\\"line\\\"\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\"},\"className\":\"[\u0026\u003e*]:rounded-md [\u0026\u003e*]:p-4 [\u0026\u003e*]:text-xs [\u0026\u003e*]:overflow-x-auto\"}],[\"$\",\"$L136\",null,{\"code\":\"response = client.responses.create(\\n    model=\\\"gpt-4o-mini\\\",\\n    input=\\\"tell me a joke\\\",\\n)\\n\",\"className\":\"absolute top-2 right-2\"}]]}],false]}]\n125:[\"$\",\"div\",null,{\"children\":[[\"$\",\"div\",null,{\"className\":\"relative\",\"children\":[[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\u003cpre class=\\\"shiki github-dark\\\" style=\\\"background-color: #24292e\\\" tabindex=\\\"0\\\"\u003e\u003ccode\u003e\u003cspan class=\\\"line\\\"\u003e\u003cspan style=\\\"color: #79B8FF\\\"\u003eprint\u003c/span\u003e\u003cspan style=\\\"color: #E1E4E8\\\"\u003e(response.output[\u003c/span\u003e\u003cspan style=\\\"color: #79B8FF\\\"\u003e0\u003c/span\u003e\u003cspan style=\\\"color: #E1E4E8\\\"\u003e].content[\u003c/span\u003e\u003cspan style=\\\"color: #79B8FF\\\"\u003e0\u003c/span\u003e\u003cspan style=\\\"color: #E1E4E8\\\"\u003e].text)\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\"},\"className\":\"[\u0026\u003e*]:rounded-md [\u0026\u003e*]:p-4 [\u0026\u003e*]:text-xs [\u0026\u003e*]:overflow-x-auto [\u0026\u003e*]:rounded-b-none\"}],[\"$\",\"$L136\",null,{\"code\":\"print(response.output[0].content[0].text)\",\"className\":\"absolute top-2 right-2\"}]]}],[\"$\",\"div\",null,{\"className\":\"border border-t-0 border-border rounded-b-md text-xs max-h-[50vh] overflow-scroll\",\"children\":[[\"$\",\"pre\",\"0\",{\"className\":\"p-4 font-mono overflow-scroll\",\"children\":[\"Why did the scarecrow win an award?\\n\",\"\\n\",\"Because he was outstandin"])</script><script>self.__next_f.push([1,"g in his field!\\n\"]}]]}]]}]\n127:[\"$\",\"div\",null,{\"children\":[[\"$\",\"div\",null,{\"className\":\"relative\",\"children\":[[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\u003cpre class=\\\"shiki github-dark\\\" style=\\\"background-color: #24292e\\\" tabindex=\\\"0\\\"\u003e\u003ccode\u003e\u003cspan class=\\\"line\\\"\u003e\u003cspan style=\\\"color: #E1E4E8\\\"\u003efetched_response \u003c/span\u003e\u003cspan style=\\\"color: #F97583\\\"\u003e=\u003c/span\u003e\u003cspan style=\\\"color: #E1E4E8\\\"\u003e client.responses.retrieve(\u003c/span\u003e\u003c/span\u003e\\n\u003cspan class=\\\"line\\\"\u003e\u003cspan style=\\\"color: #FFAB70\\\"\u003eresponse_id\u003c/span\u003e\u003cspan style=\\\"color: #F97583\\\"\u003e=\u003c/span\u003e\u003cspan style=\\\"color: #E1E4E8\\\"\u003eresponse.id)\u003c/span\u003e\u003c/span\u003e\\n\u003cspan class=\\\"line\\\"\u003e\u003c/span\u003e\\n\u003cspan class=\\\"line\\\"\u003e\u003cspan style=\\\"color: #79B8FF\\\"\u003eprint\u003c/span\u003e\u003cspan style=\\\"color: #E1E4E8\\\"\u003e(fetched_response.output[\u003c/span\u003e\u003cspan style=\\\"color: #79B8FF\\\"\u003e0\u003c/span\u003e\u003cspan style=\\\"color: #E1E4E8\\\"\u003e].content[\u003c/span\u003e\u003cspan style=\\\"color: #79B8FF\\\"\u003e0\u003c/span\u003e\u003cspan style=\\\"color: #E1E4E8\\\"\u003e].text)\u003c/span\u003e\u003c/span\u003e\\n\u003cspan class=\\\"line\\\"\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\"},\"className\":\"[\u0026\u003e*]:rounded-md [\u0026\u003e*]:p-4 [\u0026\u003e*]:text-xs [\u0026\u003e*]:overflow-x-auto [\u0026\u003e*]:rounded-b-none\"}],[\"$\",\"$L136\",null,{\"code\":\"fetched_response = client.responses.retrieve(\\nresponse_id=response.id)\\n\\nprint(fetched_response.output[0].content[0].text)\\n\",\"className\":\"absolute top-2 right-2\"}]]}],[\"$\",\"div\",null,{\"className\":\"border border-t-0 border-border rounded-b-md text-xs max-h-[50vh] overflow-scroll\",\"children\":[[\"$\",\"pre\",\"0\",{\"className\":\"p-4 font-mono overflow-scroll\",\"children\":[\"Why did the scarecrow win an award?\\n\",\"\\n\",\"Because he was outstanding in his field!\\n\"]}]]}]]}]\n137:T41e,\u003cpre class=\"shiki github-dark\" style=\"background-color: #24292e\" tabindex=\"0\"\u003e\u003ccode\u003e\u003cspan class=\"line\"\u003e\u003cspan style=\"color: #E1E4E8\"\u003eresponse_two \u003c/span\u003e\u003cspan style=\"color: #F97583\"\u003e=\u003c/span\u003e\u003cspan style=\"color: #E1E4E8\"\u003e client.responses.create(\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\"line\"\u003e\u003cspan style=\"color: #E1E4E8\"\u003e    \u003c/span\u003e\u003cspan style=\"color: #FFAB70\"\u003emodel\u003c/span\u003e\u003cspan style=\"color: #F97583\"\u003e=\u003c/span\u003e\u003cspan style=\"color: #9ECBFF\"\u003e\u0026quot;gpt-4o-mini\u0026quot;\u003c/sp"])</script><script>self.__next_f.push([1,"an\u003e\u003cspan style=\"color: #E1E4E8\"\u003e,\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\"line\"\u003e\u003cspan style=\"color: #E1E4E8\"\u003e    \u003c/span\u003e\u003cspan style=\"color: #FFAB70\"\u003einput\u003c/span\u003e\u003cspan style=\"color: #F97583\"\u003e=\u003c/span\u003e\u003cspan style=\"color: #9ECBFF\"\u003e\u0026quot;tell me another\u0026quot;\u003c/span\u003e\u003cspan style=\"color: #E1E4E8\"\u003e,\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\"line\"\u003e\u003cspan style=\"color: #E1E4E8\"\u003e    \u003c/span\u003e\u003cspan style=\"color: #FFAB70\"\u003eprevious_response_id\u003c/span\u003e\u003cspan style=\"color: #F97583\"\u003e=\u003c/span\u003e\u003cspan style=\"color: #E1E4E8\"\u003eresponse.id\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\"line\"\u003e\u003cspan style=\"color: #E1E4E8\"\u003e)\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e129:[\"$\",\"div\",null,{\"children\":[[\"$\",\"div\",null,{\"className\":\"relative\",\"children\":[[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$137\"},\"className\":\"[\u0026\u003e*]:rounded-md [\u0026\u003e*]:p-4 [\u0026\u003e*]:text-xs [\u0026\u003e*]:overflow-x-auto\"}],[\"$\",\"$L136\",null,{\"code\":\"response_two = client.responses.create(\\n    model=\\\"gpt-4o-mini\\\",\\n    input=\\\"tell me another\\\",\\n    previous_response_id=response.id\\n)\\n\",\"className\":\"absolute top-2 right-2\"}]]}],false]}]\n12a:[\"$\",\"div\",null,{\"children\":[[\"$\",\"div\",null,{\"className\":\"relative\",\"children\":[[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\u003cpre class=\\\"shiki github-dark\\\" style=\\\"background-color: #24292e\\\" tabindex=\\\"0\\\"\u003e\u003ccode\u003e\u003cspan class=\\\"line\\\"\u003e\u003cspan style=\\\"color: #79B8FF\\\"\u003eprint\u003c/span\u003e\u003cspan style=\\\"color: #E1E4E8\\\"\u003e(response_two.output[\u003c/span\u003e\u003cspan style=\\\"color: #79B8FF\\\"\u003e0\u003c/span\u003e\u003cspan style=\\\"color: #E1E4E8\\\"\u003e].content[\u003c/span\u003e\u003cspan style=\\\"color: #79B8FF\\\"\u003e0\u003c/span\u003e\u003cspan style=\\\"color: #E1E4E8\\\"\u003e].text)\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\"},\"className\":\"[\u0026\u003e*]:rounded-md [\u0026\u003e*]:p-4 [\u0026\u003e*]:text-xs [\u0026\u003e*]:overflow-x-auto [\u0026\u003e*]:rounded-b-none\"}],[\"$\",\"$L136\",null,{\"code\":\"print(response_two.output[0].content[0].text)\",\"className\":\"absolute top-2 right-2\"}]]}],[\"$\",\"div\",null,{\"className\":\"border border-t-0 border-border rounded-b-md text-xs max-h-[50vh] overflow-scroll\",\"children\":[[\"$\",\"pre\",\"0\",{\"className\":\"p-4 font-mono overflow-scroll\",\"children\":[\"Why don't skeletons fight each other?\\"])</script><script>self.__next_f.push([1,"n\",\"\\n\",\"They don't have the guts!\\n\"]}]]}]]}]\n138:T68f,\u003cpre class=\"shiki github-dark\" style=\"background-color: #24292e\" tabindex=\"0\"\u003e\u003ccode\u003e\u003cspan class=\"line\"\u003e\u003cspan style=\"color: #E1E4E8\"\u003eresponse_two_forked \u003c/span\u003e\u003cspan style=\"color: #F97583\"\u003e=\u003c/span\u003e\u003cspan style=\"color: #E1E4E8\"\u003e client.responses.create(\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\"line\"\u003e\u003cspan style=\"color: #E1E4E8\"\u003e    \u003c/span\u003e\u003cspan style=\"color: #FFAB70\"\u003emodel\u003c/span\u003e\u003cspan style=\"color: #F97583\"\u003e=\u003c/span\u003e\u003cspan style=\"color: #9ECBFF\"\u003e\u0026quot;gpt-4o-mini\u0026quot;\u003c/span\u003e\u003cspan style=\"color: #E1E4E8\"\u003e,\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\"line\"\u003e\u003cspan style=\"color: #E1E4E8\"\u003e    \u003c/span\u003e\u003cspan style=\"color: #FFAB70\"\u003einput\u003c/span\u003e\u003cspan style=\"color: #F97583\"\u003e=\u003c/span\u003e\u003cspan style=\"color: #9ECBFF\"\u003e\u0026quot;I didn\u0026#39;t like that joke, tell me another and tell me the difference between the two jokes\u0026quot;\u003c/span\u003e\u003cspan style=\"color: #E1E4E8\"\u003e,\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\"line\"\u003e\u003cspan style=\"color: #E1E4E8\"\u003e    \u003c/span\u003e\u003cspan style=\"color: #FFAB70\"\u003eprevious_response_id\u003c/span\u003e\u003cspan style=\"color: #F97583\"\u003e=\u003c/span\u003e\u003cspan style=\"color: #E1E4E8\"\u003eresponse.id \u003c/span\u003e\u003cspan style=\"color: #6A737D\"\u003e# Forking and continuing from the first response\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\"line\"\u003e\u003cspan style=\"color: #E1E4E8\"\u003e)\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\"line\"\u003e\u003c/span\u003e\n\u003cspan class=\"line\"\u003e\u003cspan style=\"color: #E1E4E8\"\u003eoutput_text \u003c/span\u003e\u003cspan style=\"color: #F97583\"\u003e=\u003c/span\u003e\u003cspan style=\"color: #E1E4E8\"\u003e response_two_forked.output[\u003c/span\u003e\u003cspan style=\"color: #79B8FF\"\u003e0\u003c/span\u003e\u003cspan style=\"color: #E1E4E8\"\u003e].content[\u003c/span\u003e\u003cspan style=\"color: #79B8FF\"\u003e0\u003c/span\u003e\u003cspan style=\"color: #E1E4E8\"\u003e].text\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\"line\"\u003e\u003cspan style=\"color: #79B8FF\"\u003eprint\u003c/span\u003e\u003cspan style=\"color: #E1E4E8\"\u003e(output_text)\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e12c:[\"$\",\"div\",null,{\"children\":[[\"$\",\"div\",null,{\"className\":\"relative\",\"children\":[[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$138\"},\"className\":\"[\u0026\u003e*]:rounded-md [\u0026\u003e*]:p-4 [\u0026\u003e*]:text-xs [\u0026\u003e*]:overflow-x-auto [\u0026\u003e*]:rounded-b-none\"}],[\"$\",\"$L136\",null,{\"code\":\"response_two_forked = client.responses.c"])</script><script>self.__next_f.push([1,"reate(\\n    model=\\\"gpt-4o-mini\\\",\\n    input=\\\"I didn't like that joke, tell me another and tell me the difference between the two jokes\\\",\\n    previous_response_id=response.id # Forking and continuing from the first response\\n)\\n\\noutput_text = response_two_forked.output[0].content[0].text\\nprint(output_text)\",\"className\":\"absolute top-2 right-2\"}]]}],[\"$\",\"div\",null,{\"className\":\"border border-t-0 border-border rounded-b-md text-xs max-h-[50vh] overflow-scroll\",\"children\":[[\"$\",\"pre\",\"0\",{\"className\":\"p-4 font-mono overflow-scroll\",\"children\":[\"Sure! Here’s another joke:\\n\",\"\\n\",\"Why don’t scientists trust atoms?\\n\",\"\\n\",\"Because they make up everything!\\n\",\"\\n\",\"**Difference:** The first joke plays on a pun involving \\\"outstanding\\\" in a literal sense versus being exceptional, while the second joke relies on a play on words about atoms \\\"making up\\\" matter versus fabricating stories. Each joke uses wordplay, but they target different concepts (farming vs. science).\\n\"]}]]}]]}]\n139:T5eb,\u003cpre class=\"shiki github-dark\" style=\"background-color: #24292e\" tabindex=\"0\"\u003e\u003ccode\u003e\u003cspan class=\"line\"\u003e\u003cspan style=\"color: #E1E4E8\"\u003eresponse \u003c/span\u003e\u003cspan style=\"color: #F97583\"\u003e=\u003c/span\u003e\u003cspan style=\"color: #E1E4E8\"\u003e client.responses.create(\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\"line\"\u003e\u003cspan style=\"color: #E1E4E8\"\u003e    \u003c/span\u003e\u003cspan style=\"color: #FFAB70\"\u003emodel\u003c/span\u003e\u003cspan style=\"color: #F97583\"\u003e=\u003c/span\u003e\u003cspan style=\"color: #9ECBFF\"\u003e\u0026quot;gpt-4o\u0026quot;\u003c/span\u003e\u003cspan style=\"color: #E1E4E8\"\u003e,  \u003c/span\u003e\u003cspan style=\"color: #6A737D\"\u003e# or another supported model\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\"line\"\u003e\u003cspan style=\"color: #E1E4E8\"\u003e    \u003c/span\u003e\u003cspan style=\"color: #FFAB70\"\u003einput\u003c/span\u003e\u003cspan style=\"color: #F97583\"\u003e=\u003c/span\u003e\u003cspan style=\"color: #9ECBFF\"\u003e\u0026quot;What\u0026#39;s the latest news about AI?\u0026quot;\u003c/span\u003e\u003cspan style=\"color: #E1E4E8\"\u003e,\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\"line\"\u003e\u003cspan style=\"color: #E1E4E8\"\u003e    \u003c/span\u003e\u003cspan style=\"color: #FFAB70\"\u003etools\u003c/span\u003e\u003cspan style=\"color: #F97583\"\u003e=\u003c/span\u003e\u003cspan style=\"color: #E1E4E8\"\u003e[\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\"line\"\u003e\u003cspan style=\"co"])</script><script>self.__next_f.push([1,"lor: #E1E4E8\"\u003e        {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\"line\"\u003e\u003cspan style=\"color: #E1E4E8\"\u003e            \u003c/span\u003e\u003cspan style=\"color: #9ECBFF\"\u003e\u0026quot;type\u0026quot;\u003c/span\u003e\u003cspan style=\"color: #E1E4E8\"\u003e: \u003c/span\u003e\u003cspan style=\"color: #9ECBFF\"\u003e\u0026quot;web_search\u0026quot;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\"line\"\u003e\u003cspan style=\"color: #E1E4E8\"\u003e        }\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\"line\"\u003e\u003cspan style=\"color: #E1E4E8\"\u003e    ]\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\"line\"\u003e\u003cspan style=\"color: #E1E4E8\"\u003e)\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e12e:[\"$\",\"div\",null,{\"children\":[[\"$\",\"div\",null,{\"className\":\"relative\",\"children\":[[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$139\"},\"className\":\"[\u0026\u003e*]:rounded-md [\u0026\u003e*]:p-4 [\u0026\u003e*]:text-xs [\u0026\u003e*]:overflow-x-auto\"}],[\"$\",\"$L136\",null,{\"code\":\"response = client.responses.create(\\n    model=\\\"gpt-4o\\\",  # or another supported model\\n    input=\\\"What's the latest news about AI?\\\",\\n    tools=[\\n        {\\n            \\\"type\\\": \\\"web_search\\\"\\n        }\\n    ]\\n)\",\"className\":\"absolute top-2 right-2\"}]]}],false]}]\n13a:T13c2,"])</script><script>self.__next_f.push([1,"        \"text\": \"As of February 25, 2025, several significant developments have emerged in the field of artificial intelligence (AI):\\n\\n**Huawei's Advancements in AI Chip Production**\\n\\nHuawei has notably enhanced its AI chip production capabilities, increasing the yield rate of its Ascend 910C processors from 20% to nearly 40%. This improvement has rendered the production line profitable for the first time and is pivotal for China's ambition to achieve self-sufficiency in advanced semiconductors. Despite these strides, Nvidia continues to dominate the AI chip market in China, attributed to its user-friendly software and widespread adoption. Huawei aims to further elevate its yield rate to 60% and plans to produce 100,000 Ascend 910C processors and 300,000 910B chips in 2025. ([ft.com](https://www.ft.com/content/f46b7f6d-62ed-4b64-8ad7-2417e5ab34f6?utm_source=chatgpt.com))\\n\\n**Apple's $500 Billion U.S. Investment Plan**\\n\\nApple has unveiled a substantial $500 billion investment strategy in the United States over the next four years. This plan encompasses the creation of 20,000 new jobs and the establishment of a major facility in Texas dedicated to manufacturing artificial intelligence servers. President Donald Trump has lauded this initiative, viewing it as a testament to the confidence in his administration. Concurrently, Wall Street has experienced further losses due to concerns over a potential economic slowdown, exacerbated by tariffs. ([theguardian.com](https://www.theguardian.com/business/live/2025/feb/24/euro-hits-one-month-high-german-election-result-stock-markets-dax-bank-of-england-business-live-news?utm_source=chatgpt.com))\\n\\n**Microsoft Adjusts AI Data Center Investments**\\n\\nMicrosoft has canceled leases on U.S. data centers totaling several hundred megawatts, potentially affecting two large centers. This decision is reportedly linked to concerns about oversupply, following claims by Chinese competitor DeepSeek of developing a generative chatbot more efficiently than U.S. companies. Analysts suggest that Microsoft might be reallocating funds or responding to OpenAI's shift to Oracle for a $500 billion project. Despite being a leading AI investor with planned expenditures of $80 billion this year, Microsoft appears to be scaling back on massive spending initiatives, allowing significant data center agreements to lapse and citing facility and power delays. ([nypost.com](https://nypost.com/2025/02/24/business/microsoft-axes-some-ai-data-center-leases-td-cowen-says/?utm_source=chatgpt.com))\\n\\n**Alibaba's $52 Billion Investment in AI and Cloud Infrastructure**\\n\\nAlibaba Group has announced plans to invest over $52 billion in artificial intelligence and cloud infrastructure over the next three years, surpassing its total investment in these areas over the past decade. This strategic move underscores Alibaba's commitment to AI-driven growth and reinforces its position as a leading global cloud provider. Following this announcement, Alibaba's U.S.-listed shares experienced a 3% drop in premarket trading. Analysts view this investment as aligning with market expectations and indicative of Alibaba Cloud's significant capital expenditure compared to peers. ([investopedia.com](https://www.investopedia.com/alibaba-plans-to-invest-usd52b-in-ai-cloud-over-next-three-years-11684981?utm_source=chatgpt.com))\\n\\n**JPMorgan's Investment in AI-Driven Chemical Development**\\n\\nJPMorgan Chase's private investment arm has led a $20 million growth investment in Albert Invent, an AI-driven chemical development platform, valuing the company at $270 million. This funding will enable Albert Invent to expand globally and increase its workforce from 120 to over 200 employees by the end of the year. The company assists chemists in developing new formulations and materials, significantly accelerating chemical experiments. For instance, Albert's platform can simulate 100,000 experiments in 10 minutes for clients like Nouryon Chemicals. ([wsj.com](https://www.wsj.com/articles/jpmorgan-unit-backs-albert-invent-at-a-270-million-valuation-1ab03c96?utm_source=chatgpt.com))\\n\\nThese developments reflect the dynamic and rapidly evolving landscape of AI, with major corporations and financial institutions making significant investments to advance technology and infrastructure in this sector.\\n\\n\\n# Key AI Developments as of February 25, 2025:\\n- [Huawei improves AI chip production in boost for China's tech goals](https://www.ft.com/content/f46b7f6d-62ed-4b64-8ad7-2417e5ab34f6?utm_source=chatgpt.com)\\n- [Apple cheers Trump with $500bn US investment plan; more losses on Wall Street - as it happened](https://www.theguardian.com/business/live/2025/feb/24/euro-hits-one-month-high-german-election-result-stock-markets-dax-bank-of-england-business-live-news?utm_source=chatgpt.com)\\n- [Microsoft axes data center leases as DeepSeek casts doubt on massive AI spend: report](https://nypost.com/2025/02/24/business/microsoft-axes-some-ai-data-center-leases-td-cowen-says/?utm_source=chatgpt.com)\\n \",\n"])</script><script>self.__next_f.push([1,"12f:[\"$\",\"div\",null,{\"children\":[[\"$\",\"div\",null,{\"className\":\"relative\",\"children\":[[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\u003cpre class=\\\"shiki github-dark\\\" style=\\\"background-color: #24292e\\\" tabindex=\\\"0\\\"\u003e\u003ccode\u003e\u003cspan class=\\\"line\\\"\u003e\u003cspan style=\\\"color: #F97583\\\"\u003eimport\u003c/span\u003e\u003cspan style=\\\"color: #E1E4E8\\\"\u003e json\u003c/span\u003e\u003c/span\u003e\\n\u003cspan class=\\\"line\\\"\u003e\u003cspan style=\\\"color: #79B8FF\\\"\u003eprint\u003c/span\u003e\u003cspan style=\\\"color: #E1E4E8\\\"\u003e(json.dumps(response.output, \u003c/span\u003e\u003cspan style=\\\"color: #FFAB70\\\"\u003edefault\u003c/span\u003e\u003cspan style=\\\"color: #F97583\\\"\u003e=lambda\u003c/span\u003e\u003cspan style=\\\"color: #E1E4E8\\\"\u003e o: o.\u003c/span\u003e\u003cspan style=\\\"color: #79B8FF\\\"\u003e__dict__\u003c/span\u003e\u003cspan style=\\\"color: #E1E4E8\\\"\u003e, \u003c/span\u003e\u003cspan style=\\\"color: #FFAB70\\\"\u003eindent\u003c/span\u003e\u003cspan style=\\\"color: #F97583\\\"\u003e=\u003c/span\u003e\u003cspan style=\\\"color: #79B8FF\\\"\u003e2\u003c/span\u003e\u003cspan style=\\\"color: #E1E4E8\\\"\u003e))\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\"},\"className\":\"[\u0026\u003e*]:rounded-md [\u0026\u003e*]:p-4 [\u0026\u003e*]:text-xs [\u0026\u003e*]:overflow-x-auto [\u0026\u003e*]:rounded-b-none\"}],[\"$\",\"$L136\",null,{\"code\":\"import json\\nprint(json.dumps(response.output, default=lambda o: o.__dict__, indent=2))\",\"className\":\"absolute top-2 right-2\"}]]}],[\"$\",\"div\",null,{\"className\":\"border border-t-0 border-border rounded-b-md text-xs max-h-[50vh] overflow-scroll\",\"children\":[[\"$\",\"pre\",\"0\",{\"className\":\"p-4 font-mono overflow-scroll\",\"children\":[\"[\\n\",\"  {\\n\",\"    \\\"id\\\": \\\"ws_67bd64fe91f081919bec069ad65797f1\\\",\\n\",\"    \\\"status\\\": \\\"completed\\\",\\n\",\"    \\\"type\\\": \\\"web_search_call\\\"\\n\",\"  },\\n\",\"  {\\n\",\"    \\\"id\\\": \\\"msg_67bd6502568c8191a2cbb154fa3fbf4c\\\",\\n\",\"    \\\"content\\\": [\\n\",\"      {\\n\",\"        \\\"annotations\\\": [\\n\",\"          {\\n\",\"            \\\"index\\\": null,\\n\",\"            \\\"title\\\": \\\"Huawei improves AI chip production in boost for China's tech goals\\\",\\n\",\"            \\\"type\\\": \\\"url_citation\\\",\\n\",\"            \\\"url\\\": \\\"https://www.ft.com/content/f46b7f6d-62ed-4b64-8ad7-2417e5ab34f6?utm_source=chatgpt.com\\\"\\n\",\"          },\\n\",\"          {\\n\",\"            \\\"index\\\": null,\\n\",\"            \\\"title\\\": \\\"Apple cheers Trump with $500bn US investment plan; more losses on Wall Street - as it happened\\\",\\n\",\"            \\\"type\\\": \\\"url_citation\\\",\\n\",\"            \\\"url\\\": \\\"https://www.theguardian.com/business/live/2025/feb/24/euro-hits-one-month-high-german-election-result-stock-markets-dax-bank-of-england-business-live-news?utm_source=chatgpt.com\\\"\\n\",\"          },\\n\",\"          {\\n\",\"            \\\"index\\\": null,\\n\",\"            \\\"title\\\": \\\"Microsoft axes data center leases as DeepSeek casts doubt on massive AI spend: report\\\",\\n\",\"            \\\"type\\\": \\\"url_citation\\\",\\n\",\"            \\\"url\\\": \\\"https://nypost.com/2025/02/24/business/microsoft-axes-some-ai-data-center-leases-td-cowen-says/?utm_source=chatgpt.com\\\"\\n\",\"          },\\n\",\"          {\\n\",\"            \\\"index\\\": null,\\n\",\"            \\\"title\\\": \\\"Alibaba Plans to Invest $52B in AI, Cloud Over Next Three Years\\\",\\n\",\"            \\\"type\\\": \\\"url_citation\\\",\\n\",\"            \\\"url\\\": \\\"https://www.investopedia.com/alibaba-plans-to-invest-usd52b-in-ai-cloud-over-next-three-years-11684981?utm_source=chatgpt.com\\\"\\n\",\"          },\\n\",\"          {\\n\",\"            \\\"index\\\": null,\\n\",\"            \\\"title\\\": \\\"JPMorgan Unit Backs Albert Invent at a $270 Million Valuation\\\",\\n\",\"            \\\"type\\\": \\\"url_citation\\\",\\n\",\"            \\\"url\\\": \\\"https://www.wsj.com/articles/jpmorgan-unit-backs-albert-invent-at-a-270-million-valuation-1ab03c96?utm_source=chatgpt.com\\\"\\n\",\"          }\\n\",\"        ],\\n\",\"$13a\",\"        \\\"type\\\": \\\"output_text\\\",\\n\",\"        \\\"logprobs\\\": null\\n\",\"      }\\n\",\"    ],\\n\",\"    \\\"role\\\": \\\"assistant\\\",\\n\",\"    \\\"type\\\": \\\"message\\\"\\n\",\"  }\\n\",\"]\\n\"]}]]}]]}]\n"])</script><script>self.__next_f.push([1,"13b:T11b8,"])</script><script>self.__next_f.push([1,"\u003cpre class=\"shiki github-dark\" style=\"background-color: #24292e\" tabindex=\"0\"\u003e\u003ccode\u003e\u003cspan class=\"line\"\u003e\u003cspan style=\"color: #F97583\"\u003eimport\u003c/span\u003e\u003cspan style=\"color: #E1E4E8\"\u003e base64\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\"line\"\u003e\u003c/span\u003e\n\u003cspan class=\"line\"\u003e\u003cspan style=\"color: #F97583\"\u003efrom\u003c/span\u003e\u003cspan style=\"color: #E1E4E8\"\u003e IPython.display \u003c/span\u003e\u003cspan style=\"color: #F97583\"\u003eimport\u003c/span\u003e\u003cspan style=\"color: #E1E4E8\"\u003e Image, display\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\"line\"\u003e\u003c/span\u003e\n\u003cspan class=\"line\"\u003e\u003cspan style=\"color: #6A737D\"\u003e# Display the image from the provided URL\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\"line\"\u003e\u003cspan style=\"color: #E1E4E8\"\u003eurl \u003c/span\u003e\u003cspan style=\"color: #F97583\"\u003e=\u003c/span\u003e\u003cspan style=\"color: #E1E4E8\"\u003e \u003c/span\u003e\u003cspan style=\"color: #9ECBFF\"\u003e\u0026quot;https://upload.wikimedia.org/wikipedia/commons/thumb/1/15/Cat_August_2010-4.jpg/2880px-Cat_August_2010-4.jpg\u0026quot;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\"line\"\u003e\u003cspan style=\"color: #E1E4E8\"\u003edisplay(Image(\u003c/span\u003e\u003cspan style=\"color: #FFAB70\"\u003eurl\u003c/span\u003e\u003cspan style=\"color: #F97583\"\u003e=\u003c/span\u003e\u003cspan style=\"color: #E1E4E8\"\u003eurl, \u003c/span\u003e\u003cspan style=\"color: #FFAB70\"\u003ewidth\u003c/span\u003e\u003cspan style=\"color: #F97583\"\u003e=\u003c/span\u003e\u003cspan style=\"color: #79B8FF\"\u003e400\u003c/span\u003e\u003cspan style=\"color: #E1E4E8\"\u003e))\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\"line\"\u003e\u003c/span\u003e\n\u003cspan class=\"line\"\u003e\u003cspan style=\"color: #E1E4E8\"\u003eresponse_multimodal \u003c/span\u003e\u003cspan style=\"color: #F97583\"\u003e=\u003c/span\u003e\u003cspan style=\"color: #E1E4E8\"\u003e client.responses.create(\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\"line\"\u003e\u003cspan style=\"color: #E1E4E8\"\u003e    \u003c/span\u003e\u003cspan style=\"color: #FFAB70\"\u003emodel\u003c/span\u003e\u003cspan style=\"color: #F97583\"\u003e=\u003c/span\u003e\u003cspan style=\"color: #9ECBFF\"\u003e\u0026quot;gpt-4o\u0026quot;\u003c/span\u003e\u003cspan style=\"color: #E1E4E8\"\u003e,\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\"line\"\u003e\u003cspan style=\"color: #E1E4E8\"\u003e    \u003c/span\u003e\u003cspan style=\"color: #FFAB70\"\u003einput\u003c/span\u003e\u003cspan style=\"color: #F97583\"\u003e=\u003c/span\u003e\u003cspan style=\"color: #E1E4E8\"\u003e[\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\"line\"\u003e\u003cspan style=\"color: #E1E4E8\"\u003e        {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\"line\"\u003e\u003cspan style=\"color: #E1E4E8\"\u003e            \u003c/span\u003e\u003cspan style=\"color: #9ECBFF\"\u003e\u0026quot;role\u0026quot;\u003c/span\u003e\u003cspan style=\"color: #E1E4E8\"\u003e: \u003c/span\u003e\u003cspan style=\"color: #9ECBFF\"\u003e\u0026quot;user\u0026quot;\u003c/span\u003e\u003cspan style=\"color: #E1E4E8\"\u003e,\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\"line\"\u003e\u003cspan style=\"color: #E1E4E8\"\u003e            \u003c/span\u003e\u003cspan style=\"color: #9ECBFF\"\u003e\u0026quot;content\u0026quot;\u003c/span\u003e\u003cspan style=\"color: #E1E4E8\"\u003e: [\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\"line\"\u003e\u003cspan style=\"color: #E1E4E8\"\u003e                {\u003c/span\u003e\u003cspan style=\"color: #9ECBFF\"\u003e\u0026quot;type\u0026quot;\u003c/span\u003e\u003cspan style=\"color: #E1E4E8\"\u003e: \u003c/span\u003e\u003cspan style=\"color: #9ECBFF\"\u003e\u0026quot;input_text\u0026quot;\u003c/span\u003e\u003cspan style=\"color: #E1E4E8\"\u003e, \u003c/span\u003e\u003cspan style=\"color: #9ECBFF\"\u003e\u0026quot;text\u0026quot;\u003c/span\u003e\u003cspan style=\"color: #E1E4E8\"\u003e: \u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\"line\"\u003e\u003cspan style=\"color: #E1E4E8\"\u003e                 \u003c/span\u003e\u003cspan style=\"color: #9ECBFF\"\u003e\u0026quot;Come up with keywords related to the image, and search on the web using the search tool for any news related to the keywords\u0026quot;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\"line\"\u003e\u003cspan style=\"color: #E1E4E8\"\u003e                 \u003c/span\u003e\u003cspan style=\"color: #9ECBFF\"\u003e\u0026quot;, summarize the findings and cite the sources.\u0026quot;\u003c/span\u003e\u003cspan style=\"color: #E1E4E8\"\u003e},\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\"line\"\u003e\u003cspan style=\"color: #E1E4E8\"\u003e                {\u003c/span\u003e\u003cspan style=\"color: #9ECBFF\"\u003e\u0026quot;type\u0026quot;\u003c/span\u003e\u003cspan style=\"color: #E1E4E8\"\u003e: \u003c/span\u003e\u003cspan style=\"color: #9ECBFF\"\u003e\u0026quot;input_image\u0026quot;\u003c/span\u003e\u003cspan style=\"color: #E1E4E8\"\u003e, \u003c/span\u003e\u003cspan style=\"color: #9ECBFF\"\u003e\u0026quot;image_url\u0026quot;\u003c/span\u003e\u003cspan style=\"color: #E1E4E8\"\u003e: \u003c/span\u003e\u003cspan style=\"color: #9ECBFF\"\u003e\u0026quot;https://upload.wikimedia.org/wikipedia/commons/thumb/1/15/Cat_August_2010-4.jpg/2880px-Cat_August_2010-4.jpg\u0026quot;\u003c/span\u003e\u003cspan style=\"color: #E1E4E8\"\u003e}\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\"line\"\u003e\u003cspan style=\"color: #E1E4E8\"\u003e            ]\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\"line\"\u003e\u003cspan style=\"color: #E1E4E8\"\u003e        }\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\"line\"\u003e\u003cspan style=\"color: #E1E4E8\"\u003e    ],\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\"line\"\u003e\u003cspan style=\"color: #E1E4E8\"\u003e    \u003c/span\u003e\u003cspan style=\"color: #FFAB70\"\u003etools\u003c/span\u003e\u003cspan style=\"color: #F97583\"\u003e=\u003c/span\u003e\u003cspan style=\"color: #E1E4E8\"\u003e[\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\"line\"\u003e\u003cspan style=\"color: #E1E4E8\"\u003e        {\u003c/span\u003e\u003cspan style=\"color: #9ECBFF\"\u003e\u0026quot;type\u0026quot;\u003c/span\u003e\u003cspan style=\"color: #E1E4E8\"\u003e: \u003c/span\u003e\u003cspan style=\"color: #9ECBFF\"\u003e\u0026quot;web_search\u0026quot;\u003c/span\u003e\u003cspan style=\"color: #E1E4E8\"\u003e}\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\"line\"\u003e\u003cspan style=\"color: #E1E4E8\"\u003e    ]\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\"line\"\u003e\u003cspan style=\"color: #E1E4E8\"\u003e)\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e"])</script><script>self.__next_f.push([1,"131:[\"$\",\"div\",null,{\"children\":[[\"$\",\"div\",null,{\"className\":\"relative\",\"children\":[[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$13b\"},\"className\":\"[\u0026\u003e*]:rounded-md [\u0026\u003e*]:p-4 [\u0026\u003e*]:text-xs [\u0026\u003e*]:overflow-x-auto [\u0026\u003e*]:rounded-b-none\"}],[\"$\",\"$L136\",null,{\"code\":\"import base64\\n\\nfrom IPython.display import Image, display\\n\\n# Display the image from the provided URL\\nurl = \\\"https://upload.wikimedia.org/wikipedia/commons/thumb/1/15/Cat_August_2010-4.jpg/2880px-Cat_August_2010-4.jpg\\\"\\ndisplay(Image(url=url, width=400))\\n\\nresponse_multimodal = client.responses.create(\\n    model=\\\"gpt-4o\\\",\\n    input=[\\n        {\\n            \\\"role\\\": \\\"user\\\",\\n            \\\"content\\\": [\\n                {\\\"type\\\": \\\"input_text\\\", \\\"text\\\": \\n                 \\\"Come up with keywords related to the image, and search on the web using the search tool for any news related to the keywords\\\"\\n                 \\\", summarize the findings and cite the sources.\\\"},\\n                {\\\"type\\\": \\\"input_image\\\", \\\"image_url\\\": \\\"https://upload.wikimedia.org/wikipedia/commons/thumb/1/15/Cat_August_2010-4.jpg/2880px-Cat_August_2010-4.jpg\\\"}\\n            ]\\n        }\\n    ],\\n    tools=[\\n        {\\\"type\\\": \\\"web_search\\\"}\\n    ]\\n)\\n\",\"className\":\"absolute top-2 right-2\"}]]}],[\"$\",\"div\",null,{\"className\":\"border border-t-0 border-border rounded-b-md text-xs max-h-[50vh] overflow-scroll\",\"children\":[[\"$\",\"div\",\"0\",{\"className\":\"p-4 font-mono overflow-scroll prose dark:prose-invert max-w-none text-xs\",\"dangerouslySetInnerHTML\":{\"__html\":\"\u003cimg src=\\\"https://upload.wikimedia.org/wikipedia/commons/thumb/1/15/Cat_August_2010-4.jpg/2880px-Cat_August_2010-4.jpg\\\" width=\\\"400\\\"/\u003e\"}}]]}]]}]\n13c:T1141,"])</script><script>self.__next_f.push([1,"                    \"text\": \"Here are some recent news stories related to cats:\\n\\n**1. Cat Survives Three Weeks Trapped in Sofa During Move**\\n\\nA cat named Sunny-Loo survived three weeks trapped inside a sofa during the Hansons' move from Washington state to Colorado. After disappearing during the move, she was discovered emaciated but alive when the family unpacked their furniture. Sunny-Loo received intensive care and has since been reunited with her family. ([nypost.com](https://nypost.com/2025/02/24/us-news/cat-miraculously-survives-3-weeks-trapped-in-sofa-during-familys-cross-country-move/?utm_source=chatgpt.com))\\n\\n**2. Man Charged with Killing Brother and Family Cat**\\n\\nMatthew Hertgen, a former college soccer player, has been charged with the murder of his younger brother, Joseph Hertgen, and animal cruelty for allegedly killing the family cat. The incident occurred in Princeton, New Jersey, where authorities found Joseph's body with signs of trauma. Matthew faces multiple charges, including first-degree murder. ([people.com](https://people.com/princeton-murder-soccer-player-accused-murdering-athlete-brother-11685671?utm_source=chatgpt.com))\\n\\n**3. \\\"Too Affectionate\\\" Cat Sparks Adoption Interest**\\n\\nAn 8-year-old cat named Ravi was surrendered to a Connecticut shelter for being \\\"too affectionate.\\\" A TikTok video highlighting his story went viral, amassing over 12.6 million views and leading to more than 160 adoption applications. Ravi now has an adoption appointment, and the shelter has gained increased attention for its other adoptable pets. ([people.com](https://people.com/cat-surrendered-connecticut-shelter-too-affectionate-11684130?utm_source=chatgpt.com))\\n\\n**4. Emaciated Cat Found in Snow Dies After Rescue Attempt**\\n\\nA severely neglected cat named Lizzy was found abandoned in a snowbank in Meriden, Connecticut. Despite rescue efforts, Lizzy did not survive. Authorities are seeking information to identify the person responsible for her abandonment, with a reward offered for leads. ([ctinsider.com](https://www.ctinsider.com/recordjournal/article/meriden-animal-control-cat-neglected-abandoned-20172924.php?utm_source=chatgpt.com))\\n\\n**5. Cat Uses Human Toilet, Surprising Family**\\n\\nIn the UK, a cat named Cruise surprised his family by using a human toilet. Despite initial skepticism from her partner and son, Hayley Bibby captured footage of Cruise's bathroom habits, validating her claims. The family now accommodates Cruise's preference by leaving the toilet seat up. ([nypost.com](https://nypost.com/video/cat-proves-mom-correct-by-using-human-toilet/?utm_source=chatgpt.com))\\n\\n**6. Litter-Robot 3 Connect: A High-Tech Litter Box Review**\\n\\nThe Litter-Robot 3 Connect, priced at $499, offers a self-cleaning solution for cat owners averse to scooping litter. While effective and reducing litter usage by 50%, some users note that odor prevention could be improved. The device includes features like a night light and smartphone app integration. ([thesprucepets.com](https://www.thesprucepets.com/litter-robot-3-connect-review-8780105?utm_source=chatgpt.com))\\n\\n**7. Taylor Swift's Favorite Cat Breed Faces Breeding Ban**\\n\\nThe Scottish Fold cat breed, favored by celebrities like Taylor Swift, may face a breeding ban in Britain due to inheritable health issues. These cats often suffer from painful conditions caused by defective cartilage formation. The Animal Welfare Committee has recommended prohibiting the breeding of such cats to prevent further health problems. ([thetimes.co.uk](https://www.thetimes.co.uk/article/taylor-swifts-favourite-cat-faces-breeding-ban-k32nvf6kv?utm_source=chatgpt.com))\\n\\n\\n# Recent Cat-Related News Stories:\\n- [Cat miraculously survives 3 weeks trapped in sofa during family's cross-country move](https://nypost.com/2025/02/24/us-news/cat-miraculously-survives-3-weeks-trapped-in-sofa-during-familys-cross-country-move/?utm_source=chatgpt.com)\\n- [Ex-College Soccer Player Accused of Killing Fellow Athlete Brother, Cat Using Knife, Golf Club: Prosecutors](https://people.com/princeton-murder-soccer-player-accused-murdering-athlete-brother-11685671?utm_source=chatgpt.com)\\n- [Cuddly 8-Year-Old Cat Surrendered to Shelter for Being 'Too Affectionate' Inspires Dozens of Adoption Applications](https://people.com/cat-surrendered-connecticut-shelter-too-affectionate-11684130?utm_source=chatgpt.com)\\n \",\n"])</script><script>self.__next_f.push([1,"132:[\"$\",\"div\",null,{\"children\":[[\"$\",\"div\",null,{\"className\":\"relative\",\"children\":[[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\u003cpre class=\\\"shiki github-dark\\\" style=\\\"background-color: #24292e\\\" tabindex=\\\"0\\\"\u003e\u003ccode\u003e\u003cspan class=\\\"line\\\"\u003e\u003cspan style=\\\"color: #F97583\\\"\u003eimport\u003c/span\u003e\u003cspan style=\\\"color: #E1E4E8\\\"\u003e json\u003c/span\u003e\u003c/span\u003e\\n\u003cspan class=\\\"line\\\"\u003e\u003cspan style=\\\"color: #79B8FF\\\"\u003eprint\u003c/span\u003e\u003cspan style=\\\"color: #E1E4E8\\\"\u003e(json.dumps(response_multimodal.\u003c/span\u003e\u003cspan style=\\\"color: #79B8FF\\\"\u003e__dict__\u003c/span\u003e\u003cspan style=\\\"color: #E1E4E8\\\"\u003e, \u003c/span\u003e\u003cspan style=\\\"color: #FFAB70\\\"\u003edefault\u003c/span\u003e\u003cspan style=\\\"color: #F97583\\\"\u003e=lambda\u003c/span\u003e\u003cspan style=\\\"color: #E1E4E8\\\"\u003e o: o.\u003c/span\u003e\u003cspan style=\\\"color: #79B8FF\\\"\u003e__dict__\u003c/span\u003e\u003cspan style=\\\"color: #E1E4E8\\\"\u003e, \u003c/span\u003e\u003cspan style=\\\"color: #FFAB70\\\"\u003eindent\u003c/span\u003e\u003cspan style=\\\"color: #F97583\\\"\u003e=\u003c/span\u003e\u003cspan style=\\\"color: #79B8FF\\\"\u003e4\u003c/span\u003e\u003cspan style=\\\"color: #E1E4E8\\\"\u003e))\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\"},\"className\":\"[\u0026\u003e*]:rounded-md [\u0026\u003e*]:p-4 [\u0026\u003e*]:text-xs [\u0026\u003e*]:overflow-x-auto [\u0026\u003e*]:rounded-b-none\"}],[\"$\",\"$L136\",null,{\"code\":\"import json\\nprint(json.dumps(response_multimodal.__dict__, default=lambda o: o.__dict__, indent=4))\",\"className\":\"absolute top-2 right-2\"}]]}],[\"$\",\"div\",null,{\"className\":\"border border-t-0 border-border rounded-b-md text-xs max-h-[50vh] overflow-scroll\",\"children\":[[\"$\",\"pre\",\"0\",{\"className\":\"p-4 font-mono overflow-scroll\",\"children\":[\"{\\n\",\"    \\\"id\\\": \\\"resp_67bd65392a088191a3b802a61f4fba14\\\",\\n\",\"    \\\"created_at\\\": 1740465465.0,\\n\",\"    \\\"error\\\": null,\\n\",\"    \\\"metadata\\\": {},\\n\",\"    \\\"model\\\": \\\"gpt-4o-2024-08-06\\\",\\n\",\"    \\\"object\\\": \\\"response\\\",\\n\",\"    \\\"output\\\": [\\n\",\"        {\\n\",\"            \\\"id\\\": \\\"msg_67bd653ab9cc81918db973f0c1af9fbb\\\",\\n\",\"            \\\"content\\\": [\\n\",\"                {\\n\",\"                    \\\"annotations\\\": [],\\n\",\"                    \\\"text\\\": \\\"Based on the image of a cat, some relevant keywords could be:\\\\n\\\\n- Cat\\\\n- Feline\\\\n- Pet\\\\n- Animal care\\\\n- Cat behavior\\\\n\\\\nI'll search for recent news related to these keywords.\\\",\\n\",\"                    \\\"type\\\": \\\"output_text\\\",\\n\",\"                    \\\"logprobs\\\": null\\n\",\"                }\\n\",\"            ],\\n\",\"            \\\"role\\\": \\\"assistant\\\",\\n\",\"            \\\"type\\\": \\\"message\\\"\\n\",\"        },\\n\",\"        {\\n\",\"            \\\"id\\\": \\\"ws_67bd653c7a548191af86757fbbca96e1\\\",\\n\",\"            \\\"status\\\": \\\"completed\\\",\\n\",\"            \\\"type\\\": \\\"web_search_call\\\"\\n\",\"        },\\n\",\"        {\\n\",\"            \\\"id\\\": \\\"msg_67bd653f34fc8191989241b2659fd1b5\\\",\\n\",\"            \\\"content\\\": [\\n\",\"                {\\n\",\"                    \\\"annotations\\\": [\\n\",\"                        {\\n\",\"                            \\\"index\\\": null,\\n\",\"                            \\\"title\\\": \\\"Cat miraculously survives 3 weeks trapped in sofa during family's cross-country move\\\",\\n\",\"                            \\\"type\\\": \\\"url_citation\\\",\\n\",\"                            \\\"url\\\": \\\"https://nypost.com/2025/02/24/us-news/cat-miraculously-survives-3-weeks-trapped-in-sofa-during-familys-cross-country-move/?utm_source=chatgpt.com\\\"\\n\",\"                        },\\n\",\"                        {\\n\",\"                            \\\"index\\\": null,\\n\",\"                            \\\"title\\\": \\\"Ex-College Soccer Player Accused of Killing Fellow Athlete Brother, Cat Using Knife, Golf Club: Prosecutors\\\",\\n\",\"                            \\\"type\\\": \\\"url_citation\\\",\\n\",\"                            \\\"url\\\": \\\"https://people.com/princeton-murder-soccer-player-accused-murdering-athlete-brother-11685671?utm_source=chatgpt.com\\\"\\n\",\"                        },\\n\",\"                        {\\n\",\"                            \\\"index\\\": null,\\n\",\"                            \\\"title\\\": \\\"Cuddly 8-Year-Old Cat Surrendered to Shelter for Being 'Too Affectionate' Inspires Dozens of Adoption Applications\\\",\\n\",\"                            \\\"type\\\": \\\"url_citation\\\",\\n\",\"                            \\\"url\\\": \\\"https://people.com/cat-surrendered-connecticut-shelter-too-affectionate-11684130?utm_source=chatgpt.com\\\"\\n\",\"                        },\\n\",\"                        {\\n\",\"                            \\\"index\\\": null,\\n\",\"                            \\\"title\\\": \\\"Emaciated cat found in Meriden abandoned in snow dies after rescue attempt, officials say\\\",\\n\",\"                            \\\"type\\\": \\\"url_citation\\\",\\n\",\"                            \\\"url\\\": \\\"https://www.ctinsider.com/recordjournal/article/meriden-animal-control-cat-neglected-abandoned-20172924.php?utm_source=chatgpt.com\\\"\\n\",\"                        },\\n\",\"                        {\\n\",\"                            \\\"index\\\": null,\\n\",\"                            \\\"title\\\": \\\"Cat proves mom correct by using human toilet\\\",\\n\",\"                            \\\"type\\\": \\\"url_citation\\\",\\n\",\"                            \\\"url\\\": \\\"https://nypost.com/video/cat-proves-mom-correct-by-using-human-toilet/?utm_source=chatgpt.com\\\"\\n\",\"                        },\\n\",\"                        {\\n\",\"                            \\\"index\\\": null,\\n\",\"                            \\\"title\\\": \\\"Litter-Robot 3 Connect Review\\\",\\n\",\"                            \\\"type\\\": \\\"url_citation\\\",\\n\",\"                            \\\"url\\\": \\\"https://www.thesprucepets.com/litter-robot-3-connect-review-8780105?utm_source=chatgpt.com\\\"\\n\",\"                        },\\n\",\"                        {\\n\",\"                            \\\"index\\\": null,\\n\",\"                            \\\"title\\\": \\\"Taylor Swift's favourite cat faces breeding ban\\\",\\n\",\"                            \\\"type\\\": \\\"url_citation\\\",\\n\",\"                            \\\"url\\\": \\\"https://www.thetimes.co.uk/article/taylor-swifts-favourite-cat-faces-breeding-ban-k32nvf6kv?utm_source=chatgpt.com\\\"\\n\",\"                        }\\n\",\"                    ],\\n\",\"$13c\",\"                    \\\"type\\\": \\\"output_text\\\",\\n\",\"                    \\\"logprobs\\\": null\\n\",\"                }\\n\",\"            ],\\n\",\"            \\\"role\\\": \\\"assistant\\\",\\n\",\"            \\\"type\\\": \\\"message\\\"\\n\",\"        }\\n\",\"    ],\\n\",\"    \\\"temperature\\\": 1.0,\\n\",\"    \\\"tool_choice\\\": \\\"auto\\\",\\n\",\"    \\\"tools\\\": [\\n\",\"        {\\n\",\"            \\\"type\\\": \\\"web_search\\\",\\n\",\"            \\\"location\\\": null,\\n\",\"            \\\"sites\\\": null\\n\",\"        }\\n\",\"    ],\\n\",\"    \\\"top_p\\\": 1.0,\\n\",\"    \\\"max_completion_tokens\\\": null,\\n\",\"    \\\"previous_response_id\\\": null,\\n\",\"    \\\"reasoning_effort\\\": null,\\n\",\"    \\\"text\\\": {\\n\",\"        \\\"format\\\": {\\n\",\"            \\\"type\\\": \\\"text\\\"\\n\",\"        },\\n\",\"        \\\"stop\\\": null\\n\",\"    },\\n\",\"    \\\"top_logprobs\\\": null,\\n\",\"    \\\"truncation\\\": \\\"disabled\\\",\\n\",\"    \\\"usage\\\": {\\n\",\"        \\\"completion_tokens\\\": null,\\n\",\"        \\\"prompt_tokens\\\": null,\\n\",\"        \\\"total_tokens\\\": 1370,\\n\",\"        \\\"completion_tokens_details\\\": null,\\n\",\"        \\\"prompt_tokens_details\\\": null\\n\",\"    }\\n\",\"}\\n\"]}]]}]]}]\n"])</script><script>self.__next_f.push([1,"121:[\"$\",\"article\",null,{\"className\":\"prose prose-sm sm:prose-base max-w-none dark:prose-invert\",\"children\":[[\"$\",\"p\",\"p-0\",{\"children\":\"The Responses API is a new way to interact with OpenAI models, designed to be simpler and more flexible than previous APIs. It makes it easy to build advanced AI applications that use multiple tools, handle multi-turn conversations, and work with different types of data (not just text).\"}],\"\\n\",[\"$\",\"p\",\"p-1\",{\"children\":\"Unlike older APIs—such as Chat Completions, which were built mainly for text, or the Assistants API, which can require a lot of setup—the Responses API is built from the ground up for:\"}],\"\\n\",[\"$\",\"ul\",\"ul-0\",{\"children\":[\"\\n\",[\"$\",\"li\",\"li-0\",{\"children\":\"Seamless multi-turn interactions (carry on a conversation across several steps in a single API call)\"}],\"\\n\",[\"$\",\"li\",\"li-1\",{\"children\":\"Easy access to powerful hosted tools (like file search, web search, and code interpreter)\"}],\"\\n\",[\"$\",\"li\",\"li-2\",{\"children\":\"Fine-grained control over the context you send to the model\"}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",\"p-2\",{\"children\":\"As AI models become more capable of complex, long-running reasoning, developers need an API that is both asynchronous and stateful. The Responses API is designed to meet these needs.\"}],\"\\n\",[\"$\",\"p\",\"p-3\",{\"children\":\"In this guide, you'll see some of the new features the Responses API offers, along with practical examples to help you get started.\"}]]}]\n122:[\"$\",\"article\",null,{\"className\":\"prose prose-sm sm:prose-base max-w-none dark:prose-invert\",\"children\":[[\"$\",\"$L13d\",null,{\"tag\":\"h2\",\"id\":\"basics\",\"className\":\"scroll-mt-24 \",\"children\":[\"$\",\"a\",\"a-0\",{\"className\":\"heading-link\",\"href\":\"#basics\",\"children\":\"Basics\"}]}],\"\\n\",[\"$\",\"p\",\"p-0\",{\"children\":\"By design, on the surface, the Responses API is very similar to the Completions API.\"}]]}]\n126:[\"$\",\"article\",null,{\"className\":\"prose prose-sm sm:prose-base max-w-none dark:prose-invert\",\"children\":[\"$\",\"p\",\"p-0\",{\"children\":\"One key feature of the Response API is that it is stateful. T"])</script><script>self.__next_f.push([1,"his means that you do not have to manage the state of the conversation by yourself, the API will handle it for you. For example, you can retrieve the response at any time and it will include the full conversation history.\"}]}]\n128:[\"$\",\"article\",null,{\"className\":\"prose prose-sm sm:prose-base max-w-none dark:prose-invert\",\"children\":[\"$\",\"p\",\"p-0\",{\"children\":\"You can continue the conversation by referring to the previous response.\"}]}]\n12b:[\"$\",\"article\",null,{\"className\":\"prose prose-sm sm:prose-base max-w-none dark:prose-invert\",\"children\":[\"$\",\"p\",\"p-0\",{\"children\":\"You can of course manage the context yourself. But one benefit of OpenAI maintaining the context for you is that you can fork the response at any point and continue the conversation from that point.\"}]}]\n12d:[\"$\",\"article\",null,{\"className\":\"prose prose-sm sm:prose-base max-w-none dark:prose-invert\",\"children\":[[\"$\",\"$L13d\",null,{\"tag\":\"h2\",\"id\":\"hosted-tools\",\"className\":\"scroll-mt-24 \",\"children\":[\"$\",\"a\",\"a-0\",{\"className\":\"heading-link\",\"href\":\"#hosted-tools\",\"children\":\"Hosted Tools\"}]}],\"\\n\",[\"$\",\"p\",\"p-0\",{\"children\":[\"Another benefit of the Responses API is that it adds support for hosted tools like \",[\"$\",\"code\",\"code-0\",{\"children\":\"file_search\"}],\" and \",[\"$\",\"code\",\"code-1\",{\"children\":\"web_search\"}],\". Instead of manually calling the tools, simply pass in the tools and the API will decide which tool to use and use it.\"]}],\"\\n\",[\"$\",\"p\",\"p-1\",{\"children\":[\"Here is an example of using the \",[\"$\",\"code\",\"code-0\",{\"children\":\"web_search\"}],\" tool to incorporate web search results into the response.\"]}]]}]\n130:[\"$\",\"article\",null,{\"className\":\"prose prose-sm sm:prose-base max-w-none dark:prose-invert\",\"children\":[[\"$\",\"$L13d\",null,{\"tag\":\"h2\",\"id\":\"multimodal-tool-augmented-conversation\",\"className\":\"scroll-mt-24 \",\"children\":[\"$\",\"a\",\"a-0\",{\"className\":\"heading-link\",\"href\":\"#multimodal-tool-augmented-conversation\",\"children\":\"Multimodal, Tool-augmented conversation\"}]}],\"\\n\",[\"$\",\"p\",\"p-0\",{\"children\":\"The Responses API natively supports"])</script><script>self.__next_f.push([1," text, images, and audio modalities.\\nTying everything together, we can build a fully multimodal, tool-augmented interaction with one API call through the responses API.\"}]]}]\n133:[\"$\",\"article\",null,{\"className\":\"prose prose-sm sm:prose-base max-w-none dark:prose-invert\",\"children\":[\"$\",\"p\",\"p-0\",{\"children\":[\"In the above example, we were able to use the \",[\"$\",\"code\",\"code-0\",{\"children\":\"web_search\"}],\" tool to search the web for news related to the image in one API call instead of multiple round trips that would be required if we were using the Chat Completions API.\"]}]}]\n134:[\"$\",\"article\",null,{\"className\":\"prose prose-sm sm:prose-base max-w-none dark:prose-invert\",\"children\":[[\"$\",\"p\",\"p-0\",{\"children\":\"With the responses API\\n🔥 a single API call can handle:\"}],\"\\n\",[\"$\",\"p\",\"p-1\",{\"children\":\"✅ Analyze a given image using a multimodal input.\"}],\"\\n\",[\"$\",\"p\",\"p-2\",{\"children\":[\"✅ Perform web search via the \",[\"$\",\"code\",\"code-0\",{\"children\":\"web_search\"}],\" hosted tool\"]}],\"\\n\",[\"$\",\"p\",\"p-3\",{\"children\":\"✅ Summarize the results.\"}],\"\\n\",[\"$\",\"p\",\"p-4\",{\"children\":\"In contrast, With Chat Completions API would require multiple steps, each requiring a round trip to the API:\"}],\"\\n\",[\"$\",\"p\",\"p-5\",{\"children\":\"1️⃣ Upload image and get analysis → 1 request\"}],\"\\n\",[\"$\",\"p\",\"p-6\",{\"children\":\"2️⃣ Extract info, call external web search → manual step + tool execution\"}],\"\\n\",[\"$\",\"p\",\"p-7\",{\"children\":\"3️⃣ Re-submit tool results for summarization → another request\"}],\"\\n\",[\"$\",\"p\",\"p-8\",{\"children\":\"See the following diagram for a side by side visualized comparison!\"}],\"\\n\",[\"$\",\"p\",\"p-9\",{\"children\":[\"$\",\"img\",\"img-0\",{\"src\":\"../../images/comparisons.png\",\"alt\":\"Responses vs Completions\"}]}],\"\\n\",[\"$\",\"p\",\"p-10\",{\"children\":\"We are very excited for you to try out the Responses API and see how it can simplify your code and make it easier to build complex, multimodal, tool-augmented interactions!\"}]]}]\n135:[\"$\",\"article\",null,{\"className\":\"prose prose-sm sm:prose-base max-w-none dark:p"])</script><script>self.__next_f.push([1,"rose-invert\",\"children\":\"$undefined\"}]\n"])</script><next-route-announcer style="position: absolute;"></next-route-announcer><div id="c4g-content-root" class="c4g-widget" data-darkreader-mode="dynamic" data-darkreader-scheme="dark"><meta name="darkreader" content="6a97ae87492b4187b7bf369142c45ea1"></div></body>